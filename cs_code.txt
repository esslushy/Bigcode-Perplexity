// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using System;
using System.Windows.Forms;

namespace CsDownloadVid
{
    static class Program
    {
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);

            SimpleLog.Init("log.txt");
            SimpleLog.Current.WriteLog("Initializing.");
            Configs.Init("options.ini");
            Configs.Current.LoadPersisted();
            Configs.Current.Set(ConfigKey.Version, "0.1");

            Application.Run(new FormMain());
        }
    }
}
// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Windows.Forms;

namespace CsDownloadVid
{
    public partial class FormMediaJoin : Form
    {
        RunToolHelper _runner;
        public FormMediaJoin(bool showCustom=false)
        {
            InitializeComponent();
            txtInput.Text = "";
            txtInput.Enabled = false;
            txtInput.BackColor = SystemColors.Control;
            _runner = new RunToolHelper(this.txtStatus, this.lblShortStatus,
                FormAudioFromVideo.GetFfmpegStdoutFilter());
            if (showCustom)
            {
                this.Text = "Encode audio or video...";
                this.label2.Text = "Choose some input files...";
                this.label1.Visible = false;
                this.tbOutputFormat.Visible = false;
            }

            this.btnJoin.Visible = !showCustom;
            this.btnMakeAudioLouder.Visible = showCustom;
            this.btnMakeAudioLouder.Visible = showCustom;
        }

        private void btnGetInput_Click(object sender, EventArgs e)
        {
            var files = Utils.AskOpenFilesDialog("Choose video files...");
            if (files != null)
            {
                txtInput.Text = string.Join(Utils.NL, files);
                txtInput.Enabled = true;
                txtInput.BackColor = SystemColors.Window;
            }
            else
            {
                txtInput.Text = "";
                txtInput.Enabled = false;
                txtInput.BackColor = SystemColors.Control;
            }
        }

        private void btnJoin_Click(object sender, EventArgs e)
        {
            _runner.RunInThread(() =>
            {
                var lines = GetInputFiles(minExpected: 2);
                var outputFormat = this.tbOutputFormat.Text;
                MediaJoin(lines, outputFormat);
            });
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            RunToolHelper.RunAndCatch(() =>
            {
                _runner.CancelProcess();
            });
        }

        string EscapeStringForFfmpeg(string s)
        {
            return s.Replace("\\", "\\\\").Replace(" ", "\\ ").Replace("'", "\\'");
        }

        void MediaJoin(string[] lines, string outFormat)
        {
            var parentDirs = (from part in lines
                              select Path.GetDirectoryName(part)).Distinct();

            if (parentDirs.Count() != 1)
            {
                throw new CsDownloadVidException("Input files must be in same directory.");
            }

            var fileExts = (from part in lines select Path.GetExtension(part)).Distinct();
            if (fileExts.Count() != 1)
            {
                throw new CsDownloadVidException("Files have different extensions.");
            }

            var tmpList = parentDirs.First() + Utils.Sep + "temp_csdownloadvid_list.txt";
            if (File.Exists(tmpList))
            {
                File.Delete(tmpList);
                Utils.AssertTrue(!File.Exists(tmpList));
            }

            foreach (var part in lines)
            {
                var file = "file " + EscapeStringForFfmpeg(part) + "\n";
                File.AppendAllText(tmpList, file);
            }

            outFormat = outFormat == "auto" ? fileExts.ToArray()[0] : outFormat;
            var output = lines[0] + "_out" + outFormat;
            if (File.Exists(output))
            {
                throw new CsDownloadVidException("File already exists " + output);
            }

            var args = new List<string>();
            args.Add("-nostdin");
            args.Add("-f");
            args.Add("concat");
            args.Add("-safe"); // many versions of ffmpeg think windows full paths are unsafe
            args.Add("0"); // perhaps better to set current directory + use relative paths
            args.Add("-i");
            args.Add(tmpList);
            args.Add("-acodec");
            args.Add("copy");
            args.Add("-vcodec");
            args.Add("copy");
            args.Add(output);
            _runner.Trace("Saving to " + output);

            var info = new ProcessStartInfo();
            info.FileName = CsDownloadVidFilepaths.GetFfmpeg();
            info.Arguments = Utils.CombineProcessArguments(args.ToArray());
            info.CreateNoWindow = true;
            info.RedirectStandardError = true;
            info.RedirectStandardOutput = true;
            info.UseShellExecute = false;
            _runner.RunProcessSync(info, "Join Media");

            if (File.Exists(tmpList))
            {
                File.Delete(tmpList);
            }
        }

        string[] GetInputFiles(int minExpected)
        {
            var lines = Utils.SplitLines(txtInput.Text);
            if (lines.Length < minExpected)
            {
                throw new CsDownloadVidException("Expected at least " + minExpected +
                    " input files");
            }

            foreach (var line in lines)
            {
                if (!File.Exists(line))
                    throw new CsDownloadVidException("Input file " + line + " not found");
            }

            return lines;
        }

        private void btnMakeAudioLouder_Click(object sender, EventArgs e)
        {
            var inputs = this.GetInputFiles(1);
            _runner.RunInThread(() =>
            {
                foreach (var input in inputs)
                {
                    if (input.Contains(".madelouder"))
                    {
                        _runner.Trace("skipping" + input + " because it contains .makelouder");
                    }
                    else
                    {
                        this.makeLouderOnes(input);
                    }
                }
            },
                "Making audio louder...");
        }

        private void makeLouderOnes(string input)
        {
            foreach (var scale in new List<string>(){ "2.0", "4.0", "8.0", "16.0", "32.0"})
            {
                var outfile = input + ".makelouder" + scale + ".wav";
                var args = new List<string>();
                args.Add("-nostdin");
                args.Add("-i");
                args.Add(input);
                args.Add("-filter:a");
                args.Add("volume="+scale);
                args.Add(outfile);
                var info = new ProcessStartInfo();
                info.FileName = CsDownloadVidFilepaths.GetFfmpeg();
                info.Arguments = Utils.CombineProcessArguments(args.ToArray());
                info.CreateNoWindow = true;
                info.RedirectStandardError = true;
                info.RedirectStandardOutput = true;
                info.UseShellExecute = false;
                _runner.RunProcessSync(info, "Make Louder");
                if (!File.Exists(outfile))
                {
                    _runner.Trace("expected to see output at " + outfile);
                    throw new Exception("expected to see output at " + outfile);
                }

                var pathOut = Utils.RunM4aConversion(outfile, "flac");
                if (new FileInfo(pathOut).Length > 1)
                {
                   File.Delete(outfile);
                }
            }
        }

        private void doCustomEncode(string example, InputBoxHistory key)
        {
            var files = this.GetInputFiles(1);
            var cmd = InputBoxForm.GetStrInput("Command for the ffmpeg encoder:", example,
                key);
            if (String.IsNullOrEmpty(cmd))
            {
                return;
            }
            else if (!cmd.Contains("%in%") && !Utils.AskToConfirm("Did not see '%in%', " +
                "won't process input files. Continue?"))
            {
                return;
            }

            if (!Utils.AskToConfirm("Run the command right now? (or copy the command line to the clipboard)"))
            {
                var s = "";
                foreach (var file in files)
                {
                    s += "\r\n\"" + CsDownloadVidFilepaths.GetFfmpeg() + "\" ";
                    s += cmd.Replace("%in%", files[0]);
                }

                Clipboard.SetText(s);
                MessageBox.Show("Command was copied to the clipboard.");
                return;
            }

            RunToolHelper.RunAndCatch(() =>
            {
                var infos = new List<ProcessStartInfo>();
                foreach (var file in files)
                {
                    var info = new ProcessStartInfo();
                    info.FileName = CsDownloadVidFilepaths.GetFfmpeg();
                    info.Arguments = cmd.Replace("%in%", file);
                    info.CreateNoWindow = true;
                    info.RedirectStandardError = true;
                    info.RedirectStandardOutput = true;
                    info.UseShellExecute = false;
                    infos.Add(info);
                }

                _runner.RunProcesses(infos.ToArray(), "Custom encode");
            });
        }

        private void btnEncodeAv1_Click(object sender, EventArgs e)
        {
            this.doCustomEncode("-i \"%in%\" -crf 20 -vf \"scale=iw/2:ih/2\" -c:v libaom-av1 -b:v 0 -cpu-used 4 -c:a copy \"%in%.mkv\"", InputBoxHistory.CustomEncodeAv1);
        }

        private void btnEncode_Click(object sender, EventArgs e)
        {
            this.doCustomEncode("-i \"%in%\" -c:v libx264 -crf 23 -preset slower -c:a copy \"%in%.mp4\"", InputBoxHistory.CustomEncode);
        }
    }
}
// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

// see unit tests at
// https://github.com/moltenform/labs_coordinate_pictures/blob/master/src/labs_coordinate_pictures/TestsSortFiles.cs

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Windows.Forms;

namespace CsDownloadVid
{
    public static class Utils
    {
        // differences from LabsCoordinatePictures 1be22cd489b58e4
        //      rename CoordinatePicturesException to CsDownloadVidException, don't prepend
        //      add AssertTrue, SplitLines
        public static readonly string Sep = Path.DirectorySeparatorChar.ToString();
        public static readonly string NL = Environment.NewLine;
        static readonly object tokenRepresentingNull = new object();
        static Random random = new Random();

        // returns exit code.
        public static int Run(string executable, string[] args, bool shellExecute, bool waitForExit,
            bool hideWindow)
        {
            return Run(executable, args, shellExecute, waitForExit,
                hideWindow, false, out string stdout, out string stderr, null);
        }

        // returns exit code. reading stdout implies waiting for exit.
        public static int Run(string executable, string[] args, bool shellExecute, bool waitForExit,
            bool hideWindow, out string stdout, out string stderr)
        {
            return Run(executable, args, shellExecute, waitForExit,
                hideWindow, true, out stdout, out stderr, null);
        }

        // returns exit code. reading stdout implies waiting for exit.
        public static int Run(string executable, string[] args, bool shellExecute, bool waitForExit,
            bool hideWindow, bool getStdout, out string outStdout,
            out string outStderr, string workingDir)
        {
            var startInfo = new ProcessStartInfo();
            startInfo.CreateNoWindow = hideWindow;
            startInfo.UseShellExecute = shellExecute;
            startInfo.FileName = executable;
            startInfo.Arguments = CombineProcessArguments(args);
            startInfo.WorkingDirectory = workingDir;
            if (getStdout)
            {
                startInfo.RedirectStandardError = true;
                startInfo.RedirectStandardOutput = true;
                waitForExit = true;
            }

            string stderr = "", stdout = "";
            var process = Process.Start(startInfo);
            if (getStdout)
            {
                process.OutputDataReceived += (sender, dataReceived) => stdout += dataReceived.Data;
                process.ErrorDataReceived += (sender, dataReceived) => stderr += dataReceived.Data;
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();
            }

            if (waitForExit)
            {
                process.WaitForExit();
            }

            outStdout = stdout;
            outStderr = stderr;

            return waitForExit ? process.ExitCode : 0;
        }

        public static bool IsWindows()
        {
            return Environment.OSVersion.Platform.ToString().StartsWith(
                "Win", StringComparison.OrdinalIgnoreCase);
        }

        public static void OpenDirInExplorer(string sDir)
        {
            if (IsWindows())
            {
                Process.Start("explorer.exe", "\"" + sDir + "\"");
            }
        }

        public static void SelectFileInExplorer(string path)
        {
            if (IsWindows())
            {
                Process.Start("explorer.exe", "/select,\"" + path + "\"");
            }
        }

        public static bool AskToConfirm(string message)
        {
            var result = System.Windows.Forms.MessageBox.Show(message, "", MessageBoxButtons.YesNo);
            return result == DialogResult.Yes;
        }

        static string BuildFileDialogFilter(string[] extensionFilter, string[] extensionFilterNames)
        {
            // example: extensionFilter = ["*.BMP;*.JPG;*.GIF", "*.*"]
            // extensionFilterNames = ["Images", "All Files"]
            if (extensionFilter == null || extensionFilter.Length == 0)
            {
                return "";
            }

            var items = new List<string>();
            for (int i = 0; i < extensionFilter.Length; i++)
            {
                items.Add(extensionFilterNames != null ? extensionFilterNames[i] : extensionFilter[i]);
                items.Add(extensionFilter[i]);
            }

            return string.Join("|", items);
        }

        public static string AskOpenFileDialog(string title, string[] extensionFilter = null, string[] extensionFilterNames = null, string initialDir = null)
        {
            using (OpenFileDialog dlg = new OpenFileDialog())
            {
                dlg.Title = title;
                dlg.InitialDirectory = initialDir;
                dlg.Filter = BuildFileDialogFilter(extensionFilter, extensionFilterNames);
                var result = dlg.ShowDialog();
                if (result == DialogResult.OK)
                {
                    return dlg.FileName;
                }
                else
                {
                    return null;
                }
            }
        }

        public static string[] AskOpenFilesDialog(string title, string[] extensionFilter = null, string[] extensionFilterNames = null, string initialDir = null)
        {
            using (OpenFileDialog dlg = new OpenFileDialog())
            {
                dlg.Multiselect = true;
                dlg.Title = title;
                dlg.InitialDirectory = initialDir;
                dlg.Filter = BuildFileDialogFilter(extensionFilter, extensionFilterNames);
                var result = dlg.ShowDialog();
                if (result == DialogResult.OK)
                {
                    return dlg.FileNames;
                }
                else
                {
                    return null;
                }
            }
        }

        public static string AskSaveFileDialog(string title, string[] extensionFilter = null, string[] extensionFilterNames = null, string initialDir = null)
        {
            using (SaveFileDialog dlg = new SaveFileDialog())
            {
                dlg.Title = title;
                dlg.InitialDirectory = initialDir;
                dlg.Filter = BuildFileDialogFilter(extensionFilter, extensionFilterNames);
                var result = dlg.ShowDialog();
                if (result == DialogResult.OK)
                {
                    return dlg.FileName;
                }
                else
                {
                    return null;
                }
            }
        }

        public static bool IsDigits(string s)
        {
            if (s == null || s.Length == 0)
            {
                return false;
            }

            foreach (var c in s)
            {
                if (!"0123456789".Contains(c))
                {
                    return false;
                }
            }

            return true;
        }

        public static string FirstTwoChars(string s)
        {
            return s.Substring(0, Math.Min(2, s.Length));
        }

        public static bool ArePathsDistinct(string s1, string s2)
        {
            // https://msdn.microsoft.com/en-us/library/dd465121.aspx
            // we'll compare with OrdinalIgnoreCase since that's what msdn recommends
            s1 = s1 + Utils.Sep;
            s2 = s2 + Utils.Sep;
            var comparison = StringComparison.OrdinalIgnoreCase;
            return !s1.StartsWith(s2, comparison) &&
                !s2.StartsWith(s1, comparison);
        }

        // "soft delete" just means moving to a designated 'trash' location.
        public static string GetSoftDeleteDestination(string path)
        {
            var deleteDir = Configs.Current.Get(ConfigKey.SoftDeleteDir);
            if (!Directory.Exists(deleteDir))
            {
                while(true)
                {
                    var got = Utils.AskOpenFileDialog("Please choose a file in the 'trash' " + 
                        "directory where we'll send deleted files.");
                    if (!string.IsNullOrEmpty(got) && Directory.Exists(Path.GetDirectoryName(got)))
                    {
                        deleteDir = Path.GetDirectoryName(got);
                        Configs.Current.Set(ConfigKey.SoftDeleteDir, deleteDir);
                        break;
                    }
                }
            }

            // as a prefix, the first 2 chars of the parent directory
            var prefix = FirstTwoChars(Path.GetFileName(Path.GetDirectoryName(path))) + "_";
            return Path.Combine(deleteDir, prefix + Path.GetFileName(path) + GetRandomDigits());
        }

        public static string GetRandomDigits() 
        {
            return random.Next().ToString();
        }

        public static void SoftDelete(string path)
        {
            var newPath = GetSoftDeleteDestination(path);
            if (newPath != null)
            {
                SimpleLog.Current.WriteLog("Moving (" + path + ") to (" + newPath + ")");
                File.Move(path, newPath);
            }
        }

        public static string CombineProcessArguments(string[] args)
        {
            // By Roger Knapp
            // http://csharptest.net/529/how-to-correctly-escape-command-line-arguments-in-c/
            if (args == null || args.Length == 0)
            {
                return "";
            }

            StringBuilder arguments = new StringBuilder();

            // these can not be escaped
            Regex invalidChar = new Regex("[\x00\x0a\x0d]");

            // contains whitespace or two quote characters
            Regex needsQuotes = new Regex(@"\s|""");

            // one or more '\' followed with a quote or end of string
            Regex escapeQuote = new Regex(@"(\\*)(""|$)");

            for (int carg = 0; carg < args.Length; carg++)
            {
                if (invalidChar.IsMatch(args[carg]))
                {
                    throw new CsDownloadVidException("invalid character (" + carg + ")");
                }

                if (string.IsNullOrEmpty(args[carg]))
                {
                    arguments.Append("\"\"");
                }
                else if (!needsQuotes.IsMatch(args[carg]))
                {
                    arguments.Append(args[carg]);
                }
                else
                {
                    arguments.Append('"');
                    arguments.Append(escapeQuote.Replace(args[carg], m =>
                        m.Groups[1].Value + m.Groups[1].Value +
                        (m.Groups[2].Value == "\"" ? "\\\"" : "")));
                    arguments.Append('"');
                }

                if (carg + 1 < args.Length)
                {
                    arguments.Append(' ');
                }
            }

            return arguments.ToString();
        }

        public static bool RepeatWhileFileLocked(string filepath, int timeout)
        {
            int millisecondsBeforeRetry = 250;
            for (int i = 0; i < timeout; i += millisecondsBeforeRetry)
            {
                if (!IsFileLocked(filepath))
                    return true;

                Thread.Sleep(millisecondsBeforeRetry);
            }

            return false;
        }

        public static bool IsFileLocked(string filepath)
        {
            FileInfo file = new FileInfo(filepath);
            FileStream stream = null;

            try
            {
                stream = file.Open(FileMode.Open, FileAccess.ReadWrite, FileShare.None);
            }
            catch (IOException)
            {
                return true;
            }
            finally
            {
                if (stream != null)
                    stream.Close();
            }

            return false;
        }

        // pretty-print a filesize as "1.24Mb" or "32k".
        public static string FormatFilesize(string filepath)
        {
            if (!File.Exists(filepath))
                return " file not found";

            return FormatFilesize(new FileInfo(filepath).Length);
        }

        public static string FormatFilesize(long len)
        {
            // we'll show small files less than 1kb as "1k".
            return (len > 1024 * 1024) ?
                string.Format(" ({0:0.00}mb)", len / (1024.0 * 1024.0)) :
                (len > 1024) ?
                string.Format(" ({0}k)", len / 1024) :
                (len == 0) ? " (0k)" : " (1k)";
        }

        public static void CloseOtherProcessesByName(string processName)
        {
            var thisId = Process.GetCurrentProcess().Id;
            foreach (var process in Process.GetProcessesByName(processName))
            {
                if (process.Id != thisId)
                    process.Kill();
            }
        }

        public static string FormatPythonError(string stderr)
        {
            // printing stderr tends to bury the actual error message under a big callstack.
            // look for last occurrence of Error, show this before anything else.
            var re = @"\w+Error:(?!.*\w+Error:)";
            var matches = Regex.Matches(stderr, re);
            if (matches.Count > 0)
            {
                return stderr.Substring(matches[0].Index)
                    + Utils.NL + Utils.NL + Utils.NL + "Details: " + stderr;
            }
            else
            {
                return stderr;
            }
        }

        public static void RunPythonScriptOnSeparateThread(string pyScript,
            string[] listArgs, bool createWindow = false, bool autoWorkingDir = false,
            string workingDir = null)
        {
            ThreadPool.QueueUserWorkItem(delegate
            {
                RunPythonScript(pyScript, listArgs, createWindow: createWindow,
                    workingDir: autoWorkingDir ? Path.GetDirectoryName(pyScript) : workingDir);
            });
        }

        public static string RunPythonScript(string pyScript,
            string[] listArgs, bool createWindow = false,
            bool warnIfStdErr = true, string workingDir = null)
        {
            if (!pyScript.Contains(Utils.Sep))
            {
                pyScript = Path.Combine(Configs.Current.Directory, pyScript);
            }

            if (!File.Exists(pyScript))
            {
                MessageBox("Script not found " + pyScript);
                return "Script not found";
            }

            var python = Configs.Current.Get(ConfigKey.PathToPython);
            if (string.IsNullOrEmpty(python) || !File.Exists(python))
            {
                MessageBox("Python not found. Go to the main screen and to the " +
                    "option menu and click Options->Set python location...");
                return "Python not found.";
            }

            var args = new List<string> { pyScript };
            args.AddRange(listArgs);
            int exitCode = Run(python, args.ToArray(), shellExecute: false,
                waitForExit: true, hideWindow: !createWindow, getStdout: true,
                outStdout: out string stdout, outStderr: out string stderr, workingDir: workingDir);

            if (warnIfStdErr && exitCode != 0)
            {
                MessageBox("warning, error from script: " + FormatPythonError(stderr) ?? "");
            }

            return stderr;
        }

        public static void RunImageConversion(string pathInput, string pathOutput,
            string resizeSpec, int jpgQuality)
        {
            if (File.Exists(pathOutput))
            {
                MessageBox("File already exists, " + pathOutput);
                return;
            }

            // send the working directory for the script so that it can find options.ini
            var workingDir = Path.Combine(Configs.Current.Directory,
                "ben_python_img");
            var script = Path.Combine(Configs.Current.Directory,
                "ben_python_img", "img_convert_resize.py");
            var args = new string[] { "convert_resize",
                pathInput, pathOutput, resizeSpec, jpgQuality.ToString() };
            var stderr = RunPythonScript(script, args,
                createWindow: false, warnIfStdErr: false, workingDir: workingDir);

            if (!string.IsNullOrEmpty(stderr) || !File.Exists(pathOutput))
            {
                MessageBox("RunImageConversion failed, " + FormatPythonError(stderr));
            }
        }

        public static string RunM4aConversion(string path, string qualitySpec)
        {
            var qualities = new string[] { "16", "24", "96", "128", "144",
                "160", "192", "224", "256", "288", "320", "640", "flac" };
            if (Array.IndexOf(qualities, qualitySpec) == -1)
            {
                throw new CsDownloadVidException("Unsupported bitrate.");
            }
            else if (!path.EndsWith(".wav", StringComparison.Ordinal) &&
                !path.EndsWith(".flac", StringComparison.Ordinal))
            {
                throw new CsDownloadVidException("Unsupported input format.");
            }
            else
            {
                var encoder = Configs.Current.Get(ConfigKey.PathToQaac);
                if (!File.Exists(encoder))
                {
                    throw new CsDownloadVidException("M4a encoder not found, use Options->Set m4a encoder.");
                }

                var pathOutput = Path.GetDirectoryName(path) + Sep +
                    Path.GetFileNameWithoutExtension(path) +
                    (qualitySpec == "flac" ? ".flac" : ".m4a");
                var script = Path.GetDirectoryName(encoder) + Sep +
                    "dropq" + qualitySpec + ".py";
                var args = new string[] { path };
                var stderr = RunPythonScript(
                    script, args, createWindow: false, warnIfStdErr: false);

                if (!File.Exists(pathOutput))
                {
                    throw new CsDownloadVidException("RunM4aConversion failed, " + FormatPythonError(stderr));
                }
                else
                {
                    return pathOutput;
                }
            }
        }

        public static void JpgStripThumbnails(string path)
        {
            // delete IFD1 tags, removes the Thumbnailimage + all associated tags.
            var exiftool = Configs.Current.Directory + "/exiftool/exiftool" +
                (Utils.IsWindows() ? ".exe" : "");
            if (!File.Exists(exiftool))
            {
                throw new CsDownloadVidException("exiftool not found, expected to be seen at " + exiftool);
            }

            var args = new string[] { "-ifd1:all=", "-PreviewImage=", "-overwrite_original", path };
            Run(exiftool, args, hideWindow: true, waitForExit: true, shellExecute: false);
        }

        public static void JpgLosslessOptimize(string path, string pathOut, bool stripAllExif)
        {
            var jpegtran = Configs.Current.Directory + "/mozjpeg/jpegtran" +
                (Utils.IsWindows() ? ".exe" : "");
            if (!File.Exists(jpegtran))
            {
                throw new CsDownloadVidException("mozjpeg not found, expected to be seen at " + jpegtran);
            }

            var args = new string[] { "-outfile", pathOut, "-optimise",
                "-progressive", "-copy", stripAllExif ? "none" : "all", path };
            Run(jpegtran, args, hideWindow: true, waitForExit: true, shellExecute: false);
        }

        public static void PlayMedia(string path)
        {
            if (path == null)
                path = Path.Combine(Configs.Current.Directory, "silence.flac");

            var player = Configs.Current.Get(ConfigKey.FilepathAudioPlayer);
            if (string.IsNullOrEmpty(player) || !File.Exists(player))
            {
                MessageBox("Media player not found. Go to the main screen " +
                    "and to the option menu and click Options->Set media player location...");
                return;
            }

            var args = player.ToLower().Contains("foobar") ? new string[] { "/playnow", path } :
                new string[] { path };

            Run(player, args, hideWindow: true, waitForExit: false, shellExecute: false);
        }

        public static string GetClipboard()
        {
            try
            {
                return Clipboard.GetText() ?? "";
            }
            catch
            {
                return "";
            }
        }

        public static string GetFirstHttpLink(string s)
        {
            foreach (var match in Regex.Matches(s, @"https?://\S+"))
            {
                return ((Match)match).ToString();
            }

            return null;
        }

        // starts website in default browser.
        public static void LaunchUrl(string url)
        {
            string prefix;
            if (url.StartsWith("http://", StringComparison.Ordinal))
            {
                prefix = "http://";
            }
            else if (url.StartsWith("https://", StringComparison.Ordinal))
            {
                prefix = "https://";
            }
            else
            {
                return;
            }

            url = url.Substring(prefix.Length);
            url = url.Replace("%", "%25");
            url = url.Replace("&", "%26");
            url = url.Replace("|", "%7C");
            url = url.Replace("\\", "%5C");
            url = url.Replace("^", "%5E");
            url = url.Replace("\"", "%22");
            url = url.Replace("'", "%27");
            url = url.Replace(">", "%3E");
            url = url.Replace("<", "%3C");
            url = url.Replace(" ", "%20");
            url = prefix + url;
            Process.Start(url);
        }

        // get item from array, clamps index / does not overflow
        public static T ArrayAt<T>(T[] arr, int index)
        {
            if (index < 0)
            {
                return arr[0];
            }
            else if (index >= arr.Length - 1)
            {
                return arr[arr.Length - 1];
            }
            else
            {
                return arr[index];
            }
        }

        public static bool LooksLikePath(string path)
        {
            return path.Length > 2 && (
                (path[0] == Sep[0]) ||
                (path[1] == ':' && path[2] == Sep[0]));
        }

        public static FileAttributes GetFileAttributesOrNone(string path)
        {
            try
            {
                return File.GetAttributes(path);
            }
            catch (IOException)
            {
                return FileAttributes.Normal;
            }
        }

        public static string GetSha512(string path)
        {
            if (path == null || !File.Exists(path))
            {
                // ensure that two files that both aren't found won't have the same hash.
                return "filenotfound:" + path;
            }

            const int bufSize = 64 * 1024;
            using (SHA512Managed sha512 = new SHA512Managed())
            {
                using (var stream = new BufferedStream(File.OpenRead(path), bufSize))
                {
                    byte[] hash = sha512.ComputeHash(stream);
                    return Convert.ToBase64String(hash);
                }
            }
        }

        public static void RunLongActionInThread(object locking, Control caption,
            Action action, Action actionOnStart = null, Action actionOnComplete = null)
        {
            ThreadPool.QueueUserWorkItem(delegate
            {
                // check if another operation is ongoing
                if (Monitor.TryEnter(locking))
                {
                    var prevText = caption.Text;
                    try
                    {
                        // on the UI thread tell the user we are "working"
                        caption.Invoke((MethodInvoker)(() =>
                        {
                            caption.Text = "Loading...";
                            if (actionOnStart != null)
                            {
                                actionOnStart.Invoke();
                            }
                        }));

                        action();
                    }
                    catch (Exception e)
                    {
                        MessageErr(e.Message);
                    }
                    finally
                    {
                        Monitor.Exit(locking);

                        // on the UI thread tell the user we are "done"
                        caption.Invoke((MethodInvoker)(() =>
                        {
                            caption.Text = prevText;
                            if (actionOnComplete != null)
                            {
                                actionOnComplete.Invoke();
                            }
                        }));
                    }
                }
                else
                {
                    MessageBox("Please wait for the operation to complete.");
                }
            });
        }

        public static string[] SplitByString(string s, string delim)
        {
            return s.Split(new string[] { delim }, StringSplitOptions.None);
        }

        public static void MessageErr(string msg, bool checkIfSuppressed = false)
        {
            SimpleLog.Current.WriteError(msg);
            MessageBox(msg, checkIfSuppressed);
        }

        public static void MessageBox(string msg, bool checkIfSuppressed = false)
        {
            if (!checkIfSuppressed || !Configs.Current.SuppressDialogs)
            {
                System.Windows.Forms.MessageBox.Show(msg);
            }
        }

        public static bool IsDebug()
        {
#if DEBUG
            return true;
#else
            return false;
#endif
        }

        public static void AssertEq(object expected, object actual, string msg = "")
        {
            // use a token to make sure that IsEq(null, null) works.
            expected = expected ?? tokenRepresentingNull;
            actual = actual ?? tokenRepresentingNull;

            if (!expected.Equals(actual))
            {
                throw new CsDownloadVidException(
                    "Assertion failure, " + Utils.NL + Utils.NL + msg +
                    ", expected " + expected + " but got " + actual);
            }
        }

        public static void AssertTrue(bool actual, string msg = "")
        {
            AssertEq(true, actual, msg);
        }

        public static string[] SplitLines(string s)
        {
            // let's support both win and unix newlines
            return s.Replace("\r\n", "\n").Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
        }
    }

    // file list that updates itself when file names are changed.
    public sealed class FileListAutoUpdated : IDisposable
    {
        bool _dirty = true;
        string[] _list = new string[] { };
        FileSystemWatcher _watcher;
        readonly string _baseDir;

        public FileListAutoUpdated(string baseDir, bool recurse)
        {
            Recurse = recurse;
            _baseDir = baseDir;
            _watcher = new FileSystemWatcher(baseDir);
            _watcher.IncludeSubdirectories = recurse;
            _watcher.Created += SetDirty;
            _watcher.Renamed += SetDirty;
            _watcher.Deleted += SetDirty;
            _watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName
                | NotifyFilters.DirectoryName;
            _watcher.EnableRaisingEvents = true;
        }

        public bool Recurse { get; private set; }

        private void SetDirty(object sender, FileSystemEventArgs e)
        {
            _dirty = true;
        }

        public void Dirty()
        {
            _dirty = true;
        }

        public string[] GetList(bool forceRefresh = false)
        {
            if (_dirty || forceRefresh)
            {
                // DirectoryInfo takes about 13ms, for a 900 file directory
                // Directory.EnumerateFiles takes about 12ms
                var enumerator = Directory.EnumerateFiles(_baseDir, "*",
                    Recurse ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly);
                _list = enumerator.ToArray();
                Array.Sort(_list, StringComparer.OrdinalIgnoreCase);
                _dirty = false;
            }

            return _list;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (_watcher != null)
                {
                    _watcher.Dispose();
                }
            }
        }
    }

    // navigates a FileListAutoUpdated in alphabetical order.
    // gracefully handles the case when navigating to a file that was just deleted, and
    // FileListAutoUpdated has not yet received the notification event.
    public sealed class FileListNavigation : IDisposable
    {
        readonly string[] _extensionsAllowed;
        readonly bool _excludeMarked;
        FileListAutoUpdated _list;
        public FileListNavigation(string baseDir, string[] extensionsAllowed,
             bool recurse, bool excludeMarked = true, string sCurrent = "")
        {
            BaseDirectory = baseDir;
            _extensionsAllowed = extensionsAllowed;
            _list = new FileListAutoUpdated(baseDir, recurse);
            _excludeMarked = excludeMarked;
            TrySetPath(sCurrent);
        }

        public string Current { get; private set; }
        public string BaseDirectory { get; private set; }

        public void Refresh()
        {
            _list = new FileListAutoUpdated(BaseDirectory, _list.Recurse);
            TrySetPath("");
        }

        public void NotifyFileChanges()
        {
            _list.Dirty();
        }

        // try an action twice if necessary.
        // if the filepath we are given no longer exists,
        // FileListAutoUpdated might have not received the notification event yet,
        // so tell it to refresh and retry once more.
        void TryAgainIfFileIsMissing(Func<string[], string> fn)
        {
            var list = GetList();
            if (list.Length == 0)
            {
                Current = null;
                return;
            }

            string firstTry = fn(list);
            if (firstTry != null && !File.Exists(firstTry))
            {
                // refresh the list and try again
                list = GetList(true);
                if (list.Length == 0)
                {
                    Current = null;
                    return;
                }

                Current = fn(list);
            }
            else
            {
                Current = firstTry;
            }
        }

        static int GetLessThanOrEqual(string[] list, string search)
        {
            var index = Array.BinarySearch(list, search, StringComparer.OrdinalIgnoreCase);
            if (index < 0)
            {
                index = ~index - 1;
            }

            return index;
        }

        public void GoNextOrPrev(bool isNext, List<string> neighbors = null,
            int retrieveNeighbors = 0)
        {
            TryAgainIfFileIsMissing((list) =>
            {
                var index = GetLessThanOrEqual(list, Current ?? "");
                if (isNext)
                {
                    // caller has asked us to return adjacent items
                    for (int i = 0; i < retrieveNeighbors; i++)
                    {
                        neighbors[i] = Utils.ArrayAt(list, index + i + 2);
                    }

                    return Utils.ArrayAt(list, index + 1);
                }
                else
                {
                    // index is LessThanOrEqual, but we want strictly LessThan
                    // so move prev if equal.
                    if (index > 0 && Current == list[index])
                    {
                        index--;
                    }

                    // caller has asked us to return adjacent items
                    for (int i = 0; i < retrieveNeighbors; i++)
                    {
                        neighbors[i] = Utils.ArrayAt(list, index - i - 1);
                    }

                    return Utils.ArrayAt(list, index);
                }
            });
        }

        public void GoFirst()
        {
            TryAgainIfFileIsMissing((list) =>
            {
                return list[0];
            });
        }

        public void GoLast()
        {
            TryAgainIfFileIsMissing((list) =>
            {
                return list[list.Length - 1];
            });
        }

        public void TrySetPath(string current, bool verify = true)
        {
            Current = current;
            if (verify)
            {
                TryAgainIfFileIsMissing((list) =>
                {
                    var index = GetLessThanOrEqual(list, Current ?? "");
                    return Utils.ArrayAt(list, index);
                });
            }
        }

        public string[] GetList(bool forceRefresh = false, bool includeMarked = false)
        {
            Func<string, bool> includeFile = (path) =>
            {
                if (!includeMarked && _excludeMarked && path.Contains(FilenameUtils.MarkerString))
                    return false;
                else if (!FilenameUtils.IsExtensionInList(path, _extensionsAllowed))
                    return false;
                else
                    return true;
            };

            return _list.GetList(forceRefresh).Where(includeFile).ToArray();
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (_list != null)
                {
                    _list.Dispose();
                }
            }
        }
    }

    public static class FilenameUtils
    {
        public static readonly string MarkerString = "__MARKAS__";

        public static bool LooksLikeImage(string filepath)
        {
            return IsExtensionInList(filepath, new string[] { ".jpg", ".png",
                ".gif", ".bmp", ".webp", ".emf", ".wmf", ".jpeg" });
        }

        public static bool LooksLikeAudio(string filepath)
        {
            return IsExtensionInList(filepath, new string[] { ".wav", ".flac",
                ".mp3", ".m4a", ".mp4" });
        }

        public static bool IsExtensionInList(string filepath, string[] extensions)
        {
            var filepathLower = filepath.ToLowerInvariant();
            foreach (var item in extensions)
            {
                if (filepathLower.EndsWith(item, StringComparison.Ordinal))
                {
                    return true;
                }
            }

            return false;
        }

        public static bool IsExt(string filepath, string extension)
        {
            return filepath.ToLowerInvariant().EndsWith(extension, StringComparison.Ordinal);
        }

        public static int NumberedPrefixLength()
        {
            return "([0000])".Length;
        }

        public static string AddNumberedPrefix(string filepath, int number)
        {
            var nameOnly = Path.GetFileName(filepath);
            if (nameOnly != GetFileNameWithoutNumberedPrefix(filepath))
            {
                // already has one
                return filepath;
            }
            else
            {
                // add a trailing zero, just lets the user change the order more easily.
                return Path.GetDirectoryName(filepath) +
                    Utils.Sep + "([" + number.ToString("D3") + "0])" + nameOnly;
            }
        }

        public static string GetFileNameWithoutNumberedPrefix(string filepath)
        {
            var nameOnly = Path.GetFileName(filepath);
            if (nameOnly.Length > NumberedPrefixLength() &&
                nameOnly.StartsWith("([", StringComparison.Ordinal) &&
                nameOnly.Substring(6, 2) == "])")
            {
                return nameOnly.Substring(NumberedPrefixLength());
            }
            else
            {
                return nameOnly;
            }
        }

        public static string AddCategoryToFilename(string path, string category)
        {
            if (path.Contains(MarkerString))
            {
                Utils.MessageErr("Path " + path + " already contains marker.");
                return path;
            }

            var ext = Path.GetExtension(path);
            var before = Path.GetFileNameWithoutExtension(path);
            return Path.Combine(Path.GetDirectoryName(path), before) +
                MarkerString + category + ext;
        }

        public static void GetCategoryFromFilename(string pathAndCategory,
            out string pathWithoutCategory, out string category)
        {
            // check nothing in path has mark
            if (Path.GetDirectoryName(pathAndCategory).Contains(MarkerString))
            {
                throw new CsDownloadVidException("Directories should not have marker");
            }

            var parts = Utils.SplitByString(pathAndCategory, MarkerString);
            if (parts.Length != 2)
            {
                throw new CsDownloadVidException("Path " + pathAndCategory +
                    " should contain exactly 1 marker.");
            }

            var partsAfterMarker = parts[1].Split(new char[] { '.' });
            if (partsAfterMarker.Length != 2)
            {
                throw new CsDownloadVidException(
                    "Parts after the marker shouldn't have another .");
            }

            category = partsAfterMarker[0];
            pathWithoutCategory = parts[0] + "." + partsAfterMarker[1];
        }

        public static bool SameExceptExtension(string filepath1, string filepath2)
        {
            var rootNoExtension1 = Path.Combine(
                Path.GetDirectoryName(filepath1), Path.GetFileNameWithoutExtension(filepath1));
            var rootNoExtension2 = Path.Combine(
                Path.GetDirectoryName(filepath2), Path.GetFileNameWithoutExtension(filepath2));

            return rootNoExtension1.ToUpperInvariant() == rootNoExtension2.ToUpperInvariant();
        }

        public static bool IsPathRooted(string filepath)
        {
            try
            {
                return Path.IsPathRooted(filepath);
            }
            catch (ArgumentException)
            {
                return false;
            }
        }
    }

    // Simple logging class, writes synchronously to a text file.
    public sealed class SimpleLog
    {
        private const int CheckFileSizePeriod = 32;
        private static SimpleLog _instance;
        readonly string _path;
        readonly int _maxFileSize;
        int _counter;
        public SimpleLog(string path, int maxFileSize = 4 * 1024 * 1024)
        {
            _path = path;
            _maxFileSize = maxFileSize;
        }

        public static SimpleLog Current
        {
            get
            {
                return _instance;
            }
        }

        public static void Init(string path)
        {
            _instance = new SimpleLog(path);
        }

        public void WriteLog(string s)
        {
            // rather than cycling logging, delete previous logs for simplicity.
            _counter++;
            if (_counter > CheckFileSizePeriod)
            {
                if (File.Exists(_path) && new FileInfo(_path).Length > _maxFileSize)
                {
                    File.Delete(_path);
                }

                _counter = 0;
            }

            try
            {
                File.AppendAllText(_path, Utils.NL + s);
            }
            catch (Exception)
            {
                if (!Utils.AskToConfirm("Could not write to " + _path +
                    "; labs_coordinate_pictures.exe currently needs to be " +
                    "in writable directory. Continue?"))
                {
                    Environment.Exit(1);
                }
            }
        }

        public void WriteWarning(string s)
        {
            WriteLog("[warning] " + s);
        }

        public void WriteError(string s)
        {
            WriteLog("[error] " + s);
        }

        public void WriteVerbose(string s)
        {
            if (Configs.Current.GetBool(ConfigKey.EnableVerboseLogging))
            {
                WriteLog("[vb] " + s);
            }
        }
    }

    // finds similar filenames, especially those created by FormGallery::convertToSeveralJpgs.
    // e.g., given example.png90.jpg, will see that
    // example.png, example_out.png and example.png60.jpg are related files.
    public static class FindSimilarFilenames
    {
        public static bool FindPathWithSuffixRemoved(string path, string[] extensions,
            out string pathWithSuffixRemoved)
        {
            pathWithSuffixRemoved = null;
            var filenameParts = Path.GetFileName(path).Split(new char[] { '.' });
            if (filenameParts.Length > 2)
            {
                var middle = filenameParts[filenameParts.Length - 2].ToLowerInvariant();
                bool found = false;
                foreach (var fileExt in extensions)
                {
                    var type = fileExt.Replace(".", "");
                    if (middle.StartsWith(type, StringComparison.Ordinal) &&
                        Utils.IsDigits(middle.Replace(type, "")))
                    {
                        found = true;
                        break;
                    }
                }

                if (found)
                {
                    var list = new List<string>(filenameParts);
                    list.RemoveAt(list.Count - 2);
                    pathWithSuffixRemoved = Path.GetDirectoryName(path) +
                        Utils.Sep + string.Join(".", list);

                    return true;
                }
            }

            return false;
        }

        public static List<string> FindSimilarNames(string path, string[] types,
            string[] otherFiles, out bool nameHasSuffix, out string pathWithoutSuffix)
        {
            // parse the file
            pathWithoutSuffix = null;
            nameHasSuffix = FindPathWithSuffixRemoved(path, types, out pathWithoutSuffix);

            // delete all the rest in group
            var nameWithoutSuffix = nameHasSuffix ? pathWithoutSuffix : path;
            List<string> results = new List<string>();
            foreach (var otherFile in otherFiles)
            {
                if (otherFile.ToUpperInvariant() != path.ToUpperInvariant())
                {
                    if (FilenameUtils.SameExceptExtension(nameWithoutSuffix, otherFile) ||
                        (FindPathWithSuffixRemoved(otherFile, types, out string nameMiddleRemoved) &&
                        FilenameUtils.SameExceptExtension(nameWithoutSuffix, nameMiddleRemoved)))
                    {
                        results.Add(otherFile);
                    }
                }
            }

            return results;
        }
    }

    public sealed class UndoStack<T>
    {
        List<T> _list = new List<T>();
        int _position = -1;

        public void Add(T current)
        {
            // if we are here after having called undo,
            // invalidate items higher on the stack
            _list.RemoveRange(_position + 1, (_list.Count - _position) - 1);

            // add to stack
            _list.Add(current);
            _position = _list.Count - 1;
        }

        public T PeekUndo()
        {
            if (_position >= 0)
                return _list[_position];
            else
                return default(T);
        }

        public void Undo()
        {
            if (_position >= 0)
                --_position;
        }

        public T PeekRedo()
        {
            if (_position + 1 <= _list.Count - 1)
                return _list[_position + 1];
            else
                return default(T);
        }

        public void Redo()
        {
            if (_position + 1 <= _list.Count - 1)
                ++_position;
        }
    }

    [Serializable]
    public sealed class CsDownloadVidException : Exception
    {
        public CsDownloadVidException(string message, Exception e)
            : base(message, e)
        {
        }

        public CsDownloadVidException(string message)
            : this(message, null)
        {
        }

        public CsDownloadVidException()
            : this("", null)
        {
        }

        CsDownloadVidException(System.Runtime.Serialization.SerializationInfo info,
            System.Runtime.Serialization.StreamingContext context)
            : base(info, context)
        {
        }
    }
}
// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Windows.Forms;

namespace CsDownloadVid
{
    public partial class FormAudioFromVideo : Form
    {
        RunToolHelper _runner;
        public FormAudioFromVideo()
        {
            InitializeComponent();
            _runner = new RunToolHelper(this.txtStatus, this.lblShortStatus,
                GetFfmpegStdoutFilter());
        }

        private void txtInput_Click(object sender, EventArgs e)
        {
            RunToolHelper.RunAndCatch(() => btnGetInput_Click(sender, e));
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            RunToolHelper.RunAndCatch(() => _runner.CancelProcess());
        }

        private void getAudio_Click(object sender, EventArgs e)
        {
            var suggestedFormat = tbOutputFormat.Text;
            RunToolHelper.RunAndCatch(() => GoExtract(true, suggestedFormat));
        }

        private void getVideo_Click(object sender, EventArgs e)
        {
            var suggestedFormat = tbOutputFormat.Text;
            RunToolHelper.RunAndCatch(() => GoExtract(false, suggestedFormat));
        }

        private void btnGetInput_Click(object sender, EventArgs e)
        {
            var files = Utils.AskOpenFilesDialog("Choose video file(s)...");
            if (files != null)
            {
                txtInput.Text = string.Join(";", files);
            }
        }

        private ProcessStartInfo MakeTask(bool audioOrVideo, string suggestedFormat, string file)
        {
            if (suggestedFormat.StartsWith("."))
            {
                // let the user type ".m4a" as well as "m4a"
                suggestedFormat = suggestedFormat.Substring(1);
            }

            Utils.AssertTrue(suggestedFormat.Length > 0, "You did not provide a suggested format.");
            var args = new List<string>();
            args.Add("-nostdin");
            args.Add("-i");
            args.Add(file);
            if (audioOrVideo)
            {
                var format = suggestedFormat == "auto" ? "m4a" : suggestedFormat;
                args.Add("-vn");
                args.Add("-acodec");
                args.Add("copy");
                args.Add(file + "_audio." + format);
            }
            else
            {
                var format = suggestedFormat == "auto" ? "m4v" : suggestedFormat;
                args.Add("-an");
                args.Add("-vcodec");
                args.Add("copy");
                args.Add(file + "_video." + format);
            }

            var info = new ProcessStartInfo();
            info.FileName = CsDownloadVidFilepaths.GetFfmpeg();
            info.Arguments = Utils.CombineProcessArguments(args.ToArray());
            info.CreateNoWindow = true;
            info.RedirectStandardError = true;
            info.RedirectStandardOutput = true;
            info.UseShellExecute = false;
            return info;
        }

        private ProcessStartInfo MakeTaskCombineAudioVideo(string audioFile, string videoFile,
            string output)
        {
            var args = new List<string>();
            args.Add("-nostdin");
            args.Add("-i");
            args.Add(videoFile);
            args.Add("-i");
            args.Add(audioFile);
            args.Add("-c:v");
            args.Add("copy");
            args.Add("-c:a");
            args.Add("copy");
            args.Add(output);
            _runner.Trace("Saving to " + output);

            var info = new ProcessStartInfo();
            info.FileName = CsDownloadVidFilepaths.GetFfmpeg();
            info.Arguments = Utils.CombineProcessArguments(args.ToArray());
            info.CreateNoWindow = true;
            info.RedirectStandardError = true;
            info.RedirectStandardOutput = true;
            info.UseShellExecute = false;
            return info;
        }

        private void GoExtract(bool audioOrVideo, string suggestedFormat)
        {
            var files = Utils.SplitByString(txtInput.Text, ";");
            if (txtInput.Text.Trim() == "" || files.Length == 0)
            {
                MessageBox.Show("No files chosen.");
            }

            List<ProcessStartInfo> tasks = new List<ProcessStartInfo>();
            foreach (var file in files)
            {
                if (!File.Exists(file))
                {
                    MessageBox.Show("Input file " + file + "does not exist");
                    return;
                }

                if (!file.ToLowerInvariant().EndsWith(".m4a") &&
                    !file.ToLowerInvariant().EndsWith(".mp4") &&
                    !file.ToLowerInvariant().EndsWith(".m4v"))
                {
                    if (!Utils.AskToConfirm("Might not work, the file is not a m4a/mp4/m4v" +
                        "... continue?"))
                    {
                        return;
                    }
                }

                ProcessStartInfo task = MakeTask(audioOrVideo, suggestedFormat, file);
                tasks.Add(task);
            }

            _runner.RunProcesses(tasks.ToArray(), "Extract " + (audioOrVideo ? "Audio" :
                "Video"));
        }

        private void btnCombineAudioVideo_Click(object sender, EventArgs e)
        {
            var audio = Utils.AskOpenFileDialog("Choose an audio file (typically m4a or mp3)...");
            if (audio == null)
            {
                return;
            }

            var video = Utils.AskOpenFileDialog("Choose a video file (typically mp4 or mkv)...");
            if (video == null)
            {
                return;
            }

            var outFormat = Path.GetExtension(video);
            outFormat = video.EndsWith(".m4v") ? ".mp4" : outFormat;
            var output = video + "_out" + outFormat;
            if (File.Exists(output))
            {
                MessageBox.Show("File already exists " + output);
                return;
            }

            var task = MakeTaskCombineAudioVideo(audio, video, output);
            _runner.RunProcesses(new ProcessStartInfo[] { task }, "Combine as soundtrack");
        }

        public static Func<string, bool> GetFfmpegStdoutFilter()
        {
            return (s) => !s.StartsWith(" ffmpeg version") &&
                !s.StartsWith("   configuration:") &&
                !s.StartsWith("   lib") &&
                !s.StartsWith("   Metadata:") &&
                !s.StartsWith(" Press [q]") &&
                !s.StartsWith("     major_brand") &&
                !s.StartsWith("     minor_version") &&
                !s.StartsWith("     compatible_brands") &&
                !s.StartsWith("     creation_time") &&
                !s.StartsWith("     encoder ") &&
                !s.StartsWith("     Encoding Params") &&
                !s.StartsWith("     iTunSMPB") &&
                !s.StartsWith("     title ") &&
                !s.StartsWith("     artist ") &&
                !s.StartsWith("     album ") &&
                !s.StartsWith("     description ") &&
                !s.StartsWith("     comment ");
        }
    }
}
// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Windows.Forms;

namespace CsDownloadVid
{
    public sealed class InputBoxForm : Form
    {
        Container _components = null;
        Button _btnBrowse;
        Button _btnCancel;
        Button _btnOK;
        ComboBox _comboBox;
        Label _label;
        PersistMostRecentlyUsedList _mru;

        public InputBoxForm(InputBoxHistory currentKey)
        {
            InitializeComponent();
            _mru = new PersistMostRecentlyUsedList(currentKey);
            this.StartPosition = FormStartPosition.CenterParent;
            this.Text = " ";
            this.AllowDrop = true;
            this._comboBox.Focus();

            // we don't use autocomplete, we just enable it
            // to get the Ctrl+Backspace shortcut
            this._comboBox.AutoCompleteMode = AutoCompleteMode.Append;
        }

        // add MRU history, suggestions, and clipboard contents to the list of examples.
        public static IEnumerable<string> GetInputSuggestions(string currentSuggestion,
            InputBoxHistory historyKey, PersistMostRecentlyUsedList history,
            bool useClipboard, bool mustBeDirectory, string[] more)
        {
            List<string> suggestions = new List<string>();
            if (!string.IsNullOrEmpty(currentSuggestion))
            {
                suggestions.Add(currentSuggestion);
            }

            if (useClipboard && !string.IsNullOrEmpty(Utils.GetClipboard()) &&
                Utils.LooksLikePath(Utils.GetClipboard()) == mustBeDirectory)
            {
                // get from clipboard if the right type of string (path vs not path)
                suggestions.Add(Utils.GetClipboard());
            }

            if (historyKey != InputBoxHistory.None)
            {
                suggestions.AddRange(history.Get());
            }

            if (more != null)
            {
                suggestions.AddRange(more);
            }

            return suggestions.Where(entry => !mustBeDirectory ||
                FilenameUtils.IsPathRooted(entry));
        }

        // ask user for string input.
        public static string GetStrInput(string mesage, string currentSuggestion = null,
            InputBoxHistory historyKey = InputBoxHistory.None, string[] more = null,
            bool useClipboard = true, bool mustBeDirectory = false, bool taller = false)
        {
            using (InputBoxForm form = new InputBoxForm(historyKey))
            {
                form._label.Text = mesage;
                form._btnBrowse.Visible = mustBeDirectory;
                form._btnBrowse.Click += (o, e) => form.OnBrowseClick();
                if (taller)
                {
                    form._comboBox.Top += form.Height - 40;
                    form._btnOK.Top += form.Height - 40;
                    form._btnCancel.Top += form.Height - 40;
                    form._label.Height += form.Height - 40;
                    form.Height *= 2;
                }

                // fill combo box with suggested input.
                form._comboBox.Items.Clear();
                var suggestions = GetInputSuggestions(currentSuggestion, historyKey, form._mru,
                    useClipboard, mustBeDirectory, more).ToArray();

                foreach (var s in suggestions)
                {
                    form._comboBox.Items.Add(s);
                }

                form._comboBox.Text = suggestions.Length > 0 ? suggestions[0] : "";
                form.ShowDialog();
                if (form.DialogResult != DialogResult.OK)
                {
                    return null;
                }

                if (mustBeDirectory && !Directory.Exists(form._comboBox.Text))
                {
                    Utils.MessageBox("Directory does not exist");
                    return null;
                }

                // save to history
                form._mru.AddToHistory(form._comboBox.Text);
                return form._comboBox.Text;
            }
        }

        public static int? GetInteger(string message, int defaultInt = 0,
            InputBoxHistory historyKey = InputBoxHistory.None)
        {
            int fromClipboard = 0;
            var clipboardContainsInt = int.TryParse(Utils.GetClipboard(), out fromClipboard);
            string s = GetStrInput(message, defaultInt.ToString(), historyKey,
                useClipboard: clipboardContainsInt);

            if (string.IsNullOrEmpty(s) || !int.TryParse(s, out int result))
            {
                return null;
            }
            else
            {
                return result;
            }
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (_components != null)
                {
                    _components.Dispose();
                }
            }

            base.Dispose(disposing);
        }

        // originally based on
        // http://www.java2s.com/Code/CSharp/GUI-Windows-Form/
        // Defineyourowndialogboxandgetuserinput.htm
        #region Windows Form Designer generated code
        private void InitializeComponent()
        {
            this._label = new System.Windows.Forms.Label();
            this._btnOK = new System.Windows.Forms.Button();
            this._btnCancel = new System.Windows.Forms.Button();
            this._comboBox = new System.Windows.Forms.ComboBox();
            this._btnBrowse = new System.Windows.Forms.Button();
            this.SuspendLayout();

            // _label
            this._label.Location = new System.Drawing.Point(12, 8);
            this._label.Name = "_label";
            this._label.Size = new System.Drawing.Size(410, 187);
            this._label.TabIndex = 6;
            this._label.Text = "Type in your message.";

            // _btnOK
            this._btnOK.DialogResult = System.Windows.Forms.DialogResult.OK;
            this._btnOK.Location = new System.Drawing.Point(259, 246);
            this._btnOK.Name = "_btnOK";
            this._btnOK.Size = new System.Drawing.Size(70, 24);
            this._btnOK.TabIndex = 2;
            this._btnOK.Text = "OK";

            // _btnCancel
            this._btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this._btnCancel.Location = new System.Drawing.Point(335, 246);
            this._btnCancel.Name = "_btnCancel";
            this._btnCancel.Size = new System.Drawing.Size(70, 24);
            this._btnCancel.TabIndex = 3;
            this._btnCancel.Text = "Cancel";

            // _comboBox
            this._comboBox.FormattingEnabled = true;
            this._comboBox.Location = new System.Drawing.Point(22, 208);
            this._comboBox.Name = "_comboBox";
            this._comboBox.Size = new System.Drawing.Size(383, 21);
            this._comboBox.TabIndex = 1;

            // _btnBrowse
            this._btnBrowse.Location = new System.Drawing.Point(183, 246);
            this._btnBrowse.Name = "_btnBrowse";
            this._btnBrowse.Size = new System.Drawing.Size(70, 24);
            this._btnBrowse.TabIndex = 3;
            this._btnBrowse.Text = "Browse...";

            // InputBoxForm
            this.AcceptButton = this._btnOK;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.CancelButton = this._btnCancel;
            this.ClientSize = new System.Drawing.Size(434, 287);
            this.ControlBox = false;
            this.Controls.Add(this._comboBox);
            this.Controls.Add(this._btnBrowse);
            this.Controls.Add(this._btnCancel);
            this.Controls.Add(this._btnOK);
            this.Controls.Add(this._label);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "InputBoxForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Input Box Dialog";
            this.DragDrop += new System.Windows.Forms.DragEventHandler(this.InputBoxForm_DragDrop);
            this.DragEnter += new System.Windows.Forms.DragEventHandler(this.InputBoxForm_DragEnter);
            this.ResumeLayout(false);
        }
        #endregion

        private void OnBrowseClick()
        {
            var dlg = new FolderBrowserDialog();
            if (dlg.ShowDialog(this) == DialogResult.OK)
            {
                _comboBox.Text = dlg.SelectedPath;
            }
        }

        private void InputBoxForm_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
                e.Effect = DragDropEffects.Copy;
            else
                e.Effect = DragDropEffects.None;
        }

        // if user drags a file onto this form, put the filepath into the combo box.
        private void InputBoxForm_DragDrop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop, false))
            {
                string[] filePaths = (string[])e.Data.GetData(DataFormats.FileDrop);
                string filePath = filePaths[0];
                if (!string.IsNullOrEmpty(filePath))
                {
                    _comboBox.Text = filePath;
                }
            }
        }
    }

    // save MRU history, limits number of entries with a queue structure.
    public sealed class PersistMostRecentlyUsedList
    {
        readonly int _maxHistoryEntries;
        readonly int _maxEntryLength;
        readonly string _delimiter = "||||";
        InputBoxHistory _historyKey = InputBoxHistory.None;
        ConfigKey _configsKey = ConfigKey.None;
        Configs _configs;
        string[] _currentItems;
        public PersistMostRecentlyUsedList(InputBoxHistory historyKey,
            Configs configs = null, int maxHistoryEntries = 50)
        {
            _historyKey = historyKey;
            _configs = configs ?? Configs.Current;
            _maxHistoryEntries = maxHistoryEntries;
            _maxEntryLength = 300;

            // find the corresponding ConfigKey for this InputBoxHistory
            if (_historyKey != InputBoxHistory.None)
            {
                if (!Enum.TryParse("MRU" + _historyKey.ToString(), out _configsKey))
                {
                    throw new CsDownloadVidException(
                        "unknown history key" + _historyKey.ToString());
                }
            }
        }

        public string[] Get()
        {
            if (_configsKey != ConfigKey.None)
            {
                _currentItems = _configs.Get(_configsKey).Split(
                    new string[] { _delimiter }, StringSplitOptions.RemoveEmptyEntries);

                return _currentItems;
            }
            else
            {
                return new string[] { };
            }
        }

        public void AddToHistory(string s)
        {
            if (_configsKey != ConfigKey.None)
            {
                if (_currentItems == null)
                {
                    Get();
                }

                // only add if it's not already in the list, and s does not contain _delimiter.
                if (!string.IsNullOrEmpty(s) &&
                    s.Length < _maxEntryLength && !s.Contains(_delimiter))
                {
                    List<string> list = new List<string>(_currentItems);

                    // if it's also elsewhere in the list, remove that one
                    var indexAlreadyFound = Array.IndexOf(_currentItems, s);
                    if (indexAlreadyFound != -1)
                    {
                        list.RemoveAt(indexAlreadyFound);
                    }

                    // insert new entry at the top
                    list.Insert(0, s);

                    // if we've reached the limit, cut out the extra ones
                    while (list.Count > _maxHistoryEntries)
                    {
                        list.RemoveAt(list.Count - 1);
                    }

                    // save to configs
                    _configs.Set(_configsKey, string.Join(_delimiter, list));

                    // refresh in-memory cache
                    Get();
                }
            }
        }
    }
}// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows.Forms;

namespace CsDownloadVid
{
    public partial class FormMediaSplit : Form
    {
        RunToolHelper _runner;
        public FormMediaSplit()
        {
            InitializeComponent();
            txtSplitpoints.Text = "0:40" + Utils.NL + "1:30";
            _runner = new RunToolHelper(txtStatus, lblShortStatus,
                FormAudioFromVideo.GetFfmpegStdoutFilter());
        }

        private void btnImportAudacity_Click(object sender, EventArgs e)
        {
            var file = Utils.AskOpenFileDialog("Choose Audacity text file " +
                "(File->Export labels as text)", new string[] { "*.txt" });

            if (file != null)
            {
                var lines = File.ReadAllLines(file);
                RunToolHelper.RunAndCatch(() => ImportAudacity(lines));
            }
        }

        private void btnShowSum_Click(object sender, EventArgs e)
        {
            RunToolHelper.RunAndCatch(() =>
            {
                var splitPoints = GetSplitTimes(txtSplitpoints.Text);
                double total = splitPoints.Sum();
                double subseconds = total - (int)total;
                int seconds = ((int)total) % 60;
                int minutes = ((int)total) / 60;
                MessageBox.Show("Sum of all times is " + minutes + ":" +
                    seconds + subseconds.ToString("#.0000"));
            });
        }

        private void btnGetInput_Click(object sender, EventArgs e)
        {
            var file = Utils.AskOpenFileDialog("Choose video file(s)...");
            txtInput.Text = file ?? "";
            txtInput.Visible = true;
        }

        private void btnSplit_Click(object sender, EventArgs e)
        {
            RunToolHelper.RunAndCatch(() =>
            {
                var input = txtInput.Text;
                var times = GetSplitTimes(txtSplitpoints.Text);
                if (times.Count == 0)
                {
                    throw new CsDownloadVidException("No split points added.");
                }
                else if (!File.Exists(input))
                {
                    throw new CsDownloadVidException("Input file not found");
                }

                if (!(input.EndsWith(".m4a") || input.EndsWith(".m4v")))
                {
                    if (!Utils.AskToConfirm("Warning: designed for .m4a or .m4v files, " +
                        "this might not work. Continue?"))
                    {
                        return;
                    }
                }

                if (checkBoxFadeout.Checked)
                {
                    SplitWithFadeout(input, times, txtFadeLength.Text);
                }
                else
                {
                    SplitMedia(input, times);
                }
            });
        }

        private void ImportAudacity(string[] lines)
        {
            txtSplitpoints.Text = "";
            foreach (var line in lines)
            {
                if (line.Trim().Length > 0)
                {
                    if (line.Contains("\t"))
                    {
                        var beforeTab = Utils.SplitByString(line, "\t")[0];
                        txtSplitpoints.AppendText(Utils.NL + beforeTab);
                    }
                    else
                    {
                        throw new CsDownloadVidException("expected lines to be in the form " +
                            "Number(tab)Label, but got " + line);
                    }
                }
            }
        }

        private void SplitWithFadeout(string inputFile, List<double> splitPoints,
            string sFadeLength)
        {
            const int sampleRate = 44100;
            string outFilename = inputFile + "_fadeout.m4a";
            if (!double.TryParse(sFadeLength, out double fadeLength) || fadeLength <= 0)
            {
                throw new CsDownloadVidException("Invalid fadelength, expected a number of " +
                    "seconds like 4");
            }
            else if (splitPoints.Count == 0)
            {
                throw new CsDownloadVidException("Enter a time, in seconds");
            }
            else if (splitPoints.Count != 1)
            {
                throw new CsDownloadVidException("It looks like you have entered more than " +
                    "one time point. Please enter just one time, in seconds.");
            }
            else if (!inputFile.EndsWith(".m4a"))
            {
                throw new CsDownloadVidException("We currently only support adding fadeout " +
                    "for m4a files (if you have a .mp4 song, please rename it to .m4a first).");
            }
            else if (File.Exists(outFilename))
            {
                throw new CsDownloadVidException("Output file already exists " + outFilename);
            }

            // preemptively make sure we have a path to qaac.
            CsDownloadVidFilepaths.GetQaac();

            // run all in a separate thread, so that UI remains responsive.
            _runner.RunInThread(() =>
            {
                var log = "";
                new AddFadeoutUsingRawAacData().Go(inputFile, sampleRate, splitPoints[0],
                    fadeLength, outFilename, ref log);

                _runner.TraceFiltered(log.Replace("\n", Utils.NL));
                _runner.Trace(File.Exists(outFilename) ? "Successfully saved to " + outFilename :
                    "Error(s) occurred");
            });
        }

        private void SplitMedia(string inputFile, List<double> splitPoints)
        {
            const int maxLenSeconds = 9999;
            splitPoints.Insert(0, 0.0);
            var startingPoints = new List<double>();
            var lengths = new List<double>();
            for (int i = 0; i < splitPoints.Count; i++)
            {
                var start = splitPoints[i];
                double length = 0;
                if (i < splitPoints.Count - 1)
                {
                    var end = splitPoints[i + 1];
                    length = end - start;
                }
                else
                {
                    // just get all the rest
                    length = maxLenSeconds;
                }

                if (start > maxLenSeconds || length > maxLenSeconds)
                {
                    throw new CsDownloadVidException("we don't currently support very long " +
                        "files longer than " + maxLenSeconds + " seconds");
                }

                startingPoints.Add(start);
                lengths.Add(length);
            }

            // run all in a separate thread, so that UI remains responsive.
            _runner.RunInThread(() =>
            {
                var log = "";
                for (int i = 0; i < startingPoints.Count; i++)
                {
                    new AddFadeoutUsingRawAacData().SplitOneFileSynchronous(
                        inputFile, startingPoints[i], lengths[i], i, ref log);
                }

                _runner.TraceFiltered(log);
                _runner.Trace("Done");
            });
        }

        string SecondsToHoursMinutesSeconds(double fSeconds, bool largestIsMinutes)
        {
            if (largestIsMinutes)
            {
                // an easy way to show minutes instead of hours
                fSeconds *= 60;
            }

            Utils.AssertTrue(fSeconds >= 0);
            var ms = fSeconds - (int)fSeconds;
            var msRounded = (int)(1000 * ms);
            int nSeconds = (int)(fSeconds);
            int secsRounded = nSeconds % 60;
            int minRounded = (nSeconds / 60) % 60;
            int hrRounded = (nSeconds / (60 * 60));
            return string.Format("{0}:{1}:{2}.{3}",
                hrRounded.ToString("D2"),
                minRounded.ToString("D2"), secsRounded.ToString("D2"),
                ms.ToString().Replace("0.", ""));
        }

        double ParseTimeFromText(string text)
        {
            var parts = text.Split(new char[] { ':' });
            if (parts.Length == 1)
            {
                return double.Parse(parts[0]);
            }
            else if (parts.Length == 2)
            {
                return 60 * double.Parse(parts[0]) + double.Parse(parts[1]);
            }
            else if (parts.Length == 3)
            {
                return 60 * 60 * double.Parse(parts[0]) + 60 * double.Parse(parts[1]) + double.Parse(parts[2]);
            }
            else
            {
                throw new CsDownloadVidException("we currently require either (seconds) or " +
                    "(minutes):(seconds) form.");
            }
        }

        List<double> GetSplitTimes(string text)
        {
            // Sites like YouTube sometimes insert this left-to-right mark character.
            string leftToRightMark = "" +(char)8206;
            string spaceMark = "" +(char)8203;
            text = text.Replace(leftToRightMark, "").Replace(spaceMark, "");

            List<double> times = new List<double>();
            foreach (var line in Utils.SplitLines(text))
            {
                times.Add(ParseTimeFromText(line));
                if (times[times.Count - 1] <= 0)
                {
                    throw new CsDownloadVidException("Invalid time, must be > 0.0 seconds");
                }
            }

            return times;
        }

        private void btnToMp3DirectCut_Click(object sender, EventArgs e)
        {
            var output = Utils.AskSaveFileDialog("Save .cue file:", new string[] { "*.cue" });
            if (!string.IsNullOrEmpty(output))
            {
                var times = GetSplitTimes(txtSplitpoints.Text);
                var result = ToCueFile(times);
                File.WriteAllText(output, result);
            }
        }

        string ToCueFile(List<double> times)
        {
            // create a file like this:
            // TITLE "example"
            // FILE "example.mp3" MP3
            //   TRACK 01 AUDIO
            //     TITLE "(Track 01)"
            //     INDEX 01 00:00:00
            var result = new List<string>();
            result.Add("TITLE \"example\"");
            result.Add("FILE \"example.mp3\" MP3");
            result.Add("  TRACK 01 AUDIO");
            result.Add("    TITLE \"(Track 01)\"");
            result.Add("    INDEX 01 00:00:00");
            for (int i = 0; i < times.Count; i++)
            {
                ToCueFileTime(result, i, times[i]);
            }

            return string.Join("\n", result);
        }

        void ToCueFileTime(List<string> result, int i, double time)
        {
            var fmtTime = SecondsToHoursMinutesSeconds(time, largestIsMinutes:true);
            var num = (i + 2).ToString("D2");
            result.Add(string.Format("  TRACK {0} AUDIO", num));
            result.Add(string.Format("    TITLE \"(Track {0})\"", num));
            result.Add(string.Format("    INDEX 01 {0}", fmtTime));
        }
    }
}
// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using System;
using System.Diagnostics;
using System.Windows.Forms;

namespace CsDownloadVid
{
    public partial class FormMain : Form
    {
        public FormMain()
        {
            InitializeComponent();
        }

        private void mnuOpenFormGetVideo_Click(object sender, EventArgs e)
        {
            using (Form form = new FormGetVideo())
                form.ShowDialog(this);
        }

        private void mnuOpenFormAudioFromVideo_Click(object sender, EventArgs e)
        {
            using (Form form = new FormAudioFromVideo())
                form.ShowDialog(this);
        }

        private void mnuOpenFormMediaSplit_Click(object sender, EventArgs e)
        {
            using (Form form = new FormMediaSplit())
                form.ShowDialog(this);
        }

        private void mnuOpenFormMediaJoin_Click(object sender, EventArgs e)
        {
            using (Form form = new FormMediaJoin())
                form.ShowDialog(this);
        }

        private void mnuEncodeCustom_Click(object sender, EventArgs e)
        {
            using (Form form = new FormMediaJoin(true))
                form.ShowDialog(this);
        }

        private void mnuOpenHelpWebsite_Click(object sender = null, EventArgs e = null)
        {
            Process.Start("https://github.com/moltenform/labs_youthful_projects/" +
                "tree/master/src/csdownloadvid/README.md");
        }
    }
}
namespace CsDownloadVid
{
    partial class FormAudioFromVideo
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.txtInput = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.btnGetInput = new System.Windows.Forms.Button();
            this.getAudio = new System.Windows.Forms.Button();
            this.getVideo = new System.Windows.Forms.Button();
            this.txtStatus = new System.Windows.Forms.TextBox();
            this.btnCombineAudioVideo = new System.Windows.Forms.Button();
            this.lblShortStatus = new System.Windows.Forms.Label();
            this.tbOutputFormat = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.btnCancel = new System.Windows.Forms.Button();
            this.label3 = new System.Windows.Forms.Label();
            this.SuspendLayout();
            // 
            // txtInput
            // 
            this.txtInput.BackColor = System.Drawing.SystemColors.Control;
            this.txtInput.Location = new System.Drawing.Point(23, 60);
            this.txtInput.Name = "txtInput";
            this.txtInput.ReadOnly = true;
            this.txtInput.Size = new System.Drawing.Size(576, 20);
            this.txtInput.TabIndex = 30;
            this.txtInput.Click += new System.EventHandler(this.txtInput_Click);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(28, 36);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(123, 13);
            this.label2.TabIndex = 2;
            this.label2.Text = "Choose a mp4 video file:";
            // 
            // btnGetInput
            // 
            this.btnGetInput.Location = new System.Drawing.Point(171, 31);
            this.btnGetInput.Name = "btnGetInput";
            this.btnGetInput.Size = new System.Drawing.Size(75, 23);
            this.btnGetInput.TabIndex = 1;
            this.btnGetInput.Text = "Choose...";
            this.btnGetInput.UseVisualStyleBackColor = true;
            this.btnGetInput.Click += new System.EventHandler(this.btnGetInput_Click);
            // 
            // getAudio
            // 
            this.getAudio.Location = new System.Drawing.Point(23, 108);
            this.getAudio.Name = "getAudio";
            this.getAudio.Size = new System.Drawing.Size(128, 42);
            this.getAudio.TabIndex = 4;
            this.getAudio.Text = "Extract Audio Channel (lossless)";
            this.getAudio.UseVisualStyleBackColor = true;
            this.getAudio.Click += new System.EventHandler(this.getAudio_Click);
            // 
            // getVideo
            // 
            this.getVideo.Location = new System.Drawing.Point(171, 108);
            this.getVideo.Name = "getVideo";
            this.getVideo.Size = new System.Drawing.Size(128, 42);
            this.getVideo.TabIndex = 4;
            this.getVideo.Text = "Extract Video Channel (lossless)";
            this.getVideo.UseVisualStyleBackColor = true;
            this.getVideo.Click += new System.EventHandler(this.getVideo_Click);
            // 
            // txtStatus
            // 
            this.txtStatus.BackColor = System.Drawing.SystemColors.Control;
            this.txtStatus.Location = new System.Drawing.Point(23, 176);
            this.txtStatus.Multiline = true;
            this.txtStatus.Name = "txtStatus";
            this.txtStatus.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.txtStatus.Size = new System.Drawing.Size(276, 108);
            this.txtStatus.TabIndex = 5;
            // 
            // btnCombineAudioVideo
            // 
            this.btnCombineAudioVideo.Location = new System.Drawing.Point(318, 108);
            this.btnCombineAudioVideo.Name = "btnCombineAudioVideo";
            this.btnCombineAudioVideo.Size = new System.Drawing.Size(128, 42);
            this.btnCombineAudioVideo.TabIndex = 4;
            this.btnCombineAudioVideo.Text = "Combine Audio+Video Channel (lossless)";
            this.btnCombineAudioVideo.UseVisualStyleBackColor = true;
            this.btnCombineAudioVideo.Click += new System.EventHandler(this.btnCombineAudioVideo_Click);
            // 
            // lblShortStatus
            // 
            this.lblShortStatus.AutoSize = true;
            this.lblShortStatus.Location = new System.Drawing.Point(29, 160);
            this.lblShortStatus.Name = "lblShortStatus";
            this.lblShortStatus.Size = new System.Drawing.Size(45, 13);
            this.lblShortStatus.TabIndex = 2;
            this.lblShortStatus.Text = "Results:";
            // 
            // tbOutputFormat
            // 
            this.tbOutputFormat.Location = new System.Drawing.Point(339, 215);
            this.tbOutputFormat.Name = "tbOutputFormat";
            this.tbOutputFormat.Size = new System.Drawing.Size(107, 20);
            this.tbOutputFormat.TabIndex = 32;
            this.tbOutputFormat.Text = "auto";
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(335, 199);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(74, 13);
            this.label1.TabIndex = 31;
            this.label1.Text = "Output format:";
            // 
            // btnCancel
            // 
            this.btnCancel.Location = new System.Drawing.Point(471, 108);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(128, 42);
            this.btnCancel.TabIndex = 4;
            this.btnCancel.Text = "Cancel";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(458, 9);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(152, 13);
            this.label3.TabIndex = 34;
            this.label3.Text = "CsDownloadVid, by Ben Fisher";
            // 
            // FormAudioFromVideo
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(622, 305);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.tbOutputFormat);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.txtStatus);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnCombineAudioVideo);
            this.Controls.Add(this.getVideo);
            this.Controls.Add(this.getAudio);
            this.Controls.Add(this.btnGetInput);
            this.Controls.Add(this.txtInput);
            this.Controls.Add(this.lblShortStatus);
            this.Controls.Add(this.label2);
            this.Name = "FormAudioFromVideo";
            this.Text = "Separate Audio And Video";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.TextBox txtInput;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Button btnGetInput;
        private System.Windows.Forms.Button getAudio;
        private System.Windows.Forms.Button getVideo;
        private System.Windows.Forms.TextBox txtStatus;
        private System.Windows.Forms.Button btnCombineAudioVideo;
        private System.Windows.Forms.Label lblShortStatus;
        private System.Windows.Forms.TextBox tbOutputFormat;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.Label label3;
    }
}namespace CsDownloadVid
{
    partial class FormMediaJoin
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.btnGetInput = new System.Windows.Forms.Button();
            this.label2 = new System.Windows.Forms.Label();
            this.txtInput = new System.Windows.Forms.TextBox();
            this.txtStatus = new System.Windows.Forms.TextBox();
            this.btnCancel = new System.Windows.Forms.Button();
            this.btnJoin = new System.Windows.Forms.Button();
            this.lblShortStatus = new System.Windows.Forms.Label();
            this.label1 = new System.Windows.Forms.Label();
            this.tbOutputFormat = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.btnMakeAudioLouder = new System.Windows.Forms.Button();
            this.btnEncodeAv1 = new System.Windows.Forms.Button();
            this.btnCustomEncode = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // btnGetInput
            // 
            this.btnGetInput.Location = new System.Drawing.Point(385, 21);
            this.btnGetInput.Margin = new System.Windows.Forms.Padding(4);
            this.btnGetInput.Name = "btnGetInput";
            this.btnGetInput.Size = new System.Drawing.Size(100, 28);
            this.btnGetInput.TabIndex = 6;
            this.btnGetInput.Text = "Choose...";
            this.btnGetInput.UseVisualStyleBackColor = true;
            this.btnGetInput.Click += new System.EventHandler(this.btnGetInput_Click);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(16, 27);
            this.label2.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(269, 17);
            this.label2.TabIndex = 5;
            this.label2.Text = "Enter some m4a audio or mp4 video files:";
            // 
            // txtInput
            // 
            this.txtInput.BackColor = System.Drawing.SystemColors.Control;
            this.txtInput.Location = new System.Drawing.Point(16, 57);
            this.txtInput.Margin = new System.Windows.Forms.Padding(4);
            this.txtInput.Multiline = true;
            this.txtInput.Name = "txtInput";
            this.txtInput.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.txtInput.Size = new System.Drawing.Size(913, 137);
            this.txtInput.TabIndex = 7;
            this.txtInput.WordWrap = false;
            // 
            // txtStatus
            // 
            this.txtStatus.BackColor = System.Drawing.SystemColors.Control;
            this.txtStatus.Location = new System.Drawing.Point(16, 324);
            this.txtStatus.Margin = new System.Windows.Forms.Padding(4);
            this.txtStatus.Multiline = true;
            this.txtStatus.Name = "txtStatus";
            this.txtStatus.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.txtStatus.Size = new System.Drawing.Size(468, 132);
            this.txtStatus.TabIndex = 10;
            // 
            // btnCancel
            // 
            this.btnCancel.Location = new System.Drawing.Point(758, 229);
            this.btnCancel.Margin = new System.Windows.Forms.Padding(4);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(171, 52);
            this.btnCancel.TabIndex = 8;
            this.btnCancel.Text = "Cancel";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            // 
            // btnJoin
            // 
            this.btnJoin.Location = new System.Drawing.Point(20, 229);
            this.btnJoin.Margin = new System.Windows.Forms.Padding(4);
            this.btnJoin.Name = "btnJoin";
            this.btnJoin.Size = new System.Drawing.Size(189, 52);
            this.btnJoin.TabIndex = 9;
            this.btnJoin.Text = "Join Together (lossless)";
            this.btnJoin.UseVisualStyleBackColor = true;
            this.btnJoin.Click += new System.EventHandler(this.btnJoin_Click);
            // 
            // lblShortStatus
            // 
            this.lblShortStatus.AutoSize = true;
            this.lblShortStatus.Location = new System.Drawing.Point(16, 304);
            this.lblShortStatus.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.lblShortStatus.Name = "lblShortStatus";
            this.lblShortStatus.Size = new System.Drawing.Size(59, 17);
            this.lblShortStatus.TabIndex = 11;
            this.lblShortStatus.Text = "Results:";
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(551, 224);
            this.label1.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(99, 17);
            this.label1.TabIndex = 5;
            this.label1.Text = "Output format:";
            // 
            // tbOutputFormat
            // 
            this.tbOutputFormat.Location = new System.Drawing.Point(555, 244);
            this.tbOutputFormat.Margin = new System.Windows.Forms.Padding(4);
            this.tbOutputFormat.Name = "tbOutputFormat";
            this.tbOutputFormat.Size = new System.Drawing.Size(169, 22);
            this.tbOutputFormat.TabIndex = 13;
            this.tbOutputFormat.Text = "auto";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(728, 11);
            this.label3.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(201, 17);
            this.label3.TabIndex = 33;
            this.label3.Text = "CsDownloadVid, by Ben Fisher";
            // 
            // btnMakeAudioLouder
            // 
            this.btnMakeAudioLouder.Location = new System.Drawing.Point(19, 206);
            this.btnMakeAudioLouder.Margin = new System.Windows.Forms.Padding(4);
            this.btnMakeAudioLouder.Name = "btnMakeAudioLouder";
            this.btnMakeAudioLouder.Size = new System.Drawing.Size(199, 60);
            this.btnMakeAudioLouder.TabIndex = 8;
            this.btnMakeAudioLouder.Text = "Make Flac Audio Louder Without Changing Filesize Too Much";
            this.btnMakeAudioLouder.UseVisualStyleBackColor = true;
            this.btnMakeAudioLouder.Click += new System.EventHandler(this.btnMakeAudioLouder_Click);
            // 
            // btnEncodeAv1
            // 
            this.btnEncodeAv1.Location = new System.Drawing.Point(238, 206);
            this.btnEncodeAv1.Margin = new System.Windows.Forms.Padding(4);
            this.btnEncodeAv1.Name = "btnEncodeAv1";
            this.btnEncodeAv1.Size = new System.Drawing.Size(148, 60);
            this.btnEncodeAv1.TabIndex = 8;
            this.btnEncodeAv1.Text = "Encode to Av1 (And possibly scale)";
            this.btnEncodeAv1.UseVisualStyleBackColor = true;
            this.btnEncodeAv1.Click += new System.EventHandler(this.btnEncodeAv1_Click);
            // 
            // btnCustomEncode
            // 
            this.btnCustomEncode.Location = new System.Drawing.Point(396, 206);
            this.btnCustomEncode.Margin = new System.Windows.Forms.Padding(4);
            this.btnCustomEncode.Name = "btnCustomEncode";
            this.btnCustomEncode.Size = new System.Drawing.Size(148, 60);
            this.btnCustomEncode.TabIndex = 8;
            this.btnCustomEncode.Text = "Custom Encode";
            this.btnCustomEncode.UseVisualStyleBackColor = true;
            this.btnCustomEncode.Click += new System.EventHandler(this.btnEncode_Click);
            // 
            // FormMediaJoin
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(947, 478);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.tbOutputFormat);
            this.Controls.Add(this.lblShortStatus);
            this.Controls.Add(this.txtStatus);
            this.Controls.Add(this.btnCustomEncode);
            this.Controls.Add(this.btnEncodeAv1);
            this.Controls.Add(this.btnMakeAudioLouder);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnJoin);
            this.Controls.Add(this.txtInput);
            this.Controls.Add(this.btnGetInput);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.label2);
            this.Margin = new System.Windows.Forms.Padding(4);
            this.Name = "FormMediaJoin";
            this.Text = "Join Together";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button btnGetInput;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.TextBox txtInput;
        private System.Windows.Forms.TextBox txtStatus;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.Button btnJoin;
        private System.Windows.Forms.Label lblShortStatus;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TextBox tbOutputFormat;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Button btnMakeAudioLouder;
        private System.Windows.Forms.Button btnEncodeAv1;
        private System.Windows.Forms.Button btnCustomEncode;
    }
}// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace CsDownloadVid
{
    // AddFadeoutUsingRawAacData: fadeout for aac audio.
    // by Ben Fisher, 2016
    // 
    // 1) Losslessly split the input file into 3 audio files
    //    0:00 - Start of fadeout
    //    Start of fadeout - End of fadeout
    //    End of fadeout - End of song
    // 2)
    //    Use ffmpeg's "afade" to fade out the second audio file
    //    Save the result as a .wav file
    // 3)
    //    Use qaac to encode the .wav file into an .m4a
    // 4)
    //    Use ffmpeg to get the raw .aac data from the first audio file in step 1)
    //    Use ffmpeg to get the raw .aac data from the audio file made in step 3)
    // 5)
    //    Splice the two raw .aac data files together to make one combined .aac file,
    //    after stripping the first frames from the second .aac as mentioned below
    // 6)
    //    Use ffmpeg to convert the combined .aac file back into an m4a.
    // 
    // The result is all lossless except for the final seconds of the fade-out itself.
    // Sometimes an artifact is heard right at the transition, in which case it's recommended
    // to try again with a different fade-out time about 1s away.
    // 
    // Alternatives considered:
    //    The -af filter for ffmpeg works, but re-encodes the entire file.
    //    It may be possible to tweak raw aac data to adjust volume levels.
    //    Gluing the 2 pieces of aac with ffmpeg -concat leaves a gap of silence
    //    Gluing the 2 pieces of aac by simply concat'ing aac files leaves a gap of silence
    // 
    // Details:
    //    The raw data aac file is built from frames. The first frames contain priming data,
    //    mentioned in https://developer.apple.com/library/mac/technotes/tn2258/_index.html
    //    We detect frames by searching for the byte sequence 0xfff15080.
    //    The encoder delay for Nero aac is ~2600 samples
    //    The encoder delay for qaac (Apple) is ~2112 samples
    //    we can't break apart a frame without needing to encode, but 2048 is close to 2112.
    //    so, for qaac, deleting the first two 1024-sample frames yields the best results
    public class AddFadeoutUsingRawAacData
    {
        public void Go(string inputFile, int sampleRate, double point, double fadeLength,
            string outFilename, ref string log)
        {
            var tmpFiles = new List<string>();
            try
            {
                GoImpl(tmpFiles, inputFile, sampleRate, point, fadeLength, outFilename,
                    ref log);
            }
            finally
            {
                // clean up temp files
                foreach (var tmpFile in tmpFiles)
                {
                    try
                    {
                        File.Delete(tmpFile);
                    }
                    catch
                    {
                        log += "\nCould not delete " + tmpFile;
                    }
                }
            }
        }

        public void GoImpl(List<string> tmpFiles, string input, int sampleRate,
            double point, double fadeLength, string outFilename, ref string log)
        {
            // round to nearest frame
            point = RoundForM4aframe(sampleRate, point);

            // split file, get the main part
            var firstPiece = SplitOneFileSynchronous(input, 0.0, point, 0, ref log);
            tmpFiles.Add(firstPiece);

            // split file, get the last 4 seconds
            var fadeWav = GetFileWithFadeoutSynchronous(input, point, fadeLength, 0, ref log);
            tmpFiles.Add(fadeWav);

            // convert the last 4 seconds to m4a
            var secondPiece = ConvertWavToM4aSynchronous(fadeWav, "320", ref log);
            tmpFiles.Add(secondPiece);

            // now losslessly concat these pieces together
            ConcatM4aFilesWithoutGap(firstPiece, secondPiece, outFilename, tmpFiles, ref log);
        }

        string ConvertM4aToAacSynchronous(string input, ref string log)
        {
            Utils.AssertTrue(input.EndsWith(".m4a"));
            var outFilename = Path.GetDirectoryName(input) + Utils.Sep +
                Path.GetFileNameWithoutExtension(input) + ".aac";

            var args = new List<string>();
            args.Add("-nostdin");
            args.Add("-i");
            args.Add(input);
            args.Add("-acodec");
            args.Add("copy");
            args.Add(outFilename);
            RunGetStdout(CsDownloadVidFilepaths.GetFfmpeg(),
                Utils.CombineProcessArguments(args.ToArray()),
                "m4a to aac", outFilename, ref log);

            Utils.AssertTrue(File.Exists(outFilename));
            return outFilename;
        }

        string ConvertAacToM4aSynchronous(string input, ref string log)
        {
            Utils.AssertTrue(input.EndsWith(".aac"));
            var outFilename = Path.GetDirectoryName(input) + Utils.Sep +
                Path.GetFileNameWithoutExtension(input) + ".m4a";

            var args = new List<string>();
            args.Add("-nostdin");
            args.Add("-i");
            args.Add(input);
            args.Add("-acodec");
            args.Add("copy");
            args.Add("-bsf:a");
            args.Add("aac_adtstoasc");
            args.Add(outFilename);
            RunGetStdout(CsDownloadVidFilepaths.GetFfmpeg(),
                Utils.CombineProcessArguments(args.ToArray()),
                "aac to m4a", outFilename, ref log);

            Utils.AssertTrue(File.Exists(outFilename));
            return outFilename;
        }

        string GetFileWithFadeoutSynchronous(string input, double start, double fadeLength,
            int i, ref string log)
        {
            var outFilename = input + string.Format("_outfade{0}.wav", i.ToString("D2"));
            var args = new List<string>();
            args.Add("-nostdin");
            args.Add("-i");
            args.Add(input);
            args.Add("-ss");
            args.Add(start.ToString());
            args.Add("-t");
            args.Add(fadeLength.ToString());
            args.Add("-vn");

            // note: hours:min:seconds format does not seem to work in the fade spec.
            args.Add("-af");
            args.Add(string.Format("afade=t=out:st={0}:d={1}",
                start.ToString(),
                fadeLength.ToString()));

            args.Add(outFilename);
            RunGetStdout(CsDownloadVidFilepaths.GetFfmpeg(),
                Utils.CombineProcessArguments(args.ToArray()),
                "get fadeout", outFilename, ref log);

            Utils.AssertTrue(File.Exists(outFilename));
            return outFilename;
        }

        public string SplitOneFileSynchronous(string input, double start, double length,
            int i, ref string log)
        {
            var outFilename = input + "." + string.Format(
                "{0}", i.ToString("D3")) + Path.GetExtension(input);

            var args = new List<string>();
            args.Add("-nostdin");
            args.Add("-i");
            args.Add(input);

            // important: put the options -ss and -t between -i and output
            args.Add("-ss");
            args.Add(start.ToString());
            args.Add("-t");
            args.Add(length.ToString());
            args.Add("-acodec");
            args.Add("copy");
            args.Add("-vcodec");
            args.Add("copy");

            args.Add(outFilename);
            RunGetStdout(CsDownloadVidFilepaths.GetFfmpeg(),
                Utils.CombineProcessArguments(args.ToArray()),
                "split", outFilename, ref log);

            Utils.AssertTrue(File.Exists(outFilename));
            return outFilename;
        }

        string ConvertWavToM4aSynchronous(string input, string bitrate, ref string log)
        {
            var outFilename = Path.GetDirectoryName(input) + Utils.Sep +
                Path.GetFileNameWithoutExtension(input) + ".m4a";

            var args = new List<string>();
            args.Add("--quality");
            args.Add("2");
            args.Add("-a");
            args.Add(bitrate);
            args.Add("--rate");
            args.Add("keep");
            args.Add(input);
            args.Add("-d");
            args.Add(Path.GetDirectoryName(input));

            RunGetStdout(CsDownloadVidFilepaths.GetQaac(),
                Utils.CombineProcessArguments(args.ToArray()),
                "convert to m4a", outFilename, ref log);

            Utils.AssertTrue(File.Exists(outFilename));
            return outFilename;
        }

        private void ConcatM4aFilesWithoutGap(string firstPiece, string secondPiece,
            string outFilename, List<string> tmpFilesMade, ref string log)
        {
            var firstPieceAac = ConvertM4aToAacSynchronous(firstPiece, ref log);
            tmpFilesMade.Add(firstPieceAac);
            var secondPieceAac = ConvertM4aToAacSynchronous(secondPiece, ref log);
            tmpFilesMade.Add(secondPieceAac);

            var allOfFirst = File.ReadAllBytes(firstPieceAac);
            var allOfSecond = File.ReadAllBytes(secondPieceAac);
            var offsets = GetFrameOffsets(allOfSecond);
            if (offsets.Count < 4)
            {
                throw new CsDownloadVidException("Length of fade out is too short, " +
                    "or this isn't 44100hz 16bit 2ch audio. Could not find aac " +
                    "frame headers " + offsets.Count);
            }

            // for the qaac encoder, this seems to be the best value for removing priming.
            // see comment in the top of class. remove two 1024 sample frames
            var cut = 2;
            var fileJoinedAac = ConcatenateRawAacData(firstPieceAac, allOfFirst, allOfSecond,
                offsets, cut, ref log);

            Utils.AssertTrue(File.Exists(fileJoinedAac));
            tmpFilesMade.Add(fileJoinedAac);

            var finalM4a = ConvertAacToM4aSynchronous(fileJoinedAac, ref log);
            Utils.AssertTrue(File.Exists(finalM4a));
            File.Move(finalM4a, outFilename);
            Utils.AssertTrue(File.Exists(outFilename));
        }

        void RunGetStdout(string exe, string args, string title, string outFilename,
            ref string log)
        {
            if (outFilename != null && File.Exists(outFilename))
            {
                throw new CsDownloadVidException("Failed to '" + title + "' because file " +
                    outFilename + "already exists");
            }

            var info = new ProcessStartInfo();
            string stderr = "";
            info.FileName = exe;
            info.Arguments = args;
            info.CreateNoWindow = true;
            info.RedirectStandardError = true;
            info.RedirectStandardOutput = true;
            info.UseShellExecute = false;

            // Note: the ErrorDataReceived callback is needed, or deadlocks can occur,
            // since ffmpeg sends out more than 4k (buffer size)
            Process p = new Process();
            p.StartInfo = info;
            p.Start();
            p.ErrorDataReceived += (o, e) => { stderr += e.Data; };
            p.BeginErrorReadLine();
            p.WaitForExit();
            log += "\nRan " + info.FileName + " " + info.Arguments;
            if (p.ExitCode != 0)
            {
                log += "\nStdout:" + p.StandardOutput.ReadToEnd();
                log += "\nStderr:" + stderr;
            }

            if (outFilename != null && !File.Exists(outFilename))
            {
                throw new CsDownloadVidException("Failed to '" + title + "' expected file " +
                    "created to " + outFilename);
            }
        }

        string ConcatenateRawAacData(string inputName, byte[] firstPiece, byte[] secondPiece,
            List<int> offsets, int cut, ref string log)
        {
            // write a truncated file
            var outFilename = inputName + "trim" + cut.ToString() + ".aac";
            using (var bw = new BinaryWriter(new FileStream(outFilename, FileMode.Create)))
            {
                // write all of the first file aac
                bw.Write(firstPiece);

                // write the truncated second file aac
                bw.Write(secondPiece, offsets[cut], secondPiece.Length - offsets[cut]);
            }

            log += "\nJoined raw aac data.";
            Utils.AssertTrue(File.Exists(outFilename));
            return outFilename;
        }

        double RoundForM4aframe(int sampleRate, double point)
        {
            // we should round to the nearest m4a section, which is usually 1024
            // samples, let's say 30 sections to be sure though, and round down.
            // this is ~0.7 seconds (@ 44.1khz).
            long pointInFrames = (long)(point * sampleRate);
            long roundTo = 30 * 1024;
            long rounded = (pointInFrames / roundTo) * roundTo - 1;
            point = rounded / ((double)sampleRate);
            if (point <= 0)
            {
                throw new CsDownloadVidException("Can't fade-out so close to the start.");
            }

            return point;
        }

        List<int> GetFrameOffsets(byte[] aacData)
        {
            var offsets = new List<int>();
            for (int i = 0; i < aacData.Length - 4; i++)
            {
                if (aacData[i] == 0xff &&
                    aacData[i + 1] == 0xf1 &&
                    aacData[i + 2] == 0x50 &&
                    aacData[i + 3] == 0x80)
                {
                    offsets.Add(i);
                }
            }

            return offsets;
        }
    }
}
// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace CsDownloadVid
{
    // Keys for storing persisted settings.
    // Unlike a C++ enum, numeric values aren't used at all,
    // it's the names that are important. Changing the names
    // here will cause loss of compatibility.
    // differences from LabsCoordinatePictures 1be22cd489b58e4:
    //      Changed ConfigKey enum and namespace
    //      Rename CoordinatePicturesException to CsDownloadVidException
    public enum ConfigKey
    {
        None,
        Version,
        PathToPython,
        PathToFfmpeg,
        PathToQaac,
        PathToYtdl,
        SaveVideosTo,
        SoftDeleteDir,
        FilepathAudioPlayer, // not currently set
        EnableVerboseLogging, // not currently set
        MRUOpenImageDirectory,
        MRUOpenImageKeepExifDirectory,
        MRUOpenAudioDirectory,
        MRUOpenWavAudioDirectory,
        MRURenameImage,
        MRURenameWavAudio,
        MRURenameOther,
        MRURenameReplaceInName,
        MRUEditConvertResizeImage,
        MRUEditCategoriesString,
        MRUSyncDirectoryLeft,
        MRUSyncDirectoryRight,
        MRUCustomEncode,
        MRUCustomEncodeAv1
    }

    // The inputbox dialog keeps a MRU list of recently used strings.
    // Each item here requires a corresponding item in ConfigKey
    // (which is verified in a test).
    public enum InputBoxHistory
    {
        None,
        OpenImageDirectory,
        OpenImageKeepExifDirectory,
        OpenAudioDirectory,
        OpenWavAudioDirectory,
        RenameImage,
        RenameWavAudio,
        RenameOther,
        RenameReplaceInName,
        EditConvertResizeImage,
        EditCategoriesString,
        SyncDirectoryLeft,
        SyncDirectoryRight,
        CustomEncode,
        CustomEncodeAv1
    }

    public static class ConfirmChecksums
    {
        public static void Check(ConfigKey key, string currentVal)
        {
            if (!string.IsNullOrEmpty(currentVal) &&
                key.ToString().StartsWith("Filepath", StringComparison.Ordinal) &&
                    !key.ToString().EndsWith("Dir", StringComparison.Ordinal) &&
                    !key.ToString().Contains("Checksum"))
            {
                var otherKeyName = key.ToString().Replace("Filepath", "FilepathChecksum");
                var otherKey = Enum.Parse(typeof(ConfigKey), otherKeyName);
                VerifyChecksum((ConfigKey)otherKey, currentVal);
            }
        }

        static void VerifyChecksum(ConfigKey sumkey, string current)
        {
            var hash = Utils.GetSha512(current);
            var hashExpected = Configs.Current.Get(sumkey);
            if (hashExpected != hash)
            {
                if (string.IsNullOrEmpty(hashExpected) ||
                    string.IsNullOrEmpty(current) ||
                    Utils.AskToConfirm("Checksum does not match for file " +
                    current + Utils.NL + "was:" + hashExpected + Utils.NL + "now: " + hash +
                    Utils.NL + "Did you recently upgrade or change this program? " +
                    "If so, click Yes. Otherwise, click No to exit."))
                {
                    Configs.Current.Set(sumkey, hash);
                }
                else
                {
                    Environment.Exit(1);
                }
            }
        }
    }

    // Class for storing settings.
    // Persisted settings are saved to a simple ini text file.
    // Currently saves to disk synchronously on every change to a persisted setting
    // which is acceptible for current usage.
    public sealed class Configs
    {
        static Configs _instance;
        string _path;
        Dictionary<ConfigKey, string> _dict = new Dictionary<ConfigKey, string>();

        internal Configs(string path)
        {
            this._path = path;
        }

        // in-memory non-persisted settings
        public string Directory { get; private set; }
        public bool SuppressDialogs { get; set; }

        public static Configs Current
        {
            get
            {
                return _instance;
            }
        }

        public static ConfigKey ConfigsPersistedKeysFromString(string keyname)
        {
            var key = ConfigKey.None;
            return Enum.TryParse(keyname, out key) ? key : ConfigKey.None;
        }

        public static void Init(string path)
        {
            _instance = new Configs(path);
            _instance.Directory = Path.GetDirectoryName(path);
        }

        public void LoadPersisted()
        {
            if (!File.Exists(_path))
            {
                return;
            }

            var lines = File.ReadAllLines(_path);
            for (int lineNumber = 0; lineNumber < lines.Length; lineNumber++)
            {
                var line = lines[lineNumber];

                // skip sections and comments
                if (line.StartsWith("[", StringComparison.Ordinal) ||
                    line.StartsWith("#", StringComparison.Ordinal))
                {
                    continue;
                }

                // split with count=2, to ignore subsequent = characters in the string.
                var split = line.Split(new char[] { '=' }, 2, StringSplitOptions.None);
                if (split.Length != 2)
                {
                    if (!string.IsNullOrEmpty(line.Trim()))
                    {
                        SimpleLog.Current.WriteWarning(
                            "malformed config, missing = on line " + lineNumber);
                    }

                    continue;
                }

                var key = ConfigsPersistedKeysFromString(split[0]);
                if (key == ConfigKey.None)
                {
                    SimpleLog.Current.WriteWarning(
                        "unrecognized config key on line " +
                        lineNumber + ", might occur if using config from future version.");
                    continue;
                }

                _dict[key] = split[1];
            }
        }

        void SavePersisted()
        {
            var sb = new StringBuilder();
            foreach (var key in from key in _dict.Keys orderby key select key)
            {
                var value = _dict[key];
                if (!string.IsNullOrEmpty(value))
                {
                    if (value.Contains("\r") || value.Contains("\n"))
                    {
                        throw new CsDownloadVidException(
                            "config values cannot contain newline, for key " + key);
                    }

                    sb.AppendLine(key.ToString() + "=" + value);
                }
            }

            File.WriteAllText(_path, sb.ToString());
        }

        public void Set(ConfigKey key, string s)
        {
            var valueWasChanged = !_dict.TryGetValue(key, out string prev) ||
                prev != s ||
                !File.Exists(_path);
            if (valueWasChanged)
            {
                _dict[key] = s;
                SavePersisted();
            }
        }

        public void SetBool(ConfigKey key, bool b)
        {
            Set(key, b ? "true" : "");
        }

        public string Get(ConfigKey key)
        {
            var ret = _dict.TryGetValue(key, out string s) ? s : "";
            ConfirmChecksums.Check(key, ret);
            return ret;
        }

        public bool GetBool(ConfigKey key)
        {
            return !string.IsNullOrEmpty(Get(key));
        }
    }
}
namespace CsDownloadVid
{
    partial class FormGetVideo
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.chkShowAdvanced = new System.Windows.Forms.CheckBox();
            this.lbl1Basic = new System.Windows.Forms.Label();
            this.txtUrl = new System.Windows.Forms.TextBox();
            this.btnNextStepIsToChooseQuality = new System.Windows.Forms.Button();
            this.panelChooseQuality = new System.Windows.Forms.Panel();
            this.btnNextStepIsToChooseOutput = new System.Windows.Forms.Button();
            this.listBoxFmts = new System.Windows.Forms.ListBox();
            this.label2 = new System.Windows.Forms.Label();
            this.txtStatus = new System.Windows.Forms.TextBox();
            this.panelAdvanced = new System.Windows.Forms.Panel();
            this.btnDownloadFromWeb = new System.Windows.Forms.Button();
            this.txtAdditionalArgs = new System.Windows.Forms.TextBox();
            this.txtWaitBetween = new System.Windows.Forms.TextBox();
            this.txtFilenamePattern = new System.Windows.Forms.TextBox();
            this.label5 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.lblNamePattern = new System.Windows.Forms.Label();
            this.btnGetPlaylist = new System.Windows.Forms.Button();
            this.chkAutoCombineAV = new System.Windows.Forms.CheckBox();
            this.chkDashToM4a = new System.Windows.Forms.CheckBox();
            this.lblEnterUrlsAdvanced = new System.Windows.Forms.Label();
            this.panelChooseOutput = new System.Windows.Forms.Panel();
            this.btnSaveTo = new System.Windows.Forms.Button();
            this.txtOutputDir = new System.Windows.Forms.TextBox();
            this.btnCancel = new System.Windows.Forms.Button();
            this.btnDownload = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.lblShortStatus = new System.Windows.Forms.Label();
            this.btnGetUpdates = new System.Windows.Forms.Button();
            this.cbUsePytube = new System.Windows.Forms.CheckBox();
            this.panelChooseQuality.SuspendLayout();
            this.panelAdvanced.SuspendLayout();
            this.panelChooseOutput.SuspendLayout();
            this.SuspendLayout();
            // 
            // chkShowAdvanced
            // 
            this.chkShowAdvanced.AutoSize = true;
            this.chkShowAdvanced.Location = new System.Drawing.Point(695, 15);
            this.chkShowAdvanced.Margin = new System.Windows.Forms.Padding(4);
            this.chkShowAdvanced.Name = "chkShowAdvanced";
            this.chkShowAdvanced.Size = new System.Drawing.Size(155, 21);
            this.chkShowAdvanced.TabIndex = 0;
            this.chkShowAdvanced.Text = "Advanced options...";
            this.chkShowAdvanced.UseVisualStyleBackColor = true;
            this.chkShowAdvanced.CheckedChanged += new System.EventHandler(this.chkShowAdvanced_CheckedChanged);
            // 
            // lbl1Basic
            // 
            this.lbl1Basic.AutoSize = true;
            this.lbl1Basic.Location = new System.Drawing.Point(17, 52);
            this.lbl1Basic.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.lbl1Basic.Name = "lbl1Basic";
            this.lbl1Basic.Size = new System.Drawing.Size(177, 17);
            this.lbl1Basic.TabIndex = 1;
            this.lbl1Basic.Text = "Step 1: Enter URL of video";
            // 
            // txtUrl
            // 
            this.txtUrl.Location = new System.Drawing.Point(21, 84);
            this.txtUrl.Margin = new System.Windows.Forms.Padding(4);
            this.txtUrl.Name = "txtUrl";
            this.txtUrl.Size = new System.Drawing.Size(664, 22);
            this.txtUrl.TabIndex = 2;
            this.txtUrl.Text = "https://www.youtube.com/watch?v=aaaaaaa";
            // 
            // btnNextStepIsToChooseQuality
            // 
            this.btnNextStepIsToChooseQuality.Location = new System.Drawing.Point(728, 80);
            this.btnNextStepIsToChooseQuality.Margin = new System.Windows.Forms.Padding(4);
            this.btnNextStepIsToChooseQuality.Name = "btnNextStepIsToChooseQuality";
            this.btnNextStepIsToChooseQuality.Size = new System.Drawing.Size(176, 28);
            this.btnNextStepIsToChooseQuality.TabIndex = 3;
            this.btnNextStepIsToChooseQuality.Text = "Go to next step";
            this.btnNextStepIsToChooseQuality.UseVisualStyleBackColor = true;
            this.btnNextStepIsToChooseQuality.Click += new System.EventHandler(this.btnNextToChooseQuality_Click);
            // 
            // panelChooseQuality
            // 
            this.panelChooseQuality.Controls.Add(this.btnNextStepIsToChooseOutput);
            this.panelChooseQuality.Controls.Add(this.listBoxFmts);
            this.panelChooseQuality.Controls.Add(this.label2);
            this.panelChooseQuality.Location = new System.Drawing.Point(3, 144);
            this.panelChooseQuality.Margin = new System.Windows.Forms.Padding(4);
            this.panelChooseQuality.Name = "panelChooseQuality";
            this.panelChooseQuality.Size = new System.Drawing.Size(951, 254);
            this.panelChooseQuality.TabIndex = 4;
            // 
            // btnNextStepIsToChooseOutput
            // 
            this.btnNextStepIsToChooseOutput.Location = new System.Drawing.Point(725, 207);
            this.btnNextStepIsToChooseOutput.Margin = new System.Windows.Forms.Padding(4);
            this.btnNextStepIsToChooseOutput.Name = "btnNextStepIsToChooseOutput";
            this.btnNextStepIsToChooseOutput.Size = new System.Drawing.Size(176, 28);
            this.btnNextStepIsToChooseOutput.TabIndex = 4;
            this.btnNextStepIsToChooseOutput.Text = "Go to next step";
            this.btnNextStepIsToChooseOutput.UseVisualStyleBackColor = true;
            this.btnNextStepIsToChooseOutput.Click += new System.EventHandler(this.btnNextStepIsToChooseOutput_Click);
            // 
            // listBoxFmts
            // 
            this.listBoxFmts.FormattingEnabled = true;
            this.listBoxFmts.ItemHeight = 16;
            this.listBoxFmts.Location = new System.Drawing.Point(19, 38);
            this.listBoxFmts.Margin = new System.Windows.Forms.Padding(4);
            this.listBoxFmts.Name = "listBoxFmts";
            this.listBoxFmts.ScrollAlwaysVisible = true;
            this.listBoxFmts.SelectionMode = System.Windows.Forms.SelectionMode.MultiExtended;
            this.listBoxFmts.Size = new System.Drawing.Size(664, 196);
            this.listBoxFmts.TabIndex = 1;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(15, 5);
            this.label2.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(214, 17);
            this.label2.TabIndex = 0;
            this.label2.Text = "Step 2: Choose download quality";
            // 
            // txtStatus
            // 
            this.txtStatus.BackColor = System.Drawing.SystemColors.Control;
            this.txtStatus.Location = new System.Drawing.Point(21, 631);
            this.txtStatus.Margin = new System.Windows.Forms.Padding(4);
            this.txtStatus.Multiline = true;
            this.txtStatus.Name = "txtStatus";
            this.txtStatus.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.txtStatus.Size = new System.Drawing.Size(664, 138);
            this.txtStatus.TabIndex = 14;
            // 
            // panelAdvanced
            // 
            this.panelAdvanced.Controls.Add(this.btnDownloadFromWeb);
            this.panelAdvanced.Controls.Add(this.txtAdditionalArgs);
            this.panelAdvanced.Controls.Add(this.txtWaitBetween);
            this.panelAdvanced.Controls.Add(this.txtFilenamePattern);
            this.panelAdvanced.Controls.Add(this.label5);
            this.panelAdvanced.Controls.Add(this.label6);
            this.panelAdvanced.Controls.Add(this.label4);
            this.panelAdvanced.Controls.Add(this.lblNamePattern);
            this.panelAdvanced.Controls.Add(this.btnGetPlaylist);
            this.panelAdvanced.Controls.Add(this.chkAutoCombineAV);
            this.panelAdvanced.Controls.Add(this.chkDashToM4a);
            this.panelAdvanced.Location = new System.Drawing.Point(784, 468);
            this.panelAdvanced.Margin = new System.Windows.Forms.Padding(4);
            this.panelAdvanced.Name = "panelAdvanced";
            this.panelAdvanced.Size = new System.Drawing.Size(300, 303);
            this.panelAdvanced.TabIndex = 15;
            // 
            // btnDownloadFromWeb
            // 
            this.btnDownloadFromWeb.Location = new System.Drawing.Point(160, 263);
            this.btnDownloadFromWeb.Margin = new System.Windows.Forms.Padding(4);
            this.btnDownloadFromWeb.Name = "btnDownloadFromWeb";
            this.btnDownloadFromWeb.Size = new System.Drawing.Size(108, 32);
            this.btnDownloadFromWeb.TabIndex = 42;
            this.btnDownloadFromWeb.Text = "From Web";
            this.btnDownloadFromWeb.UseVisualStyleBackColor = true;
            this.btnDownloadFromWeb.Click += new System.EventHandler(this.btnDownloadFromWeb_Click);
            // 
            // txtAdditionalArgs
            // 
            this.txtAdditionalArgs.Location = new System.Drawing.Point(25, 231);
            this.txtAdditionalArgs.Margin = new System.Windows.Forms.Padding(4);
            this.txtAdditionalArgs.Name = "txtAdditionalArgs";
            this.txtAdditionalArgs.Size = new System.Drawing.Size(153, 22);
            this.txtAdditionalArgs.TabIndex = 41;
            // 
            // txtWaitBetween
            // 
            this.txtWaitBetween.Location = new System.Drawing.Point(25, 188);
            this.txtWaitBetween.Margin = new System.Windows.Forms.Padding(4);
            this.txtWaitBetween.Name = "txtWaitBetween";
            this.txtWaitBetween.Size = new System.Drawing.Size(153, 22);
            this.txtWaitBetween.TabIndex = 41;
            this.txtWaitBetween.Text = "5";
            // 
            // txtFilenamePattern
            // 
            this.txtFilenamePattern.Location = new System.Drawing.Point(25, 140);
            this.txtFilenamePattern.Margin = new System.Windows.Forms.Padding(4);
            this.txtFilenamePattern.Name = "txtFilenamePattern";
            this.txtFilenamePattern.Size = new System.Drawing.Size(269, 22);
            this.txtFilenamePattern.TabIndex = 40;
            this.txtFilenamePattern.Text = "%(uploader)s @ %(title)s [%(id)s].%(ext)s";
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(21, 217);
            this.label5.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(102, 17);
            this.label5.TabIndex = 39;
            this.label5.Text = "Additional args";
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Location = new System.Drawing.Point(21, 28);
            this.label6.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(106, 17);
            this.label6.TabIndex = 39;
            this.label6.Text = "Advanced opts:";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(21, 169);
            this.label4.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(206, 17);
            this.label4.TabIndex = 39;
            this.label4.Text = "Wait between dloads (seconds)";
            // 
            // lblNamePattern
            // 
            this.lblNamePattern.AutoSize = true;
            this.lblNamePattern.Location = new System.Drawing.Point(23, 98);
            this.lblNamePattern.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.lblNamePattern.Name = "lblNamePattern";
            this.lblNamePattern.Size = new System.Drawing.Size(114, 17);
            this.lblNamePattern.TabIndex = 39;
            this.lblNamePattern.Text = "Filename pattern";
            // 
            // btnGetPlaylist
            // 
            this.btnGetPlaylist.Location = new System.Drawing.Point(4, 263);
            this.btnGetPlaylist.Margin = new System.Windows.Forms.Padding(4);
            this.btnGetPlaylist.Name = "btnGetPlaylist";
            this.btnGetPlaylist.Size = new System.Drawing.Size(97, 32);
            this.btnGetPlaylist.TabIndex = 38;
            this.btnGetPlaylist.Text = "Get playlist";
            this.btnGetPlaylist.UseVisualStyleBackColor = true;
            this.btnGetPlaylist.Click += new System.EventHandler(this.btnGetPlaylist_Click);
            // 
            // chkAutoCombineAV
            // 
            this.chkAutoCombineAV.AutoSize = true;
            this.chkAutoCombineAV.Checked = true;
            this.chkAutoCombineAV.CheckState = System.Windows.Forms.CheckState.Checked;
            this.chkAutoCombineAV.Location = new System.Drawing.Point(26, 44);
            this.chkAutoCombineAV.Margin = new System.Windows.Forms.Padding(4);
            this.chkAutoCombineAV.Name = "chkAutoCombineAV";
            this.chkAutoCombineAV.Size = new System.Drawing.Size(242, 21);
            this.chkAutoCombineAV.TabIndex = 0;
            this.chkAutoCombineAV.Text = "auto combine a+v if both selected";
            this.chkAutoCombineAV.UseVisualStyleBackColor = true;
            // 
            // chkDashToM4a
            // 
            this.chkDashToM4a.AutoSize = true;
            this.chkDashToM4a.Checked = true;
            this.chkDashToM4a.CheckState = System.Windows.Forms.CheckState.Checked;
            this.chkDashToM4a.Location = new System.Drawing.Point(26, 70);
            this.chkDashToM4a.Margin = new System.Windows.Forms.Padding(4);
            this.chkDashToM4a.Name = "chkDashToM4a";
            this.chkDashToM4a.Size = new System.Drawing.Size(240, 21);
            this.chkDashToM4a.TabIndex = 0;
            this.chkDashToM4a.Text = "fix DASH audio after downloading";
            this.chkDashToM4a.UseVisualStyleBackColor = true;
            // 
            // lblEnterUrlsAdvanced
            // 
            this.lblEnterUrlsAdvanced.AutoSize = true;
            this.lblEnterUrlsAdvanced.Location = new System.Drawing.Point(68, 52);
            this.lblEnterUrlsAdvanced.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.lblEnterUrlsAdvanced.Name = "lblEnterUrlsAdvanced";
            this.lblEnterUrlsAdvanced.Size = new System.Drawing.Size(780, 17);
            this.lblEnterUrlsAdvanced.TabIndex = 28;
            this.lblEnterUrlsAdvanced.Text = "Enter URL, list of URLs separated by |, path of a .url file, path of a .txt file " +
    "containing urls, or a directory containing .url files:";
            // 
            // panelChooseOutput
            // 
            this.panelChooseOutput.Controls.Add(this.btnSaveTo);
            this.panelChooseOutput.Controls.Add(this.txtOutputDir);
            this.panelChooseOutput.Controls.Add(this.btnCancel);
            this.panelChooseOutput.Controls.Add(this.btnDownload);
            this.panelChooseOutput.Controls.Add(this.label1);
            this.panelChooseOutput.Location = new System.Drawing.Point(3, 417);
            this.panelChooseOutput.Margin = new System.Windows.Forms.Padding(4);
            this.panelChooseOutput.Name = "panelChooseOutput";
            this.panelChooseOutput.Size = new System.Drawing.Size(763, 180);
            this.panelChooseOutput.TabIndex = 30;
            // 
            // btnSaveTo
            // 
            this.btnSaveTo.Location = new System.Drawing.Point(583, 48);
            this.btnSaveTo.Margin = new System.Windows.Forms.Padding(4);
            this.btnSaveTo.Name = "btnSaveTo";
            this.btnSaveTo.Size = new System.Drawing.Size(101, 28);
            this.btnSaveTo.TabIndex = 35;
            this.btnSaveTo.Text = "Browse...";
            this.btnSaveTo.UseVisualStyleBackColor = true;
            this.btnSaveTo.Click += new System.EventHandler(this.btnSaveTo_Click);
            // 
            // txtOutputDir
            // 
            this.txtOutputDir.BackColor = System.Drawing.SystemColors.Control;
            this.txtOutputDir.Location = new System.Drawing.Point(19, 50);
            this.txtOutputDir.Margin = new System.Windows.Forms.Padding(4);
            this.txtOutputDir.Name = "txtOutputDir";
            this.txtOutputDir.ReadOnly = true;
            this.txtOutputDir.Size = new System.Drawing.Size(555, 22);
            this.txtOutputDir.TabIndex = 34;
            // 
            // btnCancel
            // 
            this.btnCancel.Location = new System.Drawing.Point(177, 95);
            this.btnCancel.Margin = new System.Windows.Forms.Padding(4);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(148, 70);
            this.btnCancel.TabIndex = 30;
            this.btnCancel.Text = "Cancel";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            // 
            // btnDownload
            // 
            this.btnDownload.Location = new System.Drawing.Point(19, 95);
            this.btnDownload.Margin = new System.Windows.Forms.Padding(4);
            this.btnDownload.Name = "btnDownload";
            this.btnDownload.Size = new System.Drawing.Size(143, 70);
            this.btnDownload.TabIndex = 30;
            this.btnDownload.Text = "Download";
            this.btnDownload.UseVisualStyleBackColor = true;
            this.btnDownload.Click += new System.EventHandler(this.btnDownload_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(15, 25);
            this.label1.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(202, 17);
            this.label1.TabIndex = 1;
            this.label1.Text = "Step 3: Choose output location";
            // 
            // lblShortStatus
            // 
            this.lblShortStatus.AutoSize = true;
            this.lblShortStatus.Location = new System.Drawing.Point(32, 612);
            this.lblShortStatus.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.lblShortStatus.Name = "lblShortStatus";
            this.lblShortStatus.Size = new System.Drawing.Size(105, 17);
            this.lblShortStatus.TabIndex = 31;
            this.lblShortStatus.Text = "Current status: ";
            // 
            // btnGetUpdates
            // 
            this.btnGetUpdates.Location = new System.Drawing.Point(928, 80);
            this.btnGetUpdates.Margin = new System.Windows.Forms.Padding(4);
            this.btnGetUpdates.Name = "btnGetUpdates";
            this.btnGetUpdates.Size = new System.Drawing.Size(156, 28);
            this.btnGetUpdates.TabIndex = 3;
            this.btnGetUpdates.Text = "Get updates";
            this.btnGetUpdates.UseVisualStyleBackColor = true;
            this.btnGetUpdates.Click += new System.EventHandler(this.btnGetUpdates_Click);
            // 
            // cbUsePytube
            // 
            this.cbUsePytube.AutoSize = true;
            this.cbUsePytube.Location = new System.Drawing.Point(889, 15);
            this.cbUsePytube.Margin = new System.Windows.Forms.Padding(4);
            this.cbUsePytube.Name = "cbUsePytube";
            this.cbUsePytube.Size = new System.Drawing.Size(194, 21);
            this.cbUsePytube.TabIndex = 0;
            this.cbUsePytube.Text = "Use pytube instead of ytdl";
            this.cbUsePytube.UseVisualStyleBackColor = true;
            this.cbUsePytube.CheckedChanged += new System.EventHandler(this.chkShowAdvanced_CheckedChanged);
            // 
            // FormGetVideo
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(1104, 805);
            this.Controls.Add(this.lblShortStatus);
            this.Controls.Add(this.panelChooseOutput);
            this.Controls.Add(this.lblEnterUrlsAdvanced);
            this.Controls.Add(this.panelAdvanced);
            this.Controls.Add(this.txtStatus);
            this.Controls.Add(this.panelChooseQuality);
            this.Controls.Add(this.btnGetUpdates);
            this.Controls.Add(this.btnNextStepIsToChooseQuality);
            this.Controls.Add(this.txtUrl);
            this.Controls.Add(this.lbl1Basic);
            this.Controls.Add(this.cbUsePytube);
            this.Controls.Add(this.chkShowAdvanced);
            this.Margin = new System.Windows.Forms.Padding(4);
            this.Name = "FormGetVideo";
            this.Text = "Download Video";
            this.Load += new System.EventHandler(this.FormGetVideo_Load);
            this.panelChooseQuality.ResumeLayout(false);
            this.panelChooseQuality.PerformLayout();
            this.panelAdvanced.ResumeLayout(false);
            this.panelAdvanced.PerformLayout();
            this.panelChooseOutput.ResumeLayout(false);
            this.panelChooseOutput.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.CheckBox chkShowAdvanced;
        private System.Windows.Forms.Label lbl1Basic;
        private System.Windows.Forms.TextBox txtUrl;
        private System.Windows.Forms.Button btnNextStepIsToChooseQuality;
        private System.Windows.Forms.Panel panelChooseQuality;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.ListBox listBoxFmts;
        private System.Windows.Forms.TextBox txtStatus;
        private System.Windows.Forms.Panel panelAdvanced;
        private System.Windows.Forms.CheckBox chkDashToM4a;
        private System.Windows.Forms.Label lblEnterUrlsAdvanced;
        private System.Windows.Forms.Panel panelChooseOutput;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label lblNamePattern;
        private System.Windows.Forms.TextBox txtFilenamePattern;
        private System.Windows.Forms.Button btnDownload;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.TextBox txtOutputDir;
        private System.Windows.Forms.Button btnSaveTo;
        private System.Windows.Forms.Button btnNextStepIsToChooseOutput;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.TextBox txtWaitBetween;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.TextBox txtAdditionalArgs;
        private System.Windows.Forms.Label lblShortStatus;
        private System.Windows.Forms.Button btnGetUpdates;
        private System.Windows.Forms.Button btnGetPlaylist;
        private System.Windows.Forms.CheckBox cbUsePytube;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.Button btnDownloadFromWeb;
        private System.Windows.Forms.CheckBox chkAutoCombineAV;
    }
}// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Threading;
using System.Windows.Forms;

namespace CsDownloadVid
{
    // Run tasks in a background thread
    public class RunToolHelper
    {
        TextBox _tb;
        Label _shortLabel;
        readonly Func<string, bool> _filterOutput;
        readonly object _lock = new object();
        int _waitBetweenMs = 0;
        bool _showOutputSooner = false;
        volatile Process _process;
        volatile bool _cancelRequested = false;
        public RunToolHelper(TextBox tb, Label shortlabel,
            Func<string, bool> filter,
            bool showOutputSooner = false)
        {
            _tb = tb;
            _shortLabel = shortlabel;
            _showOutputSooner = showOutputSooner;
            _filterOutput = filter;
        }

        public static string ExceptionToString(Exception e)
        {
            if (e is CsDownloadVidException eOurs)
                return eOurs.Message;
            else if (e == null)
                return "(null)";
            else
                return e.ToString();
        }

        public static void RunAndCatch(Action fn)
        {
            try
            {
                fn.Invoke();
            }
            catch (Exception e)
            {
                Utils.MessageErr(ExceptionToString(e));
            }
        }

        public void Trace(string txt, bool alert = false)
        {
            Utils.AssertTrue(_tb != null, "tb is null");
            _tb.BeginInvoke((MethodInvoker)(() =>
            {
                if (alert)
                {
                    MessageBox.Show(txt);
                }
                else
                {
                    _tb.AppendText(Utils.NL);
                    _tb.AppendText(txt);
                }
            }));
        }

        public void TraceFiltered(string txt)
        {
            // consumer can provide a "filter" callback to determine what is logged
            var lines = Utils.SplitLines(txt);
            foreach (var line in lines)
            {
                if (_filterOutput == null || _filterOutput(line))
                {
                    Trace(line);
                }
            }
        }

        public void SetWaitBetween(int n)
        {
            _waitBetweenMs = n;
        }

        private void _process_OnDataReceived(object o, DataReceivedEventArgs e)
        {
            if (!string.IsNullOrWhiteSpace(e.Data))
            {
                var s = Utils.NL + "output: " + e.Data;
                if (_showOutputSooner)
                {
                    _tb.Invoke((MethodInvoker)(() =>
                    {
                        _tb.AppendText(s);
                    }));
                }
                else
                {
                    _tb.BeginInvoke((MethodInvoker)(() =>
                    {
                        _tb.AppendText(s);
                    }));
                }
            }
        }

        public void RunProcesses(ProcessStartInfo[] infos, string actionName, Action doAfterRun=null)
        {
            RunInThread(() =>
            {
                _cancelRequested = false;
                for (int i = 0; i < infos.Length; i++)
                {
                    _tb.Invoke((MethodInvoker)(() =>
                    {
                        _shortLabel.Text = "Task " + (i + 1) + " of " + infos.Length + "...";
                    }));

                    if (_cancelRequested)
                    {
                        break;
                    }
                    else
                    {
                        Thread.Sleep(_waitBetweenMs);
                        RunProcessSync(infos[i], actionName);
                    }
                }

                _tb.Invoke((MethodInvoker)(() =>
                {
                    doAfterRun?.Invoke();
                    _shortLabel.Text = _cancelRequested ? "Canceled" : "Complete";
                }));
            });
        }

        public void RunProcessSync(ProcessStartInfo info, string actionName,
            bool prioritizeStdErr = true)
        {
            _cancelRequested = false;
            try
            {
                _process = new Process();
                _process.StartInfo = info;
                _process.Start();
                _process.OutputDataReceived += _process_OnDataReceived;
                if (prioritizeStdErr)
                {
                    _process.BeginErrorReadLine();
                }
                else 
                {
                    _process.BeginOutputReadLine();
                }

                _process.WaitForExit();
                Trace("Running: " + info.FileName + " " + info.Arguments);
                if (_process.ExitCode != 0)
                {
                    Trace("warning: exited with code " + _process.ExitCode, true);
                }

                var stm = prioritizeStdErr ? _process.StandardOutput : _process.StandardError;
                using (StreamReader reader = stm)
                {
                    string stdout = reader.ReadToEnd();
                    TraceFiltered(stdout);
                }
            }
            catch (Exception e)
            {
                Utils.MessageErr(ExceptionToString(e));
            }
            finally
            {
                if (_process != null)
                {
                    _process.Close();
                    _process.Dispose();
                    _process = null;
                }
            }

            Trace(actionName + " " + (_cancelRequested ? "Canceled" : "Complete"));
        }

        public void RunProcess(ProcessStartInfo info, string actionName,
            bool prioritizeStdErr = true)
        {
            RunInThread(() =>
            {
                RunProcessSync(info, actionName, prioritizeStdErr);
            });
        }

        public void RunInThread(Action fn, string setStatus = null)
        {
            _cancelRequested = false;
            ThreadPool.QueueUserWorkItem(delegate
            {
                var locker = new LockCloser(_lock);
                using (locker)
                {
                    if (locker.TryEnter())
                    {
                        if (setStatus != null)
                        {
                            this._shortLabel.Invoke((MethodInvoker)
                                (() => this._shortLabel.Text = setStatus));
                        }

                        try
                        {
                            fn.Invoke();
                        }
                        catch (Exception e)
                        {
                            Utils.MessageErr(ExceptionToString(e));
                        }

                        if (setStatus != null)
                        {
                            this._shortLabel.Invoke((MethodInvoker)
                                (() => this._shortLabel.Text = "Done"));
                        }
                    }
                    else
                    {
                        Trace("Can't do this yet, since there's already an operation " +
                            "in progress.", true);
                    }
                }
            });
        }

        public void CancelProcess()
        {
            _cancelRequested = true;
            if (_process != null)
            {
                try
                {
                    _process.Kill();
                    Trace("Process canceled.");
                }
                catch (Exception e)
                {
                    Utils.MessageErr(ExceptionToString(e));
                }
            }
            else
            {
                Trace("Could not cancel process, maybe nothing is running.");
            }
        }
    }

    public static class CsDownloadVidFilepaths
    {
        public static string GetPython()
        {
            var hints = new string[] { @"C:\python33\python.exe", @"C:\python34\python.exe",
                @"C:\python35\python.exe", @"C:\python36\python.exe",
                @"C:\python37\python.exe" };

            return GetPathToBinary(ConfigKey.PathToPython, "Python 3 (python.exe)", hints);
        }

        public static string GetFfmpeg()
        {
            var hints = new string[] { @".\tools\ffmpeg.exe", @".\ffmpeg.exe", @"..\ffmpeg.exe",
                @"..\..\ffmpeg.exe" };

            return GetPathToBinary(ConfigKey.PathToFfmpeg, "FFmpeg (FFmpeg.exe)", hints);
        }

        public static string GetQaac()
        {
            var hints = new string[] { @".\tools\qaac.exe", @".\qaac.exe", @"..\qaac.exe",
                @"..\..\qaac.exe" };

            return GetPathToBinary(ConfigKey.PathToQaac, "Qaac (qaac.exe)", hints);
        }

        private static string GetYtdlImpl(bool usePytube)
        {
            var bin = Utils.Sep + "bin" + Utils.Sep;
            if (Application.ExecutablePath.Contains(bin))
            {
                throw new CsDownloadVidException(bin + " found in path, it's best to run " +
                    "this in its own directory, near the config files, instead of running " +
                    "directly from visual studio.");
            }

            if (usePytube)
            {
                if (!File.Exists("benpytwrapper.py"))
                    throw new CsDownloadVidException("benpytwrapper.py was not found.");
                else if (!File.Exists("./tools/pytubemasterdir/pytube-master/pytube/__init__.py"))
                    throw new CsDownloadVidException("Try clicking the 'Get updates' button in the top " +
                    "right corner. ('pytubemasterdir was not found.')");

                return "benpytwrapper.py";
            }
            else
            {
                var relPath = "tools/ytmasterdir/youtube-dl-master/youtube_dl/__main__.py";
                if (File.Exists("./" + relPath))
                    return "./" + relPath;
                else if (File.Exists("../" + relPath))
                    return "../ " + relPath;
                else if (File.Exists("../../" + relPath))
                    return "../../" + relPath;

                throw new CsDownloadVidException("Try clicking the 'Get updates' button in the top " + 
                    "right corner. ('ytmasterdir was not found.')");
            }
        }

        public static string GetYtdlPath(bool usePytube, bool required = true)
        {
            string ret;
            try
            {
                ret = GetYtdlImpl(usePytube);
            }
            catch (CsDownloadVidException e)
            {
                MessageBox.Show(e.Message);
                if (!required)
                {
                    return null;
                }
                else
                {
                    throw;
                }
            }

            return ret;
        }

        private static string GetPathToBinary(ConfigKey key, string name, string[] hints)
        {
            var current = Configs.Current.Get(key);
            if (File.Exists(current))
            {
                return current;
            }

            foreach (var hint in hints)
            {
                if (File.Exists(hint))
                {
                    SimpleLog.Current.WriteLog("automatically detected location of " + name +
                        Utils.NL + hint);

                    Configs.Current.Set(key, hint);
                    return hint;
                }
            }

            while (true)
            {
                var file = Utils.AskOpenFileDialog("Please find " + name);
                if (file != null)
                {
                    Configs.Current.Set(key, file);
                    return file;
                }
                else if (!Utils.AskToConfirm("Program " + name + " still not found. Continue?"))
                {
                    throw new CsDownloadVidException("Program " + name + " not found.");
                }
            }
        }

        public static string GetDefaultDownloadsDir()
        {
            var downloadsDir = Configs.Current.Get(ConfigKey.SaveVideosTo);
            if (string.IsNullOrEmpty(downloadsDir) || !Directory.Exists(downloadsDir))
            {
                OperatingSystem os = Environment.OSVersion;
                PlatformID plid = os.Platform;
                var isWindows = plid.ToString().Contains("Win");
                if (isWindows)
                {
                    var guid = "{374DE290-123F-4565-9164-39C4925E467B}";
                    var hk = @"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\" +
                        @"Explorer\Shell Folders";
                    downloadsDir = Registry.GetValue(hk, guid, String.Empty).ToString();
                }
                else
                {
                    downloadsDir = Directory.Exists("~/Downloads") ? "~/Downloads" :
                        "~/downloads";
                }
            }

            return downloadsDir ?? "";
        }
    }

    public abstract class DownloadLatestPyScriptBase
    {
        public void Go(RunToolHelper run)
        {
            var prefix = this.GetPrefix();
            Directory.CreateDirectory("./tools");
            var pathCurrentZip = "./tools/%.zip".Replace("%", prefix);
            var pathCurrentDir = "./tools/%dir".Replace("%", prefix);
            var pathOldZip = "./tools/%-old.zip".Replace("%", prefix);
            var pathOldDir = "./tools/%dir-old".Replace("%", prefix);
            var pathIncomingZip = "./tools/%-incoming.zip".Replace("%", prefix);
            var pathIncomingDir = "./tools/%dir-incoming".Replace("%", prefix);

            // check before calling Delete(), since we want this to work even if
            // dir is currently empty
            run.Trace("Deleting temporary files");
            if (File.Exists(pathIncomingZip))
                File.Delete(pathIncomingZip);

            if (Directory.Exists(pathIncomingDir))
                Directory.Delete(pathIncomingDir, true);

            var url = this.GetUrl();
            run.Trace("Downloading from " + url);
            DownloadFile(url, pathIncomingZip);

            if (!File.Exists(pathIncomingZip))
                throw new CsDownloadVidException("No file was downloaded. " + url);

            if (new FileInfo(pathIncomingZip).Length < 500 * 1024)
                throw new CsDownloadVidException("File downloaded was too small, " +
                    "expect > 500k. " + pathIncomingZip);

            var currentHash = Utils.GetSha512(pathCurrentZip);
            var incomingHash = Utils.GetSha512(pathIncomingZip);
            if (currentHash == incomingHash)
            {
                run.Trace("We seem to have the latest version -- already up to date!");
                return;
            }

            run.Trace("Extracting from zip file...");
            ZipFile.ExtractToDirectory(pathIncomingZip, pathIncomingDir);
            run.Trace("Removing unneeded files...");
            var dir = pathIncomingDir + "/youtube-dl-master/youtube_dl/extractor";

            this.DoPostProcessing(dir, pathIncomingDir);
            run.Trace("Found a newer version!");
            run.Trace("Moving from current to old");
            if (File.Exists(pathOldZip))
                File.Delete(pathOldZip);
            if (Directory.Exists(pathOldDir))
                Directory.Delete(pathOldDir, true);
            if (File.Exists(pathCurrentZip))
                File.Move(pathCurrentZip, pathOldZip);
            if (Directory.Exists(pathCurrentDir))
                Directory.Move(pathCurrentDir, pathOldDir);

            run.Trace("Moving incoming to current");
            File.Move(pathIncomingZip, pathCurrentZip);
            Directory.Move(pathIncomingDir, pathCurrentDir);
        }

        public static void DownloadFile(string url, string dest)
        {
            if (url.StartsWith("https"))
            {
                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
            }

            using (var client = new WebClient())
            {
                client.DownloadFile(url, dest);
            }
        }

        public abstract string GetPrefix();

        public abstract string GetUrl();

        public abstract void DoPostProcessing(string dir, string pathIncomingDir);
    }

    public class DownloadLatestPytube : DownloadLatestPyScriptBase
    {
        public override string GetPrefix()
        {
            return "pytubemaster";
        }

        public override string GetUrl()
        {
            return "https://github.com/pytube/pytube/archive/master.zip";
        }

        public override void DoPostProcessing(string dir, string pathIncomingDir)
        {
            var expectedMain = pathIncomingDir + "/pytube-master/pytube/__main__.py";
            if (!File.Exists(expectedMain))
                throw new CsDownloadVidException("no main.py found, expected at " + expectedMain);
        }
    }

    public class DownloadLatestYtdl : DownloadLatestPyScriptBase
    {
        bool trimRareScripts = false;
        public override string GetPrefix()
        {
            return "ytmaster";
        }

        public override string GetUrl()
        {
            return "https://github.com/rg3/youtube-dl/archive/master.zip";
        }

        public override void DoPostProcessing(string dir, string pathIncomingDir)
        {
            var pathMain = pathIncomingDir + "/youtube-dl-master/youtube_dl/__main__.py";
            if (!File.Exists(pathMain))
                throw new CsDownloadVidException("no main.py found, expected at " + pathMain);

            if (!trimRareScripts)
            {
                return;
            }

            if (Directory.Exists(dir))
            {
                // let's delete most of the python scripts in Ytdl -- there are 100s of scripts for 
                // sites I don't care about
                var allow = @"abc.py
amp.py
abcnews.py
acast.py
adobepass.py
adobetv.py
adultswim.py
adn.py
aljazeera.py
appleconnect.py
appletrailers.py
archiveorg.py
bandcamp.py
bostonglobe.py
common.py
commonmistakes.py
commonprotocols.py
buzzfeed.py
criterion.py
dailymotion.py
espn.py
ebaumsworld.py
facebook.py
extractors.py
giga.py
flickr.py
gfycat.py
go.py
go90.py
huffpost.py
imgur.py
instagram.py
imdb.py
khanacademy.py
kickstarter.py
metacafe.py
myspace.py
nytimes.py
turner.py
patreon.py
pokemon.py
reuters.py
vimeo.py
soundcloud.py
washingtonpost.py
youtube.py
vice.py
once.py
openload.py"; // note: no generic.py since it pulls in a lot. once.py and openload.py added december 2017
                var allowList = Utils.SplitLines(allow);
                var filesInDir = Directory.GetFiles(dir);
                foreach (var fileName in filesInDir)
                {
                    var shortName = Path.GetFileName(fileName);
                    if (shortName.EndsWith(".py") && !shortName.Contains("__") && Array.IndexOf(allowList, shortName) == -1)
                        File.Delete(fileName);
                }

                // comment out any reference to deleted files
                var linesOut = new List<string>();
                foreach (var line in File.ReadAllLines(Path.Combine(dir, "extractors.py")))
                {
                    if (line.StartsWith("from .") && line.Contains(" import "))
                    {
                        var moduleName = Utils.SplitByString(Utils.SplitByString(line, "from .")[1], " import ")[0];
                        if (File.Exists(Path.Combine(dir, moduleName + ".py")))
                            linesOut.Add(line);
                        else
                        {
                            linesOut.Add("if False:");
                            linesOut.Add("    " + line);
                        }
                    }
                    else
                    {
                        linesOut.Add(line);
                    }
                }

                File.WriteAllLines(Path.Combine(dir, "extractors.py"), linesOut.ToArray());

                // does the line reference GenericIE, and not as a string?
                Func<string, bool> hasGenericIE = (s) => s.Contains("GenericIE") &&
                    !s.Contains("'GenericIE'") && !s.Contains("\"GenericIE\"");

                // comment out reference to generic.py, since generic.py references a bunch of others
                var codePrev = File.ReadAllLines(Path.Combine(dir, "__init__.py"));
                var codeNew = from line in codePrev
                              select
                             hasGenericIE(line) ? "# " + line : line;
                File.WriteAllLines(Path.Combine(dir, "__init__.py"), codeNew);
            }
        }
    }

    public class LockCloser : IDisposable
    {
        private readonly object _lock;
        private bool _needToClose;
        public LockCloser(object locker)
        {
            _lock = locker;
        }

        public bool TryEnter()
        {
            Utils.AssertTrue(!this._needToClose, "Cannot enter when already entered.");
            var entered = Monitor.TryEnter(this._lock);
            if (entered)
            {
                this._needToClose = true;
            }

            return entered;
        }

        public void Dispose()
        {
            if (this._needToClose)
            {
                Monitor.Exit(_lock);
            }
        }
    }
}
namespace CsDownloadVid
{
    partial class FormMain
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormMain));
            this.lblMain = new System.Windows.Forms.Label();
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.csDownloadVidToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.downloadVideoToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripSeparator();
            this.audioFromVideoToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.splitMediaIntoPartsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.joinTwoVideosLosslessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuEncodeCustom = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripSeparator();
            this.helpAndTutorialsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.menuStrip1.SuspendLayout();
            this.SuspendLayout();
            // 
            // lblMain
            // 
            this.lblMain.Location = new System.Drawing.Point(16, 172);
            this.lblMain.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.lblMain.Name = "lblMain";
            this.lblMain.Size = new System.Drawing.Size(565, 142);
            this.lblMain.TabIndex = 0;
            this.lblMain.Text = resources.GetString("lblMain.Text");
            // 
            // menuStrip1
            // 
            this.menuStrip1.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.csDownloadVidToolStripMenuItem});
            this.menuStrip1.Location = new System.Drawing.Point(0, 0);
            this.menuStrip1.Name = "menuStrip1";
            this.menuStrip1.Size = new System.Drawing.Size(581, 28);
            this.menuStrip1.TabIndex = 1;
            this.menuStrip1.Text = "menuStrip1";
            // 
            // csDownloadVidToolStripMenuItem
            // 
            this.csDownloadVidToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.downloadVideoToolStripMenuItem,
            this.toolStripMenuItem1,
            this.audioFromVideoToolStripMenuItem,
            this.splitMediaIntoPartsToolStripMenuItem,
            this.joinTwoVideosLosslessToolStripMenuItem,
            this.mnuEncodeCustom,
            this.toolStripMenuItem2,
            this.helpAndTutorialsToolStripMenuItem});
            this.csDownloadVidToolStripMenuItem.Name = "csDownloadVidToolStripMenuItem";
            this.csDownloadVidToolStripMenuItem.Size = new System.Drawing.Size(54, 24);
            this.csDownloadVidToolStripMenuItem.Text = "Start";
            // 
            // downloadVideoToolStripMenuItem
            // 
            this.downloadVideoToolStripMenuItem.Name = "downloadVideoToolStripMenuItem";
            this.downloadVideoToolStripMenuItem.Size = new System.Drawing.Size(401, 26);
            this.downloadVideoToolStripMenuItem.Text = "Download a video...";
            this.downloadVideoToolStripMenuItem.Click += new System.EventHandler(this.mnuOpenFormGetVideo_Click);
            // 
            // toolStripMenuItem1
            // 
            this.toolStripMenuItem1.Name = "toolStripMenuItem1";
            this.toolStripMenuItem1.Size = new System.Drawing.Size(398, 6);
            // 
            // audioFromVideoToolStripMenuItem
            // 
            this.audioFromVideoToolStripMenuItem.Name = "audioFromVideoToolStripMenuItem";
            this.audioFromVideoToolStripMenuItem.Size = new System.Drawing.Size(401, 26);
            this.audioFromVideoToolStripMenuItem.Text = "Separate audio and video (Lossless)...";
            this.audioFromVideoToolStripMenuItem.Click += new System.EventHandler(this.mnuOpenFormAudioFromVideo_Click);
            // 
            // splitMediaIntoPartsToolStripMenuItem
            // 
            this.splitMediaIntoPartsToolStripMenuItem.Name = "splitMediaIntoPartsToolStripMenuItem";
            this.splitMediaIntoPartsToolStripMenuItem.Size = new System.Drawing.Size(401, 26);
            this.splitMediaIntoPartsToolStripMenuItem.Text = "Split a video or a song into pieces (Lossless)...";
            this.splitMediaIntoPartsToolStripMenuItem.Click += new System.EventHandler(this.mnuOpenFormMediaSplit_Click);
            // 
            // joinTwoVideosLosslessToolStripMenuItem
            // 
            this.joinTwoVideosLosslessToolStripMenuItem.Name = "joinTwoVideosLosslessToolStripMenuItem";
            this.joinTwoVideosLosslessToolStripMenuItem.Size = new System.Drawing.Size(401, 26);
            this.joinTwoVideosLosslessToolStripMenuItem.Text = "Join the pieces of a video or a song (Lossless)...";
            this.joinTwoVideosLosslessToolStripMenuItem.Click += new System.EventHandler(this.mnuOpenFormMediaJoin_Click);
            // 
            // mnuEncodeCustom
            // 
            this.mnuEncodeCustom.Name = "mnuEncodeCustom";
            this.mnuEncodeCustom.Size = new System.Drawing.Size(401, 26);
            this.mnuEncodeCustom.Text = "Encode video or audio...";
            this.mnuEncodeCustom.Click += new System.EventHandler(this.mnuEncodeCustom_Click);
            // 
            // toolStripMenuItem2
            // 
            this.toolStripMenuItem2.Name = "toolStripMenuItem2";
            this.toolStripMenuItem2.Size = new System.Drawing.Size(398, 6);
            // 
            // helpAndTutorialsToolStripMenuItem
            // 
            this.helpAndTutorialsToolStripMenuItem.Name = "helpAndTutorialsToolStripMenuItem";
            this.helpAndTutorialsToolStripMenuItem.Size = new System.Drawing.Size(401, 26);
            this.helpAndTutorialsToolStripMenuItem.Text = "Online info and tutorials...";
            this.helpAndTutorialsToolStripMenuItem.Click += new System.EventHandler(this.mnuOpenHelpWebsite_Click);
            // 
            // FormMain
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(581, 325);
            this.Controls.Add(this.lblMain);
            this.Controls.Add(this.menuStrip1);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MainMenuStrip = this.menuStrip1;
            this.Margin = new System.Windows.Forms.Padding(4);
            this.Name = "FormMain";
            this.Text = "CsDownloadVid";
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label lblMain;
        private System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem csDownloadVidToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem downloadVideoToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem audioFromVideoToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem splitMediaIntoPartsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem joinTwoVideosLosslessToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripMenuItem1;
        private System.Windows.Forms.ToolStripSeparator toolStripMenuItem2;
        private System.Windows.Forms.ToolStripMenuItem helpAndTutorialsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem mnuEncodeCustom;
    }
}namespace CsDownloadVid
{
    partial class FormMediaSplit
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.btnGetInput = new System.Windows.Forms.Button();
            this.txtInput = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.checkBoxFadeout = new System.Windows.Forms.CheckBox();
            this.txtFadeLength = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.txtSplitpoints = new System.Windows.Forms.TextBox();
            this.lblShortStatus = new System.Windows.Forms.Label();
            this.txtStatus = new System.Windows.Forms.TextBox();
            this.btnSplit = new System.Windows.Forms.Button();
            this.btnImportAudacityLabel = new System.Windows.Forms.Button();
            this.btnShowSum = new System.Windows.Forms.Button();
            this.label4 = new System.Windows.Forms.Label();
            this.btnToMp3DirectCut = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // btnGetInput
            // 
            this.btnGetInput.Location = new System.Drawing.Point(245, 12);
            this.btnGetInput.Name = "btnGetInput";
            this.btnGetInput.Size = new System.Drawing.Size(75, 23);
            this.btnGetInput.TabIndex = 31;
            this.btnGetInput.Text = "Choose...";
            this.btnGetInput.UseVisualStyleBackColor = true;
            this.btnGetInput.Click += new System.EventHandler(this.btnGetInput_Click);
            // 
            // txtInput
            // 
            this.txtInput.BackColor = System.Drawing.SystemColors.Control;
            this.txtInput.Location = new System.Drawing.Point(13, 41);
            this.txtInput.Name = "txtInput";
            this.txtInput.ReadOnly = true;
            this.txtInput.Size = new System.Drawing.Size(307, 20);
            this.txtInput.TabIndex = 33;
            this.txtInput.Visible = false;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(10, 17);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(229, 13);
            this.label2.TabIndex = 32;
            this.label2.Text = "Choose a m4v video, mp4 video, or m4a audio:";
            // 
            // checkBoxFadeout
            // 
            this.checkBoxFadeout.AutoSize = true;
            this.checkBoxFadeout.Location = new System.Drawing.Point(47, 70);
            this.checkBoxFadeout.Name = "checkBoxFadeout";
            this.checkBoxFadeout.Size = new System.Drawing.Size(197, 17);
            this.checkBoxFadeout.TabIndex = 34;
            this.checkBoxFadeout.Text = "Add fadeout, fade length in seconds";
            this.checkBoxFadeout.UseVisualStyleBackColor = true;
            // 
            // txtFadeLength
            // 
            this.txtFadeLength.Location = new System.Drawing.Point(253, 67);
            this.txtFadeLength.Name = "txtFadeLength";
            this.txtFadeLength.Size = new System.Drawing.Size(67, 20);
            this.txtFadeLength.TabIndex = 35;
            this.txtFadeLength.Text = "4";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(12, 115);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(141, 13);
            this.label3.TabIndex = 32;
            this.label3.Text = "Enter split points in seconds:";
            // 
            // txtSplitpoints
            // 
            this.txtSplitpoints.BackColor = System.Drawing.SystemColors.Window;
            this.txtSplitpoints.Location = new System.Drawing.Point(15, 131);
            this.txtSplitpoints.Multiline = true;
            this.txtSplitpoints.Name = "txtSplitpoints";
            this.txtSplitpoints.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.txtSplitpoints.Size = new System.Drawing.Size(252, 109);
            this.txtSplitpoints.TabIndex = 36;
            // 
            // lblShortStatus
            // 
            this.lblShortStatus.AutoSize = true;
            this.lblShortStatus.Location = new System.Drawing.Point(11, 328);
            this.lblShortStatus.Name = "lblShortStatus";
            this.lblShortStatus.Size = new System.Drawing.Size(45, 13);
            this.lblShortStatus.TabIndex = 40;
            this.lblShortStatus.Text = "Results:";
            // 
            // txtStatus
            // 
            this.txtStatus.BackColor = System.Drawing.SystemColors.Control;
            this.txtStatus.Location = new System.Drawing.Point(12, 346);
            this.txtStatus.Multiline = true;
            this.txtStatus.Name = "txtStatus";
            this.txtStatus.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.txtStatus.Size = new System.Drawing.Size(447, 108);
            this.txtStatus.TabIndex = 39;
            // 
            // btnSplit
            // 
            this.btnSplit.Location = new System.Drawing.Point(12, 255);
            this.btnSplit.Name = "btnSplit";
            this.btnSplit.Size = new System.Drawing.Size(447, 67);
            this.btnSplit.TabIndex = 38;
            this.btnSplit.Text = "Split (Lossless)";
            this.btnSplit.UseVisualStyleBackColor = true;
            this.btnSplit.Click += new System.EventHandler(this.btnSplit_Click);
            // 
            // btnImportAudacityLabel
            // 
            this.btnImportAudacityLabel.Location = new System.Drawing.Point(273, 131);
            this.btnImportAudacityLabel.Name = "btnImportAudacityLabel";
            this.btnImportAudacityLabel.Size = new System.Drawing.Size(186, 23);
            this.btnImportAudacityLabel.TabIndex = 38;
            this.btnImportAudacityLabel.Text = "Import Audacity label track...";
            this.btnImportAudacityLabel.UseVisualStyleBackColor = true;
            this.btnImportAudacityLabel.Click += new System.EventHandler(this.btnImportAudacity_Click);
            // 
            // btnShowSum
            // 
            this.btnShowSum.Location = new System.Drawing.Point(273, 160);
            this.btnShowSum.Name = "btnShowSum";
            this.btnShowSum.Size = new System.Drawing.Size(186, 23);
            this.btnShowSum.TabIndex = 38;
            this.btnShowSum.Text = "Show sum of these times...";
            this.btnShowSum.UseVisualStyleBackColor = true;
            this.btnShowSum.Click += new System.EventHandler(this.btnShowSum_Click);
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(63, 86);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(97, 13);
            this.label4.TabIndex = 32;
            this.label4.Text = "(requires qaac.exe)";
            // 
            // btnToMp3DirectCut
            // 
            this.btnToMp3DirectCut.Location = new System.Drawing.Point(273, 189);
            this.btnToMp3DirectCut.Name = "btnToMp3DirectCut";
            this.btnToMp3DirectCut.Size = new System.Drawing.Size(186, 23);
            this.btnToMp3DirectCut.TabIndex = 38;
            this.btnToMp3DirectCut.Text = "Export to mp3DirectCut...";
            this.btnToMp3DirectCut.UseVisualStyleBackColor = true;
            this.btnToMp3DirectCut.Click += new System.EventHandler(this.btnToMp3DirectCut_Click);
            // 
            // FormMediaSplit
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(473, 466);
            this.Controls.Add(this.lblShortStatus);
            this.Controls.Add(this.txtStatus);
            this.Controls.Add(this.btnToMp3DirectCut);
            this.Controls.Add(this.btnShowSum);
            this.Controls.Add(this.btnImportAudacityLabel);
            this.Controls.Add(this.btnSplit);
            this.Controls.Add(this.txtSplitpoints);
            this.Controls.Add(this.txtFadeLength);
            this.Controls.Add(this.checkBoxFadeout);
            this.Controls.Add(this.btnGetInput);
            this.Controls.Add(this.txtInput);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.label2);
            this.Name = "FormMediaSplit";
            this.Text = "Split a video or a song";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button btnGetInput;
        private System.Windows.Forms.TextBox txtInput;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.CheckBox checkBoxFadeout;
        private System.Windows.Forms.TextBox txtFadeLength;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox txtSplitpoints;
        private System.Windows.Forms.Label lblShortStatus;
        private System.Windows.Forms.TextBox txtStatus;
        private System.Windows.Forms.Button btnSplit;
        private System.Windows.Forms.Button btnImportAudacityLabel;
        private System.Windows.Forms.Button btnShowSum;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Button btnToMp3DirectCut;
    }
}// Copyright (c) Ben Fisher, 2016.
// Licensed under GPLv3.

using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows.Forms;

namespace CsDownloadVid
{
    public partial class FormGetVideo : Form
    {
        RunToolHelper _runner;
        Dictionary<string, string> _formatsGeneric = new Dictionary<string, string>
        {
            { "best audio+video", "best" },
            { "worst audio+video", "worst" },
            { "best audio", "bestaudio" },
            { "worst audio", "worstaudio" },
            { "best m4a", "m4a" },
            { "best mp4", "mp4" },
            { "best aac", "aac" },
            { "best webm", "webm" },
        };

        public FormGetVideo()
        {
            InitializeComponent();
            panelAdvanced.Visible = chkShowAdvanced.Checked;
            lblEnterUrlsAdvanced.Visible = chkShowAdvanced.Checked;
            panelChooseQuality.Visible = false;
            panelChooseOutput.Visible = false;
            btnNextStepIsToChooseOutput.Enabled = false;
            lblShortStatus.Text = "";
            txtStatus.Visible = false;

            AddGenericFormatsToListbox();
            txtOutputDir.Text = CsDownloadVidFilepaths.GetDefaultDownloadsDir();
            lblNamePattern.Text = "Filename pattern, see also" + Utils.NL +
                "%(upload_date)s";
            _runner = new RunToolHelper(this.txtStatus, this.lblShortStatus,
                (line) => (!line.Contains("[download]")));

            // pre-emptively ensure that we have paths
            var ensurePath = CsDownloadVidFilepaths.GetPython();
        }

        private void NextStepIsToChooseQuality()
        {
            if (CsDownloadVidFilepaths.GetYtdlPath(cbUsePytube.Checked,
                required: false) == null)
            {
                return;
            }

            listBoxFmts.Items.Clear();
            AddGenericFormatsToListbox();
            GetOptionsFromUI(out List<string> urlsRet, out int waitBetween,
                out string filenamePattern, out string outDir);

            // look up formats
            txtStatus.Visible = true;
            lblShortStatus.Visible = true;
            panelChooseQuality.Visible = true;
            btnNextStepIsToChooseOutput.Enabled = false;
            btnNextStepIsToChooseOutput.Text = "Looking up formats...";
            var urlToGet = urlsRet[0];
            var info = GetStartInfo(urlToGet, "", true);

            // run all in a separate thread, so that UI remains responsive.
            _runner.RunInThread(() =>
            {
                LoadFormats_StartProc(urlToGet, info);
            });
        }

        private void LoadFormats_StartProc(string urlToGet, ProcessStartInfo info)
        {
            string log = "";
            string stderr = "";
            string stdout = "";
            bool succeeded = false;

            Process p = new Process();
            p.StartInfo = info;
            p.Start();
            p.ErrorDataReceived += (o, eparam) => { stderr += eparam.Data; };
            p.BeginErrorReadLine();
            p.WaitForExit();
            log += "\nRan " + info.FileName + " " + info.Arguments;
            stdout = p.StandardOutput.ReadToEnd();
            if (p.ExitCode == 0)
            {
                succeeded = true;
            }
            else
            {
                log += "\nStdout:" + stdout;
                log += "\nStderr:" + stderr;
            }

            _runner.TraceFiltered(log.Replace("\n", Utils.NL));
            if (succeeded)
            {
                LoadFormats_ToUI(urlToGet, stdout);
            }
            else
            {
                Utils.MessageErr("Could not get formats");
                _runner.Trace("Could not get formats");
            }
        }

        private void LoadFormats_ToUI(string urlToGet, string stdout)
        {
            _runner.Trace("Done getting formats");
            this.Invoke(new Action(() =>
            {
                List<ListBoxItemFormat> items = LoadFormats_Parse(stdout, urlToGet);
                listBoxFmts.Items.Clear();
                if (items != null)
                {
                    listBoxFmts.Items.AddRange(items.ToArray());
                }

                AddGenericFormatsToListbox();
                for (int i = 0; i < listBoxFmts.Items.Count; i++)
                {
                    if (listBoxFmts.Items[i].ToString().Contains(" (140) mp4a") ||
                    listBoxFmts.Items[i].ToString().Contains("\"140\" \"m4a\""))
                    {
                        listBoxFmts.SelectedIndices.Add(i);
                        break;
                    }
                }

                btnNextStepIsToChooseOutput.Text = "Go to next step";
                btnNextStepIsToChooseOutput.Enabled = true;
            }));
        }

        void AddGenericFormatsToListbox()
        {
            if (!cbUsePytube.Checked)
            {
                var formats = from key in _formatsGeneric.Keys orderby key select key;
                foreach (var format in formats)
                {
                    var item = new ListBoxItemFormat();
                    item._displayText = format;
                    listBoxFmts.Items.Add(item);
                }
            }
        }

        List<ListBoxItemFormat> LoadFormats_Parse(string result, string url)
        {
            var results = new List<ListBoxItemFormat>();
            bool isYoutube = url.Contains("youtube");
            var resultLines = Utils.SplitLines(result);
            var containsAvailFormats = resultLines.Any(
                (s) => s.StartsWith("[info] Available formats for "));
            if (!containsAvailFormats)
            {
                throw new CsDownloadVidException("did not see any line with " +
                    "'[info] Available formats'. result was " + result);
            }

            if (cbUsePytube.Checked)
            {
                foreach (var line in resultLines)
                {
                    if (line.StartsWith("<Stream:"))
                    {
                        ListBoxItemFormat item = new ListBoxItemFormat();
                        item._displayText = line;
                        results.Add(item);
                    }
                }

                return results;
            }

            bool shouldIncludeLine = false;
            foreach (var line in resultLines)
            {
                if (!shouldIncludeLine && line.Replace(" ", "").StartsWith(
                    "format code  extension resolution".Replace(" ", "")))
                {
                    shouldIncludeLine = true;
                }
                else if (shouldIncludeLine)
                {
                    ParseFormat(results, line, isYoutube);
                }
            }

            if (results.Count == 0)
            {
                throw new CsDownloadVidException("Did not see any formats... stdout was " +
                    result);
            }

            results.Sort();
            return results;
        }

        private void ParseFormat(List<ListBoxItemFormat> results, string line, bool isYoutube)
        {
            var parts = line.Split(new string[] { "          " }, count: 2,
                options: StringSplitOptions.None);
            var firstNumber = parts[0];
            if (int.TryParse(firstNumber, out int nOut))
            {
                parts[1] = parts[1].Trim();
                parts[1] = parts[1].Replace("  ", " ").Replace("  ", " ").Replace("  ", " ");
                if (parts[1].Contains("audio only"))
                    parts[1] = "audio: " + parts[1].Replace("audio only", "");
                else if (parts[1].Contains("video only"))
                    parts[1] = "video: " + parts[1].Replace("video only", "");
                else
                    parts[1] = "a+v: " + parts[1];

                parts[1] = parts[1].Replace(" , ", "");

                ListBoxItemFormat item = new ListBoxItemFormat();
                item._formatNumber = nOut;
                item._displayText = parts[1];
                results.Add(item);
            }
            else if (!isYoutube)
            {
                if (line.Contains("   "))
                {
                    ListBoxItemFormat item = new ListBoxItemFormat();
                    item._displayText = line.Trim();
                    results.Add(item);
                }
            }
            else if (line.Contains("   "))
            {
                _runner.Trace("ignoring line " + line);
            }
        }

        private void chkShowAdvanced_CheckedChanged(object sender, EventArgs e)
        {
            panelAdvanced.Visible = chkShowAdvanced.Checked;
            lblEnterUrlsAdvanced.Visible = chkShowAdvanced.Checked;
        }

        private void btnNextToChooseQuality_Click(object sender, EventArgs e)
        {
            RunToolHelper.RunAndCatch(() => NextStepIsToChooseQuality());
        }

        private void btnSaveTo_Click(object sender, EventArgs e)
        {
            var outDir = Utils.AskSaveFileDialog("Save to?", new string[] { ".mp4" },
                null, txtOutputDir.Text);

            outDir = Path.GetDirectoryName(outDir);
            if (Directory.Exists(outDir))
            {
                txtOutputDir.Text = outDir;
            }
        }

        private void btnDownload_Click(object sender, EventArgs e)
        {
            RunToolHelper.RunAndCatch(() =>
            {
                if (chkDashToM4a.Checked || chkAutoCombineAV.Checked)
                {
                    CsDownloadVidFilepaths.GetFfmpeg();
                }

                GetOptionsFromUI(out List<string> urlsRet, out int waitBetween,
                    out string filenamePattern, out string outDir);

                var formats = GetFormatsFromUI();
                if (formats == null || formats.Length == 0)
                {
                    throw new CsDownloadVidException("No format chosen.");
                }
                else if (formats.Any((fmt) => cbUsePytube.Checked != fmt.StartsWith("<Stream:")))
                {
                    throw new CsDownloadVidException("It looks like you've clicked " +
                        "'use pytube instead of ytdl' half-way through-- when you change " +
                        "this you have to start over at step 1.");
                }

                Configs.Current.Set(ConfigKey.SaveVideosTo, txtOutputDir.Text);
                _runner.SetWaitBetween(waitBetween);
                List<ProcessStartInfo> listInfos = new List<ProcessStartInfo>();
                foreach (var url in urlsRet)
                {
                    foreach (var fmt in formats)
                    {
                        listInfos.Add(GetStartInfo(url, fmt, false));
                    }
                }

                _runner.RunProcesses(listInfos.ToArray(), "downloading", () =>
                {
                    if (chkAutoCombineAV.Checked && Directory.Exists(txtOutputDir.Text))
                    {
                        runAutocombineAVAll(txtOutputDir.Text);
                    }
                });
            });
        }

        private void runAutocombineAVAll(string dir)
        {
            var vidExts = new string[] { ".mp4", ".webm", ".3gp", ".3gpp" };
            foreach (var file in Directory.EnumerateFiles(dir, "*", SearchOption.TopDirectoryOnly))
            {
                var asAudio = dir + "/" + Path.GetFileNameWithoutExtension(file) + ".m4a";
                var isVid = vidExts.Any((v) => file.ToLowerInvariant().EndsWith(v));
                if (isVid && File.Exists(asAudio))
                {
                    // we won't run runAutocombineAV on temp results because there won't be an m4a
                    runAutocombineAV(file, asAudio);
                }
            }
        }

        private void runAutocombineAV(string vid, string aud)
        {
            var vidOnly = Path.GetDirectoryName(vid) + "/" + Path.GetFileNameWithoutExtension(vid) +
                "_{vidonly}" + Path.GetExtension(vid);
            var outFile = Path.GetDirectoryName(vid) + "/" + Path.GetFileNameWithoutExtension(vid) +
                "_{out}" + Path.GetExtension(vid);
            if (File.Exists(outFile))
            {
                Utils.SoftDelete(outFile);
            }

            var args = Utils.SplitByString("-i|" + vid + "|-an|-c:v|copy|" + vidOnly, "|");
            var info = new ProcessStartInfo();
            info.FileName = CsDownloadVidFilepaths.GetFfmpeg();
            info.Arguments = Utils.CombineProcessArguments(args.ToArray());
            info.CreateNoWindow = true;
            info.RedirectStandardError = true;
            info.RedirectStandardOutput = true;
            info.UseShellExecute = false;
            _runner.RunProcessSync(info, "AutocombineAV: 1) Ensuring video-only version " + vid);
            Utils.AssertTrue(File.Exists(vidOnly) && new FileInfo(vidOnly).Length > 0, "Did not write to " + vidOnly);

            args = Utils.SplitByString("-i|" + vidOnly + "|-i|" + aud + "|-c:a|copy|-c:v|copy|" + outFile, "|");
            info = new ProcessStartInfo();
            info.FileName = CsDownloadVidFilepaths.GetFfmpeg();
            info.Arguments = Utils.CombineProcessArguments(args.ToArray());
            info.CreateNoWindow = true;
            info.RedirectStandardError = true;
            info.RedirectStandardOutput = true;
            info.UseShellExecute = false;
            _runner.RunProcessSync(info, "AutocombineAV: 2) Putting A+V together " + vid);
            Utils.AssertTrue(File.Exists(outFile) && new FileInfo(outFile).Length > 0, "Did not write to " + outFile);

            _runner.Trace("AutocombineAV: 3) Deleting temporaries");
            Utils.SoftDelete(vidOnly);
            Utils.SoftDelete(vid);
            Utils.SoftDelete(aud);
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            RunToolHelper.RunAndCatch(() => _runner.CancelProcess());
        }

        string GetUrlFromUrlFile(string sFile)
        {
            var lines = File.ReadAllLines(sFile);
            foreach (var line in lines)
            {
                if (line.StartsWith("URL="))
                {
                    return line.Substring("URL=".Length);
                }
            }

            throw new CsDownloadVidException("url not found in file " + sFile);
        }

        private void GetUrlsFromTextFile(string filename, List<string> results)
        {
            var all = File.ReadAllLines(filename);
            foreach (var line in all)
            {
                if (line.StartsWith("http"))
                {
                    results.Add(line);
                }
            }
        }

        public void GetOptionsFromUI(out List<string> urlsRet, out int waitBetween,
            out string filenamePattern, out string outDir)
        {
            urlsRet = new List<string>();
            if (!Directory.Exists(txtOutputDir.Text))
            {
                throw new CsDownloadVidException("Directory does not exist: " +
                    txtOutputDir.Text);
            }

            outDir = txtOutputDir.Text;

            if (!double.TryParse(txtWaitBetween.Text, out double dwaitBetween))
            {
                throw new CsDownloadVidException("Invalid wait between: " +
                    txtWaitBetween.Text);
            }

            waitBetween = (int)(1000 * double.Parse(txtWaitBetween.Text));

            if (!txtFilenamePattern.Text.Contains("%(title)") &&
                !txtFilenamePattern.Text.Contains("%(id)"))
            {
                throw new CsDownloadVidException("filename pattern should have at " +
                    "least %(title) or %(id) but got: " + txtFilenamePattern.Text);
            }

            filenamePattern = txtFilenamePattern.Text;

            var url = txtUrl.Text;
            if (url.StartsWith("http"))
            {
                var urlsTry = url.Split(new char[] { '|' });
                foreach (var one in urlsTry)
                {
                    if (!one.StartsWith("http"))
                    {
                        throw new CsDownloadVidException("Reading multiple urls separated " +
                            "by |. Why does one of the urls not start with http? Got " + one);
                    }
                    urlsRet.Add(one);
                }
            }
            else if (Directory.Exists(url))
            {
                var urlLinks = Directory.GetFiles(url, "*.url");
                if (urlLinks.Length == 0)
                {
                    throw new CsDownloadVidException("no .url files seen in this directory " +
                        url);
                }
                else if (urlLinks.Length > 1 && Utils.AskToConfirm("Found " + urlLinks.Length +
                    " .url files. Continue?"))
                {
                    foreach (var link in urlLinks)
                        urlsRet.Add(GetUrlFromUrlFile(link));
                }
            }
            else if (File.Exists(url) && url.ToLowerInvariant().EndsWith(".url"))
            {
                urlsRet.Add(GetUrlFromUrlFile(url));
            }
            else if (File.Exists(url) && url.ToLowerInvariant().EndsWith(".txt"))
            {
                GetUrlsFromTextFile(url, urlsRet);
            }
            else
            {
                throw new CsDownloadVidException("unrecognized input " + url);
            }
        }

        public string[] GetFormatsFromUI()
        {
            var ret = new List<string>();
            foreach (var itemRaw in listBoxFmts.SelectedItems)
            {
                var item = itemRaw as ListBoxItemFormat;
                ret.Add(displayFmtToChosenFormat(item));
            }

            return ret.ToArray();
        }

        private string displayFmtToChosenFormat(ListBoxItemFormat item)
        {
            if (cbUsePytube.Checked)
            {
                return item._displayText;
            }
            if (item._formatNumber == -1)
            {
                if (_formatsGeneric.ContainsKey(item._displayText))
                    return _formatsGeneric[item._displayText];
                else return item._displayText.Split(new string[] { " " },
                    StringSplitOptions.None)[0];
            }
            else
            {
                return item._formatNumber.ToString();
            }
        }

        ProcessStartInfo GetStartInfo(string url, string format, bool listSupportedFormatsOnly)
        {
            var args = new List<string>();
            args.Add("--ignore-config"); // don't look for global config file
            args.Add("--no-mark-watched");
            args.Add("--no-call-home");
            args.Add("--no-mtime"); // don't adjust the lmt of the file, it's confusing
            args.Add("--no-playlist");

            if (listSupportedFormatsOnly)
            {
                args.Add("--list-formats");
                args.Add("--simulate");
            }
            else
            {
                args.Add("--format");
                args.Add(format);

                // post-process, otherwise the m4a won't show correctly in some media players
                if (chkDashToM4a.Checked)
                {
                    args.Add("--ffmpeg-location");
                    args.Add(CsDownloadVidFilepaths.GetFfmpeg());
                }
            }

            if (cbUsePytube.Checked)
            {
                args.Add("--outputdir=" + txtOutputDir.Text);
            }
            else
            {
                var outputTemplate = Path.Combine(txtOutputDir.Text, txtFilenamePattern.Text);
                args.Add("--output");
                args.Add(outputTemplate);
            }

            var sArgs = Utils.CombineProcessArguments(args.ToArray());
            if (!string.IsNullOrWhiteSpace(txtAdditionalArgs.Text))
            {
                sArgs += " " + txtAdditionalArgs.Text + " ";
            }

            sArgs += " " + Utils.CombineProcessArguments(new string[] { url });

            var info = new ProcessStartInfo();
            info.FileName = CsDownloadVidFilepaths.GetYtdlPath(this.cbUsePytube.Checked);
            info.Arguments = sArgs;
            info.CreateNoWindow = true;
            info.RedirectStandardError = true;
            info.RedirectStandardOutput = true;
            info.UseShellExecute = false;

            if (CsDownloadVidFilepaths.GetYtdlPath(this.cbUsePytube.Checked).EndsWith(".py"))
            {
                info.FileName = CsDownloadVidFilepaths.GetPython();
                info.Arguments = "\"" + CsDownloadVidFilepaths.GetYtdlPath(
                    this.cbUsePytube.Checked) + "\" " + sArgs;
            }

            return info;
        }

        private void btnGetUpdates_Click(object sender, EventArgs e)
        {
            RunToolHelper.RunAndCatch(() =>
            {
                _runner.RunInThread(() =>
                {
                    GetUpdatesImpl();
                },
                "Getting new youtube-dl...");
            });
        }

        private void GetUpdatesImpl()
        {
            _runner.Trace("Getting new youtube-dl...");
            if (cbUsePytube.Checked)
            {
                new DownloadLatestPytube().Go(_runner);
            }
            else
            {
                new DownloadLatestYtdl().Go(_runner);
            }

            _runner.Trace("Done getting new youtube-dl.");
        }

        private void btnNextStepIsToChooseOutput_Click(object sender, EventArgs e)
        {
            panelChooseOutput.Visible = true;
            txtStatus.Visible = true;
        }

        private static void GetPlaylistImpl(string url, string txtpath, RunToolHelper runner)
        {
            bool isPytube = false; // use only ytdl, not pytube
            var args = new List<string>();
            args.Add("--ignore-config"); // don't look for global config file
            args.Add("--no-mark-watched");
            args.Add("--no-call-home");
            args.Add("-j"); // send output in json format
            args.Add("--flat-playlist");
            args.Add("-i"); // continue after errs
            args.Add(url);

            var info = new ProcessStartInfo();
            info.FileName = CsDownloadVidFilepaths.GetYtdlPath(isPytube);
            info.Arguments = Utils.CombineProcessArguments(args.ToArray());
            info.CreateNoWindow = true;
            info.RedirectStandardError = true;
            info.RedirectStandardOutput = true;
            info.UseShellExecute = false;

            if (CsDownloadVidFilepaths.GetYtdlPath(isPytube).EndsWith(".py"))
            {
                info.FileName = CsDownloadVidFilepaths.GetPython();
                info.Arguments = "\"" + CsDownloadVidFilepaths.GetYtdlPath(isPytube) + "\" " +
                    Utils.CombineProcessArguments(args.ToArray());
            }

            var stdoutGot = "";
            Process p = new Process();
            p.StartInfo = info;
            p.Start();
            p.OutputDataReceived += (o, eparam) => { stdoutGot += eparam.Data; };
            p.BeginOutputReadLine();
            p.WaitForExit();

            if (p.ExitCode != 0)
            {
                throw new CsDownloadVidException("error - non-zero exit code of " + p.ExitCode);
            }

            stdoutGot = stdoutGot.Trim();
            if (!stdoutGot.StartsWith("{"))
            {
                throw new CsDownloadVidException("error - did not get valid json back " +
                    stdoutGot);
            }

            GetPlaylistImplFromJson(runner, url, stdoutGot, txtpath);
        }

        private static void GetPlaylistImplFromJson(RunToolHelper runner, string url,
            string json, string txtPath)
        {
            // we could also use JsonReaderWriterFactory instead
            runner.Trace("process returned successfully. parsing json...");
            var parts = new List<string>(Utils.SplitByString(json, "\"id\": \""));
            parts.RemoveAt(0);
            var linesOut = new List<string>();
            foreach (var part in parts)
            {
                var proposedId = Utils.SplitByString(part, "\"")[0];
                if (proposedId.Length >= 10 && proposedId.Length <= 12 &&
                    !proposedId.Contains(" "))
                {
                    linesOut.Add("https://www.youtube.com/watch?v=" + proposedId);
                    runner.Trace("Found " + "https://www.youtube.com/watch?v=" + proposedId);
                }
            }

            if (linesOut.Count == 0)
            {
                throw new CsDownloadVidException("did not find any videos in this playlist.");
            }

            runner.Trace("Successfully found " + linesOut.Count + " ids.");
            File.WriteAllLines(txtPath, linesOut);
        }

        private void btnGetPlaylist_Click(object sender, EventArgs e)
        {
            var url = txtUrl.Text;
            if (string.IsNullOrWhiteSpace(url))
            {
                MessageBox.Show("no url entered. please enter one of the url with a " +
                    "playlist in the box for 'step 1'.");
                return;
            }
            else if (!Utils.AskToConfirm("Get playlist for " + url + "?"))
            {
                return;
            }

            var txtPath = Utils.AskSaveFileDialog("Save playlist video ids to what text file?",
                new string[] { ".txt" }, new string[] { "Text file" });

            if (string.IsNullOrEmpty(txtPath))
            {
                return;
            }

            RunToolHelper.RunAndCatch(() =>
            {
                _runner.RunInThread(() =>
                {
                    GetPlaylistStart(url, txtPath);
                },
                "Getting playlist...");
            });
        }

        private void GetPlaylistStart(string url, string txtPath)
        {
            _runner.Trace("Getting playlist...");
            _runner.Trace("url=" + url);
            GetPlaylistImpl(url, txtPath, _runner);

            this.Invoke(new Action(() =>
            {
                _runner.Trace("Done getting playlist.");
                MessageBox.Show("We saved the video ids in the playlist to " +
                    txtPath + ". You can now put this path in instead of a URL " +
                    "and hit download.");
                txtUrl.Text = txtPath;
            }));
        }

        private void btnDownloadFromWeb_Click(object sender, EventArgs e)
        {
            MessageBox.Show("Go to the Chrome Inspector, go to the Network tab, " +
                "and refresh the page. Look for a .mp4, .m3u, or .m3u8 url.");
            var url = InputBoxForm.GetStrInput("Enter the url that was seen,");
            if (!String.IsNullOrEmpty(url))
            {
                RunToolHelper.RunAndCatch(() =>
                {
                    downloadFromWeb(url);
                });
            }
        }

        private void downloadFromWeb(string url)
        {
            lblShortStatus.Visible = true;
            txtStatus.Visible = true;
            var urlBeforeParam = Utils.SplitByString(url, "?")[0];
            if (urlBeforeParam.EndsWith(".m3u") || urlBeforeParam.EndsWith(".m3u8"))
            {
                var ext = Utils.AskToConfirm(
                    "Use mp4 (default) or .mkv (more resilient)?") ? ".mp4" : ".mkv";
                var nameShort = Path.GetFileName(urlBeforeParam);
                var destName = Path.Combine(txtOutputDir.Text,
                    Path.GetFileNameWithoutExtension(nameShort) + ext);
                MessageBox.Show("Downloading video (via m3u) to " + destName + "...");
                Utils.AssertTrue(!File.Exists(destName), "File already exists here.");
                var args = new List<string>() { "-i", url, "-c", "copy" };
                if (ext == ".mp4")
                {
                    args.Add("-bsf:a");
                    args.Add("aac_adtstoasc");
                }

                args.Add(destName);
                var info = new ProcessStartInfo();
                info.FileName = CsDownloadVidFilepaths.GetFfmpeg();
                info.Arguments = Utils.CombineProcessArguments(args.ToArray());
                info.CreateNoWindow = true;
                info.RedirectStandardError = true;
                info.RedirectStandardOutput = true;
                info.UseShellExecute = false;
                _runner.RunInThread(() =>
                {
                    _runner.Trace("Downloading...");
                    _runner.RunProcessSync(info, "Download from web");
                    _runner.Trace("Download complete, to " + destName);
                });
            }
            else
            {
                var destName = Path.Combine(txtOutputDir.Text,
                    Path.GetFileName(urlBeforeParam));
                MessageBox.Show("Downloading video to " + destName + "...");
                Utils.AssertTrue(!File.Exists(destName), "File already exists here.");
                _runner.RunInThread(() =>
                {
                    _runner.Trace("Downloading...");
                    DownloadLatestPyScriptBase.DownloadFile(url, destName);
                    _runner.Trace("Download complete, to " + destName);
                });
            }
        }

        void FormGetVideo_Load(object sender, EventArgs e)
        {
            // Run this here, ahead of time, since we're on main thread and can safely open a dialog
            Utils.GetSoftDeleteDestination("(example)");
        }
    }

    public class ListBoxItemFormat : IComparable<ListBoxItemFormat>
    {
        // -1 for generic like 'best', 'worst'
        public int _formatNumber = -1;
        public string _displayText;

        public int CompareTo(ListBoxItemFormat other)
        {
            return _displayText.CompareTo(other._displayText);
        }

        public override string ToString()
        {
            if (_formatNumber == -1)
                return _displayText;

            return _displayText.Insert(_displayText.IndexOf(", ") + 2, "(" +
                _formatNumber.ToString() + ") ");
        }
    }
}
