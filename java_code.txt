import org.nfunk.jep.*;

/**
 * An example class to test custom functions with JEP.
 */
class CustFunc {
	
	/**
	 * Constructor.
	 */
	public CustFunc() {

	}

	/**
	 * Main method. Create a new JEP object and parse an example expression
	 * that uses the SquareRoot function.
	 */
	public static void main(String args[]) {
		
		JEP parser = new JEP();        // Create a new parser
		String expr = "1 + half(2)";
		double value;
		
		System.out.println("Starting CustFunc...");
		parser.addStandardFunctions();
		parser.addStandardConstants();
		parser.addFunction("half", new Half()); // Add the custom function
		
		parser.parseExpression(expr);                 // Parse the expression
		if (parser.hasError()) {
			System.out.println("Error while parsing");
			System.out.println(parser.getErrorInfo());
			return;
		}
		
		value = parser.getValue();                    // Get the value
		if (parser.hasError()) {
			System.out.println("Error during evaluation");
			System.out.println(parser.getErrorInfo());
			return;
		}
		
		System.out.println(expr + " = " + value); // Print value
	}
}
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * An example custom function class for JEP.
 */
class Half extends PostfixMathCommand {

	/**
	 * Constructor
	 */
	public Half() {
		numberOfParameters = 1;
	}
	
	/**
	 * Runs the square root operation on the inStack. The parameter is popped
	 * off the <code>inStack</code>, and the square root of it's value is 
	 * pushed back to the top of <code>inStack</code>.
	 */
	public void run(Stack inStack) throws ParseException {

		// check the stack
		checkStack(inStack);

		// get the parameter from the stack
		Object param = inStack.pop();

		// check whether the argument is of the right type
		if (param instanceof Double) {
			// calculate the result
			double r = ((Double)param).doubleValue() / 2;
			// push the result on the inStack
			inStack.push(new Double(r));
		} else {
			throw new ParseException("Invalid parameter type");
		}
	}
}
package org.lsmp.djepJUnit;

import junit.framework.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.mrpe.MRpCommandList;
import org.lsmp.djep.mrpe.MRpEval;
import org.lsmp.djep.mrpe.MRpRes;
import org.lsmp.djep.vectorJep.values.*;

/* @author rich
 * Created on 19-Nov-2003
 */

/**
 * JUnit test for full Matrix Rp evaluator
 * 
 * @author Rich Morris
 * Created on 19-Nov-2003
 */
public class MRpTest extends TestCase {
	MatrixJep mj;
	MRpEval mrpe;
	public static final boolean SHOW_BAD=false;
	
	public MRpTest(String name) {
		super(name);
	}

	public static Test suite() {
		return new TestSuite(MRpTest.class);
	}

	public static void main(String args[]) {
		// Create an instance of this class and analyse the file

		TestSuite suite= new TestSuite(MRpTest.class);
//		DJepTest jt = new DJepTest("DJepTest");
//		jt.setUp();
		suite.run(new TestResult());
	}	
	/** strings for each variable */
	String matStrs[][] = new String[10][10];
	String matStrsB[][] = new String[10][10];
	String vecStrs[] = new String[10];

	protected void setUp() {
		mj = new MatrixJep();
		mj.addStandardConstants();
		mj.addStandardFunctions();
		mj.addComplex();
		//j.setTraverse(true);
		mj.setAllowAssignment(true);
		mj.setAllowUndeclared(true);
		mj.setImplicitMul(true);
		mj.addStandardDiffRules();
		mrpe = new MRpEval(mj);
		for(int i=2;i<=9;++i)
			for(int j=2;j<=9;++j)
			{
				int num=1;
				StringBuffer sb = new StringBuffer("[");
				for(int k=0;k<i;++k)
				{
						if(k>0)sb.append(",");
						sb.append("[");
						for(int l=0;l<j;++l)
						{
							if(l>0)sb.append(",");
							sb.append(String.valueOf(num++));
						}
						sb.append("]");
				}
				sb.append("]");
				matStrs[i][j] = sb.toString();
			}

		for(int i=2;i<=9;++i)
			for(int j=2;j<=9;++j)
			{
				int num=20;
				StringBuffer sb = new StringBuffer("[");
				for(int k=0;k<i;++k)
				{
						if(k>0)sb.append(",");
						sb.append("[");
						for(int l=0;l<j;++l)
						{
							if(l>0)sb.append(",");
							sb.append(String.valueOf(num++));
						}
						sb.append("]");
				}
				sb.append("]");
				matStrsB[i][j] = sb.toString();
			}

		for(int i=2;i<=9;++i)
			{
				int num=1;
				StringBuffer sb = new StringBuffer("[");
				for(int k=0;k<i;++k)
				{
						if(k>0)sb.append(",");
						sb.append(String.valueOf(num++));
				}
				sb.append("]");
				vecStrs[i] = sb.toString();
			}
	}

	public void testGood()
	{
		assertEquals(1,1);
	}

	public void myAssertEquals(String msg,String actual,String expected)
	{
		if(!actual.equals(expected))
			System.out.println("Error \""+msg+"\" is \n<"+actual+"> should be \n<"+expected+">");
		assertEquals("<"+msg+">",expected,actual);
		System.out.println("Success: Value of <"+msg+"> is <"+actual+">");
	}

	public void valueTest(String expr,Object expected) throws ParseException
	{
		Object res = calcValue(expr);
		if(mj.hasError())
			fail("Evaluation Failure: "+expr+mj.getErrorInfo());
		assertEquals("<"+expr+">",expected,res);
		System.out.println("Success value of <"+expr+"> is "+res);
	}

	public void valueTest(String expr,String expected) throws ParseException
	{
		Object res = calcValue(expr);
		if(mj.hasError())
			fail("Evaluation Failure: "+expr+mj.getErrorInfo());
		assertEquals("<"+expr+">",expected,res.toString());
		System.out.println("Success value of <"+expr+"> is "+res.toString());
	}

	public void complexValueTest(String expr,Complex expected,double tol) throws Exception
	{
		Node node = mj.preprocess(mj.parse(expr));
		Object res = mj.evaluate(node);
		assertTrue("<"+expr+"> expected: <"+expected+"> but was <"+res+">",
			expected.equals((Complex) res,tol));
		System.out.println("Sucess value of <"+expr+"> is "+res);
	}

	public Object calcValue(String expr) throws ParseException
	{
		Node node = mj.parse(expr);
		Node matEqn = mj.preprocess(node);
		MRpCommandList list = mrpe.compile(matEqn);
		MRpRes res = mrpe.evaluate(list);
		return res;
	}

	public void simplifyTest(String expr,String expected) throws ParseException
	{
		Node node = mj.parse(expr);
		Node matEqn = mj.preprocess(node);
		Node simp = mj.simplify(matEqn);
		String res = mj.toString(simp);
		
		Node node2 = mj.parse(expected);
		Node matEqn2 = mj.preprocess(node2);
		Node simp2 = mj.simplify(matEqn2);
		String res2 = mj.toString(simp2);


		if(!res2.equals(res))		
			System.out.println("Error: Value of \""+expr+"\" is \""+res+"\" should be \""+res2+"\"");
		assertEquals("<"+expr+">",res2,res);
		System.out.println("Sucess: Value of \""+expr+"\" is \""+res+"\"");
			
//		System.out.print("Full Brackets:\t");
//		j.pv.setFullBrackets(true);
//		j.pv.println(simp);
//		j.pv.setFullBrackets(false);

	}

	public void simplifyTestString(String expr,String expected) throws ParseException
	{
		Node node = mj.parse(expr);
		Node matEqn = mj.preprocess(node);
		String res = mj.toString(matEqn);
		
		if(!expected.equals(res))		
			System.out.println("Error: Value of \""+expr+"\" is \""+res+"\" should be \""+expected+"\"");
		assertEquals("<"+expr+">",expected,res);
		System.out.println("Sucess: Value of \""+expr+"\" is \""+res+"\"");
			
//		System.out.print("Full Brackets:\t");
//		j.pv.setFullBrackets(true);
//		j.pv.println(simp);
//		j.pv.setFullBrackets(false);

	}

	void rpTest(String eqns[], String eqn2) throws ParseException
	{
		for(int i=0;i<eqns.length;++i)	{
			System.out.println("eqns "+eqns[i]);
			Node node = mj.simplify(mj.preprocess(mj.parse(eqns[i])));
			mj.evaluate(node);
		}
		Node node3 = mj.simplify(mj.preprocess(mj.parse(eqn2)));
		MRpEval rpe = new MRpEval(mj);
		MRpCommandList list = rpe.compile(node3);
		MRpRes rpRes = rpe.evaluate(list);
		MatrixValueI mat = rpRes.toVecMat();

		Object matRes = mj.evaluateRaw(node3);
//		System.out.println("rpRes: "+rpRes.getClass().getName()+" = "+rpRes.toString());
		if(mj.hasError())
			fail("Evaluation Failure: "+eqn2+mj.getErrorInfo());
		myAssertEquals("<"+eqn2+">",rpRes.toString(),matRes.toString());

		if(!mat.equals(matRes))
			fail("Expected <"+matRes+"> found <"+mat+">");

		if(rpRes.getDims().is1D())
		{
			double vecArray[] = (double []) rpRes.toArray();
			for(int i=0;i<vecArray.length;++i)
				if(vecArray[i] != ((Double) ((MVector) matRes).getEle(i)).doubleValue())
					fail("Problem with toArray");
		}
		else if(rpRes.getDims().is2D())
		{
			double matArray[][] = (double [][]) rpRes.toArray();
			for(int i=0;i<matArray.length;++i)
				for(int j=0;j<matArray[i].length;++j)
				if(matArray[i][j] != ((Double) ((Matrix) matRes).getEle(i,j)).doubleValue())
					fail("Problem with toArray");
		}
		rpe.cleanUp();
	}

	/** As before but don't test with MatrixJep.evaluate */
	void rpTest2(String eqns[]) throws ParseException
	{
		Node nodes[] = new Node[eqns.length];
		MatrixValueI rpMats[] = new MatrixValueI[eqns.length];
		MRpEval rpe = new MRpEval(mj);
		for(int i=0;i<eqns.length;++i)	{
			System.out.println("eqns "+eqns[i]);
			nodes[i] = mj.simplify(mj.preprocess(mj.parse(eqns[i])));
			MRpCommandList list = rpe.compile(nodes[i]);
			MRpRes rpRes = rpe.evaluate(list);
			rpMats[i] = rpRes.toVecMat();
			System.out.println("<"+eqns[i]+"> "+rpRes.toString());
		}
		for(int i=0;i<eqns.length;++i)	{
			Object matRes = mj.evaluateRaw(nodes[i]);
			if(!rpMats[i].equals(matRes))
					fail("Expected <"+matRes+"> found <"+rpMats[i]+">");
		}		
		rpe.cleanUp();
	}

	public void testRp() throws ParseException
	{
		rpTest(new String[]{"y=[[1,2,3],[4,5,6],[7,8,9]]"},"y*y");
		rpTest(new String[]{"y=[[1,2,3],[4,5,6],[7,8,9]]"},"y+y");
		rpTest(new String[]{"y=[[1,2,3],[4,5,6],[7,8,9]]"},"y-y");
		rpTest(new String[]{"y=[[1,2,3],[4,5,6],[7,8,9]]"},"y*y+y");
		rpTest(new String[]{"x=[1,2,3]","y=[[1,2,3],[4,5,6],[7,8,9]]"},"x*y");
		rpTest(new String[]{"x=[1,2,3]","y=[[1,2,3],[4,5,6],[7,8,9]]"},"y*x");
		rpTest(new String[0],"[[1,2,3],[4,5,6],[7,8,9]]*[[1,2,3],[4,5,6],[7,8,9]]");

		rpTest(new String[]{"y=[1,2]"},"y+y");
		rpTest(new String[]{"y=[1,2,3]"},"y+y");
		rpTest(new String[]{"y=[1,2,3,4]"},"y+y");
		rpTest(new String[]{"y=[1,2]"},"-y");
		rpTest(new String[]{"y=[1,2,3]"},"-y");
		rpTest(new String[]{"y=[1,2,3,4]"},"-y");
		rpTest(new String[]{"y=[1,2]"},"y-y");
		rpTest(new String[]{"y=[1,2,3]"},"y-y");
		rpTest(new String[]{"y=[1,2,3,4]"},"y-y");
		rpTest(new String[]{"y=[1,2]"},"y*3");
		rpTest(new String[]{"y=[1,2,3]"},"y*3");
		rpTest(new String[]{"y=[1,2,3,4]"},"y*3");
		rpTest(new String[]{"y=[1,2]"},"5*y");
		rpTest(new String[]{"y=[1,2,3]"},"5*y");
		rpTest(new String[]{"y=[1,2,3,4]"},"5*y");

		rpTest(new String[]{"y=[1,2,3]"},"y . y");
		rpTest(new String[]{"y=[1,2,3]"},"y^^y");

		rpTest(new String[]{"y=[[1,2],[3,4]]"},"y*y");
		rpTest(new String[]{"y=[[1,2],[3,4]]"},"y+y");
		rpTest(new String[]{"y=[[1,2],[3,4]]"},"y-y");
		rpTest(new String[]{"y=[[1,2],[3,4]]"},"y*y+y");
		rpTest(new String[]{"x=[1,2]","y=[[1,2],[3,4]]"},"x*y");
		rpTest(new String[]{"x=[1,2]","y=[[1,2],[3,4]]"},"y*x");
		rpTest(new String[0],"1*2*3+4*5*6+7*8*9");
		
		rpTest(new String[]{"x1=1","x2=2","x3=3","x4=4","x5=5","x6=6","x7=7","x8=8","x9=9"},
			"x1*x2*x3+x4*x5*x6+x7*x8*x9");

	}

	public void testRpAllDim() throws ParseException
	{
		
		for(int i=2;i<=4;++i)
			for(int j=2;j<=4;++j)
			{
				int num=1;
				StringBuffer sb = new StringBuffer("x=[");
				for(int k=0;k<i;++k)
				{
						if(k>0)sb.append(",");
						sb.append("[");
						for(int l=0;l<j;++l)
						{
							if(l>0)sb.append(",");
							sb.append(String.valueOf(num++));
						}
						sb.append("]");
				}
				sb.append("]");
				String varStr = sb.toString();
				rpTest(new String[]{varStr},"x+x");
				rpTest(new String[]{varStr},"x-x");

				rpTest(new String[]{varStr},"3*x");
				rpTest(new String[]{varStr},"x*5");
				rpTest(new String[]{varStr},"-x");
			}
	}


	public void testMul() throws ParseException
	{
		rpTest(new String[]{"x=[1,2]","y="+matStrs[2][2]},"x*y");
		rpTest(new String[]{"x=[1,2]","y="+matStrs[2][3]},"x*y");
		rpTest(new String[]{"x=[1,2]","y="+matStrs[2][4]},"x*y");

		rpTest(new String[]{"x=[1,2,3]","y="+matStrs[3][2]},"x*y");
		rpTest(new String[]{"x=[1,2,3]","y="+matStrs[3][3]},"x*y");
		rpTest(new String[]{"x=[1,2,3]","y="+matStrs[3][4]},"x*y");

		rpTest(new String[]{"x=[1,2,3,4]","y="+matStrs[4][2]},"x*y");
		rpTest(new String[]{"x=[1,2,3,4]","y="+matStrs[4][3]},"x*y");
		rpTest(new String[]{"x=[1,2,3,4]","y="+matStrs[4][4]},"x*y");

		rpTest(new String[]{"x=[1,2]","y="+matStrs[2][2]},"y*x");
		rpTest(new String[]{"x=[1,2]","y="+matStrs[3][2]},"y*x");
		rpTest(new String[]{"x=[1,2]","y="+matStrs[4][2]},"y*x");

		rpTest(new String[]{"x=[1,2,3]","y="+matStrs[2][3]},"y*x");
		rpTest(new String[]{"x=[1,2,3]","y="+matStrs[3][3]},"y*x");
		rpTest(new String[]{"x=[1,2,3]","y="+matStrs[4][3]},"y*x");

		rpTest(new String[]{"x=[1,2,3,4]","y="+matStrs[2][4]},"y*x");
		rpTest(new String[]{"x=[1,2,3,4]","y="+matStrs[3][4]},"y*x");
		rpTest(new String[]{"x=[1,2,3,4]","y="+matStrs[4][4]},"y*x");

		rpTest(new String[]{"x="+matStrs[2][2],"y="+matStrs[2][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[2][2],"y="+matStrsB[2][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[2][2],"y="+matStrs[2][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[2][2],"y="+matStrs[2][4]},"x*y");

		rpTest(new String[]{"x="+matStrs[2][3],"y="+matStrs[3][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[2][3],"y="+matStrs[3][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[2][3],"y="+matStrs[3][4]},"x*y");

		rpTest(new String[]{"x="+matStrs[2][4],"y="+matStrs[4][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[2][4],"y="+matStrs[4][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[2][4],"y="+matStrs[4][4]},"x*y");
		//
		rpTest(new String[]{"x="+matStrs[3][2],"y="+matStrs[2][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[3][2],"y="+matStrs[2][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[3][2],"y="+matStrs[2][4]},"x*y");

		rpTest(new String[]{"x="+matStrs[3][3],"y="+matStrs[3][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[3][3],"y="+matStrs[3][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[3][3],"y="+matStrsB[3][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[3][3],"y="+matStrs[3][4]},"x*y");

		rpTest(new String[]{"x="+matStrs[3][4],"y="+matStrs[4][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[3][4],"y="+matStrs[4][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[3][4],"y="+matStrs[4][4]},"x*y");
		//
		rpTest(new String[]{"x="+matStrs[4][2],"y="+matStrs[2][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[4][2],"y="+matStrs[2][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[4][2],"y="+matStrs[2][4]},"x*y");

		rpTest(new String[]{"x="+matStrs[4][3],"y="+matStrs[3][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[4][3],"y="+matStrs[3][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[4][3],"y="+matStrs[3][4]},"x*y");

		rpTest(new String[]{"x="+matStrs[4][4],"y="+matStrs[4][2]},"x*y");
		rpTest(new String[]{"x="+matStrs[4][4],"y="+matStrs[4][3]},"x*y");
		rpTest(new String[]{"x="+matStrs[4][4],"y="+matStrs[4][4]},"x*y");
		rpTest(new String[]{"x="+matStrs[4][4],"y="+matStrsB[4][4]},"x*y");

		rpTest(new String[]{"x=[1,2]","y=[1,2]"},"x*y");
		rpTest(new String[]{"x=[1,0]","y=[1,2]"},"x*y");
		rpTest(new String[]{"x=[1,2]","y=[1,0]"},"x*y");
		rpTest(new String[]{"x=[1,2,3]","y=[1,2,3]"},"x*y");
		rpTest(new String[]{"x=[1,0,0]","y=[1,2,3]"},"x*y");
		rpTest(new String[]{"x=[1,2,3]","y=[1,0,0]"},"x*y");
		rpTest(new String[]{"x=[1,2,3,4]","y=[1,2,3,4]"},"x*y");
		rpTest(new String[]{"x=[1,0,0,0]","y=[1,2,3,4]"},"x*y");
		rpTest(new String[]{"x=[1,2,3,4]","y=[1,0,0,0]"},"x*y");
		rpTest(new String[]{"x=[1,2,3,4,5]","y=[1,2,3,4,5]"},"x*y");
		rpTest(new String[]{"x=[1,0,0,0,0]","y=[1,2,3,4,5]"},"x*y");
		rpTest(new String[]{"x=[1,2,3,4,5]","y=[1,0,0,0,0]"},"x*y");

	}
	
	public void testAssign() throws ParseException
	{
		rpTest2(new String[]{"x=[[5,6],[7,8]]","x+x"});
		rpTest2(new String[]{"x=[5,6]","x+x"});
		rpTest2(new String[]{"x=[5,6,7]","x+x"});
		rpTest2(new String[]{"x=[5,6,7,8]","x+x"});
		rpTest2(new String[]{"x=5","x+x"});

		for(int i=2;i<=4;++i)
			for(int j=2;j<=4;++j)
			{
				rpTest2(new String[]{"x="+matStrs[i][j],"x+x"});
			}
	}
	
	public void testLogical() throws ParseException
	{
		rpTest2(new String[]{"1&&1","1&&0","0&&0","0&&1","3.14&&1"});
		rpTest2(new String[]{"1||1","1||0","0||0","0||1","3.14||0"});
		rpTest2(new String[]{"!0","!1","!3.14","!-3.14"});
		
		rpTest2(new String[]{"1>1","1>0","0>0","0>1","3.14>1"});
		rpTest2(new String[]{"1<1","1<0","0<0","0<1","3.14<1"});
		rpTest2(new String[]{"1>=1","1>=0","0>=0","0>=1","3.14>=1"});
		rpTest2(new String[]{"1<=1","1<=0","0<=0","0<=1","3.14<=1"});
		rpTest2(new String[]{"1==1","1==0","0==0","0==1","3.14==1"});
		rpTest2(new String[]{"1!=1","1!=0","0!=0","0!=1","3.14!=1"});

		rpTest2(new String[]{"[1,2]==[1,2]"});		
		rpTest2(new String[]{"[1,2]!=[1,2]"});		
		rpTest2(new String[]{"[1,2]==[5,6]"});		
		rpTest2(new String[]{"[1,2]!=[5,6]"});		

		rpTest2(new String[]{"[1,2,3]==[1,2,3]"});		
		rpTest2(new String[]{"[1,2,3]!=[1,2,3]"});		
		rpTest2(new String[]{"[1,2,3]==[5,6,7]"});		
		rpTest2(new String[]{"[1,2,3]!=[5,6,7]"});		
		rpTest2(new String[]{"[1,2,3]==[1,2,4]"});		
		rpTest2(new String[]{"[1,2,3]!=[1,2,4]"});		

		rpTest2(new String[]{"[1,2,3,4]==[1,2,3,4]"});		
		rpTest2(new String[]{"[1,2,3,4]!=[1,2,3,4]"});		
		rpTest2(new String[]{"[1,2,3,4]==[5,6,7,8]"});		
		rpTest2(new String[]{"[1,2,3,4]!=[5,6,7,8]"});	
		
		rpTest2(new String[]{matStrs[2][2]+"=="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"=="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"=="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"=="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"=="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"=="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"=="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"=="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"=="+matStrs[2][2]});	

		rpTest2(new String[]{matStrs[2][2]+"!="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"!="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"!="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"!="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"!="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"!="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"!="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"!="+matStrs[2][2]});	
		rpTest2(new String[]{matStrs[2][2]+"!="+matStrs[2][2]});	
	}
	boolean TESTALL = false;
	public void testVn() throws ParseException {
		rpTest2(new String[]{"x=[5,6,7,8,9]","x+x","x-x","2*x","x*3","x.x"});
		rpTest2(new String[]{"x=[[1,2,3,4,5],[5,6,7,8,9]]","x+x","x-x","2*x","x*3"});
		rpTest2(new String[]{"x=[[1,2],[3,4]]","y=[[1,2,3,4,5],[5,6,7,8,9]]","x*y"});
		rpTest2(new String[]{"x=[[1,2],[3,4]]","y=[[1,2],[3,4],[5,6],[7,8],[9,10]]","y*x"});
		rpTest2(new String[]{"x=[[1,2,3,4,5],[5,6,7,8,9]]","y=[[1,2],[3,4],[5,6],[7,8],[9,10]]","y*x"});

	  if(TESTALL)
	  {
	    for(int i=2;i<10;++i)
			for(int j=2;j<10;++j)
				for(int k=2;k<10;++k)
				{
					System.out.println("\n["+i+","+j+"]*["+j+","+k+"]");
					rpTest2(new String[]{"x="+matStrs[i][j],"y="+matStrsB[j][k],"x*y"});
				}

		for(int i=2;i<10;++i)
			for(int j=2;j<10;++j)
				{
					System.out.println("\n["+i+","+j+"]*["+j+"]");
					rpTest2(new String[]{"x="+matStrs[i][j],"y="+vecStrs[j],"x*y"});
				}

			for(int j=2;j<10;++j)
				for(int k=2;k<10;++k)
				{
					System.out.println("\n["+j+"]*["+j+","+k+"]");
					rpTest2(new String[]{"x="+vecStrs[j],"y="+matStrs[j][k],"x*y"});
				}
	  }
	}

	public void testFun() throws ParseException {
		rpTest2(new String[]{"x=5","y=4","x/y","x%y","x^y"});
		rpTest2(new String[]{"x=0.5","cos(x)","sin(x)","tan(x)","asin(x)","acos(x)","atan(x)"});
		rpTest2(new String[]{"x=0.5","cosh(x)","sinh(x)","tanh(x)","asinh(x)","acosh(x+1)","atanh(x)"});
		rpTest2(new String[]{"x=0.5","sqrt(x)","ln(x)","log(x)","exp(x)","abs(x)"});
		rpTest2(new String[]{"x=0.5","sec(x)","cosec(x)","cot(x)"});
		rpTest2(new String[]{"x=3","y=4","atan2(y,x)","if(x>y,1,2)","if(x<y,1,2)"} );
	}
	
	public void testUndecVar() throws ParseException {
		mj.setAllowUndeclared(true);
		MRpEval rpe = new MRpEval(mj);
		Node node1 = mj.parse("zap * gosh");
		Node node3 = mj.preprocess(node1);
		rpe.compile(node3);
	}

	/*	public void testSimpleSum() throws ParseException
	{
		valueTest("1+2",3);		
		valueTest("2*6+3",15);		
		valueTest("2*(6+3)",18);
	}
	
	public void testOperators()  throws ParseException
	{
//		if(!Operator.OP_MULTIPLY.isDistributiveOver(Operator.OP_ADD))
//			fail("* should be distrib over +");
//		if(Operator.OP_MULTIPLY.isDistributiveOver(Operator.OP_DIVIDE))
//			fail("* should not be distrib over /");
//		if(Operator.OP_MULTIPLY.getPrecedence() > Operator.OP_ADD.getPrecedence())
//			fail("* should have a lower precedence than +");

		valueTest("T=1",1);
		valueTest("F=0",0);
		calcValue("a=F"); calcValue("b=F"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=F"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=T"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=T"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);

		calcValue("a=T"); calcValue("b=F"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=F"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=T"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=T"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
	}
	
	public void testSimp() throws ParseException
	{
		simplifyTest("2+3","5");
		simplifyTest("2*3","6");
		simplifyTest("2^3","8");
		simplifyTest("3/2","1.5");
		simplifyTest("2*3+4","10");
		simplifyTest("2*(3+4)","14");

		simplifyTest("0+x","x");
		simplifyTest("x+0","x");
		simplifyTest("0-x","0-x");
		simplifyTest("x-0","x");
		simplifyTest("0*x","0");
		simplifyTest("x*0","0");
		simplifyTest("1*x","x");
		simplifyTest("x*1","x");
		simplifyTest("-1*x","-x");
		simplifyTest("x*-1","-x");
		simplifyTest("-(-x)","x");
		simplifyTest("-(-(-x))","-x");
		simplifyTest("(-1)*(-1)*x","x");
		simplifyTest("(-1)*(-1)*(-1)*x","-x");
		
		simplifyTest("0/x","0");
		simplifyTest("x/0","1/0");
		
		simplifyTest("x^0","1");
		simplifyTest("x^1","x");
		simplifyTest("0^x","0");
		simplifyTest("1^x","1");

		// (a+b)+c
		simplifyTest("(2+3)+x","5+x");
		simplifyTest("(2+x)+3","5+x");
		simplifyTest("(x+2)+3","5+x");
		// a+(b+c)
		simplifyTest("x+(2+3)","5+x");
		simplifyTest("2+(x+3)","5+x");
		simplifyTest("2+(3+x)","5+x");
		// (a+b)-c
		simplifyTest("(2+3)-x","5-x");
		simplifyTest("(2+x)-3","x-1");
		simplifyTest("(x+2)-3","x-1");
		// (a-b)+c
		simplifyTest("(2-3)+x","-1+x");
		simplifyTest("(2-x)+3","5-x");
		simplifyTest("(x-2)+3","1+x");
		// a-(b+c)
		simplifyTest("x-(2+3)","x-5");
		simplifyTest("2-(x+3)","-1-x");
		simplifyTest("2-(3+x)","-1-x");
		// a+(b-c)
		simplifyTest("x+(2-3)","x-1");
		simplifyTest("2+(x-3)","-1+x");
		simplifyTest("2+(3-x)","5-x");
		// a-(b-c)
		simplifyTest("x-(2-3)","1+x");
		simplifyTest("2-(x-3)","5-x");
		simplifyTest("2-(3-x)","-1+x");
		// (a-b)-c
		simplifyTest("(2-3)-x","-1-x");
		simplifyTest("(2-x)-3","-1-x");
		simplifyTest("(x-2)-3","x-5");

		// (a*b)*c
		simplifyTest("(2*3)*x","6*x");
		simplifyTest("(2*x)*3","6*x");
		simplifyTest("(x*2)*3","6*x");
		// a+(b+c)
		simplifyTest("x*(2*3)","6*x");
		simplifyTest("2*(x*3)","6*x");
		simplifyTest("2*(3*x)","6*x");
		// (a+b)-c
		simplifyTest("(2*3)/x","6/x");
		simplifyTest("(3*x)/2","1.5*x");
		simplifyTest("(x*3)/2","1.5*x");
		// (a-b)+c
		simplifyTest("(3/2)*x","1.5*x");
		simplifyTest("(3/x)*2","6/x");
		simplifyTest("(x/2)*3","1.5*x");
		// a-(b+c)
		simplifyTest("x/(2*3)","x/6");
		simplifyTest("3/(x*2)","1.5/x");
		simplifyTest("3/(2*x)","1.5/x");
		// a+(b-c)
		simplifyTest("x*(3/2)","1.5*x");
		simplifyTest("3*(x/2)","1.5*x");
		simplifyTest("3*(2/x)","6/x");
		// a-(b-c)
		simplifyTest("x/(3/2)","x/1.5");
		simplifyTest("2/(x/3)","6/x");
		simplifyTest("3/(2/x)","1.5*x");
		// (a-b)-c
		simplifyTest("(3/2)/x","1.5/x");
		simplifyTest("(3/x)/2","1.5/x");
		simplifyTest("(x/3)/2","x/6");


		simplifyTest("x*(3+2)","5*x");
		simplifyTest("3*(x+2)","6+3*x");
		simplifyTest("3*(2+x)","6+3*x");
		simplifyTest("(3+2)*x","5*x");
		simplifyTest("(3+x)*2","6+2*x");
		simplifyTest("(x+3)*2","6+x*2");

		simplifyTest("x*(3-2)","x");
		simplifyTest("3*(x-2)","-6+3*x");
		simplifyTest("3*(2-x)","6-3*x");
		simplifyTest("(3-2)*x","x");
		simplifyTest("(3-x)*2","6-2*x");
		simplifyTest("(x-3)*2","-6+2*x");

		simplifyTest("3+(x/4)","3+x/4");
		simplifyTest("2*(x/4)","0.5*x");
		simplifyTest("(2*(3+(x/4)))","6+0.5*x");
		simplifyTest("1+(2*(3+(x/4)))","7+0.5*x");
		simplifyTest("((3+(x/4))*2)+1","7+0.5*x");
		
	}

	public void testComplex() throws Exception
	{
		double tol = 0.00000001;

		complexValueTest("z=complex(3,2)",new Complex(3,2),tol);
		complexValueTest("z*z-z",new Complex(2,10),tol);
		complexValueTest("z^3",new Complex(-9,46),tol);
		complexValueTest("(z*z-z)/z",new Complex(2,2),tol);
		complexValueTest("w=polar(2,pi/2)",new Complex(0,2),tol);
		
	}

	public void testIf()  throws ParseException
	{
		valueTest("if(1,2,3)",2);		
		valueTest("if(-1,2,3)",3);		
		valueTest("if(0,2,3)",3);		
		valueTest("if(1,2,3,4)",2);		
		valueTest("if(-1,2,3,4)",3);		
		valueTest("if(0,2,3,4)",4);		
		valueTest("if(0>=0,2,3,4)",2);		
		valueTest("x=3",3);		
		valueTest("if(x==3,1,-1)",1);		
		valueTest("if(x!=3,1,-1)",-1);		
		valueTest("if(x>=3,1,-1)",1);		
		valueTest("if(x>3,1,-1)",-1);		
		valueTest("if(x<=3,1,-1)",1);		
		valueTest("if(x<3,1,-1)",-1);		
	}

	public void testAssign()  throws ParseException
	{
		valueTest("x=3",3);
		valueTest("y=3+4",7);
		valueTest("z=x+y",10);
		valueTest("a=b=c=z",10);
		valueTest("b",10);
		valueTest("d=f=a-b",0);
	}

						
	public void testDiff() throws ParseException
	{
		simplifyTest("diff(x^2,x)","2 x");
		simplifyTest("diff(x^3,x)","3 x^2");
		simplifyTest("diff(x,x)","1");
		simplifyTest("diff(1,x)","0");
		simplifyTest("diff(x^2+x+1,x)","2 x+1");
		simplifyTest("diff((x+x^2)*(x+x^3),x)","(1+2*x)*(x+x^3)+(x+x^2)*(1+3*x^2)");
		simplifyTest("diff((x+x^2)/(x+x^3),x)","((1+2*x)*(x+x^3)-(x+x^2)*(1+3*x^2))/((x+x^3)*(x+x^3))");
		simplifyTest("diff(sin(x),x)","cos(x)");
		simplifyTest("diff(-(x-5)^3,x)","-(3.0*(x-5.0)^2.0)");
		

		simplifyTest("diff((x+1)^2,x)","2+2*x");
		simplifyTest("diff((x+y)^2,x)","2*(x+y)");
		simplifyTest("diff((x+x^2)^3,x)","3*(x+x^2)^2*(1+2*x)");
		
		simplifyTest("diff(sin(x+1),x)","cos(x+1)");
		simplifyTest("diff(sin(x+x^2),x)","cos(x+x^2)*(1+2*x)");

		simplifyTest("diff(cos(x),x)","-sin(x)"); 	
		simplifyTest("diff(tan(x),x)","1/((cos(x))^2)");

		simplifyTest("diff(sec(x),x)","sec(x)*tan(x)");
		simplifyTest("diff(cosec(x),x)","-cosec(x) * cot(x)");
		simplifyTest("diff(cot(x),x)","-(cosec(x))^2");
		
		simplifyTest("diff(sec(x),x)","sec(x) * tan(x)");
		simplifyTest("diff(cosec(x),x)","-cosec(x) * cot(x)");
		simplifyTest("diff(cot(x),x)","-(cosec(x))^2");
			
		simplifyTest("diff(asin(x),x)","1/(sqrt(1-x^2))");
		simplifyTest("diff(acos(x),x)","-1/(sqrt(1-x^2))");
		simplifyTest("diff(atan(x),x)","1/(1+x^2)");

		simplifyTest("diff(sinh(x),x)","cosh(x)");
		simplifyTest("diff(cosh(x),x)","sinh(x)");
		simplifyTest("diff(tanh(x),x)","1-(tanh(x))^2");

		simplifyTest("diff(asinh(x),x)","1/(sqrt(1+x^2))");
		simplifyTest("diff(acosh(x),x)","1/(sqrt(x^2-1))");
		simplifyTest("diff(atanh(x),x)","1/(1-x^2)");

		simplifyTest("diff(sqrt(x),x)","1/(2 (sqrt(x)))");
		
		simplifyTest("diff(exp(x),x)","exp(x)");
//		simplifyTest("diff(pow(x,y),x)","y*(pow(x,y-1))");
//		simplifyTest("diff(pow(x,y),y)","(ln(x)) (pow(x,y))");
		simplifyTest("diff(ln(x),x)","1/x");
		simplifyTest("diff(log(x),x)","(1/ln(10)) /x");
		simplifyTest("diff(abs(x),x)","abs(x)/x");
		simplifyTest("diff(angle(x,y),x)","y/(x^2+y^2)");
		simplifyTest("diff(angle(x,y),y)","-x/(x^2+y^2)");
		simplifyTest("diff(mod(x,y),x)","1");
		simplifyTest("diff(mod(x,y),y)","0");
		simplifyTest("diff(sum(x,x^2,x^3),x)","sum(1,2 x,3 x^2)");

//		addDiffRule(new PassThroughDiffRule(this,"sum"));
//		addDiffRule(new PassThroughDiffRule(this,"re"));
//		addDiffRule(new PassThroughDiffRule(this,"im"));
//		addDiffRule(new PassThroughDiffRule(this,"rand"));
//		
//		MacroFunction complex = new MacroFunction("complex",2,"x+i*y",xjep);
//		xjep.addFunction("complex",complex);
//		addDiffRule(new MacroFunctionDiffRules(this,complex));
//		
//		addDiffRule(new PassThroughDiffRule(this,"\"<\"",new Comparative(0)));
//		addDiffRule(new PassThroughDiffRule(this,"\">\"",new Comparative(1)));
//		addDiffRule(new PassThroughDiffRule(this,"\"<=\"",new Comparative(2)));
//		addDiffRule(new PassThroughDiffRule(this,"\">=\"",new Comparative(3)));
//		addDiffRule(new PassThroughDiffRule(this,"\"!=\"",new Comparative(4)));
//		addDiffRule(new PassThroughDiffRule(this,"\"==\"",new Comparative(5)));
	}

	public void myAssertEquals(String msg,String actual,String expected)
	{
		if(!actual.equals(expected))
			System.out.println("Error \""+msg+"\" is \""+actual+" should be "+expected+"\"");
		assertEquals("<"+msg+">",expected,actual);
		System.out.println("Success: Value of \""+msg+"\" is \""+actual+"\"");
	}
	*/
	public void testAssignDiff() throws ParseException
	{
		//TODO Used to be an error but new procedure for working with derivs should add test
		//rpTest2(new String[]{"x=2","y=x^5","z=diff(y,x)"});
	}
	
/*
	public void testMatrix() throws ParseException
	{
		j.getSymbolTable().clearValues();
		valueTest("x=2",2);
		valueTest("y=[x^3,x^2,x]","[8.0,4.0,2.0]");
		valueTest("z=diff(y,x)","[12.0,4.0,1.0]");
		valueTest("3*y","[24.0,12.0,6.0]");
		valueTest("y*4","[32.0,16.0,8.0]");
		valueTest("y*z","[[96.0,32.0,8.0],[48.0,16.0,4.0],[24.0,8.0,2.0]]");
		valueTest("z*y","[[96.0,48.0,24.0],[32.0,16.0,8.0],[8.0,4.0,2.0]]");
		valueTest("w=y^z","[-4.0,16.0,-16.0]");
		simplifyTestString("diff(w,x)","[3.0*x^2.0,2.0*x,1.0]^z+y^[6.0*x,2.0,0.0]");
		simplifyTestString("diff(y . z,x)","[3.0*x^2.0,2.0*x,1.0].z+y.[6.0*x,2.0,0.0]");
		valueTest("w.y",0.0);
		valueTest("w.z",0.0);
		valueTest("sqrt(w . z)",0.0);
		valueTest("sqrt([3,4].[3,4])",5.0); // tests result is unwrapped from scaler
		valueTest("y+z","[20.0,8.0,3.0]");
		valueTest("y-z","[-4.0,0.0,1.0]");
		j.getSymbolTable().clearValues();
		// the following two tests insure that ^ is printed correctly
		simplifyTestString("y^z","y^z");
		simplifyTestString("[8.0,4.0,2.0]^[12.0,4.0,1.0]","[8.0,4.0,2.0]^[12.0,4.0,1.0]");
		simplifyTestString("y=[cos(x),sin(x)]","y=[cos(x),sin(x)]");
		simplifyTestString("z=diff(y,x)","z=[-sin(x),cos(x)]");
		valueTest("y.y",1.0);
		valueTest("y.z",0.0);
		valueTest("z.z",1.0);
		j.getSymbolTable().clearValues();
		valueTest("x=[[1,2],[3,4]]","[[1.0,2.0],[3.0,4.0]]");
		valueTest("y=[1,-1]","[1.0,-1.0]");
		valueTest("x*y","[-1.0,-1.0]");			
		valueTest("y*x","[-2.0,-2.0]");
		valueTest("x+[y,y]","[[2.0,1.0],[4.0,3.0]]");	
		valueTest("ele(y,1)","1.0");              // Value: 2.0
		valueTest("ele(y,2)","-1.0");              // Value: 2.0
		valueTest("ele(x,[1,1])","1.0");          // Value: 2.0
		valueTest("ele(x,[1,2])","2.0");          // Value: 2.0
		valueTest("ele(x,[2,1])","3.0");          // Value: 2.0
		valueTest("ele(x,[2,2])","4.0");          // Value: 2.0
	}
	public void testBad() throws ParseException
	{
		if(SHOW_BAD)
		{
			simplifyTest("1&&(1||x)","1");
			simplifyTest("diff(sgn(x),x)","0");	// sgn not implemented
			simplifyTest("diff(re(x+i y),x)","1"); // not smart enought to work out re(i) = 1
			simplifyTest("diff(re(x+i y),y)","0");
			simplifyTest("diff(im(x+i y),x)","0");
			simplifyTest("diff(im(x+i y),y)","1");
			simplifyTest("(x/2)*3","x*1.5");
		}
	}
	*/
}
/* @author rich
 * Created on 22-Apr-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepJUnit;

import org.lsmp.djep.vectorJep.VectorJep;
import org.nfunk.jep.ParseException;

import junit.framework.Test;
import junit.framework.TestResult;
import junit.framework.TestSuite;

/**
 * @author Rich Morris
 * Created on 22-Apr-2005
 */
public class VectorJepTest extends JepTest {

	/**
	 * @param name
	 */
	public VectorJepTest(String name) {
		super(name);
		// TODO Auto-generated constructor stub
	}

	/**
	 * Create a test suite.
	 * @return the TestSuite
	 */
	public static Test suite() {
		return new TestSuite(VectorJepTest.class);
	}

	/**
	 * Main entry point.
	 * @param args
	 */
	public static void main(String args[]) {
		// Create an instance of this class and analyse the file

		TestSuite suite= new TestSuite(VectorJepTest.class);
		suite.run(new TestResult());
	}	
	
	protected void setUp() {
		j = new VectorJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		//j.setTraverse(true);
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
	}

	public void testMatrix() throws Exception
	{
		System.out.println("\nTesting vector and matrix operations");
		j.getSymbolTable().clearValues();
		valueTest("x=2",2);
		valueTest("(x*x)*x*(x*x)",32.0);
		valueTest("y=[x^3,x^2,x]","[8.0,4.0,2.0]");
		valueTest("z=[3*x^2,2*x,1]","[12.0,4.0,1.0]");
		valueTest("w=y^^z","[-4.0,16.0,-16.0]");
		valueTest("w.y","0.0");
		valueTest("w.z","0.0");
		valueTest("sqrt(w . z)","0.0"); // tests result is unwrapped from scaler
		valueTest("sqrt([3,4] . [3,4])","5.0"); // tests result is unwrapped from scaler
		valueTest("y+z","[20.0,8.0,3.0]");
		valueTest("y-z","[-4.0,0.0,1.0]");
		valueTest("3*y","[24.0,12.0,6.0]");
		valueTest("y*4","[32.0,16.0,8.0]");
		valueTest("y*z","[[96.0,32.0,8.0],[48.0,16.0,4.0],[24.0,8.0,2.0]]");
		valueTest("z*y","[[96.0,48.0,24.0],[32.0,16.0,8.0],[8.0,4.0,2.0]]");
		j.getSymbolTable().clearValues();
		j.evaluate(j.parse("y=[cos(x),sin(x)]"));
		j.evaluate(j.parse("z=[-sin(x),cos(x)]"));
		valueTest("y . y","1.0");
		valueTest("y . z","0.0");
		valueTest("z . z","1.0");
		j.getSymbolTable().clearValues();
		valueTest("x=[[1,2],[3,4]]","[[1.0,2.0],[3.0,4.0]]");
		valueTest("y=[1,-1]","[1.0,-1.0]");
		valueTest("x*y","[-1.0,-1.0]");			
		valueTest("y*x","[-2.0,-2.0]");
		valueTest("x+[y,y]","[[2.0,1.0],[4.0,3.0]]");	
		valueTest("ele(y,1)","1.0");              // Value: 2.0
		valueTest("ele(y,2)","-1.0");              // Value: 2.0
		valueTest("ele(x,[1,1])","1.0");          // Value: 2.0
		valueTest("ele(x,[1,2])","2.0");          // Value: 2.0
		valueTest("ele(x,[2,1])","3.0");          // Value: 2.0
		valueTest("ele(x,[2,2])","4.0");          // Value: 2.0
	}

	public void testLength() throws ParseException,Exception
	{
		System.out.println("\nTesting vector and matrix functions");
		valueTest("len(5)","1");
		valueTest("len([1,2,3])","3");
		valueTest("len([[1,2,3],[4,5,6]])","6");
		valueTest("size(5)","1");
		valueTest("size([1,2,3])","3");
		valueTest("size([[1,2,3],[4,5,6]])","[2,3]");
		valueTest("size([[[1,2],[3,4],[5,6]],[[7,8],[9,10],[11,12]]])","[2,3,2]");

		valueTest("diag([1,2,3])","[[1.0,0.0,0.0],[0.0,2.0,0.0],[0.0,0.0,3.0]]");
		valueTest("id(3)","[[1.0,0.0,0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]");
		valueTest("getdiag([[1,2],[3,4]])","[1.0,4.0]");
		valueTest("trans([[1,2],[3,4]])","[[1.0,3.0],[2.0,4.0]]");
		valueTest("det([[1,2],[3,4]])","-2.0");
		valueTest("det([[1,2,3],[4,5,6],[9,8,9]])","-6.0");
		valueTest("det([[1,2,3],[4,5,6],[7,8,9]])","0.0");
		valueTest("det([[1,2,3,4],[5,6,77,8],[4,3,2,1],[17,9,23,19]])","9100.0");

		valueTest("trace([[1,2],[3,4]])","5.0");
		valueTest("trace([[1,2,3],[4,5,6],[7,8,9]])","15.0");
		valueTest("trace([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])","34.0");

		valueTest("vsum([[1,2],[3,4]])","10.0");
		valueTest("vsum([1,2,3])","6.0");
		
		valueTest("Map(x^3,x,[1,2,3])","[1.0,8.0,27.0]");
		valueTest("Map(x*y,[x,y],[1,2,3],[4,5,6])","[4.0,10.0,18.0]");
		valueTest("Map(if(x>0,x,0),x,[-2,-1,0,1,2])","[0.0,0.0,0.0,1.0,2.0]");
		valueTest("Map(abs(x),x,[[-2,-1],[1,2]])","[[2.0,1.0],[1.0,2.0]]");
	}

	public void testSumVector() throws Exception {
		
	}
	public void testVecCmp() throws Exception {
		valueTest("[1,2,3]==[1,2,3]",1);
		valueTest("[1,2,3]==[1,2,4]",0);
	}
	public void testDotInName() throws ParseException, Exception {
	}
	public void testGenMatEle() throws Exception
	{
	    System.out.println("The following caused a problem as ele only acepted Double arguments");
	    valueTest("m=[1,2,3]","[1.0,2.0,3.0]");
	    valueTest("GenMat(3,ele(m,n)*10,n)","[10.0,20.0,30.0]");
	}
	
	public void testArrayAccess() throws Exception {
	    System.out.println("\nTests array access on lhs and rhs using the a[3] notation");
		valueTest("a=[1,2,3]","[1.0,2.0,3.0]");
		valueTest("a[2]=4",4);
		valueTest("b=a[2]",4);
		valueTest("b",4);
		valueTest("c=[[1,2],[3,4]]","[[1.0,2.0],[3.0,4.0]]");
		valueTest("c[1,2]=5",5);
		valueTest("c","[[1.0,5.0],[3.0,4.0]]");
		valueTest("c[2,1]",3);
	}
	
	public void testElementOperations() throws Exception {
		((VectorJep) j).setElementMultiply(true);
		valueTest("[1,2,3] == [2,2,2]","[0.0,1.0,0.0]");
		valueTest("[1,2,3] != [2,2,2]","[1.0,0.0,1.0]");
		valueTest("[1,2,3] < [2,2,2]","[1.0,0.0,0.0]");
		valueTest("[1,2,3] <= [2,2,2]","[1.0,1.0,0.0]");
		valueTest("[1,2,3] > [2,2,2]","[0.0,0.0,1.0]");
		valueTest("[1,2,3] >= [2,2,2]","[0.0,1.0,1.0]");
		valueTest("[1,2,3] * [2,2,2]","[2.0,4.0,6.0]");
		valueTest("[1,2,3] / [2,2,2]","[0.5,1.0,1.5]");
	}
	
	public void testComplexMatricies() throws Exception {
		valueTest("v=[1+i,1-2i]","[(1.0, 1.0),(1.0, -2.0)]");
		valueTest("vsum(v)","(2.0, -1.0)");
		valueTest("m=[[1+i,-1+i],[1-i,-1-i]]","[[(1.0, 1.0),(-1.0, 1.0)],[(1.0, -1.0),(-1.0, -1.0)]]");
		valueTest("vsum(m)","(0.0, 0.0)");
		valueTest("trace(m)","(0.0, 0.0)");
		valueTest("m*v","[(1.0, 5.0),(-1.0, 1.0)]");
		valueTest("v*m","[(-1.0, -1.0),(-5.0, 1.0)]");
		valueTest("trans(m)","[[(1.0, 1.0),(1.0, -1.0)],[(-1.0, 1.0),(-1.0, -1.0)]]");
		valueTest("det(m)","(0.0, -4.0)");
	}
}
package org.lsmp.djepJUnit;

import junit.framework.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
import org.lsmp.djep.xjep.*;
import org.lsmp.djep.djep.*;
import java.text.NumberFormat;
import org.lsmp.djep.sjep.*;
/* @author rich
 * Created on 19-Nov-2003
 */

/**
 * @author Rich Morris
 * Created on 19-Nov-2003
 */
public class SJepTest extends TestCase {
	DJep j;
	PolynomialCreator pc;
	
	public static final boolean SHOW_BAD=false;
	
	public SJepTest(String name) {
		super(name);
	}

	public static void main(String args[]) {
		// Create an instance of this class and analyse the file

		TestSuite suite= new TestSuite(SJepTest.class);
//		DJepTest jt = new DJepTest("DJepTest");
//		jt.setUp();
		suite.run(new TestResult());
	}	

	protected void setUp() {
		j = new DJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		//j.setTraverse(true);
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.addStandardDiffRules();
		pc = new PolynomialCreator(j);
	}

	public static Test suite() {
		return new TestSuite(SJepTest.class);
	}

	public void myAssertEquals(String msg,String actual,String expected)
	{
		if(!actual.equals(expected))
			System.out.println("Error \""+msg+"\" is \""+actual+" should be "+expected+"\"");
		assertEquals("<"+msg+">",expected,actual);
		System.out.println("Success: Value of \""+msg+"\" is \""+actual+"\"");
	}
	
	public void assertPolynomialEquals(String s1,String s2) throws ParseException
	{
		Node n1= j.parse(s1);
		PNodeI p1 = pc.createPoly(n1);
		PNodeI e1 = p1.expand();
		Node n2 = j.parse(s2);
		PNodeI p2 = pc.createPoly(n2);
		PNodeI e2 = p2.expand();
		if(e1.equals(e2)){
			System.out.println("Sucess: \""+s1+"\" equals \""+s2+"\"");
		}else{
			System.out.println("Error: \""+s1+"\" is not equal to \""+s2+"\"");
			assertTrue("<"+s1+"> should be equal to <"+s2+"> it is not",false);
		}
	}
	/** just test JUnit working OK */
	public void testGood()
	{
		assertEquals(1,1);
	}

	public void valueTest(String expr,double dub) throws Exception
	{
		valueTest(expr,new Double(dub));
	}
	public void valueTest(String expr,Object expected) throws Exception
	{
		Node node = j.parse(expr);
		Node n2 = j.preprocess(node);
		Object res = j.evaluate(n2);
		assertEquals("<"+expr+">",expected,res);
		System.out.println("Success value of <"+expr+"> is "+res);
	}
	public void complexValueTest(String expr,Complex expected,double tol) throws Exception
	{
		Node node = j.parse(expr);
		Node n2 = j.preprocess(node);
		Object res = j.evaluate(n2);
		assertTrue("<"+expr+"> expected: <"+expected+"> but was <"+res+">",
			expected.equals((Complex) res,tol));
		System.out.println("Success value of <"+expr+"> is "+res);
	}

	public Object calcValue(String expr) throws ParseException
	{
		Node node = j.parse(expr);
		Node n2 = j.preprocess(node);
		Object res = j.evaluate(n2);
		return res;
	}
	
	public void simplifyTest(String expr,String expected) throws ParseException
	{
		Node node = j.parse(expr);
		Node processed = j.preprocess(node);
		PNodeI poly = pc.createPoly(processed);
		String res = poly.toString();
		
		Node node2 = j.parse(expected);
		Node processed2 = j.preprocess(node2);
		PNodeI poly2 = pc.createPoly(processed2);
		String res2 = poly2.toString();

		if(!res2.equals(res))		
			System.out.println("Error: Value of \""+expr+"\" is \""+res+"\" should be \""+res2+"\"");
		assertEquals("<"+expr+">",res2,res);
		System.out.println("Sucess: Value of \""+expr+"\" is \""+res+"\"");
			
//		System.out.print("Full Brackets:\t");
//		j.pv.setFullBrackets(true);
//		j.pv.println(simp);
//		j.pv.setFullBrackets(false);

	}

	public void simplifyTestString(String expr,String expected) throws ParseException
	{
		Node node = j.parse(expr);
		Node processed = j.preprocess(node);
		PNodeI poly = pc.createPoly(processed);
		String res = poly.toString();
		
		if(!expected.equals(res))		
			System.out.println("Error: Value of \""+expr+"\" is \""+res+"\" should be \""+expected+"\"");
		assertEquals("<"+expr+">",expected,res);
		System.out.println("Sucess: Value of \""+expr+"\" is \""+res+"\"");
			
//		System.out.print("Full Brackets:\t");
//		j.pv.setFullBrackets(true);
//		j.pv.println(simp);
//		j.pv.setFullBrackets(false);

	}

	public void expandTestString(String expr,String expected) throws ParseException
	{
		Node node = j.parse(expr);
		Node processed = j.preprocess(node);
		PNodeI poly = pc.createPoly(processed);
		PNodeI expand = poly.expand();
		String res = expand.toString();
		
		if(!expected.equals(res))		
			System.out.println("Error: Value of \""+expr+"\" is \""+res+"\" should be \""+expected+"\"");
		assertEquals("<"+expr+">",expected,res);
		System.out.println("Sucess: Value of \""+expr+"\" is \""+res+"\"");
			
//		System.out.print("Full Brackets:\t");
//		j.pv.setFullBrackets(true);
//		j.pv.println(simp);
//		j.pv.setFullBrackets(false);

	}
/*	
	public Node parseProcSimpEval(String expr,Object expected) throws ParseException,Exception
	{
		Node node = j.parse(expr);
		Node processed = j.preprocess(node);
		Node simp = j.simplify(processed);
		Object res = j.evaluate(simp);
		
		if(!expected.equals(res))		
			System.out.println("Error: Value of \""+expr+"\" is \""+res+"\" should be \""+expected+"\"");
		assertEquals("<"+expr+">",expected,res);
		System.out.println("Sucess: Value of \""+expr+"\" is \""+res+"\"");
		return simp;
	}
*/

	public void testSimpleSum() throws Exception
	{
		valueTest("1+2",3);		
		valueTest("2*6+3",15);		
		valueTest("2*(6+3)",18);
	}
	
	public void testOperators() throws Exception
	{
		OperatorSet opSet = j.getOperatorSet();
		if(!((XOperator) opSet.getMultiply()).isDistributiveOver(opSet.getAdd()))
			fail("* should be distrib over +");
		if(((XOperator) opSet.getMultiply()).isDistributiveOver(opSet.getDivide()))
			fail("* should not be distrib over /");
		if(((XOperator) opSet.getMultiply()).getPrecedence() > ((XOperator) opSet.getAdd()).getPrecedence())
			fail("* should have a lower precedence than +");

		valueTest("T=1",1);
		valueTest("F=0",0);
		calcValue("a=F"); calcValue("b=F"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=F"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=T"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=T"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);

		calcValue("a=T"); calcValue("b=F"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=F"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=T"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=T"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
	}
	
	public void testPrint() throws ParseException
	{
		simplifyTestString("(a+b)+c","a+b+c");
		simplifyTestString("(a-b)+c","a-b+c");
		simplifyTestString("(a+b)-c","a+b-c"); 
		simplifyTestString("(a-b)-c","a-b-c");

		simplifyTestString("a+(b+c)","a+b+c");
		simplifyTestString("a-(b+c)","a-b-c"); //
		simplifyTestString("a+(b-c)","a+b-c");   
		simplifyTestString("a-(b-c)","a-b+c");

		simplifyTestString("(a*b)*c","a*b*c");
		simplifyTestString("(a/b)*c","a*c/b");
		simplifyTestString("(a*b)/c","a*b/c"); 
		simplifyTestString("(a/b)/c","a/(b*c)");

		simplifyTestString("a*(b*c)","a*b*c");
		simplifyTestString("a/(b*c)","a/(b*c)");
		simplifyTestString("a*(b/c)","a*b/c");
		simplifyTestString("a/(b/c)","a*c/b");

		//simplifyTestString("a=(b=c)","a=b=c");
		//simplifyTestString("(a=b)=c","a/(b/c)");

		simplifyTestString("(a*b)+c","a*b+c");
		simplifyTestString("(a+b)*c","(a+b)*c");
		simplifyTestString("a*(b+c)","a*(b+c)"); 
		simplifyTestString("a+(b*c)","a+b*c");

//		simplifyTestString("(a||b)||c","a||b||c");
//		simplifyTestString("(a&&b)||c","a&&b||c");
//		simplifyTestString("(a||b)&&c","(a||b)&&c"); 
//		simplifyTestString("(a&&b)&&c","a&&b&&c");

//		simplifyTestString("a||(b||c)","a||b||c");
//		simplifyTestString("a&&(b||c)","a&&(b||c)");
//		simplifyTestString("a||(b&&c)","a||b&&c");   
//		simplifyTestString("a&&(b&&c)","a&&b&&c");
	}
	
	public void testSimp() throws ParseException
	{
		simplifyTest("2+3","5");
		simplifyTest("2*3","6");
		simplifyTest("2^3","8");
		simplifyTest("3/2","1.5");
		simplifyTest("2*3+4","10");
		simplifyTest("2*(3+4)","14");

		simplifyTest("0+x","x");
		simplifyTest("x+0","x");
		simplifyTest("0-x","0-x");
		simplifyTest("x-0","x");
		simplifyTest("0*x","0");
		simplifyTest("x*0","0");
		simplifyTest("1*x","x");
		simplifyTest("x*1","x");
		simplifyTest("-1*x","-x");
		simplifyTest("x*-1","-x");
		simplifyTest("-(-x)","x");
		simplifyTest("-(-(-x))","-x");
		simplifyTest("(-1)*(-1)*x","x");
		simplifyTest("(-1)*(-1)*(-1)*x","-x");
		
		simplifyTest("0/x","0");
		simplifyTest("x/0","1/0");
		
		simplifyTest("x^0","1");
		simplifyTest("x^1","x");
		simplifyTest("0^x","0");
		simplifyTest("1^x","1");

		// (a+b)+c
		simplifyTest("(2+3)+x","5+x");
		simplifyTest("(2+x)+3","5+x");
		simplifyTest("(x+2)+3","5+x");
		// a+(b+c)
		simplifyTest("x+(2+3)","5+x");
		simplifyTest("2+(x+3)","5+x");
		simplifyTest("2+(3+x)","5+x");
		// (a+b)-c
		simplifyTest("(2+3)-x","5-x");
		simplifyTest("(2+x)-3","x-1");
		simplifyTest("(x+2)-3","x-1");
		// (a-b)+c
		simplifyTest("(2-3)+x","-1+x");
		simplifyTest("(2-x)+3","5-x");
		simplifyTest("(x-2)+3","1+x");
		// a-(b+c)
		simplifyTest("x-(2+3)","x-5");
		simplifyTest("2-(x+3)","-1-x");
		simplifyTest("2-(3+x)","-1-x");
		// a+(b-c)
		simplifyTest("x+(2-3)","x-1");
		simplifyTest("2+(x-3)","-1+x");
		simplifyTest("2+(3-x)","5-x");
		// a-(b-c)
		simplifyTest("x-(2-3)","1+x");
		simplifyTest("2-(x-3)","5-x");
		simplifyTest("2-(3-x)","-1+x");
		// (a-b)-c
		simplifyTest("(2-3)-x","-1-x");
		simplifyTest("(2-x)-3","-1-x");
		simplifyTest("(x-2)-3","x-5");

		// (a*b)*c
		simplifyTest("(2*3)*x","6*x");
		simplifyTest("(2*x)*3","6*x");
		simplifyTest("(x*2)*3","6*x");
		// a+(b+c)
		simplifyTest("x*(2*3)","6*x");
		simplifyTest("2*(x*3)","6*x");
		simplifyTest("2*(3*x)","6*x");
		// (a+b)-c
		simplifyTest("(2*3)/x","6/x");
		simplifyTest("(3*x)/2","1.5*x");
		simplifyTest("(x*3)/2","1.5*x");
		// (a-b)+c
		simplifyTest("(3/2)*x","1.5*x");
		simplifyTest("(3/x)*2","6/x");
		simplifyTest("(x/2)*3","1.5*x");
		// a-(b+c)
		simplifyTest("x/(2*3)","x/6");
		simplifyTest("3/(x*2)","1.5/x");
		simplifyTest("3/(2*x)","1.5/x");
		// a+(b-c)
		simplifyTest("x*(3/2)","1.5*x");
		simplifyTest("3*(x/2)","1.5*x");
		simplifyTest("3*(2/x)","6/x");
		// a-(b-c)
		simplifyTest("x/(3/2)","x/1.5");
		simplifyTest("2/(x/3)","6/x");
		simplifyTest("3/(2/x)","1.5*x");
		// (a-b)-c
		simplifyTest("(3/2)/x","1.5/x");
		simplifyTest("(3/x)/2","1.5/x");
		simplifyTest("(x/3)/2","x/6");


		simplifyTest("x*(3+2)","5*x");
//		simplifyTest("3*(x+2)","6+3*x");
//		simplifyTest("3*(2+x)","6+3*x");
//		simplifyTest("(3+2)*x","5*x");
//		simplifyTest("(3+x)*2","6+2*x");
//		simplifyTest("(x+3)*2","6+x*2");

		simplifyTest("x*(3-2)","x");
//		simplifyTest("3*(x-2)","-6+3*x");
//		simplifyTest("3*(2-x)","6-3*x");
		simplifyTest("(3-2)*x","x");
//		simplifyTest("(3-x)*2","6-2*x");
//		simplifyTest("(x-3)*2","-6+2*x");

//		simplifyTest("3+(x/4)","3+x/4");
//		simplifyTest("2*(x/4)","0.5*x");
//		simplifyTest("(2*(3+(x/4)))","6+0.5*x");
//		simplifyTest("1+(2*(3+(x/4)))","7+0.5*x");
//		simplifyTest("((3+(x/4))*2)+1","7+0.5*x");

		simplifyTest("x*x","x^2");
		simplifyTest("x*x*x","x^3");
		simplifyTest("(x^3)*(x^4)","x^7");
		simplifyTest("(x^4)/(x^3)","x");
		simplifyTest("(x^3)/(x^4)","1/x");
		simplifyTest("(x^2)/(x^4)","1/x^2");
		simplifyTestString("1/x","1/x");
		simplifyTestString("-1/x","-1/x");
		simplifyTestString("2/x","2/x");
		simplifyTestString("-2/x","-2/x");
		simplifyTestString("(1+x)*(1+x)","(1+x)^2");
		simplifyTestString("(1+x)/(1+x)","1");
		simplifyTest("2*x+x","3*x");
		simplifyTest("2*x+3*x","5*x");
		simplifyTest("5*x-3*x","2*x");
		simplifyTest("3*x-5*x","-2*x");
		simplifyTest("3*x-x","2*x");
		simplifyTest("(2*x+x)^3","27*x^3");
	}

	public void testPolySimp() throws ParseException,Exception
	{
		Node n1 = j.parse("(1.0+2.0*x+x^2.0)*(1.0+2.0*x+x^2.0)");
		pc.createPoly(n1);		

		expandTestString("(a+b)*(c+d)","a*c+a*d+b*c+b*d");
		expandTestString("a*c+a*d+b*c+b*d","a*c+a*d+b*c+b*d");
		expandTestString("(a+b)*(a+b)","2*a*b+a^2+b^2");
		expandTestString("(a-b)*(a-b)","-2*a*b+a^2+b^2");
		expandTestString("(x+7.6)*(x+5.8832)*(x-55.12)","-2464.5430784-698.4816639999999*x-41.636799999999994*x^2+x^3");
		simplifyTestString("(a+b)^0","1");
		simplifyTestString("(a-b)^0","1");
		simplifyTestString("(a+b)^1","a+b");
		simplifyTestString("(a-b)^1","a-b");
		expandTestString("(a+b)^2","2*a*b+a^2+b^2");
		expandTestString("(a-b)^2","-2*a*b+a^2+b^2");
		expandTestString("(a+b)^3","3*a*b^2+3*a^2*b+a^3+b^3");
		expandTestString("(a-b)^3","3*a*b^2-3*a^2*b+a^3-b^3");
		expandTestString("1+x+x^2+x*y+y^2","1+x+x*y+x^2+y^2");
		expandTestString("(5*x+3*y)^2","30*x*y+25*x^2+9*y^2");

		j.getPrintVisitor().setMaxLen(80);
		Node Q8node = j.parse("(xx^2+yy^2+zz^2+ww^2)^4");
		Node Q8expand = pc.expand(Q8node);
		j.println(Q8expand);
		expandTestString("(xx^2+yy^2+zz^2+ww^2)^4",
		"24*ww^2*xx^2*yy^2*zz^2+12*ww^2*xx^2*yy^4+12*ww^2*xx^2*"+
		"zz^4+12*ww^2*xx^4*yy^2+12*ww^2*xx^4*zz^2+4*ww^2*xx^6+"+
		"12*ww^2*yy^2*zz^4+12*ww^2*yy^4*zz^2+4*ww^2*yy^6+4*"+
		"ww^2*zz^6+12*ww^4*xx^2*yy^2+12*ww^4*xx^2*zz^2+6*ww^4*"+
		"xx^4+12*ww^4*yy^2*zz^2+6*ww^4*yy^4+6*ww^4*zz^4+4*"+
		"ww^6*xx^2+4*ww^6*yy^2+4*ww^6*zz^2+ww^8+12*xx^2*yy^2*"+
		"zz^4+12*xx^2*yy^4*zz^2+4*xx^2*yy^6+4*xx^2*zz^6+12*"+
		"xx^4*yy^2*zz^2+6*xx^4*yy^4+6*xx^4*zz^4+4*xx^6*yy^2+4*"+
		"xx^6*zz^2+xx^8+4*yy^2*zz^6+6*yy^4*zz^4+4*yy^6*zz^2+"+
		"yy^8+zz^8");

		Node n = j.parse("ln(x+1)");
		Node diff = j.differentiate(n,"x");
		Node simp = pc.simplify(diff);
		myAssertEquals("diff(ln(x+1))",j.toString(simp),"1.0/(1.0+x)");
		diff = j.differentiate(simp,"x");
		j.println(diff);
		simp = pc.simplify(diff);
		myAssertEquals("d^2(ln(x+1))",j.toString(simp),"-1.0/(1.0+x)^2.0");
		diff = j.differentiate(simp,"x");
		j.println(diff);
		simp = pc.simplify(diff);
		myAssertEquals("d^3(ln(x+1))",j.toString(simp),"2.0/(1.0+x)^3.0");
		diff = j.differentiate(simp,"x");
		j.println(diff);
		simp = pc.simplify(diff);
		System.out.println("D^4\t"+j.toString(simp));

		j.getPrintVisitor().setMaxLen(80);

		diff = j.differentiate(simp,"x");
//		j.println(diff);
		simp = pc.simplify(diff);
		System.out.print("D^5\t");
		j.println(simp);

		diff = j.differentiate(simp,"x");
//		j.println(diff);
		simp = pc.simplify(diff);
		System.out.print("D^6\t");
		j.println(simp);

		diff = j.differentiate(simp,"x");
//		j.println(diff);
		simp = pc.simplify(diff);
		System.out.print("D^7\t");
		j.println(simp);

		diff = j.differentiate(simp,"x");
//		j.println(diff);
		simp = pc.simplify(diff);
		System.out.print("D^8\t");
		j.println(simp);
	}

	public void testTotalOrder() throws ParseException,Exception
	{
		expandTestString("y+x","x+y");
		expandTestString("x^2+x","x+x^2");
		expandTestString("x^3+x^2","x^2+x^3");
		expandTestString("x*y+x","x+x*y");
		expandTestString("x^2+x*y","x*y+x^2");
		expandTestString("x+1/x","1/x+x");
		expandTestString("1/x^2+1/x","1/x^2+1/x");

		simplifyTestString("y+x","x+y");
		simplifyTestString("x^2+x","x+x^2");
		simplifyTestString("x^3+x^2","x^2+x^3");
		simplifyTestString("x*y+x","x+x*y");
		simplifyTestString("x^2+x*y","x*y+x^2");
		simplifyTestString("x+1/x","1/x+x");
		simplifyTestString("1/x^2+1/x","1/x^2+1/x");
	}
	
	public void testPolySimp2() throws ParseException,Exception
	{
		expandTestString("1+2*(1+x)","3+2*x");
		expandTestString("6x+3y+4x+3(15x+7y)+40","40+55*x+24*y");
		expandTestString("x*y+2*x","2*x+x*y");
		expandTestString("(1+x+y)^2","1+2*x+2*x*y+x^2+2*y+y^2");
	}
	
	public void testFormat() throws ParseException
	{
		NumberFormat format = NumberFormat.getInstance();
		j.getPrintVisitor().setNumberFormat(format);
		format.setMaximumFractionDigits(3);
		format.setMinimumFractionDigits(0);
		
		String s1 = "[10,0,0.1,0.11,0.111,0.1111]";
		String r1 = j.toString(j.parse(s1));
		String s2 = "[0.9,0.99,0.999,0.9999]";
		String r2 = j.toString(j.parse(s2));
		this.myAssertEquals(s1,r1,"[10,0,0.1,0.11,0.111,0.111]");
		this.myAssertEquals(s2,r2,"[0.9,0.99,0.999,1]");
		
		//j.addComplex();
		j.println(j.parse("[0,1,i,1+i]"));
		j.getPrintVisitor().setMode(PrintVisitor.COMPLEX_I,true);
		j.println(j.simplify(j.parse("(2+i)+(1+i)")));
		j.parseExpression("(2+i)+(1+i)");
		Complex c = j.getComplexValue();
		System.out.println(c.toString(format,true));
	}

	public void testSimpleEquals() throws ParseException
	{
		assertPolynomialEquals("a+b-(c+d)","(a+b)-c-d");
	}
	public void testBad() throws ParseException
	{
		if(SHOW_BAD)
		{
			simplifyTest("1&&(1||x)","1");
			simplifyTest("diff(sgn(x),x)","0");	// sgn not implemented
			simplifyTest("diff(re(x+i y),x)","1"); // not smart enought to work out re(i) = 1
			simplifyTest("diff(re(x+i y),y)","0");
			simplifyTest("diff(im(x+i y),x)","0");
			simplifyTest("diff(im(x+i y),y)","1");
			simplifyTest("(x/2)*3","x*1.5");
		}
	}
}
/* @author rich
 * Created on 17-Apr-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepJUnit;

import java.text.NumberFormat;
import java.util.Vector;

import org.nfunk.jep.*;
import org.nfunk.jep.type.Complex;
import org.lsmp.djep.xjep.*;

import junit.framework.Test;
import junit.framework.TestResult;
import junit.framework.TestSuite;

/**
 * @author Rich Morris
 * Created on 17-Apr-2005
 */
public class XJepTest extends JepTest {

	public XJepTest(String name) {
		super(name);
	}

	public static Test suite() {
		return new TestSuite(XJepTest.class);
	}

	public static void main(String[] args) {
		TestSuite suite= new TestSuite(XJepTest.class);
		suite.run(new TestResult());
	}
	
	protected void setUp() {
		j = new XJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		//j.setTraverse(true);
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
	}
	
	public String parsePreprocSimp(String expr) throws ParseException
	{
		XJep xj = (XJep) j;
		Node node = xj.parse(expr);
		Node matEqn = xj.preprocess(node);
		Node simp = xj.simplify(matEqn);
		String res = xj.toString(simp);
		return res;
	}

	public void simplifyTestString(String expr,String expected) throws ParseException
	{
		XJep xj = (XJep) j;

		Node node = xj.parse(expr);
		Node processed = xj.preprocess(node);
		Node simp = xj.simplify(processed);
		String res = xj.toString(simp);
		
		if(!expected.equals(res))		
			System.out.println("Error: Value of \""+expr+"\" is \""+res+"\" should be \""+expected+"\"");
		assertEquals("<"+expr+">",expected,res);
		System.out.println("Success: Value of \""+expr+"\" is \""+res+"\"");
	}

	public void simplifyTest(String expr,String expected) throws ParseException
	{
		XJep xj = (XJep) j;
		
		Node node2 = xj.parse(expected);
		Node processed2 = xj.preprocess(node2);
		Node simp2 = xj.simplify(processed2);
		String res2 = xj.toString(simp2);

		simplifyTestString(expr,res2);
	}

	public Node parseProcSimpEval(String expr,Object expected) throws ParseException,Exception
	{
		XJep xj = (XJep) j;

		Node node = xj.parse(expr);
		Node processed = xj.preprocess(node);
		Node simp = xj.simplify(processed);
		Object res = xj.evaluate(simp);
		
		myAssertEquals(expr,expected,res);
		return simp;
	}

	public void testLogical() throws Exception {
		super.testLogical();
		OperatorSet opSet = j.getOperatorSet();
		if(!((XOperator) opSet.getMultiply()).isDistributiveOver(opSet.getAdd()))
			fail("* should be distributive over +");
		if(((XOperator) opSet.getMultiply()).isDistributiveOver(opSet.getDivide()))
			fail("* should not be distributive over /");
		if(((XOperator) opSet.getMultiply()).getPrecedence() > ((XOperator) opSet.getAdd()).getPrecedence())
			fail("* should have a lower precedence than +");

	}
	
	public void testPrint() throws ParseException
	{
		simplifyTestString("(a+b)+c","a+b+c");
		simplifyTestString("(a-b)+c","a-b+c");
		simplifyTestString("(a+b)-c","a+b-c"); 
		simplifyTestString("(a-b)-c","a-b-c");

		simplifyTestString("a+(b+c)","a+b+c");
		simplifyTestString("a-(b+c)","a-(b+c)");
		simplifyTestString("a+(b-c)","a+b-c");   
		simplifyTestString("a-(b-c)","a-(b-c)");

		simplifyTestString("(a*b)*c","a*b*c");
		simplifyTestString("(a/b)*c","(a/b)*c");
		simplifyTestString("(a*b)/c","a*b/c"); 
		simplifyTestString("(a/b)/c","(a/b)/c");

		simplifyTestString("a*(b*c)","a*b*c");
		simplifyTestString("a/(b*c)","a/(b*c)");
		simplifyTestString("a*(b/c)","a*b/c");
		simplifyTestString("a/(b/c)","a/(b/c)");

		simplifyTestString("a=(b=c)","a=b=c");
		//simplifyTestString("(a=b)=c","a/(b/c)");

		simplifyTestString("(a*b)+c","a*b+c");
		simplifyTestString("(a+b)*c","(a+b)*c");
		simplifyTestString("a*(b+c)","a*(b+c)"); 
		simplifyTestString("a+(b*c)","a+b*c");

		simplifyTestString("(a||b)||c","a||b||c");
		simplifyTestString("(a&&b)||c","a&&b||c");
		simplifyTestString("(a||b)&&c","(a||b)&&c"); 
		simplifyTestString("(a&&b)&&c","a&&b&&c");

		simplifyTestString("a||(b||c)","a||b||c");
		simplifyTestString("a&&(b||c)","a&&(b||c)");
		simplifyTestString("a||(b&&c)","a||b&&c");   
		simplifyTestString("a&&(b&&c)","a&&b&&c");
	}
	
	public void testSimp() throws ParseException
	{
		simplifyTest("2+3","5");
		simplifyTest("2*3","6");
		simplifyTest("2^3","8");
		simplifyTest("3/2","1.5");
		simplifyTest("2*3+4","10");
		simplifyTest("2*(3+4)","14");

		simplifyTest("0+x","x");
		simplifyTest("x+0","x");
		simplifyTest("0-x","0-x");
		simplifyTest("x-0","x");
		simplifyTest("0*x","0");
		simplifyTest("x*0","0");
		simplifyTest("1*x","x");
		simplifyTest("x*1","x");
		simplifyTest("-1*x","-x");
		simplifyTest("x*-1","-x");
		simplifyTest("-(-x)","x");
		simplifyTest("-(-(-x))","-x");
		simplifyTest("(-1)*(-1)*x","x");
		simplifyTest("(-1)*(-1)*(-1)*x","-x");
		
		simplifyTest("0/x","0");
		simplifyTest("x/0","1/0");
		
		simplifyTest("x^0","1");
		simplifyTest("x^1","x");
		simplifyTest("0^x","0");
		simplifyTest("1^x","1");

		// (a+b)+c
		simplifyTest("(2+3)+x","5+x");
		simplifyTest("(2+x)+3","5+x");
		simplifyTest("(x+2)+3","5+x");
		// a+(b+c)
		simplifyTest("x+(2+3)","5+x");
		simplifyTest("2+(x+3)","5+x");
		simplifyTest("2+(3+x)","5+x");
		// (a+b)-c
		simplifyTest("(2+3)-x","5-x");
		simplifyTest("(2+x)-3","x-1");
		simplifyTest("(x+2)-3","x-1");
		// (a-b)+c
		simplifyTest("(2-3)+x","-1+x");
		simplifyTest("(2-x)+3","5-x");
		simplifyTest("(x-2)+3","1+x");
		// a-(b+c)
		simplifyTest("x-(2+3)","x-5");
		simplifyTest("2-(x+3)","-1-x");
		simplifyTest("2-(3+x)","-1-x");
		// a+(b-c)
		simplifyTest("x+(2-3)","x-1");
		simplifyTest("2+(x-3)","-1+x");
		simplifyTest("2+(3-x)","5-x");
		// a-(b-c)
		simplifyTest("x-(2-3)","1+x");
		simplifyTest("2-(x-3)","5-x");
		simplifyTest("2-(3-x)","-1+x");
		// (a-b)-c
		simplifyTest("(2-3)-x","-1-x");
		simplifyTest("(2-x)-3","-1-x");
		simplifyTest("(x-2)-3","x-5");

		// (a*b)*c
		simplifyTest("(2*3)*x","6*x");
		simplifyTest("(2*x)*3","6*x");
		simplifyTest("(x*2)*3","6*x");
		// a+(b+c)
		simplifyTest("x*(2*3)","6*x");
		simplifyTest("2*(x*3)","6*x");
		simplifyTest("2*(3*x)","6*x");
		// (a+b)-c
		simplifyTest("(2*3)/x","6/x");
		simplifyTest("(3*x)/2","1.5*x");
		simplifyTest("(x*3)/2","1.5*x");
		// (a-b)+c
		simplifyTest("(3/2)*x","1.5*x");
		simplifyTest("(3/x)*2","6/x");
		simplifyTest("(x/2)*3","1.5*x");
		// a-(b+c)
		simplifyTest("x/(2*3)","x/6");
		simplifyTest("3/(x*2)","1.5/x");
		simplifyTest("3/(2*x)","1.5/x");
		// a+(b-c)
		simplifyTest("x*(3/2)","1.5*x");
		simplifyTest("3*(x/2)","1.5*x");
		simplifyTest("3*(2/x)","6/x");
		// a-(b-c)
		simplifyTest("x/(3/2)","x/1.5");
		simplifyTest("2/(x/3)","6/x");
		simplifyTest("3/(2/x)","1.5*x");
		// (a-b)-c
		simplifyTest("(3/2)/x","1.5/x");
		simplifyTest("(3/x)/2","1.5/x");
		simplifyTest("(x/3)/2","x/6");


		simplifyTest("x*(3+2)","5*x");
		simplifyTest("3*(x+2)","6+3*x");
		simplifyTest("3*(2+x)","6+3*x");
		simplifyTest("(3+2)*x","5*x");
		simplifyTest("(3+x)*2","6+2*x");
		simplifyTest("(x+3)*2","6+x*2");

		simplifyTest("x*(3-2)","x");
		simplifyTest("3*(x-2)","-6+3*x");
		simplifyTest("3*(2-x)","6-3*x");
		simplifyTest("(3-2)*x","x");
		simplifyTest("(3-x)*2","6-2*x");
		simplifyTest("(x-3)*2","-6+2*x");

		simplifyTest("3+(x/4)","3+x/4");
		simplifyTest("2*(x/4)","0.5*x");
		simplifyTest("(2*(3+(x/4)))","6+0.5*x");
		simplifyTest("1+(2*(3+(x/4)))","7+0.5*x");
		simplifyTest("((3+(x/4))*2)+1","7+0.5*x");

		simplifyTest("(x/2)*3","x*1.5");

	}

	public void testMacroFun() throws Exception
	{
		j.addFunction("zap",new MacroFunction("zap",1,"x*(x-1)/2",(XJep) j));
		valueTest("zap(10)",45);
		j.addFunction("zap2",new MacroFunction("zap",4,"x1+x2+x3+x4",(XJep) j));
		valueTest("zap2(5,5,3,6)",19);
	}

	public void testVariableReuse() throws Exception
	{
		XJep xj = (XJep) j;
		System.out.println("\nTesting variable reuse");
		parseProcSimpEval("x=3",new Double(3));
		Node node13 = parseProcSimpEval("y=x^2",new Double(9));
		Node node15 = parseProcSimpEval("z=y+x",new Double(12));
			
		j.setVarValue("x",new Double(4));
		System.out.println("j.setVarValue(\"x\",new Double(4));");
		System.out.println("j.getVarValue(y): "+j.getVarValue("y"));
		myAssertEquals("eval y eqn","16.0",j.evaluate(node13).toString());
		System.out.println("j.getVarValue(y): "+j.getVarValue("y"));
		myAssertEquals("eval z eqn","20.0",j.evaluate(node15).toString());

//		j.getSymbolTable().clearValues();
		j.setVarValue("x",new Double(5));
		System.out.println("j.setVarValue(\"x\",new Double(5));");
		myAssertEquals("j.findVarValue(y)","25.0",xj.calcVarValue("y").toString());
		myAssertEquals("j.findVarValue(z)","30.0",xj.calcVarValue("z").toString());

		j.getSymbolTable().clearValues();
		j.setVarValue("x",new Double(6));
		System.out.println("j.setVarValue(\"x\",new Double(6));");
		myAssertEquals("j.findVarValue(z)","42.0",xj.calcVarValue("z").toString());
		myAssertEquals("j.findVarValue(y)","36.0",xj.calcVarValue("y").toString());

		parseProcSimpEval("x=7",new Double(7));
		myAssertEquals("eval y eqn","49.0",j.evaluate(node13).toString());
		myAssertEquals("eval z eqn","56.0",j.evaluate(node15).toString());
	}

	public void testReentrant() throws ParseException,Exception
	{
		XJep xj = (XJep) j;

		xj.restartParser("x=1; // semi-colon; in comment\n y=2; z=x+y;");
		Node node = xj.continueParsing();
		myAssertEquals("x=1; ...","1.0",calcValue(node).toString());
		node = xj.continueParsing();
		myAssertEquals("..., y=2; ...","2.0",calcValue(node).toString());
		node = xj.continueParsing();
		myAssertEquals("..., z=x+y;","3.0",calcValue(node).toString());
		node = xj.continueParsing();
		assertNull("empty string ",node);
	}
	
	
	public void testFormat() throws ParseException
	{
		XJep xj = (XJep) j;

		NumberFormat format = NumberFormat.getInstance();
		xj.getPrintVisitor().setNumberFormat(format);
		format.setMaximumFractionDigits(3);
		format.setMinimumFractionDigits(0);
		
		String s1 = "[10,0,0.1,0.11,0.111,0.1111]";
		String r1 = xj.toString(j.parse(s1));
		String s2 = "[0.9,0.99,0.999,0.9999]";
		String r2 = xj.toString(j.parse(s2));
		this.myAssertEquals(s1,r1,"[10,0,0.1,0.11,0.111,0.111]");
		this.myAssertEquals(s2,r2,"[0.9,0.99,0.999,1]");
		
		//j.addComplex();
		xj.println(j.parse("[0,1,i,1+i]"));
		xj.getPrintVisitor().setMode(PrintVisitor.COMPLEX_I,true);
		xj.println(xj.simplify(j.parse("(2+i)+(1+i)")));
		//j.parseExpression("(2+i)+(1+i)");
		Complex c = (Complex) calcValue("(2+i)+(1+i)");
		System.out.println(c.toString(format,true));
	}

	public void testVarInEqn() throws Exception
	{
		XJep xj = (XJep) j;

		Node n1 = j.parse("a+b+c+d");
		Vector v = xj.getVarsInEquation(n1,new Vector());
		assertTrue("Does not contain a",v.contains(j.getSymbolTable().getVar("a")));
		assertTrue("Does not contain b",v.contains(j.getSymbolTable().getVar("b")));
		assertTrue("Does not contain c",v.contains(j.getSymbolTable().getVar("c")));
		assertTrue("Does not contain d",v.contains(j.getSymbolTable().getVar("d")));

		xj.preprocess(j.parse("x=a+b t"));
		xj.preprocess(j.parse("y=c+d t"));
		xj.preprocess(j.parse("f=x*y"));
		xj.preprocess(j.parse("g=x+y"));
		Node n2 = xj.preprocess(j.parse("f+g"));

		Vector v2 = xj.recursiveGetVarsInEquation(n2,new Vector());
		Vector v3 = new Vector();
		v3.add(j.getVar("a"));
		v3.add(j.getVar("b"));
		v3.add(j.getVar("t"));
		v3.add(j.getVar("x"));
		v3.add(j.getVar("c"));
		v3.add(j.getVar("d"));
		v3.add(j.getVar("y"));
		v3.add(j.getVar("f"));
		v3.add(j.getVar("g"));

		System.out.println(v2.toString());
		assertEquals("Bad element seq",v3,v2);
	}

	public void testUndecVar() throws ParseException {
		j.setAllowUndeclared(true);
		Node node1 = ((XJep) j).parse("zap * biff * gosh");
		((XJep) j).preprocess(node1);
	}

	public void testSum() throws Exception
	{
		valueTest("Sum(x,x,1,10)",55);
		valueTest("Sum(x^2,x,1,5)",55);
		valueTest("Product(x,x,1,5)",120);
		valueTest("Min(x^2,x,1,5)",1);
		valueTest("Max(x^2,x,1,5)",25);
		valueTest("MinArg(x^2,x,1,5)",1);
		valueTest("MaxArg(x^2,x,1,5)",5);
	}

	public void testHex() throws Exception
	{
	    valueTest("toHex(0)","0x0");
	    valueTest("toHex(0,1)","0x0.0");
	    valueTest("toHex(0,2)","0x0.00");

	    valueTest("toHex(1)","0x1");
	    valueTest("toHex(1,1)","0x1.0");
	    valueTest("toHex(1,2)","0x1.00");

	    valueTest("toHex(-1)","-0x1");
	    valueTest("toHex(-1,1)","-0x1.0");
	    valueTest("toHex(-1,2)","-0x1.00");
	    
	    valueTest("toHex(7)","0x7");
	    valueTest("toHex(7,1)","0x7.0");
	    valueTest("toHex(7,2)","0x7.00");

	    valueTest("toHex(-7)","-0x7");
	    valueTest("toHex(-7,1)","-0x7.0");
	    valueTest("toHex(-7,2)","-0x7.00");

	    valueTest("toHex(8)","0x8");
	    valueTest("toHex(8,1)","0x8.0");
	    valueTest("toHex(8,2)","0x8.00");

	    valueTest("toHex(-8)","-0x8");
	    valueTest("toHex(-8,1)","-0x8.0");
	    valueTest("toHex(-8,2)","-0x8.00");

	    valueTest("toHex(10)","0xa");
	    valueTest("toHex(10,1)","0xa.0");
	    valueTest("toHex(10,2)","0xa.00");

	    valueTest("toHex(-10)","-0xa");
	    valueTest("toHex(-10,1)","-0xa.0");
	    valueTest("toHex(-10,2)","-0xa.00");

	    valueTest("toHex(15)","0xf");
	    valueTest("toHex(15,1)","0xf.0");
	    valueTest("toHex(15,2)","0xf.00");

	    valueTest("toHex(-15)","-0xf");
	    valueTest("toHex(-15,1)","-0xf.0");
	    valueTest("toHex(-15,2)","-0xf.00");

	    valueTest("toHex(16)","0x10");
	    valueTest("toHex(16,1)","0x10.0");
	    valueTest("toHex(16,2)","0x10.00");

	    valueTest("toHex(-16)","-0x10");
	    valueTest("toHex(-16,1)","-0x10.0");
	    valueTest("toHex(-16,2)","-0x10.00");

	    valueTest("toHex(17)","0x11");
	    valueTest("toHex(17,1)","0x11.0");
	    valueTest("toHex(17,2)","0x11.00");

	    valueTest("toHex(-17)","-0x11");
	    valueTest("toHex(-17,1)","-0x11.0");
	    valueTest("toHex(-17,2)","-0x11.00");

	    valueTest("toHex(256)","0x100");
	    valueTest("toHex(256,1)","0x100.0");
	    valueTest("toHex(256,2)","0x100.00");

	    valueTest("toHex(-256)","-0x100");
	    valueTest("toHex(-256,1)","-0x100.0");
	    valueTest("toHex(-256,2)","-0x100.00");

	    valueTest("toHex(1/16)","0x0");
	    valueTest("toHex(1/16,1)","0x0.1");
	    valueTest("toHex(1/16,2)","0x0.10");

	    valueTest("toHex(-1/16)","-0x0");
	    valueTest("toHex(-1/16,1)","-0x0.1");
	    valueTest("toHex(-1/16,2)","-0x0.10");

	    valueTest("toHex(7/16)","0x0");
	    valueTest("toHex(7/16,1)","0x0.7");
	    valueTest("toHex(7/16,2)","0x0.70");

	    valueTest("toHex(-7/16)","-0x0");
	    valueTest("toHex(-7/16,1)","-0x0.7");
	    valueTest("toHex(-7/16,2)","-0x0.70");

	    valueTest("toHex(8/16)","0x1");
	    valueTest("toHex(8/16,1)","0x0.8");
	    valueTest("toHex(8/16,2)","0x0.80");

	    valueTest("toHex(-8/16)","-0x1");
	    valueTest("toHex(-8/16,1)","-0x0.8");
	    valueTest("toHex(-8/16,2)","-0x0.80");

	    valueTest("toHex(10/16)","0x1");
	    valueTest("toHex(10/16,1)","0x0.a");
	    valueTest("toHex(10/16,2)","0x0.a0");

	    valueTest("toHex(-10/16)","-0x1");
	    valueTest("toHex(-10/16,1)","-0x0.a");
	    valueTest("toHex(-10/16,2)","-0x0.a0");

	    valueTest("toHex(15/16)","0x1");
	    valueTest("toHex(15/16,1)","0x0.f");
	    valueTest("toHex(15/16,2)","0x0.f0");

	    valueTest("toHex(-15/16)","-0x1");
	    valueTest("toHex(-15/16,1)","-0x0.f");
	    valueTest("toHex(-15/16,2)","-0x0.f0");
	    
	    valueTest("toHex(17/16)","0x1");
	    valueTest("toHex(17/16,1)","0x1.1");
	    valueTest("toHex(17/16,2)","0x1.10");

	    valueTest("toHex(-17/16)","-0x1");
	    valueTest("toHex(-17/16,1)","-0x1.1");
	    valueTest("toHex(-17/16,2)","-0x1.10");
	    
	    valueTest("toHex(31/16)","0x2");
	    valueTest("toHex(31/16,1)","0x1.f");
	    valueTest("toHex(31/16,2)","0x1.f0");

	    valueTest("toHex(-31/16)","-0x2");
	    valueTest("toHex(-31/16,1)","-0x1.f");
	    valueTest("toHex(-31/16,2)","-0x1.f0");
	    
	    valueTest("toHex(1/256)","0x0");
	    valueTest("toHex(1/256,1)","0x0.0");
	    valueTest("toHex(1/256,2)","0x0.01");

	    valueTest("toHex(-1/256)","-0x0");
	    valueTest("toHex(-1/256,1)","-0x0.0");
	    valueTest("toHex(-1/256,2)","-0x0.01");

	    valueTest("toHex(15/256)","0x0");
	    valueTest("toHex(15/256,1)","0x0.1");
	    valueTest("toHex(15/256,2)","0x0.0f");

	    valueTest("toHex(-15/256)","-0x0");
	    valueTest("toHex(-15/256,1)","-0x0.1");
	    valueTest("toHex(-15/256,2)","-0x0.0f");

	    valueTest("toHex(17/256)","0x0");
	    valueTest("toHex(17/256,1)","0x0.1");
	    valueTest("toHex(17/256,2)","0x0.11");

	    valueTest("toHex(-17/256)","-0x0");
	    valueTest("toHex(-17/256,1)","-0x0.1");
	    valueTest("toHex(-17/256,2)","-0x0.11");

	    valueTest("toHex(127/256)","0x0");
	    valueTest("toHex(127/256,1)","0x0.8");
	    valueTest("toHex(127/256,2)","0x0.7f");

	    valueTest("toHex(-127/256)","-0x0");
	    valueTest("toHex(-127/256,1)","-0x0.8");
	    valueTest("toHex(-127/256,2)","-0x0.7f");

	    valueTest("toHex(128/256)","0x1");
	    valueTest("toHex(128/256,1)","0x0.8");
	    valueTest("toHex(128/256,2)","0x0.80");

	    valueTest("toHex(-128/256)","-0x1");
	    valueTest("toHex(-128/256,1)","-0x0.8");
	    valueTest("toHex(-128/256,2)","-0x0.80");

	    valueTest("toHex(240/256)","0x1");
	    valueTest("toHex(240/256,1)","0x0.f");
	    valueTest("toHex(240/256,2)","0x0.f0");

	    valueTest("toHex(-240/256)","-0x1");
	    valueTest("toHex(-240/256,1)","-0x0.f");
	    valueTest("toHex(-240/256,2)","-0x0.f0");

	    valueTest("toHex(248/256)","0x1");
	    valueTest("toHex(248/256,1)","0x1.0");
	    valueTest("toHex(248/256,2)","0x0.f8");

	    valueTest("toHex(-248/256)","-0x1");
	    valueTest("toHex(-248/256,1)","-0x1.0");
	    valueTest("toHex(-248/256,2)","-0x0.f8");
	    
	    valueTest("toHex(1/4096)","0x0");
	    valueTest("toHex(1/4096,1)","0x0.0");
	    valueTest("toHex(1/4096,2)","0x0.00");
	    valueTest("toHex(1/4096,3)","0x0.001");
	    valueTest("toHex(1/4096,4)","0x0.0010");

	    valueTest("toHex(1+1/4096)","0x1");
	    valueTest("toHex(1+1/4096,1)","0x1.0");
	    valueTest("toHex(1+1/4096,2)","0x1.00");
	    valueTest("toHex(1+1/4096,3)","0x1.001");
	    valueTest("toHex(1+1/4096,4)","0x1.0010");
	    
	    XJep xj = (XJep) j;
	    BaseFormat bf = new BaseFormat(16,"0x");
	    bf.setMaximumFractionDigits(0);
	    xj.getPrintVisitor().setNumberFormat(bf);
	    String st = "10 x+15 x^2 - 16 x^3 + 32 x^4 - 256 x^5";
	    Node n = xj.parse(st);
	    String res = xj.toString(n);
	    myAssertEquals(st,"0xa*x+0xf*x^0x2-0x10*x^0x3+0x20*x^0x4-0x100*x^0x5",res);
}
	public void testDefine() throws Exception
	{
	    XJep xj = (XJep) j;
	    //Node n = xj.parse("Define(\"sumToX\",1,\"x*(x+1)/2\")");
	    //xj.preprocess(n);
	    //valueTest("sumToX(4)",10);
	}
	public void testBad() throws Exception
	{
		if(SHOW_BAD)
		{
			valueTest("recurse = recurse+1",null);
			simplifyTest("1&&(1||x)","1");
			simplifyTest("diff(sgn(x),x)","0");	// sgn not implemented
			simplifyTest("diff(re(x+i y),x)","1"); // not smart enough to work out re(i) = 1
			simplifyTest("diff(re(x+i y),y)","0");
			simplifyTest("diff(im(x+i y),x)","0");
			simplifyTest("diff(im(x+i y),y)","1");
		}
	}

}
package org.lsmp.djepJUnit;

import junit.framework.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
import org.lsmp.djep.rpe.*;
import org.lsmp.djep.xjep.XJep;

/* @author rich
 * Created on 19-Nov-2003
 */

/**
 * JUnit test for full Matrix Rp evaluator
 * 
 * @author Rich Morris
 * Created on 19-Nov-2003
 */
public class RpTest extends TestCase {
	JEP j;
	public static final boolean SHOW_BAD=false;
	
	public RpTest(String name) {
		super(name);
	}

	public static void main(String args[]) {
		// Create an instance of this class and analyse the file

		TestSuite suite= new TestSuite(RpTest.class);
//		DJepTest jt = new DJepTest("DJepTest");
//		jt.setUp();
		suite.run(new TestResult());
	}	
	/** strings for each variable */
	String matStrs[][] = new String[10][10];
	String vecStrs[] = new String[10];

	protected void setUp() {
		j = new XJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		//j.setTraverse(true);
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);

	}

	public static Test suite() {
		return new TestSuite(RpTest.class);
	}

	public void testGood()
	{
		assertEquals(1,1);
	}

	public void myAssertEquals(String msg,String actual,String expected)
	{
		if(!actual.equals(expected))
			System.out.println("Error \""+msg+"\" is \n<"+actual+"> should be \n<"+expected+">");
		assertEquals("<"+msg+">",expected,actual);
		System.out.println("Success: Value of <"+msg+"> is <"+actual+">");
	}

	public void valueTest(String expr,double dub) throws ParseException,Exception
	{
		valueTest(expr,new Double(dub));
	}
	public void valueTest(String expr,Object expected) throws ParseException,Exception
	{
		Node node = j.parse(expr);
		Object res = j.evaluate(node);
		if(j.hasError())
			fail("Evaluation Failure: "+expr+j.getErrorInfo());
		assertEquals("<"+expr+">",expected,res);
		System.out.println("Sucess value of <"+expr+"> is "+res);
	}

	public void valueTest(String expr,String expected) throws ParseException,Exception
	{
		Node node = j.parse(expr);
		Object res = j.evaluate(node);
		if(j.hasError())
			fail("Evaluation Failure: "+expr+j.getErrorInfo());
		assertEquals("<"+expr+">",expected,res.toString());
		System.out.println("Sucess value of <"+expr+"> is "+res.toString());
	}

	public void complexValueTest(String expr,Complex expected,double tol) throws Exception
	{
		Node node = j.parse(expr);
		Object res = j.evaluate(node);
		assertTrue("<"+expr+"> expected: <"+expected+"> but was <"+res+">",
			expected.equals((Complex) res,tol));
		System.out.println("Sucess value of <"+expr+"> is "+res);
	}

	public Object calcValue(String expr) throws ParseException,Exception
	{
		Node node = j.parse(expr);
		Object res = j.evaluate(node);
		return res;
	}
/*	
	public void simplifyTest(String expr,String expected) throws ParseException,Exception
	{
		Node node = j.parse(expr);
		String res = j.toString(node);
		
		Node node2 = j.parse(expected);
		Node matEqn2 = j.preprocess(node2);
		Node simp2 = j.simplify(matEqn2);
		String res2 = j.toString(simp2);


		if(!res2.equals(res))		
			System.out.println("Error: Value of \""+expr+"\" is \""+res+"\" should be \""+res2+"\"");
		assertEquals("<"+expr+">",res2,res);
		System.out.println("Sucess: Value of \""+expr+"\" is \""+res+"\"");
			
//		System.out.print("Full Brackets:\t");
//		j.pv.setFullBrackets(true);
//		j.pv.println(simp);
//		j.pv.setFullBrackets(false);

	}
*/

/*
	public void simplifyTestString(String expr,String expected) throws ParseException
	{
		Node node = j.parse(expr);
		Node matEqn = j.preprocess(node);
		String res = j.toString(matEqn);
		
		if(!expected.equals(res))		
			System.out.println("Error: Value of \""+expr+"\" is \""+res+"\" should be \""+expected+"\"");
		assertEquals("<"+expr+">",expected,res);
		System.out.println("Sucess: Value of \""+expr+"\" is \""+res+"\"");
			
//		System.out.print("Full Brackets:\t");
//		j.pv.setFullBrackets(true);
//		j.pv.println(simp);
//		j.pv.setFullBrackets(false);

	}
*/
	void rpTest(String eqns[], String eqn2) throws ParseException,Exception
	{
		for(int i=0;i<eqns.length;++i)	{
			System.out.println("eqns "+eqns[i]);
			Node node = j.parse(eqns[i]);
			j.evaluate(node);
		}
		Node node3 = j.parse(eqn2);
		RpEval rpe = new RpEval(j);
		RpCommandList list = rpe.compile(node3);
//		rpe.copyVars();
		double rpRes = rpe.evaluate(list);

		Object matRes = j.evaluate(node3);
//		System.out.println("rpRes: "+rpRes.getClass().getName()+" = "+rpRes.toString());
		if(j.hasError())
			fail("Evaluation Failure: "+eqn2+j.getErrorInfo());
		myAssertEquals("<"+eqn2+">",""+rpRes,matRes.toString());

		if(!matRes.equals(new Double(rpRes)))
			fail("Expected <"+matRes+"> found <"+rpRes+">");
	}

	/** As before but don't test with MatrixJep.evaluate */
	void rpTest2(String eqns[]) throws ParseException,Exception
	{
		Node nodes[] = new Node[eqns.length];
		double rpRes[] = new double[eqns.length];
		RpEval rpe = new RpEval(j);
		for(int i=0;i<eqns.length;++i)	{
			System.out.println("eqns "+eqns[i]);
			nodes[i] = j.parse(eqns[i]);
			RpCommandList list = rpe.compile(nodes[i]);
			rpRes[i] = rpe.evaluate(list);
			System.out.println("<"+eqns[i]+"> "+rpRes[i]);
		}
		for(int i=0;i<eqns.length;++i)	{
			Object matRes = j.evaluate(nodes[i]);
			if(!matRes.equals(new Double(rpRes[i])))
					fail("Expected <"+matRes+"> found <"+rpRes[i]+">");
		}
		rpe.cleanUp();
	}

	public void testRp() throws ParseException,Exception
	{
		rpTest(new String[0],"1*2*3+4*5*6+7*8*9");
		
		rpTest(new String[]{"x1=1","x2=2","x3=3","x4=4","x5=5","x6=6","x7=7","x8=8","x9=9"},
			"x1*x2*x3+x4*x5*x6+x7*x8*x9");

	}

	public void testAssign() throws ParseException,Exception
	{
		rpTest2(new String[]{"x=5","x+x"});
		j.setVarValue("x",new Double(6.0));
		rpTest2(new String[]{"x+x"});
	}
	
	public void testLogical() throws ParseException,Exception
	{
		rpTest2(new String[]{"1&&1","1&&0","0&&0","0&&1","3.14&&1"});
		rpTest2(new String[]{"1||1","1||0","0||0","0||1","3.14||0"});
		rpTest2(new String[]{"!0","!1","!3.14","!-3.14"});
		
		rpTest2(new String[]{"1>1","1>0","0>0","0>1","3.14>1"});
		rpTest2(new String[]{"1<1","1<0","0<0","0<1","3.14<1"});
		rpTest2(new String[]{"1>=1","1>=0","0>=0","0>=1","3.14>=1"});
		rpTest2(new String[]{"1<=1","1<=0","0<=0","0<=1","3.14<=1"});
		rpTest2(new String[]{"1==1","1==0","0==0","0==1","3.14==1"});
		rpTest2(new String[]{"1!=1","1!=0","0!=0","0!=1","3.14!=1"});

	}
	boolean TESTALL = false;
	public void testFun() throws ParseException,Exception
	{
		rpTest2(new String[]{"x=5","y=4","x/y","x%y","x^y"});
		rpTest2(new String[]{"x=0.5","cos(x)","sin(x)","tan(x)","asin(x)","acos(x)","atan(x)"});
		rpTest2(new String[]{"x=0.5","cosh(x)","sinh(x)","tanh(x)","asinh(x)","acosh(x+1)","atanh(x)"});
		rpTest2(new String[]{"x=0.5","sqrt(x)","ln(x)","log(x)","exp(x)","abs(x)"});

		rpTest2(new String[]{"x=0.5","cos(x)^2+sin(x)^2"});
		rpTest2(new String[]{"x=0.5","sec(x)","cosec(x)","cot(x)"});
		rpTest2(new String[]{"x=3","y=4","atan2(y,x)","if(x>y,1,2)","if(x<y,1,2)"} );
	}
	
/*	public void testSimpleSum() throws ParseException
	{
		valueTest("1+2",3);		
		valueTest("2*6+3",15);		
		valueTest("2*(6+3)",18);
	}
	
	public void testOperators()  throws ParseException
	{
//		if(!Operator.OP_MULTIPLY.isDistributiveOver(Operator.OP_ADD))
//			fail("* should be distrib over +");
//		if(Operator.OP_MULTIPLY.isDistributiveOver(Operator.OP_DIVIDE))
//			fail("* should not be distrib over /");
//		if(Operator.OP_MULTIPLY.getPrecedence() > Operator.OP_ADD.getPrecedence())
//			fail("* should have a lower precedence than +");

		valueTest("T=1",1);
		valueTest("F=0",0);
		calcValue("a=F"); calcValue("b=F"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=F"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=T"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=T"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);

		calcValue("a=T"); calcValue("b=F"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=F"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=T"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=T"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
	}
	
	public void testSimp() throws ParseException
	{
		simplifyTest("2+3","5");
		simplifyTest("2*3","6");
		simplifyTest("2^3","8");
		simplifyTest("3/2","1.5");
		simplifyTest("2*3+4","10");
		simplifyTest("2*(3+4)","14");

		simplifyTest("0+x","x");
		simplifyTest("x+0","x");
		simplifyTest("0-x","0-x");
		simplifyTest("x-0","x");
		simplifyTest("0*x","0");
		simplifyTest("x*0","0");
		simplifyTest("1*x","x");
		simplifyTest("x*1","x");
		simplifyTest("-1*x","-x");
		simplifyTest("x*-1","-x");
		simplifyTest("-(-x)","x");
		simplifyTest("-(-(-x))","-x");
		simplifyTest("(-1)*(-1)*x","x");
		simplifyTest("(-1)*(-1)*(-1)*x","-x");
		
		simplifyTest("0/x","0");
		simplifyTest("x/0","1/0");
		
		simplifyTest("x^0","1");
		simplifyTest("x^1","x");
		simplifyTest("0^x","0");
		simplifyTest("1^x","1");

		// (a+b)+c
		simplifyTest("(2+3)+x","5+x");
		simplifyTest("(2+x)+3","5+x");
		simplifyTest("(x+2)+3","5+x");
		// a+(b+c)
		simplifyTest("x+(2+3)","5+x");
		simplifyTest("2+(x+3)","5+x");
		simplifyTest("2+(3+x)","5+x");
		// (a+b)-c
		simplifyTest("(2+3)-x","5-x");
		simplifyTest("(2+x)-3","x-1");
		simplifyTest("(x+2)-3","x-1");
		// (a-b)+c
		simplifyTest("(2-3)+x","-1+x");
		simplifyTest("(2-x)+3","5-x");
		simplifyTest("(x-2)+3","1+x");
		// a-(b+c)
		simplifyTest("x-(2+3)","x-5");
		simplifyTest("2-(x+3)","-1-x");
		simplifyTest("2-(3+x)","-1-x");
		// a+(b-c)
		simplifyTest("x+(2-3)","x-1");
		simplifyTest("2+(x-3)","-1+x");
		simplifyTest("2+(3-x)","5-x");
		// a-(b-c)
		simplifyTest("x-(2-3)","1+x");
		simplifyTest("2-(x-3)","5-x");
		simplifyTest("2-(3-x)","-1+x");
		// (a-b)-c
		simplifyTest("(2-3)-x","-1-x");
		simplifyTest("(2-x)-3","-1-x");
		simplifyTest("(x-2)-3","x-5");

		// (a*b)*c
		simplifyTest("(2*3)*x","6*x");
		simplifyTest("(2*x)*3","6*x");
		simplifyTest("(x*2)*3","6*x");
		// a+(b+c)
		simplifyTest("x*(2*3)","6*x");
		simplifyTest("2*(x*3)","6*x");
		simplifyTest("2*(3*x)","6*x");
		// (a+b)-c
		simplifyTest("(2*3)/x","6/x");
		simplifyTest("(3*x)/2","1.5*x");
		simplifyTest("(x*3)/2","1.5*x");
		// (a-b)+c
		simplifyTest("(3/2)*x","1.5*x");
		simplifyTest("(3/x)*2","6/x");
		simplifyTest("(x/2)*3","1.5*x");
		// a-(b+c)
		simplifyTest("x/(2*3)","x/6");
		simplifyTest("3/(x*2)","1.5/x");
		simplifyTest("3/(2*x)","1.5/x");
		// a+(b-c)
		simplifyTest("x*(3/2)","1.5*x");
		simplifyTest("3*(x/2)","1.5*x");
		simplifyTest("3*(2/x)","6/x");
		// a-(b-c)
		simplifyTest("x/(3/2)","x/1.5");
		simplifyTest("2/(x/3)","6/x");
		simplifyTest("3/(2/x)","1.5*x");
		// (a-b)-c
		simplifyTest("(3/2)/x","1.5/x");
		simplifyTest("(3/x)/2","1.5/x");
		simplifyTest("(x/3)/2","x/6");


		simplifyTest("x*(3+2)","5*x");
		simplifyTest("3*(x+2)","6+3*x");
		simplifyTest("3*(2+x)","6+3*x");
		simplifyTest("(3+2)*x","5*x");
		simplifyTest("(3+x)*2","6+2*x");
		simplifyTest("(x+3)*2","6+x*2");

		simplifyTest("x*(3-2)","x");
		simplifyTest("3*(x-2)","-6+3*x");
		simplifyTest("3*(2-x)","6-3*x");
		simplifyTest("(3-2)*x","x");
		simplifyTest("(3-x)*2","6-2*x");
		simplifyTest("(x-3)*2","-6+2*x");

		simplifyTest("3+(x/4)","3+x/4");
		simplifyTest("2*(x/4)","0.5*x");
		simplifyTest("(2*(3+(x/4)))","6+0.5*x");
		simplifyTest("1+(2*(3+(x/4)))","7+0.5*x");
		simplifyTest("((3+(x/4))*2)+1","7+0.5*x");
		
	}

	public void testComplex() throws Exception
	{
		double tol = 0.00000001;

		complexValueTest("z=complex(3,2)",new Complex(3,2),tol);
		complexValueTest("z*z-z",new Complex(2,10),tol);
		complexValueTest("z^3",new Complex(-9,46),tol);
		complexValueTest("(z*z-z)/z",new Complex(2,2),tol);
		complexValueTest("w=polar(2,pi/2)",new Complex(0,2),tol);
		
	}

	public void testIf()  throws ParseException
	{
		valueTest("if(1,2,3)",2);		
		valueTest("if(-1,2,3)",3);		
		valueTest("if(0,2,3)",3);		
		valueTest("if(1,2,3,4)",2);		
		valueTest("if(-1,2,3,4)",3);		
		valueTest("if(0,2,3,4)",4);		
		valueTest("if(0>=0,2,3,4)",2);		
		valueTest("x=3",3);		
		valueTest("if(x==3,1,-1)",1);		
		valueTest("if(x!=3,1,-1)",-1);		
		valueTest("if(x>=3,1,-1)",1);		
		valueTest("if(x>3,1,-1)",-1);		
		valueTest("if(x<=3,1,-1)",1);		
		valueTest("if(x<3,1,-1)",-1);		
	}

	public void testAssign()  throws ParseException
	{
		valueTest("x=3",3);
		valueTest("y=3+4",7);
		valueTest("z=x+y",10);
		valueTest("a=b=c=z",10);
		valueTest("b",10);
		valueTest("d=f=a-b",0);
	}

						
	public void testDiff() throws ParseException
	{
		simplifyTest("diff(x^2,x)","2 x");
		simplifyTest("diff(x^3,x)","3 x^2");
		simplifyTest("diff(x,x)","1");
		simplifyTest("diff(1,x)","0");
		simplifyTest("diff(x^2+x+1,x)","2 x+1");
		simplifyTest("diff((x+x^2)*(x+x^3),x)","(1+2*x)*(x+x^3)+(x+x^2)*(1+3*x^2)");
		simplifyTest("diff((x+x^2)/(x+x^3),x)","((1+2*x)*(x+x^3)-(x+x^2)*(1+3*x^2))/((x+x^3)*(x+x^3))");
		simplifyTest("diff(sin(x),x)","cos(x)");
		simplifyTest("diff(-(x-5)^3,x)","-(3.0*(x-5.0)^2.0)");
		

		simplifyTest("diff((x+1)^2,x)","2+2*x");
		simplifyTest("diff((x+y)^2,x)","2*(x+y)");
		simplifyTest("diff((x+x^2)^3,x)","3*(x+x^2)^2*(1+2*x)");
		
		simplifyTest("diff(sin(x+1),x)","cos(x+1)");
		simplifyTest("diff(sin(x+x^2),x)","cos(x+x^2)*(1+2*x)");

		simplifyTest("diff(cos(x),x)","-sin(x)"); 	
		simplifyTest("diff(tan(x),x)","1/((cos(x))^2)");

		simplifyTest("diff(sec(x),x)","sec(x)*tan(x)");
		simplifyTest("diff(cosec(x),x)","-cosec(x) * cot(x)");
		simplifyTest("diff(cot(x),x)","-(cosec(x))^2");
		
		simplifyTest("diff(sec(x),x)","sec(x) * tan(x)");
		simplifyTest("diff(cosec(x),x)","-cosec(x) * cot(x)");
		simplifyTest("diff(cot(x),x)","-(cosec(x))^2");
			
		simplifyTest("diff(asin(x),x)","1/(sqrt(1-x^2))");
		simplifyTest("diff(acos(x),x)","-1/(sqrt(1-x^2))");
		simplifyTest("diff(atan(x),x)","1/(1+x^2)");

		simplifyTest("diff(sinh(x),x)","cosh(x)");
		simplifyTest("diff(cosh(x),x)","sinh(x)");
		simplifyTest("diff(tanh(x),x)","1-(tanh(x))^2");

		simplifyTest("diff(asinh(x),x)","1/(sqrt(1+x^2))");
		simplifyTest("diff(acosh(x),x)","1/(sqrt(x^2-1))");
		simplifyTest("diff(atanh(x),x)","1/(1-x^2)");

		simplifyTest("diff(sqrt(x),x)","1/(2 (sqrt(x)))");
		
		simplifyTest("diff(exp(x),x)","exp(x)");
//		simplifyTest("diff(pow(x,y),x)","y*(pow(x,y-1))");
//		simplifyTest("diff(pow(x,y),y)","(ln(x)) (pow(x,y))");
		simplifyTest("diff(ln(x),x)","1/x");
		simplifyTest("diff(log(x),x)","(1/ln(10)) /x");
		simplifyTest("diff(abs(x),x)","abs(x)/x");
		simplifyTest("diff(angle(x,y),x)","y/(x^2+y^2)");
		simplifyTest("diff(angle(x,y),y)","-x/(x^2+y^2)");
		simplifyTest("diff(mod(x,y),x)","1");
		simplifyTest("diff(mod(x,y),y)","0");
		simplifyTest("diff(sum(x,x^2,x^3),x)","sum(1,2 x,3 x^2)");

//		addDiffRule(new PassThroughDiffRule(this,"sum"));
//		addDiffRule(new PassThroughDiffRule(this,"re"));
//		addDiffRule(new PassThroughDiffRule(this,"im"));
//		addDiffRule(new PassThroughDiffRule(this,"rand"));
//		
//		MacroFunction complex = new MacroFunction("complex",2,"x+i*y",xjep);
//		xjep.addFunction("complex",complex);
//		addDiffRule(new MacroFunctionDiffRules(this,complex));
//		
//		addDiffRule(new PassThroughDiffRule(this,"\"<\"",new Comparative(0)));
//		addDiffRule(new PassThroughDiffRule(this,"\">\"",new Comparative(1)));
//		addDiffRule(new PassThroughDiffRule(this,"\"<=\"",new Comparative(2)));
//		addDiffRule(new PassThroughDiffRule(this,"\">=\"",new Comparative(3)));
//		addDiffRule(new PassThroughDiffRule(this,"\"!=\"",new Comparative(4)));
//		addDiffRule(new PassThroughDiffRule(this,"\"==\"",new Comparative(5)));
	}

	public void myAssertEquals(String msg,String actual,String expected)
	{
		if(!actual.equals(expected))
			System.out.println("Error \""+msg+"\" is \""+actual+" should be "+expected+"\"");
		assertEquals("<"+msg+">",expected,actual);
		System.out.println("Success: Value of \""+msg+"\" is \""+actual+"\"");
	}
	public void testAssignDiff() throws ParseException
	{
		simplifyTestString("y=x^5","y=x^5.0");
		simplifyTestString("z=diff(y,x)","z=5.0*x^4.0");
		Node n1 = ((DSymbolTable) j.getSymbolTable()).getPartialDeriv("y",new String[]{"x"}).getEquation();
		myAssertEquals("dy/dx","5.0*x^4.0",j.toString(n1));
		simplifyTestString("w=diff(z,x)","w=20.0*x^3.0");
		Node n2 = ((DSymbolTable) j.getSymbolTable()).getPartialDeriv("y",new String[]{"x","x"}).getEquation();
		myAssertEquals("d^2y/dxdx","20.0*x^3.0",j.toString(n2));
		j.getSymbolTable().clearValues();
		valueTest("x=2",2);
		valueTest("y",32); // x^5
		valueTest("z",80); // 5 x^4 
		valueTest("w",160); // 20 x^3
	}

	public void testMatrix() throws ParseException
	{
		j.getSymbolTable().clearValues();
		valueTest("x=2",2);
		valueTest("y=[x^3,x^2,x]","[8.0,4.0,2.0]");
		valueTest("z=diff(y,x)","[12.0,4.0,1.0]");
		valueTest("3*y","[24.0,12.0,6.0]");
		valueTest("y*4","[32.0,16.0,8.0]");
		valueTest("y*z","[[96.0,32.0,8.0],[48.0,16.0,4.0],[24.0,8.0,2.0]]");
		valueTest("z*y","[[96.0,48.0,24.0],[32.0,16.0,8.0],[8.0,4.0,2.0]]");
		valueTest("w=y^z","[-4.0,16.0,-16.0]");
		simplifyTestString("diff(w,x)","[3.0*x^2.0,2.0*x,1.0]^z+y^[6.0*x,2.0,0.0]");
		simplifyTestString("diff(y . z,x)","[3.0*x^2.0,2.0*x,1.0].z+y.[6.0*x,2.0,0.0]");
		valueTest("w.y",0.0);
		valueTest("w.z",0.0);
		valueTest("sqrt(w . z)",0.0);
		valueTest("sqrt([3,4].[3,4])",5.0); // tests result is unwrapped from scaler
		valueTest("y+z","[20.0,8.0,3.0]");
		valueTest("y-z","[-4.0,0.0,1.0]");
		j.getSymbolTable().clearValues();
		// the following two tests insure that ^ is printed correctly
		simplifyTestString("y^z","y^z");
		simplifyTestString("[8.0,4.0,2.0]^[12.0,4.0,1.0]","[8.0,4.0,2.0]^[12.0,4.0,1.0]");
		simplifyTestString("y=[cos(x),sin(x)]","y=[cos(x),sin(x)]");
		simplifyTestString("z=diff(y,x)","z=[-sin(x),cos(x)]");
		valueTest("y.y",1.0);
		valueTest("y.z",0.0);
		valueTest("z.z",1.0);
		j.getSymbolTable().clearValues();
		valueTest("x=[[1,2],[3,4]]","[[1.0,2.0],[3.0,4.0]]");
		valueTest("y=[1,-1]","[1.0,-1.0]");
		valueTest("x*y","[-1.0,-1.0]");			
		valueTest("y*x","[-2.0,-2.0]");
		valueTest("x+[y,y]","[[2.0,1.0],[4.0,3.0]]");	
		valueTest("ele(y,1)","1.0");              // Value: 2.0
		valueTest("ele(y,2)","-1.0");              // Value: 2.0
		valueTest("ele(x,[1,1])","1.0");          // Value: 2.0
		valueTest("ele(x,[1,2])","2.0");          // Value: 2.0
		valueTest("ele(x,[2,1])","3.0");          // Value: 2.0
		valueTest("ele(x,[2,2])","4.0");          // Value: 2.0
	}
	public void testBad() throws ParseException
	{
		if(SHOW_BAD)
		{
			simplifyTest("1&&(1||x)","1");
			simplifyTest("diff(sgn(x),x)","0");	// sgn not implemented
			simplifyTest("diff(re(x+i y),x)","1"); // not smart enought to work out re(i) = 1
			simplifyTest("diff(re(x+i y),y)","0");
			simplifyTest("diff(im(x+i y),x)","0");
			simplifyTest("diff(im(x+i y),y)","1");
			simplifyTest("(x/2)*3","x*1.5");
		}
	}
	*/
}
package org.lsmp.djepJUnit;

import junit.framework.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
import org.lsmp.djep.groupJep.interfaces.*;
import org.lsmp.djep.groupJep.values.*;
import org.lsmp.djep.groupJep.*;
import org.lsmp.djep.groupJep.groups.*;
import java.math.*;
/* @author rich
 * Created on 19-Nov-2003
 */

/**
 * Tests some strange properties of special groups.
 * 
 * @author Rich Morris
 * Created on 19-Nov-2003
 */
public class GroupJepTest extends TestCase {
	GroupJep j;
	public static final boolean SHOW_BAD=false;
	
	public GroupJepTest(String name) {
		super(name);
	}

	public static void main(String args[]) {
		// Create an instance of this class and analyse the file

		TestSuite suite= new TestSuite(GroupJepTest.class);
//		DJepTest jt = new DJepTest("DJepTest");
//		jt.setUp();
		suite.run(new TestResult());
	}	

	protected void setUp() {
	}

	public static Test suite() {
		return new TestSuite(GroupJepTest.class);
	}

	public void myAssertEquals(String msg,String expected,String actual)
	{
		if(!actual.equals(expected))
			System.out.println("Error \""+msg+"\" is \""+actual+" should be "+expected+"\"");
		assertEquals("<"+msg+">",expected,actual);
		System.out.println("Success: Value of \""+msg+"\" is \""+actual+"\"");
	}

	public void myAssertEquals(String msg,String expected,String actual,String ending)
	{
		if(!actual.equals(expected))
			System.out.println("Error \""+msg+"\" is \""+actual+" should be "+expected+"\"");
		assertEquals("<"+msg+">",expected,actual);
		System.out.println("Success: Value of \""+msg+"\" is \""+actual+"\": "+ending);
	}

	/** just test JUnit working OK */
	public void testGood()
	{
		assertEquals(1,1);
	}

	public void valueToStringTest(String expr,String expected) throws Exception
	{
		Node node = j.parse(expr);
		Object val = j.evaluate(node);
		String res = val.toString();
		String ending="";
		if(val instanceof HasComplexValueI)
		{
			Complex cval = ((HasComplexValueI) val).getComplexValue();
			ending = cval.toString();
		}
		myAssertEquals(expr,expected,res,ending);
	}

	/** Tests very large numbers, 20! */
	public void testZ() throws Exception
	{
		j = new GroupJep(new Integers());
		valueToStringTest("1*2*3*4*5*6*7*8*9*10*11*12*13*14*15*16*17*18*19*20","2432902008176640000");
	}

	/** Tests rationals */
	public void testQ() throws Exception
	{
		j = new GroupJep(new Rationals());
		System.out.println(j.getGroup().toString());
		valueToStringTest("(1/2)-(1/3)","1/6");
	}
	
	/** Tests Quaternions */
	public void testQuartonians() throws Exception
	{
		j = new GroupJep(new Quaternions());
		j.addStandardConstants();
		System.out.println(j.getGroup().toString());
		valueToStringTest("i*j","-k");
	}

	/** Tests integers mod 5 */
	public void testZn() throws Exception
	{
		j = new GroupJep(new Zn(BigInteger.valueOf(5)));
		System.out.println(j.getGroup().toString());
		valueToStringTest("2*3","1");
		valueToStringTest("2*4","3");
		valueToStringTest("3*3","4");
		valueToStringTest("3*4","2");
		valueToStringTest("4*4","1");

		valueToStringTest("2/3","4");
		valueToStringTest("2/4","3");
		valueToStringTest("3/2","4");
		valueToStringTest("3/4","2");
		valueToStringTest("4/2","2");
		valueToStringTest("4/3","3");
	}

	public void testZroot2() throws Exception
	{
		RingI ring = new Integers();
		Number coeffs[] = new Number[]{
			BigInteger.valueOf(-2),
			BigInteger.ZERO,
			BigInteger.ONE};
		Polynomial p1 = new Polynomial(ring,"rt2",coeffs);

		j = new GroupJep(new AlgebraicExtension(ring, p1));
		j.addStandardConstants();
		System.out.println(j.getGroup().toString());
		valueToStringTest("rt2*rt2","2");
		valueToStringTest("(rt2+1)*(rt2+1)","2 rt2+3");
	}
	
	public void testZ5thRootUnity() throws Exception
	{
		RingI ring = new Integers();
		Number coeffs[] = new Number[]{
			BigInteger.valueOf(-1),
			BigInteger.ZERO,
			BigInteger.ZERO,
			BigInteger.ZERO,
			BigInteger.ZERO,
			BigInteger.ONE};
		Polynomial p1 = new Polynomial(ring,"t",coeffs);

		j = new GroupJep(new AlgebraicExtension(ring, p1));
		j.addStandardConstants();
		System.out.println(j.getGroup().toString());
		valueToStringTest("t*t","t^2");
		valueToStringTest("t*t*t","t^3");
		valueToStringTest("t*t*t*t","t^4");
		valueToStringTest("t*t*t*t*t","1");
	}

	public void testZRoot2Root5() throws Exception
	{
		RingI ring = new Integers();
		Number coeffs1[] = new Number[]{
			BigInteger.valueOf(-2),
			BigInteger.ZERO,
			BigInteger.ONE};
		Polynomial p1 = new Polynomial(ring,"t",coeffs1);
		AlgebraicExtension an1 = new AlgebraicExtension(ring, p1);
		
		Number coeffs2[] = new Number[]{
			an1.valueOf("-5"),
			an1.valueOf("0"),
			an1.valueOf("1")};
		Polynomial p2 = new Polynomial(an1,"s",coeffs2);
		AlgebraicExtension an2 = new AlgebraicExtension(an1, p2);

		j = new GroupJep(an2);
		j.addStandardConstants();
		System.out.println(j.getGroup().toString());

		valueToStringTest("t","t");
		valueToStringTest("s","s");
		valueToStringTest("t*t","2");
		valueToStringTest("s*s","5");
		valueToStringTest("s*t","t s");
		valueToStringTest("s+t","s+t");
		valueToStringTest("(t-1)*(s-1)","(t-1) s-t+1");
	}

	public void testZtau() throws Exception
	{
		RingI ring = new Integers();
		Number coeffs[] = new Number[]{
			BigInteger.valueOf(-1),
			BigInteger.valueOf(-1),
			BigInteger.ONE};
		Polynomial p1 = new Polynomial(ring,"t",coeffs);

		AlgebraicExtension an = new AlgebraicExtension(ring, p1);
		j = new GroupJep(an);
		j.addStandardConstants();
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		System.out.println(j.getGroup().toString());
		valueToStringTest("t*t","t+1");
		valueToStringTest("t*t*t","2 t+1");
		valueToStringTest("t*t*t*t","3 t+2");
		valueToStringTest("t*t*t*t*t","5 t+3");
		valueToStringTest("t*t*t*t*t*t","8 t+5");
		valueToStringTest("x=2*t-1","2 t-1");
		valueToStringTest("x*x","5");
		valueToStringTest("-t","-t");
		valueToStringTest("1-t","-t+1");
		valueToStringTest("t*(1-t)","-1");
	}

	public void testPolynomials() throws Exception
	{
		RingI ring = new Reals();
		FreeGroup fg = new ExtendedFreeGroup(ring,"x");
		j = new GroupJep(fg);
		j.addStandardConstants();
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		Node n = j.parse("(x+7.6)*(x+5.8832)*(x-55.12)");	
		FreeGroupElement fge = (FreeGroupElement) j.evaluate(n);
		Number coeffs[] = fge.getCoeffs();
		for(int i=0;i<coeffs.length;++i)
			System.out.println("Coeffs ["+i+"] "+coeffs[i]);
		Complex val = fge.calculateComplexValue(new Complex(1.0));
		System.out.println("Value "+val);
		System.out.println(fge.toString());
		myAssertEquals("(x+7.6)*(x+5.8832)*(x-55.12): x=1.0","(-3203.6615424, 0.0)",val.toString());
		System.out.println("rounding error 7.6+5.8832-55.12 = "+(7.6+5.8832-55.12));

		FreeGroup fg2 = new ExtendedFreeGroup(fg,"y");
		j = new GroupJep(fg2);
		j.addStandardConstants();
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		Node n2 = j.parse("(x+1)*(y-2)");	
		FreeGroupElement fge2 = (FreeGroupElement) j.evaluate(n2);
		Number co1[] = fge2.getCoeffs();
		for(int i=0;i<co1.length;++i)
		{
			FreeGroupElement fge3 = (FreeGroupElement) co1[i];
			Number co2[] = fge3.getCoeffs();
			for(int jj=0;jj<co2.length;++jj)
				System.out.print(co2[jj]+"\t");
			System.out.println();
		}
		fg.setRootVal(new Complex(5.0));
		fg2.setRootVal(new Complex(4.0));
		System.out.println(fge2.toString());
		myAssertEquals("(x+1)*(y-2): x=5,y=4","(12.0, 0.0)",fge2.getComplexValue().toString());		

		valueToStringTest("a=5","5.0");
		valueToStringTest("z=x+y-1","y+x-1.0");
		valueToStringTest("z^a","y^5+(5.0 x-5.0) y^4+(10.0 x^2-20.0 x+10.0) y^3+(10.0 x^3-30.0 x^2+30.0 x-10.0) y^2+(5.0 x^4-20.0 x^3+30.0 x^2-20.0 x+5.0) y+x^5-5.0 x^4+10.0 x^3-10.0 x^2+5.0 x-1.0");
		
	}

	public void testPolynomials2() throws Exception
	{
		RingI ring = new Reals();
		FreeGroup fg = new ExtendedFreeGroup(ring,"x");
		FreeGroup fg2 = new ExtendedFreeGroup(fg,"y");
		j = new GroupJep(fg2);
		j.addStandardConstants();
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		
		String expr1 = "(3*2) x+34+23+3*2 y+4 x";
		Node node1 = j.parse(expr1);
		Object val1 = j.evaluate(node1);
		String res1 = val1.toString();
		System.out.println(expr1 +" -> "+res1);
		
		String expr2 = "6x+3y+4x+3(15x+7y)+40";
		Node node2 = j.parse(expr2);
		Object val2 = j.evaluate(node2);
		String res2 = val2.toString();
		System.out.println(expr2 +" -> "+res2);

	}
	public void testPolynomialCreator() throws Exception
	{
		RingI ring = new Reals();
		FreeGroup fg = new FreeGroup(ring,"x");

		JEP j2 = new JEP();
		j2.addStandardConstants();
		j2.addStandardFunctions();
		j2.setAllowUndeclared(true);
		
		Node n = j2.parse("(x+7.6)*(x+5.8832)*(x-55.12)");	
		PolynomialVisitor pv = new PolynomialVisitor(j2);
		Polynomial poly = pv.calcPolynomial(n,fg);
		Number coeffs[] = poly.getCoeffs();
		for(int i=0;i<coeffs.length;++i)
			System.out.println("Coeffs ["+i+"] "+coeffs[i]);
	}

	public void testBad() throws ParseException
	{
		if(SHOW_BAD)
		{
//			simplifyTest("1&&(1||x)","1");
//			simplifyTest("diff(sgn(x),x)","0");	// sgn not implemented
//			simplifyTest("diff(re(x+i y),x)","1"); // not smart enought to work out re(i) = 1
//			simplifyTest("diff(re(x+i y),y)","0");
//			simplifyTest("diff(im(x+i y),x)","0");
//			simplifyTest("diff(im(x+i y),y)","1");
//			simplifyTest("(x/2)*3","x*1.5");
		}
	}
}
package org.lsmp.djepJUnit;

import junit.framework.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/* @author rich
 * Created on 19-Nov-2003
 */

/**
 * @author Rich Morris
 * Created on 19-Nov-2003
 */
public class JepTest extends TestCase {
	JEP j;
	public static final boolean SHOW_BAD=false;
	
	public JepTest(String name) {
		super(name);
	}

	/**
	 * Create a test suite.
	 * @return the TestSuite
	 */
	public static Test suite() {
		return new TestSuite(JepTest.class);
	}

	/**
	 * Main entry point.
	 * @param args
	 */
	public static void main(String args[]) {
		// Create an instance of this class and analyse the file

		TestSuite suite= new TestSuite(JepTest.class);
		suite.run(new TestResult());
	}	
	/**
	 * Run before each test.
	 */
	protected void setUp() {
		j = new JEP();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		//j.setTraverse(true);
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
	}

	/**
	 * Assertion with message on command line.
	 * 
	 * @param msg message to display
	 * @param expected expected result
	 * @param actual actual result
	 */
	public void myAssertEquals(String msg,Object expected,Object actual)
	{
		if(!actual.equals(expected))
			System.out.println("Error: '"+msg+"' is '"+actual+"' should be '"+expected+"'");
		assertEquals("<"+msg+">",expected,actual);
		System.out.println("Success: Value of \""+msg+"\" is "+actual+"");
	}
	
	public void myAssertNaN(String msg,Object actual)
	{
		if(actual instanceof Double) {
			if(Double.isNaN( ((Double) actual).doubleValue()) ) {
				System.out.println("Success: Value of \""+msg+"\" is "+actual+"");
			}
			else {
				System.out.println("Error: \""+msg+"\" is '"+actual+"' should be NaN");
				assertTrue("<"+msg+"> is "+actual+" should be NaN",false);
			}
		}
		else {
			System.out.println("Error: '"+msg+"' is '"+actual+"' should be 'NaN'");
			assertTrue("<"+msg+">",false);
		}
	}


	/** Parse and evaluate an expression.
	 * 
	 * @param expr string to parse
	 * @return value after evaluate.
	 * @throws ParseException
	 */
	public Object calcValue(String expr) throws ParseException
	{
		Node n = j.parse(expr);
		return calcValue(n);
	}

	public Object calcValue(Node expr) throws ParseException
	{
		Object val = j.evaluate(expr);
		return val;
	}
	
	/**
	 * Test result j.evaluate(j.parse(expr))
	 * @param expr the expression to parse and evaluate
	 * @param expected result expected
	 * @throws Exception
	 */
	public void valueTest(String expr,Object expected) throws Exception
	{
		Object res = calcValue(expr);
		myAssertEquals(expr,expected,res);
	}

	public void valueTest(String expr,String expected) throws Exception
	{
		Object res = calcValue(expr);
		myAssertEquals(expr,expected,res.toString());
	}

	public void valueTestNaN(String expr) throws Exception
	{
		Object res = calcValue(expr);
		myAssertNaN(expr,res);
	}
	/**
	 * Test parse and evaluate which should give the result Integer(a).
	 * @param expr
	 * @param a expected value will be converted to an Integer.
	 * @throws Exception
	 */
	public void valueTestInt(String expr,int a) throws Exception
	{
		valueTest(expr,new Integer(a));
	}
	
	/** Test parse and evaluate with with a Double result.
	 * 
	 * @param expr
	 * @param a expected value will be converted to a Double.
	 * @throws Exception
	 */
	public void valueTest(String expr,double a) throws Exception
	{
		valueTest(expr,new Double(a));
	}

	public void valueTest(String expr,double a,double tol) throws Exception
	{
		Object res = calcValue(expr);
		if(res instanceof Double) {
			double val = ((Double) res).doubleValue();
			if(Math.abs(val-a)<tol) {
				System.out.println("Success value of \""+expr+"\" is "+res);
			}
			else {
				System.out.println("Error value of \""+expr+"\" is "+res+" should be "+a);
				assertEquals(expr,a,val,tol);
			}
		}
		else {
			System.out.println("Error value of \""+expr+"\" is "+res+" should be "+a);
			assertTrue("<"+expr+"> expected: <"+a+"> but was <"+res+">",false);
		}
	}

	/** Test parse-evaluate with complex number and given tollerence.
	 * 
	 * @param expr
	 * @param expected
	 * @param tol
	 * @throws Exception
	 */
	public void complexValueTest(String expr,Complex expected,double tol) throws Exception
	{
		Object res = calcValue(expr);
		if(expected.equals((Complex) res,tol))
			System.out.println("Success value of \""+expr+"\" is "+res);
		else {
			System.out.println("Error value of \""+expr+"\" is "+res+" should be "+expected);
			assertTrue("<"+expr+"> expected: <"+expected+"> but was <"+res+">",false);
		}
	}

	/////////////////// Tests ////////////////
	
	/** just test JUnit working OK */
	public void testGood()
	{
		myAssertEquals("1",new Double(1),new Double(1));
		myAssertNaN("NaN",new Double(Double.NaN));
	}

	public void testSimpleSum() throws Exception
	{
		valueTest("1+2",3);		
		valueTest("2*6+3",15);		
		valueTest("2*(6+3)",18);
	}
	
	public void testLogical() throws Exception
	{
		System.out.println("\nTesting logical operations");

		valueTest("T=1",1);
		valueTest("F=0",0);
		valueTest("!T",0);
		valueTest("!F",1);
		valueTest("!5",0);
		valueTest("-0==0",1);
		valueTest("!-5",0);
		valueTest("-!5==0",1);
		valueTest("-!0",-1);
		valueTest("-0",-0.0);
		valueTest("T&&T",1);
		valueTest("T&&F",0);
		valueTest("F&&T",0);
		valueTest("F&&F",0);
		valueTest("T||T",1);
		valueTest("T||F",1);
		valueTest("F||T",1);
		valueTest("F||F",0);
		calcValue("a=F"); calcValue("b=F"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=F"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=T"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=F"); calcValue("b=T"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);

		calcValue("a=T"); calcValue("b=F"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=F"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=T"); calcValue("c=F");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		calcValue("a=T"); calcValue("b=T"); calcValue("c=T");
		valueTest("(a&&(b||c)) == ((a&&b)||(a&&c))",1);
		valueTest("(a||(b&&c)) == ((a||b)&&(a||c))",1);
		
		j.addVariable("true",new Boolean(true));
		j.addVariable("false",new Boolean(false));
		valueTest("true==true",1);
		valueTest("false==false",1);
		valueTest("true==false",0);
		valueTest("true==true&&false==false",1);
		valueTest("if(true==true&&false==false,6,7)",6);
		valueTest("if(false&&true,6,7)",7);
		valueTest("if(true&&false==false,6,7)",6);
		valueTest("if((true&&true)==true,6,7)",6);
		valueTest("if((!false)==true,6,7)",6);
	}
	
	public void testFunction() throws Exception
	{
		System.out.println("\nTesting real functions");
		valueTest("abs(2.5)",2.5);
		valueTest("abs(-2.5)",2.5);
		valueTest("acos(1/sqrt(2))",Math.PI/4,0.00000001);
		valueTest("cos(pi/3)",0.5,0.00000001);
		valueTest("atan2(3,4)",Math.atan2(3.0,4.0),0.00000001);
		valueTest("2^4",16);
		valueTest("2^10",1024);
		valueTest("2^0.5",Math.sqrt(2),0.00000001);
		valueTest("2^(-0.5)",1.0/Math.sqrt(2),0.00000001);
		valueTest("2^(-4)",1.0/16,0.00000001);
		valueTest("2^(-10)",1.0/1024,0.00000001);
	}
	public void testComplex() throws Exception
	{
		System.out.println("\nTesting complex values");
		double tol = 0.00000001;

		complexValueTest("z=complex(3,2)",new Complex(3,2),tol);
		complexValueTest("z*z-z",new Complex(2,10),tol);
		complexValueTest("z^3",new Complex(-9,46),tol);
		complexValueTest("(z*z-z)/z",new Complex(2,2),tol);
		complexValueTest("w=polar(2,pi/2)",new Complex(0,2),tol);
		
		complexValueTest("ln(-1)",new Complex(0,Math.PI),tol);
		complexValueTest("sqrt(-1)",new Complex(0,1),tol);
		complexValueTest("pow(-1,0.5)",new Complex(0,1),tol);
		valueTest("arg(w)",Math.PI/2);
		valueTest("cmod(w)",2);
		valueTest("re(z)",3);
		valueTest("im(z)",2);
		complexValueTest("conj(z)",new Complex(3,-2),tol);
		complexValueTest("exp(pi i/2)",new Complex(0,1),tol);
		//complexValueTest("cos(z)",new Complex(3,-2),tol);
	}


	public void testIf()  throws Exception
	{
		System.out.println("\nTesting if statement");
		valueTest("if(1,2,3)",2);		
		valueTest("if(-1,2,3)",3);		
		valueTest("if(0,2,3)",3);		
		valueTest("if(1,2,3,4)",2);		
		valueTest("if(-1,2,3,4)",3);		
		valueTest("if(0,2,3,4)",4);		
		valueTest("if(0>=0,2,3,4)",2);		
		valueTest("x=3",3);		
		valueTest("if(x==3,1,-1)",1);		
		valueTest("if(x!=3,1,-1)",-1);		
		valueTest("if(x>=3,1,-1)",1);		
		valueTest("if(x>3,1,-1)",-1);		
		valueTest("if(x<=3,1,-1)",1);		
		valueTest("if(x<3,1,-1)",-1);		
	}

	public void testAssign()  throws Exception
	{
		System.out.println("\nTesting assignment of variables");
		valueTest("x=3",3);
		valueTest("y=3+4",7);
		valueTest("z=x+y",10);
		valueTest("a=b=c=z",10);
		valueTest("b",10);
		valueTest("d=f=a-b",0);
		valueTest("x=2",2);
		valueTest("(x*x)*x*(x*x)",32.0); // Works fine with Multiply
		new org.lsmp.djep.vectorJep.VectorJep();
		valueTest("(x*x)*x*(x*x)",32.0);
		// this created an error in 2.3.0b
		// as creating a VectorJep changed the operator set
		// and hence the broken MMultiply was used.								
	}

	public void testDotInName() throws ParseException,Exception
	{
		System.out.println("\nTesting names with dot in them");
		valueTest("x.x=3",3);
		valueTest("x.x+1",4);
	}


	public void testBinom() throws ParseException,Exception
	{
		System.out.println("\nTesting binomial coeffs");
		valueTestInt("binom(0,0)",1);
		valueTestInt("binom(1,0)",1);
		valueTestInt("binom(1,1)",1);
		valueTestInt("binom(2,0)",1);
		valueTestInt("binom(2,1)",2);
		valueTestInt("binom(2,2)",1);
		valueTestInt("binom(3,0)",1);
		valueTestInt("binom(3,1)",3);
		valueTestInt("binom(3,2)",3);
		valueTestInt("binom(3,3)",1);
		valueTestInt("binom(4,0)",1);
		valueTestInt("binom(4,1)",4);
		valueTestInt("binom(4,2)",6);
		valueTestInt("binom(4,3)",4);
		valueTestInt("binom(4,4)",1);
		valueTestInt("binom(5,0)",1);
		valueTestInt("binom(5,1)",5);
		valueTestInt("binom(5,2)",10);
		valueTestInt("binom(5,3)",10);
		valueTestInt("binom(5,4)",5);
		valueTestInt("binom(5,5)",1);

		valueTestInt("binom(6,0)",1);
		valueTestInt("binom(6,1)",6);
		valueTestInt("binom(6,2)",15);
		valueTestInt("binom(6,3)",20);
		valueTestInt("binom(6,4)",15);
		valueTestInt("binom(6,5)",6);
		valueTestInt("binom(6,6)",1);
		
		valueTestInt("binom(10,1)",10);
		valueTestInt("binom(10,5)",252);
	}
	
	public void testNaN() throws Exception
	{
		System.out.println("\nTesting for NaN");
		j.addVariable("x",new Double(Double.NaN));
		System.out.println("x=NaN");
		valueTestNaN("ln(x)");
		valueTestNaN("log(x)");
		valueTestNaN("sin(x)");
		valueTestNaN("x+x");
		valueTest("x!=x",1);
		valueTest("x==x",0);

		j.addVariable("y",new Double(Double.NaN));
		Node n = j.parse("x+5");
		System.out.println(calcValue(n));
		Node n2 = j.parse("y");
		System.out.println(calcValue(n2));
		valueTest("x == x+5",0);
		valueTest("x == 0/0",0);
		valueTest("x == x",0);
		valueTest("x == 0 * x",0);
		valueTest("x == 5",0);
		valueTest("x == y",0);
		valueTest("y == y",0);
		System.out.println("Set x to Double(5)");
		j.setVarValue("x",new Double(5));
		valueTest("x == x+5",0);
		valueTest("x == x",1);
	}
	
	public void testAssign2()
	{
		System.out.println("\nTesting for assignment using parseExpression and getValue");

		JEP parser = new JEP();

		parser.addVariable("AB",12);
		parser.addVariable("graph",new Object());
		parser.addVariable("graph1",(Double) null);
		parser.setAllowAssignment(true);
		parser.parseExpression("AB=3"); // AB = 8
		System.out.println("AB=3"+parser.getValue());
		parser.parseExpression("AB+2");
		double result= parser.getValue(); // Result = 17
		assertEquals("<AB+2>",5.0,result,0.0);
	}

	 boolean isExpressionValid(String expression) 
	 { 
		 JEP jep = j; 
		 try{ 
			 Node n = jep.parse(expression); 
			 System.out.println("expression " + expression + " \n Parsed value " + jep.hasError()); 
			 if(jep.hasError())
			 { 
				 System.out.println("jep.getErrorInfo " + jep.getErrorInfo()); 
				 return false; 
			 } 
			 System.out.println("jep.getSymbolTable " + jep.getSymbolTable());
			 System.out.println("Eval: " +jep.evaluate(n).toString());
			 return true; 
		 }
		 catch(Error e)
		 { 
			 System.out.println(e.getMessage()); 
			 if(jep.hasError()) 
			 System.out.println("Error is : " + jep.getErrorInfo()); 
			 return false; 
		 }
		 catch(Exception e1)
		 { 
			 System.out.println(e1.getMessage());  
			 if(jep.hasError()) 
			 System.out.println("Error is : " + jep.getErrorInfo()); 
			 return false; 
		 } 
	  
	 } 

	public void testNumParam() throws Exception
	{
		j.parse("if(3,1,2)");
		j.parse("if(4,1,2,3)");
		try
		{
			j.parse("if(5,1,2,3,4)");
			fail("Did not trap illegal number of arguments");
		}
		catch(ParseException e) {}
		j.parse("a1=1234");
		j.parse("a2=5678");
		j.parse("ApportionmentAmt=4321");
		j.parse("a4 = 2000 + (3000 /2000) + (3.45787 * 33544 - (212.223 /2000)) + + 1200");
		j.parse("a3 = if(a1 > 0 && ApportionmentAmt < 1000, if(a2 < 2000, if(a2 < 1000, 200, 0), if(a1 > 1000, if((2000 + (3000 /2000) + (3.45787 * 33544 - (212.223 /2000)) + 1200 + ApportionmentAmt / 2000 + ApportionmentAmt * ApportionmentAmt + 2000) > 0, 100, 200),200)), if(a1/a2 < 1000, a1/a2, 1, a1 * a2 + a1))");
		try
		{
		 j.parse("a3 = if(a1 > 0 && ApportionmentAmt < 1000, if(a2 < 2000, if(a2 < 1000, 200, 0), if(a1 > 1000, if((2000 + (3000 /2000) + (3.45787 * 33544 - (212.223 /2000)) + 1200 + ApportionmentAmt / 2000 + ApportionmentAmt * ApportionmentAmt + 2000) > 0, 100, 200)),200), if(a1/a2 < 1000, a1/a2, 1, a1 * a2 + a1))");
			fail("Did not trap illegal number of arguments");
		}
		catch(ParseException e) {}
/*		 double a1=0,a2=0,ApportionmentAmt=0;
		 double a3 = 
			 myif(
					 a1 > 0 && ApportionmentAmt < 1000, 
					 myif(
							 a2 < 2000, 
							 myif(a2 < 1000, 200, 0), 
							 myif(
									 a1 > 1000, 
									 myif(
											 (2000 + (3000 /2000) + (3.45787 * 33544 - (212.223 /2000)) + 1200 + ApportionmentAmt / 2000 + ApportionmentAmt * ApportionmentAmt + 2000) > 0,
											 100,
											 200
									 ),
									 333)), 
				myif(a1/a2 < 1000, a1/a2,  a1 * a2 + a1));


a3 = if(a1 > 0 && ApportionmentAmt < 1000, 
		if(a2 < 2000, 
			if(a2 < 1000, 200, 0), 
			if(a1 > 1000, 
				if(
					(2000 + (3000 /2000) + (3.45787 * 33544 - (212.223 /2000)) + 1200 + ApportionmentAmt / 2000 + ApportionmentAmt * ApportionmentAmt + 2000) > 0,
					100,
					200
				)
			),
			200
		),
		if(a1/a2 < 1000, a1/a2, 1, a1 * a2 + a1)
	)
*/
	}
	public void testUndeclared() throws Exception
	{
	    j.setAllowUndeclared(false);
	    try {
	        j.parse("zap * wow");
	        fail("Should have found undeclared error");
	    } catch(ParseException e) {
	        System.out.println("Error caught: "+e.getMessage());
	    }
	    try {
	        j.setVarValue("foo",new Double(5.0));
	        fail("Should have found a null pointer exception");
	    } catch(NullPointerException e) {
	        System.out.println("Expected error caught: "+e.getClass().getName()+": "+e.getMessage());
	    }
	}
	
	public void testBad() throws Exception
	{
		if(SHOW_BAD)
		{
			valueTest("recurse = recurse+1",null);
		}
	}
}
/* @author rich
 * Created on 22-Apr-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepJUnit;

import junit.framework.Test;
import junit.framework.TestResult;
import junit.framework.TestSuite;

import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.djep.DSymbolTable;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;

/**
 * @author Rich Morris
 * Created on 22-Apr-2005
 */
public class DJepTest extends XJepTest {

	public DJepTest(String name) {
		super(name);
	}

	public static Test suite() {
		return new TestSuite(DJepTest.class);
	}

	public static void main(String[] args) {
		TestSuite suite= new TestSuite(DJepTest.class);
		suite.run(new TestResult());
	}
	
	protected void setUp() {
		j = new DJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		//j.setTraverse(true);
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		((DJep) j).addStandardDiffRules();
	}

	public void testDiff() throws ParseException
	{
		System.out.println("\nTesting assignment");

		simplifyTest("diff(x^2,x)","2 x");
		simplifyTest("diff(x^3,x)","3 x^2");
		simplifyTest("diff(x,x)","1");
		simplifyTest("diff(1,x)","0");
		simplifyTest("diff(x^2+x+1,x)","2 x+1");
		simplifyTest("diff((x+x^2)*(x+x^3),x)","(1+2*x)*(x+x^3)+(x+x^2)*(1+3*x^2)");
		simplifyTest("diff((x+x^2)/(x+x^3),x)","((1+2*x)*(x+x^3)-(x+x^2)*(1+3*x^2))/((x+x^3)*(x+x^3))");

		simplifyTest("diff(y^x,x)","y^x*ln(y)");
		simplifyTest("diff(e^x,x)","e^x*ln(e)");

		simplifyTest("diff(sin(x),x)","cos(x)");

		simplifyTest("diff((x+1)^2,x)","2+2*x");
		simplifyTest("diff((x+y)^2,x)","2*(x+y)");
		simplifyTest("diff((x+x^2)^3,x)","3*(x+x^2)^2*(1+2*x)");
		
		simplifyTest("diff(sin(x+1),x)","cos(x+1)");
		simplifyTest("diff(sin(x+x^2),x)","cos(x+x^2)*(1+2*x)");

		simplifyTest("diff(cos(x),x)","-sin(x)"); 	
		simplifyTest("diff(tan(x),x)","1/((cos(x))^2)");

		simplifyTest("diff(sec(x),x)","sec(x)*tan(x)");
		simplifyTest("diff(cosec(x),x)","-cosec(x) * cot(x)");
		simplifyTest("diff(cot(x),x)","-(cosec(x))^2");
		
		simplifyTest("diff(sec(x),x)","sec(x) * tan(x)");
		simplifyTest("diff(cosec(x),x)","-cosec(x) * cot(x)");
		simplifyTest("diff(cot(x),x)","-(cosec(x))^2");
			
		simplifyTest("diff(asin(x),x)","1/(sqrt(1-x^2))");
		simplifyTest("diff(acos(x),x)","-1/(sqrt(1-x^2))");
		simplifyTest("diff(atan(x),x)","1/(1+x^2)");

		simplifyTest("diff(sinh(x),x)","cosh(x)");
		simplifyTest("diff(cosh(x),x)","sinh(x)");
		simplifyTest("diff(tanh(x),x)","1-(tanh(x))^2");

		simplifyTest("diff(asinh(x),x)","1/(sqrt(1+x^2))");
		simplifyTest("diff(acosh(x),x)","1/(sqrt(x^2-1))");
		simplifyTest("diff(atanh(x),x)","1/(1-x^2)");

		simplifyTest("diff(sqrt(x),x)","1/(2 (sqrt(x)))");
		
		simplifyTest("diff(exp(x),x)","exp(x)");
		simplifyTest("diff(ln(x),x)","1/x");
		simplifyTest("diff(log(x),x)","(1/ln(10)) /x");
		simplifyTest("diff(abs(x),x)","abs(x)/x");
		simplifyTest("diff(atan2(y,x),x)","y/(y^2+x^2)");
		simplifyTest("diff(atan2(y,x),y)","-x/(y^2+x^2)");
		simplifyTest("diff(mod(x,y),x)","1");
		simplifyTest("diff(mod(x,y),y)","0");
		simplifyTest("diff(sum(x,x^2,x^3),x)","sum(1,2 x,3 x^2)");

//		addDiffRule(new PassThroughDiffRule(this,"sum"));
//		addDiffRule(new PassThroughDiffRule(this,"re"));
//		addDiffRule(new PassThroughDiffRule(this,"im"));
//		addDiffRule(new PassThroughDiffRule(this,"rand"));
//		
//		MacroFunction complex = new MacroFunction("complex",2,"x+i*y",xjep);
//		xjep.addFunction("complex",complex);
//		addDiffRule(new MacroFunctionDiffRules(this,complex));
//		
//		addDiffRule(new PassThroughDiffRule(this,"\"<\"",new Comparative(0)));
//		addDiffRule(new PassThroughDiffRule(this,"\">\"",new Comparative(1)));
//		addDiffRule(new PassThroughDiffRule(this,"\"<=\"",new Comparative(2)));
//		addDiffRule(new PassThroughDiffRule(this,"\">=\"",new Comparative(3)));
//		addDiffRule(new PassThroughDiffRule(this,"\"!=\"",new Comparative(4)));
//		addDiffRule(new PassThroughDiffRule(this,"\"==\"",new Comparative(5)));
	}

	public void testAssignDiff() throws Exception
	{
		System.out.println("\nTesting assignment and diff");
		simplifyTestString("y=x^5","y=x^5.0");
		simplifyTestString("z=diff(y,x)","z=5.0*x^4.0");
		Node n1 = ((DSymbolTable) j.getSymbolTable()).getPartialDeriv("y",new String[]{"x"}).getEquation();
		myAssertEquals("dy/dx",((DJep) j).toString(n1),"5.0*x^4.0");
		simplifyTestString("w=diff(z,x)","w=20.0*x^3.0");
		Node n2 = ((DSymbolTable) j.getSymbolTable()).getPartialDeriv("y",new String[]{"x","x"}).getEquation();
		myAssertEquals("d^2y/dxdx",((DJep) j).toString(n2),"20.0*x^3.0");
		valueTest("x=2",2);
		valueTest("y",32); // x^5
		valueTest("z",80); // 5 x^4 
		valueTest("w",160); // 20 x^3
		simplifyTestString("diff(ln(y),x)","(1.0/y)*5.0*x^4.0");

	}

	public void testChainedVaraibles() throws Exception
	{
		simplifyTestString("x=5","x=5.0");
		simplifyTestString("y=x","y=x");
		simplifyTestString("z=y","z=y");
		simplifyTestString("w=diff(z,x)","w=1.0");
	}
}
package org.lsmp.djepJUnit;

import junit.framework.*;

import org.nfunk.jep.*;
import org.lsmp.djep.djep.*;
import org.lsmp.djep.rewrite.*;

/* @author rich
 * Created on 19-Nov-2003
 */

/**
 * @author Rich Morris
 * Created on 19-Nov-2003
 */
public class RewriteTest extends DJepTest {
	DJep j;
	public static final boolean SHOW_BAD=false;
	
	public RewriteTest(String name) {
		super(name);
	}

	public static void main(String args[]) {
		// Create an instance of this class and analyse the file

		TestSuite suite= new TestSuite(RewriteTest.class);
//		DJepTest jt = new DJepTest("DJepTest");
//		jt.setUp();
		suite.run(new TestResult());
	}	

	public static Test suite() {
		return new TestSuite(RewriteTest.class);
	}

	public void testRewrite() throws Exception
	{
		DJep j=new DJep();
		j.addStandardFunctions();
		j.addStandardConstants();
		j.setImplicitMul(true);    
		j.addComplex();
		j.setAllowUndeclared(true);    
		j.setAllowAssignment(true);    
		j.addStandardDiffRules();
		j.getPrintVisitor().setMaxLen(80);
        
		j.addVariable("x", 0);
		RewriteVisitor ev = new RewriteVisitor();
		RewriteRuleI expand = new ExpandBrackets(j);
		RewriteRuleI colectPower = new CollectPowers(j);
		RewriteRuleI rules[] = new RewriteRuleI[]{expand,colectPower};

		String expresions[] = new String[]{
			"x*x",
			"x*x^2",
			"x^2*x"		
		};
		for(int i=0;i<expresions.length;++i)
		{
			Node node = j.parse(expresions[i]);
			System.out.print("Eqn:\t");
			j.println(node);
			Node node2 = ev.rewrite(node,j,rules,true);
			System.out.print("Expand:\t");
			j.println(node2);
		}
	}

	public void testTaylor() throws Exception
	{
		DJep taylorParser=new DJep();
		taylorParser.addStandardFunctions();
		taylorParser.addStandardConstants();
		taylorParser.setAllowUndeclared(true);    
		taylorParser.setAllowAssignment(true);    
		taylorParser.setImplicitMul(true); 
		taylorParser.addComplex();
		taylorParser.addStandardDiffRules();
		taylorParser.getPrintVisitor().setMaxLen(80);
       
		taylorParser.addVariable("x", 0);
		RewriteVisitor ev = new RewriteVisitor();
		RewriteRuleI expand = new ExpandBrackets(taylorParser);
		RewriteRuleI colectPower = new CollectPowers(taylorParser);
		RewriteRuleI rules[] = new RewriteRuleI[]{expand,colectPower};
		
		Node node2 = taylorParser.parse("ln(1+x)");
		Node node3 = node2;
		for(int i=1;i<5;++i)
		{
			Node node4 = taylorParser.differentiate(node3,"x");
			System.out.println("Deriv "+i);
			taylorParser.println(node4);
			Node node5 = taylorParser.simplify(node4);
			System.out.println("Simp ");
			taylorParser.println(node5);
			Node node6 = ev.rewrite(node5,taylorParser,rules,true);
			System.out.println("Expand ");
			taylorParser.println(node6);

			node3 = node5;
		}
	}
	
	public void testMemory() throws Exception
	{
		DJep taylorParser=new DJep();
		taylorParser.addStandardFunctions();
		taylorParser.addStandardConstants();
		taylorParser.setAllowUndeclared(true);    
		taylorParser.setAllowAssignment(true);    
		taylorParser.setImplicitMul(true);    
		taylorParser.addComplex();
		taylorParser.addStandardDiffRules();
       
		taylorParser.addVariable("x", 0);
		/*
		try {
			Node node = taylorParser.parse("diff(diff(diff(diff(diff(diff(diff(diff(ln(x+1),x),x),x),x),x),x),x),x)");
			Node processed = taylorParser.preprocess(node);
			Node simp = taylorParser.simplify(processed); 
		}
		catch(OutOfMemoryError e) { System.out.println(e.getMessage()); e.printStackTrace(); }
		
//		System.out.println(taylorParser.toString(simp));
 		*/   
	}

	public void testBad() throws ParseException
	{
		if(SHOW_BAD)
		{
			simplifyTest("1&&(1||x)","1");
			simplifyTest("diff(sgn(x),x)","0");	// sgn not implemented
			simplifyTest("diff(re(x+i y),x)","1"); // not smart enought to work out re(i) = 1
			simplifyTest("diff(re(x+i y),y)","0");
			simplifyTest("diff(im(x+i y),x)","0");
			simplifyTest("diff(im(x+i y),y)","1");
			simplifyTest("(x/2)*3","x*1.5");
			simplifyTest("diff(pow(x,y),x)","y*(pow(x,y-1))");
			simplifyTest("diff(pow(x,y),y)","(ln(x)) (pow(x,y))");

			DJep j2 = new DJep();			
			j2.addStandardDiffRules();

		}
	}
}
/* @author rich
 * Created on 22-Apr-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepJUnit;

import org.lsmp.djep.matrixJep.MatrixJep;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;

import junit.framework.Test;
import junit.framework.TestResult;
import junit.framework.TestSuite;

/**
 * @author Rich Morris
 * Created on 22-Apr-2005
 */
public class MatrixJepTest extends DJepTest {

	/**
	 * @param name
	 */
	public MatrixJepTest(String name) {
		super(name);
		// TODO Auto-generated constructor stub
	}
	/**
	 * Create a test suite.
	 * @return the TestSuite
	 */
	public static Test suite() {
		return new TestSuite(MatrixJepTest.class);
	}

	/**
	 * Main entry point.
	 * @param args
	 */
	public static void main(String args[]) {
		// Create an instance of this class and analyse the file

		TestSuite suite= new TestSuite(MatrixJepTest.class);
		suite.run(new TestResult());
	}	

	protected void setUp() {
		j = new MatrixJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		//j.setTraverse(true);
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		((MatrixJep) j).addStandardDiffRules();
	}

	public Object calcValue(Node node) throws ParseException
	{
		Node matEqn = ((MatrixJep) j).preprocess(node);
		Object res = ((MatrixJep) j).evaluate(matEqn);
		return res;
	}

	public void testMatrix() throws Exception
	{
		j.getSymbolTable().clearValues();
		valueTest("x=2",2);
		valueTest("y=[x^3,x^2,x]","[8.0,4.0,2.0]");
		valueTest("z=diff(y,x)","[12.0,4.0,1.0]");
		valueTest("3*y","[24.0,12.0,6.0]");
		valueTest("y*4","[32.0,16.0,8.0]");
		valueTest("y*z","[[96.0,32.0,8.0],[48.0,16.0,4.0],[24.0,8.0,2.0]]");
		valueTest("z*y","[[96.0,48.0,24.0],[32.0,16.0,8.0],[8.0,4.0,2.0]]");
		valueTest("w=y^z","[-4.0,16.0,-16.0]");
		simplifyTestString("diff(w,x)","[3.0*x^2.0,2.0*x,1.0]^z+y^[6.0*x,2.0,0.0]");
		simplifyTestString("diff(y . z,x)","[3.0*x^2.0,2.0*x,1.0].z+y.[6.0*x,2.0,0.0]");
		valueTest("w.y",0.0);
		valueTest("w.z",0.0);
		valueTest("sqrt(w . z)",0.0);
		valueTest("sqrt([3,4].[3,4])",5.0); // tests result is unwrapped from scaler
		valueTest("y+z","[20.0,8.0,3.0]");
		valueTest("y-z","[-4.0,0.0,1.0]");
		j.getSymbolTable().clearValues();
		// the following two tests insure that ^ is printed correctly
		simplifyTestString("y^z","y^z");
		simplifyTestString("[8.0,4.0,2.0]^[12.0,4.0,1.0]","[8.0,4.0,2.0]^[12.0,4.0,1.0]");
		simplifyTestString("y=[cos(x),sin(x)]","y=[cos(x),sin(x)]");
		simplifyTestString("z=diff(y,x)","z=[-sin(x),cos(x)]");
		valueTest("y.y",1.0);
		valueTest("y.z",0.0);
		valueTest("z.z",1.0);
		j.getSymbolTable().clearValues();
		valueTest("x=[[1,2],[3,4]]","[[1.0,2.0],[3.0,4.0]]");
		valueTest("y=[1,-1]","[1.0,-1.0]");
		valueTest("x*y","[-1.0,-1.0]");			
		valueTest("y*x","[-2.0,-2.0]");
		valueTest("x+[y,y]","[[2.0,1.0],[4.0,3.0]]");	
		valueTest("ele(y,1)","1.0");              // Value: 2.0
		valueTest("ele(y,2)","-1.0");              // Value: 2.0
		valueTest("ele(x,[1,1])","1.0");          // Value: 2.0
		valueTest("ele(x,[1,2])","2.0");          // Value: 2.0
		valueTest("ele(x,[2,1])","3.0");          // Value: 2.0
		valueTest("ele(x,[2,2])","4.0");          // Value: 2.0
	}
	
	public void testLength() throws ParseException,Exception
	{
		valueTest("len(5)","1");
		valueTest("len([1,2,3])","3");
		valueTest("len([[1,2,3],[4,5,6]])","6");
		valueTest("size(5)","1");
		valueTest("size([1,2,3])","3");
		valueTest("size([[1,2,3],[4,5,6]])","[2,3]");
		valueTest("size([[[1,2],[3,4],[5,6]],[[7,8],[9,10],[11,12]]])","[2,3,2]");

		valueTest("diag([1,2,3])","[[1.0,0.0,0.0],[0.0,2.0,0.0],[0.0,0.0,3.0]]");
		valueTest("getdiag([[1,2],[3,4]])","[1.0,4.0]");
		valueTest("trans([[1,2],[3,4]])","[[1.0,3.0],[2.0,4.0]]");
		valueTest("det([[1,2],[3,4]])","-2.0");
		valueTest("det([[1,2,3],[4,5,6],[9,8,9]])","-6.0");
		valueTest("det([[1,2,3],[4,5,6],[7,8,9]])","0.0");
		valueTest("det([[1,2,3,4],[5,6,77,8],[4,3,2,1],[17,9,23,19]])","9100.0");

		valueTest("trace([[1,2],[3,4]])","5.0");
		valueTest("trace([[1,2,3],[4,5,6],[7,8,9]])","15.0");
		valueTest("trace([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])","34.0");

		valueTest("vsum([[1,2],[3,4]])","10.0");
		valueTest("vsum([1,2,3])","6.0");
		
		valueTest("Map(x^3,x,[1,2,3])","[1.0,8.0,27.0]");
		valueTest("Map(x*y,[x,y],[1,2,3],[4,5,6])","[4.0,10.0,18.0]");
		valueTest("Map(if(x>0,x,0),x,[-2,-1,0,1,2])","[0.0,0.0,0.0,1.0,2.0]");
		valueTest("Map(abs(x),x,[[-2,-1],[1,2]])","[[2.0,1.0],[1.0,2.0]]");
	}

	public void testDotInName() throws ParseException, Exception {
	}
	
	public void testVecCmp() throws Exception {
		valueTest("[1,2,3]==[1,2,3]",1);
		valueTest("[1,2,3]==[1,2,4]",0);
	}

	public void testVectorSum() throws Exception {
		valueTest("Sum([x,x^2],x,1,10)","[55.0,385.0]");
	}
	
	public void testTgtDev() throws Exception
	{
		parsePreprocSimp("v=[x,x^2.0,x^3.0]");
		parsePreprocSimp("l=7");
		parsePreprocSimp("v/l");
		parsePreprocSimp("dv=diff(v,x)");
		parsePreprocSimp("dotprod=dv.dv");
		parsePreprocSimp("length=sqrt(dotprod)");
		parsePreprocSimp("v+y*dv/length");
	}

	public void testComplexMatricies() throws Exception {
		valueTest("v=[1+i,1-2i]","[(1.0, 1.0),(1.0, -2.0)]");
		valueTest("vsum(v)","(2.0, -1.0)");
		valueTest("m=[[1+i,-1+i],[1-i,-1-i]]","[[(1.0, 1.0),(-1.0, 1.0)],[(1.0, -1.0),(-1.0, -1.0)]]");
		valueTest("vsum(m)","(0.0, 0.0)");
		valueTest("trace(m)","(0.0, 0.0)");
		valueTest("m*v","[(1.0, 5.0),(-1.0, 1.0)]");
		valueTest("v*m","[(-1.0, -1.0),(-5.0, 1.0)]");
		valueTest("trans(m)","[[(1.0, 1.0),(1.0, -1.0)],[(-1.0, 1.0),(-1.0, -1.0)]]");
		valueTest("det(m)","(0.0, -4.0)");
	}

	public void testSimpIf() throws Exception {
		MatrixJep mj = (MatrixJep) j;
		Node n = mj.parse("if(1,2,3)");
		Node pre = mj.preprocess(n);
		Node simp = mj.simplify(pre);
	}
/* TODO GenMat Not jet implemented for MatrixJep (can it be done?)
	public void testGenMatEle() throws Exception
	{
	    System.out.println("The following caused a problem as ele only acepted Double arguments");
	    valueTest("m=[1,2,3]","[1.0,2.0,3.0]");
	    valueTest("GenMat(3,ele(m,n)*10,n)","[10.0,20.0,30.0]");
	}
*/
}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.vectorJep.*;

/**
 * Compares the speed of matrix operations
 * using both VectorJep or MatrixJep.
 */
public class MatrixSpeed {
	static MatrixJep mj;
	static VectorJep vj;
	static int num_itts = 100000; // for normal use
//	static int num_itts = 1000;	  // for use with profiler
		
	public static void main(String args[])	{
		long t1 = System.currentTimeMillis();
		initVec();
		long t2 = System.currentTimeMillis();
		System.out.println("Vec initialise "+(t2-t1));
		initMat();
		long t3 = System.currentTimeMillis();
		System.out.println("Mat initialise "+(t3-t2));
		
		doBoth("y=[[1,2,3],[3,4,5],[6,7,8]]","y*y");
		doBoth("y=[[1,2,3],[3,4,5],[6,7,8]]","y+y");
		doBoth("y=[[1,2,3],[3,4,5],[6,7,8]]","y-y");
		doBoth("y=[[1,2,3],[3,4,5],[6,7,8]]","y*y+y");
		doBoth("y=[1,2,3]","y+y");
		doBoth("y=[1,2,3]","y . y");
		doBoth("y=[1,2,3]","y^^y");
	}
	
	public static void doBoth(String eqn1,String eqn2)
	{
		System.out.println("Testing speed for <"+eqn1+"> and <"+eqn2+">");
		doVec(eqn1,eqn2);
		doMat(eqn1,eqn2);
	}
	static void initVec()
	{
		vj = new VectorJep();
		vj.addStandardConstants();
		vj.addStandardFunctions();
		vj.addComplex();
		vj.setAllowUndeclared(true);
		vj.setImplicitMul(true);
		vj.setAllowAssignment(true);
	}
	
	static void doVec(String eqn1,String eqn2)
	{
	//	System.out.println("vec init"+(t4-t3));
		try
		{
			Node node1 = vj.parse(eqn1);
			vj.evaluate(node1);
			Node node = vj.parse(eqn2);
			long t1 = System.currentTimeMillis();
	//		System.out.println("vec parse"+(t1-t4));
			for(int i=0;i<num_itts;++i)
				vj.evaluate(node);
			long t2 = System.currentTimeMillis();
			System.out.println("Using VectorJep :"+(t2-t1));
		}
		catch(Exception e) {System.out.println("Error"+e.getMessage());}
	}
	
	static void initMat()
	{
		mj = new MatrixJep();
		mj.addStandardConstants();
		mj.addStandardFunctions();
		mj.addComplex();
		mj.setAllowUndeclared(true);
		mj.setImplicitMul(true);
		mj.setAllowAssignment(true);
	}
	
	static void doMat(String eqn1, String eqn2)
	{
		try
		{
			Node node2 = mj.simplify(mj.preprocess(mj.parse(eqn1)));
			mj.evaluate(node2);
			Node node3 = mj.simplify(mj.preprocess(mj.parse(eqn2)));
			long t1 = System.currentTimeMillis();
	//		System.out.println("mat parse"+(t1-t4));
			for(int i=0;i<num_itts;++i)
				mj.evaluateRaw(node3);
			long t2 = System.currentTimeMillis();
			System.out.println("Using MatrixJep :"+(t2-t1));
		}
		catch(Exception e) {System.out.println("Error"+e.getMessage());}
	}
}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;
/**
 * @author Rich Morris
 * Created on 26-Feb-2004
 */
public class PrintExample {

	public static void main(String[] args) {
		XJep j = new XJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.setAllowAssignment(true);

		try
		{
			// parse expression
			Node node = j.parse("a*b+c*(d+sin(x))");
			// print it
			j.println(node);
			// convert to string
			String str = j.toString(node);
			System.out.println("String is '"+str+"'");
			j.getPrintVisitor().setMode(PrintVisitor.FULL_BRACKET,true);
			j.println(node);
			
			j.getPrintVisitor().setMode(PrintVisitor.FULL_BRACKET,false);
			Node node2=j.parse("1*x^1+0");
			j.println(node2);
			Node simp=j.simplify(node2);
			j.println(simp);

		}
		catch(ParseException e) { System.out.println("Parse error"); }
	}
}
/* @author rich
 * Created on 22-Mar-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;

import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.lsmp.djep.xjep.XJep;
import org.lsmp.djep.sjep.Monomial;
import org.lsmp.djep.sjep.PConstant;
import org.lsmp.djep.sjep.PFunction;
import org.lsmp.djep.sjep.PNodeI;
import org.lsmp.djep.sjep.POperator;
import org.lsmp.djep.sjep.PVariable;
import org.lsmp.djep.sjep.Polynomial;
import org.lsmp.djep.sjep.PolynomialCreator;

/**
 * @author Rich Morris
 * Created on 22-Mar-2005
 */
public class SJepConsole extends DJepConsole
{
	private static final long serialVersionUID = -2796652887843007314L;
	PolynomialCreator pc = null;
	
	public static void main(String[] args)
	{
		Console c = new SJepConsole();
		c.run(args);
	}

	public String getPrompt()
	{
		return "SJep > ";
	}

	public void initialise()
	{
		super.initialise();
		pc = new PolynomialCreator((XJep) j);
	}

	public void printIntroText()
	{
		println("SJep: advanced simplification/expansion");
	}

	public void processEquation(Node node) throws ParseException
	{
		XJep xj = (XJep) j;

		Node pre = xj.preprocess(node);
		Node proc = xj.simplify(pre);
		print("Old simp:\t"); 
		println(xj.toString(proc));
		Node simp = pc.simplify(proc);
		print("New simp:\t"); 
		println(xj.toString(simp));

		PNodeI poly = pc.createPoly(proc);
		explain(poly,0);
		
		Node expand = pc.expand(proc);
		print("Expanded:\t"); 
		println(xj.toString(expand));

		Object val = xj.evaluate(simp);
		String s = xj.getPrintVisitor().formatValue(val);
		println("Value:\t\t"+s);
	}

	private void explain(PNodeI pnode,int depth) {
		// TODO Auto-generated method stub
		for(int i=0;i<depth;++i) print(" ");
		if(pnode instanceof Polynomial)
		{
			Polynomial poly = (Polynomial) pnode;
			println("Polynomial with "+poly.getNTerms()+" terms:");
			for(int i=0;i<poly.getNTerms();++i)
				explain(poly.getTerm(i),depth+1);
		}
		else if(pnode instanceof Monomial)
		{
			Monomial mon = (Monomial) pnode;
			print("Monomial with coefficient: ");
			print(mon.getCoeff().getValue().toString());
			println(" and "+mon.getNVars()+" variables:");
			for(int i=0;i<mon.getNVars();++i)
			{
				explain(mon.getVar(i),depth+1);
				for(int j=0;j<depth;++j) print(" ");
				println(" power:");
				explain(mon.getPower(i),depth+1);
			}
		}
		else if(pnode instanceof PConstant)
		{
			println("Constant: "+((PConstant) pnode).getValue().toString());
		}
		else if(pnode instanceof PVariable)
		{
			println("Variable: "+((PVariable) pnode).getVariable().toString());
		}
		else if(pnode instanceof PFunction)
		{
			PFunction fun = (PFunction) pnode;
			println("Function: "+fun.getName()+" with "+fun.getNArgs()+"arguments:");
			for(int i=0;i<fun.getNArgs();++i)
				explain(fun.getArg(i),depth+1);
		}
		else if(pnode instanceof POperator)
		{
			POperator fun = (POperator) pnode;
			println("Operator: "+fun.getName()+" with "+fun.getNArgs()+"arguments:");
			for(int i=0;i<fun.getNArgs();++i)
				explain(fun.getArg(i),depth+1);
		}
	}
}
package org.lsmp.djepExamples;
import java.util.Stack;

import org.nfunk.jep.*;

/**
* Example code illustrating how block control structures could be implemented.
* <p>
* Sample session
* <pre>
JEP > a=3
3.0
JEP > IF a>2
JEP  > IF a>3
JEP   > b=4
skipped
JEP   > ELSE
JEP   > b=3
3.0
JEP   > ENDIF
JEP  > ELSE
JEP  > b=2
skipped
JEP  > ENDIF
JEP > b
3.0
JEP >
*</pre>
*This code does currently allow looping statements.
**/

public class BlockStatments extends Console {
	
	private static final long serialVersionUID = 9035584745289937584L;

	/** Indicates current state where in */
	protected Stack states = new Stack();
	protected Stack conds= new Stack();
	
	/** Creates a new Console object and calls run() */
	public static void main(String args[]) {
		Console c = new BlockStatments();
		c.run(args);
	}

	/** 
	 * Catches macros which are not handled by JEP
	 * 
	 * @return false - stops further processing of the line
	 */
	public boolean testSpecialCommands(String command) 
	{	
		String trim = command.trim();
		if(trim.startsWith("IF "))
		{
			String tail = trim.substring(3);
			try
			{
				Node n = j.parse(tail);
				Object res = j.evaluate(n);
				if( (res instanceof Boolean && ((Boolean) res).booleanValue() )
						|| (res instanceof Number  && ((Number) res).intValue() != 0) )
					conds.push(Boolean.TRUE);
				else
					conds.push(Boolean.FALSE);
				states.push(Boolean.TRUE);
				return false;
			}
			catch(ParseException e) {
				handleError(e);
			}
		}
		if(command.equals("ELSE"))
		{
			states.pop();
			states.push(Boolean.FALSE);
			return false;
		}
		if(command.equals("ENDIF")) {
			if(states.isEmpty())
				println("ERROR: Too many ENDIF statements");
			states.pop();
			conds.pop();
			return false;
		}
		if(command.equals("states"))
		{
			print("STATES: ");
			for(int i=0;i<states.size();++i)
				if(((Boolean)states.elementAt(i)).booleanValue()) 
					 print("T");
				else print("F");
			println("");
			print("CONDS:  ");
			for(int i=0;i<conds.size();++i)
				if(((Boolean)conds.elementAt(i)).booleanValue()) 
					 print("T");
				else print("F");
			println("");
			return false;
		}
		return true;
	}

	/** Evaluates a node, but only if the state corresponds to the conditionValue.
	 * Also saves the result of evaluation in conditionValue for use in subsequent calls
	 *  
	 * @param node Node representing expression
	 * @throws ParseException if a Parse or evaluation error
	 */ 
	public void processEquation(Node node) throws ParseException
	{
		for(int i=0;i<states.size();++i)
			if(!states.elementAt(i).equals(conds.elementAt(i)))
			{
				println("skipped");
				return;
			}
		Object res = j.evaluate(node);
		println(res);
	}
	
	/** Prints introductory text. */
	public void printIntroText() {
		println("JEP Console with basic IF ELSE ENDIF nested block structure.");
		printStdHelp();
	}

	public String getPrompt() { 
		StringBuffer sb = new StringBuffer("JEP ");
		for(int i=0;i<states.size();++i)
			sb.append(' ');
		sb.append("> ");
		return sb.toString();
	}

	public void printHelp() {
		super.printHelp();
		println("'IF condition' begins a (true) block");
		println("'ELSE' begins a false block");
		println("'ENDIF' ends a block");
		println("'states' shows the current states and conditions");
	}

}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import java.util.Random;

import org.nfunk.jep.*;
import org.lsmp.djep.rpe.*;
/**
 * Compares the speed of evaluation between normal jep, rpe, and occasionally java.
 * <p>
 * If you have some nice complicated examples, I'd love to
 * hear about them to see if we can tune things up. - rich
 */
public class RpSpeed {
	static JEP j;
	static int num_itts = 1000000; // for normal use
//	static int num_itts = 1000;	  // for use with profiler
	static long seed; // seed for random number generator
	static int num_vals = 1000; // number of random numbers selected
	public static void main(String args[])	{
		long t1 = System.currentTimeMillis();
		initJep();
		long t2 = System.currentTimeMillis();
		System.out.println("Jep initialise "+(t2-t1));

		doAll("5",new String[]{});
		doAll("x",new String[]{"x"});
		doAll("1+x",new String[]{"x"});
		doAll("x^2",new String[]{"x"});
		doAll("x*x",new String[]{"x"});
		doAll("5*x",new String[]{"x"});
		doAll("cos(x)",new String[]{"x"});
		doCos();
		doAll("1+x+x^2",new String[]{"x"});
		doAll("1+x+x^2+x^3",new String[]{"x"});
		doAll("1+x+x^2+x^3+x^4",new String[]{"x"});
		doAll("1+x+x^2+x^3+x^4+x^5",new String[]{"x"});
		doAll("1+x(1+x(1+x(1+x(1+x))))",new String[]{"x"});
		doHorner();
		doAll("if(x>0.5,1,0)",new String[]{"x"});
		doAll("1*2*3+4*5*6+7*8*9",new String[]{});
		doAll("x1*x2*x3+x4*x5*x6+x7*x8*x9",new String[]{"x1","x2","x3","x4","x5","x6","x7","x8","x9"});
		doAll("cos(x)^2+sin(x)^2",new String[]{"x"});
	}
	
	/** Run speed comparison  between jep and rpe.
	 * 
	 * @param eqn The equation to test
	 * @param varNames an array of variable names which will be set to random values.
	 */
	public static void doAll(String eqn,String varNames[])
	{
		System.out.println("\nTesting speed for \""+eqn+"\"");
		seed = System.currentTimeMillis();
		try {
			j.parse(eqn);
		} catch(Exception e) {};
		Variable vars[] = new Variable[varNames.length];
		Double varVals[][] = new Double[varNames.length][num_vals];
		Random generator = new Random(seed);
		for(int i=0;i<vars.length;++i)
		{
			vars[i] = j.getVar(varNames[i]);
			for(int j=0;j<num_vals;++j)
				varVals[i][j] = new Double(generator.nextDouble());
		}
	
		long tj = doJep(eqn,vars,varVals);
		long tr = doRpe(eqn,vars,varVals);
		System.out.println("Speed up:\t"+(tj/tr));
		//System.out.println("<tr><td>"+eqn+"</td><td>"+tj+"</td><td>"+tr+"</td></tr>");
	}

	static void initJep()
	{
		j = new JEP();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.setAllowAssignment(true);
	}
	
	static long doJep(String eqn2,Variable vars[],Double vals[][])
	{
		long tdiff=0;
	//	System.out.println("vec init"+(t4-t3));
		try
		{
			Node node = j.parse(eqn2);
	//		System.out.println("vec parse"+(t1-t4));
			
			long t1 = System.currentTimeMillis();
			for(int i=0;i<num_itts;++i)
			{
				for(int j=0;j<vars.length;++j)
					vars[j].setValue(vals[j][i%num_vals]);
				j.evaluate(node);
			}
			long t2 = System.currentTimeMillis();
			tdiff = t2-t1;
			System.out.println("Using Jep:\t"+(t2-t1));
		}
		catch(Exception e) {System.out.println("Error"+e.getMessage());}
		return tdiff;
	}

	static long doRpe(String eqn2,Variable vars[],Double vals[][])
	{
		long tdiff=0;
		try
		{
			Node node3 = j.parse(eqn2);
			RpEval rpe = new RpEval(j);
			RpCommandList list = rpe.compile(node3);
			int refs[]=new int[vars.length];
			for(int i=0;i<vars.length;++i)
				refs[i]=rpe.getVarRef(vars[i]);
			long t1 = System.currentTimeMillis();
	//		System.out.println("mat parse"+(t1-t4));
			for(int i=0;i<num_itts;++i)
			{
				for(int j=0;j<vars.length;++j)
					rpe.setVarValue(refs[j],vals[j][i%num_vals].doubleValue());
				rpe.evaluate(list);
			}
			long t2 = System.currentTimeMillis();
			tdiff = t2-t1;
			System.out.println("Using RpEval2:\t"+(t2-t1));
			rpe.cleanUp();
		}
		catch(Exception e) {System.out.println("Error"+e.getMessage());e.printStackTrace();}
		return tdiff;
	}
	
	static void doCos()
	{
		Double varVals[] = new Double[num_vals];
		Random generator = new Random(seed);
		for(int j=0;j<num_vals;++j)
			varVals[j] = new Double(generator.nextDouble());
		
		long t1 = System.currentTimeMillis();
		double x; 
		double y;
		for(int i=0;i<num_itts;++i)
		{
			x = varVals[i%num_vals].doubleValue();
			double c = Math.cos(x);
			//double s = Math.sin(x);
			//y = c*c+s*s;
		}
		long t2 = System.currentTimeMillis();
		System.out.println("Using Java:\t"+(t2-t1));
	}

	static void doHorner()
	{
		Double varVals[] = new Double[num_vals];
		Random generator = new Random(seed);
		for(int j=0;j<num_vals;++j)
			varVals[j] = new Double(generator.nextDouble());
		
		long t1 = System.currentTimeMillis();
		double x; 
		double y;
		for(int i=0;i<num_itts;++i)
		{
			x = varVals[i%num_vals].doubleValue();
			y = 1+x*(1+x*(1+x*(1+x*(1+x))));
		}
		long t2 = System.currentTimeMillis();
		System.out.println("Using Java:\t"+(t2-t1));
	}
}
/*
Created 15-Jul-2006 - Richard Morris
*/
package org.lsmp.djepExamples;

import org.lsmp.djep.mrpe.*;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.lsmp.djep.matrixJep.*;

/** A Console application illustrating the use of the RPE evaluator.
 * The org.lsmp.djep.rpe package is intended to speed up multiple evaluation of the same equation
 * with different values for the variable. 
 * As each equation is only evaluated once this will not show a speed improvement. 
 * @author Richard Morris
 */
public class MRpConsole extends MatrixConsole {
	private static final long serialVersionUID = 2604208990249603097L;
	MRpEval rpe;

	public static void main(String[] args) {
		Console c = new MRpConsole();
		c.run(args);
	}

	public void initialise() {
		super.initialise();
		rpe = new MRpEval((MatrixJep)j);
	}

	public void processEquation(Node node) throws ParseException {
		MatrixJep mj = (MatrixJep) j;

		if(verbose) {
			print("Parsed:\t\t"); 
			println(mj.toString(node));
		}
		Node processed = mj.preprocess(node);
		if(verbose) {
			print("Processed:\t"); 
			println(mj.toString(processed));
		}
					
		Node simp = mj.simplify(processed);
		if(verbose) {
			print("Simplified:\t"); 
			println(mj.toString(simp));
		}	

		MRpCommandList list = rpe.compile(simp);
		MRpRes res = rpe.evaluate(list);
		println(res.toString());
	}

	public String getPrompt() {
		return "MRpe > ";
	}

	public void printIntroText() {
		println("MRpe Console.");
		printStdHelp();
	}

}
/*
 * Created on 16-Jun-2003 by Rich webmaster@pfaf.org
 * www.comp.leeds.ac.uk/pfaf/lsmp
 *
 * Adapted from :
 */

/*****************************************************************************

JEP - Java Math Expression Parser 2.24
	  December 30 2002
	  (c) Copyright 2002, Nathan Funk
	  See LICENSE.txt for license information.

*****************************************************************************/

/**
 * Console - JEP Example Applet
 * Copyright (c) 2000 Nathan Funk
 *
 * @author Nathan Funk 
 */

package org.lsmp.djepExamples;
import org.lsmp.djep.djep.*;
import org.nfunk.jep.*;
import java.applet.*;
import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

/**
* This class implements a simple command line utility for evaluating
* mathematical expressions.
*
*   Usage: java org.lsmp.djep.DJepConsole [expression]
*
* If an argument is passed, it is interpreted as an expression
* and evaluated. Otherwise, a prompt is printed, and the user can enter
* expressions to be evaluated. To exit from the command prompt a 'q' must
* be entered.
* typing 
* <pre>diff(x^2,x)</pre>
* will differentiate x^2 wrt 2. And
* <pre>eval(x^2,x,3)</pre> 
* will calculate x^2 at x=3.
* Expresions like
* <pre>eval(diff(diff(x^2+y^3,x),y),x,3,y,4)</pre>
* are also allowed.
*/
public class DJepApplet extends Applet implements ActionListener {
	/**
	 * 
	 */
	private static final long serialVersionUID = -2026659445630529741L;
	/**
	 * 
	 */
	/** Main JEP object */
	DJep j;	
	/** Input equation. */
	TextField inputTF;
	/** variable to differentiate wrt respect to. */
	TextField varTF;
	/** Output equation. */
	TextField outputTF;
	/** Button to perform differentiation. */
	Button but;
	
	/** Applet initialisation */
		
	public void init() 
	{
		initialise();
		setLayout(new GridLayout(3,2));
		inputTF = new TextField("sin(x^2)",50);
		outputTF = new TextField(50);
		outputTF.setEditable(false);
		varTF = new TextField("x",5);
		but = new Button("Calculate");
		but.addActionListener(this);
		inputTF.addActionListener(this);

		Panel p1 = new Panel();
		p1.add(new Label("Differentiate:"));
		p1.add(inputTF);
		add(p1);
		
		Panel p2 = new Panel();
		p2.add(new Label("with respect to:"));
		p2.add(varTF);
		p2.add(but);
		add(p2);
		
		Panel p3 = new Panel();
		p3.add(new Label("Result:"));
		p3.add(outputTF);
		add(p3);
	}
	
	/** Called when the Calculate button is pressed.
	 * Firsts differentiates the expresion in inputTF wrt variable in
	 * varTF, then simplifies it and puts results into outputTF.
	 */ 
	public void actionPerformed(ActionEvent e)
	{
			String command = inputTF.getText();
			j.parseExpression(command);
			if (j.hasError())
			{
				outputTF.setText(j.getErrorInfo());
			}
			else
			{
				// expression is OK, get the value
				try
				{
					Node diff = j.differentiate(j.getTopNode(),varTF.getText());
					Node simp = j.simplify(diff);
					if (j.hasError()) 
					{
						outputTF.setText(j.getErrorInfo());
					}
					else
						outputTF.setText(j.toString(simp));
				}
				catch(ParseException e1) { outputTF.setText("Parse Error: "+e1.getMessage()); }
				catch(IllegalArgumentException e2) { outputTF.setText(e2.getMessage()); }
				catch(Exception e3) { outputTF.setText(e3.getMessage()); }

				// did error occur during evaluation?
			}
		
	}
	
	/** Creates a new Console object and calls run() */
	public static void main(String args[]) {
		DJepApplet app = new DJepApplet();
		app.init();

		Frame mainFrame = new Frame("Wallpaper patterns");
		mainFrame.setBounds(0,0,200,200);
		mainFrame.add(app);
		mainFrame.show();
	}
	
	/** sets up all the needed objects. */
	public void initialise()
	{
		j = new DJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setAllowAssignment(true);
		j.setImplicitMul(true);
		j.addStandardDiffRules();
		//j.setTraverse(true);
	}
	
	
	
}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;

/**
 * Examples using assignment
 */
public class AssignmentExample {

	public static void main(String args[])
	{
		// standard initilisation
		JEP j = new JEP();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);

		// swith assignment facilities on
		j.setAllowAssignment(true);

		// parse assignment equations
		j.parseExpression("x=3");
		// evaluate it - no need to save the value returned
		j.getValueAsObject();
		// parse a second equation
		j.parseExpression("y=2");
		j.getValueAsObject();

		// an equation involving above variables
		j.parseExpression("x^y");
		Object val3 = j.getValueAsObject();
		System.out.println("Value is "+val3);
		
		try
		{
			// Alternative syntax
			Node node1 = j.parse("z=i*pi");
			j.evaluate(node1);
			Node node2 = j.parse("exp(z)");
			Object val2 = j.evaluate(node2);
			System.out.println("Value: "+val2);
			
			// getting and setting variable values
			Node node3 = j.parse("z=x^y");
			j.setVarValue("x",new Double(2));
			j.setVarValue("y",new Double(3));
			j.evaluate(node3);
			System.out.println(j.getVarValue("z")); // prints 8
		}
		catch(ParseException e)	{
			System.out.println("Error with parsing");
		}
		catch(Exception e)	{
			System.out.println("Error with evaluation");
		}
	}
}
/* @author rich
 * Created on 01-Apr-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;

import java.util.Enumeration;
import java.util.Vector;

import org.lsmp.djep.djep.DPrintVisitor;
import org.lsmp.djep.matrixJep.MatrixJep;
import org.lsmp.djep.matrixJep.MatrixVariableI;
import org.lsmp.djep.mrpe.MRpCommandList;
import org.lsmp.djep.mrpe.MRpEval;
import org.lsmp.djep.mrpe.MRpRes;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;

/**
 * An example of using MRpEval with differentation.
 * 
 * @author Rich Morris
 * Created on 01-Apr-2005
 */
public class MRpDiffExample {
	MatrixJep mj;
	MRpEval mrpe=null;
	MRpCommandList allCommands[];
	int xref,yref;
	double xmin = -1.0,xmax = 1.0,ymin=1.0,ymax=1.0;
	int xsteps = 100,ysteps = 100;

	public static void main(String args[]) {
		timePrint("\tStart");
		MRpDiffExample surf = new MRpDiffExample();
		timePrint("\tDone init");
		try {
		surf.compile("th=pi*x;phi=pi*y;f=[cos(th) cos(phi),sin(th) cos(phi),sin(phi)];dx=diff(f,x);dy=diff(f,y);dx^dy;");
		timePrint("\tDone parse");

		surf.calcMRPE();
		surf.mrpe.cleanUp();
		timePrint("\tDone mrpe");
		
		} catch(Exception e) { System.out.println(e.getClass().getName()+": "+e.getMessage()); }
	}
	static long oldTime = 0;
	public static void timePrint(String msg) {
		long time = System.currentTimeMillis();
		long timediff = time-oldTime;
		oldTime = time;
		System.out.println(""+timediff+"\t"+msg);
	}
	public MRpDiffExample() {

		mj = new MatrixJep();
		mj.setAllowAssignment(true);
		mj.setAllowUndeclared(true);
		mj.setImplicitMul(true);
		mj.addComplex();
		mj.addStandardConstants();
		mj.addStandardFunctions();
		mj.addStandardDiffRules();
		mrpe = new MRpEval(mj);
		//mj.getPrintVisitor().setMode(PrintVisitor.FULL_BRACKET,true);
		mj.getPrintVisitor().setMode(DPrintVisitor.PRINT_PARTIAL_EQNS,false);
	}

	/**
	 * Compile a sequence of equations.
	 * 
	 * @param text
	 */
	public void compile(String text)
	{
		mj.restartParser(text);
		try
		{
			Vector eqns = new Vector();
			Node n;
			while((n = mj.continueParsing())!=null) {
				Node n2 = mj.preprocess(n);
				Node n3 = mj.simplify(n2);
				eqns.add(n3);
			}
			// gets the top equation
			Node topEqn = (Node) eqns.get(eqns.size()-1);
			// differentiate it
			Node dx = mj.differentiate(topEqn,"x");
			Node dy = mj.differentiate(topEqn,"y");
			
			// create a list of all variables needed to 
			// successfully evaluate topEqn, dx, and dy
			Vector deps = mj.recursiveGetVarsInEquation(topEqn,new Vector());
			deps = mj.recursiveGetVarsInEquation(dx,deps);
			deps = mj.recursiveGetVarsInEquation(dy,deps);
			
			// Compile all equations needed for successful evaluation
			// of top, dx, dy
			Vector coms = new Vector();
			for(Enumeration en=deps.elements();en.hasMoreElements();) {
				MatrixVariableI var = (MatrixVariableI) en.nextElement();
				if(var.hasEquation()) {
					Node eqn = var.getEquation();
					System.out.print("Compiling "+var.getName()+"=");
					mj.println(eqn);
					coms.add(mrpe.compile(var,eqn));
				}
				else {
					// The variable has no equation
					System.out.println("Ignoring "+var.getName());
				}
			}
			// compile the top equation and derivatives
			System.out.print("Compiling ");	mj.println(topEqn);
			coms.add(mrpe.compile(topEqn));
			System.out.print("Compiling ");	mj.println(dx);
			coms.add(mrpe.compile(dx));
			System.out.print("Compiling ");	mj.println(dy);
			coms.add(mrpe.compile(dy));

			// put into any array
			int i=0;
			allCommands = new MRpCommandList[coms.size()];
			for(Enumeration en=coms.elements();en.hasMoreElements();++i)
				allCommands[i] = (MRpCommandList) en.nextElement();

			// finds the references for two variables
			xref = mrpe.getVarRef(mj.getVar("x"));
			yref = mrpe.getVarRef(mj.getVar("y"));
		}
		catch(ParseException e) {e.getMessage();}
	}

	public void calcMRPE() {
		double topRes[]=null,dxRes[]=null,dyRes[]=null;
		for(int i=0;i<=xsteps;++i) {
			double x = xmin + ((xmax - xmin)*i)/xsteps;
			mrpe.setVarValue(xref,x);
			for(int j=0;j<=ysteps;++j) {
				double y = ymin + ((ymax - ymin)*j)/ysteps;
				mrpe.setVarValue(yref,y);

				MRpRes res=null;
				for(int k=0;k<allCommands.length-3;++k)
					res = mrpe.evaluate(allCommands[k]);
				res = mrpe.evaluate(allCommands[allCommands.length-3]);
				topRes = (double []) res.toArray();
				res = mrpe.evaluate(allCommands[allCommands.length-2]);
				dxRes = (double []) res.toArray();
				res = mrpe.evaluate(allCommands[allCommands.length-1]);
				dyRes = (double []) res.toArray();
				
			}
		}
		System.out.println("top ["+topRes[0]+","+topRes[1]+","+topRes[2]+"]");
		System.out.println("dx ["+dxRes[0]+","+dxRes[1]+","+dxRes[2]+"]");
		System.out.println("dy ["+dyRes[0]+","+dyRes[1]+","+dyRes[2]+"]");
	}
}
/*
Created 15-Jul-2006 - Richard Morris
*/
package org.lsmp.djepExamples;

import org.lsmp.djep.rpe.*;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;

/** A Console application illustrating the use of the RPE evaluator.
 * The org.lsmp.djep.rpe package is intended to speed up multiple evaluation of the same equation
 * with different values for the variable. 
 * As each equation is only evaluated once this will not show a speed improvement. 
 * @author Richard Morris
 */
public class RpeConsole extends Console {
	private static final long serialVersionUID = 2604208990249603097L;
	RpEval rpe;

	public static void main(String[] args) {
		Console c = new RpeConsole();
		c.run(args);
	}

	public void initialise() {
		super.initialise();
		rpe = new RpEval(j);
	}

	public void processEquation(Node node) throws ParseException {
		RpCommandList list = rpe.compile(node);
		double val = rpe.evaluate(list);
		println(new Double(val));
	}

	public String getPrompt() {
		return "RPE > ";
	}

	public void printIntroText() {
		println("RPE Console.");
		printStdHelp();
	}

}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.*;
/**
 * Examples using vectors and matricies
 */
public class VectorExample {
	static VectorJep j;
	
	public static void main(String args[])	{
		j = new VectorJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.setAllowAssignment(true);

		// parse and evaluate each equation in turn
		
		doStuff("[1,2,3]");               // Value: [1.0,2.0,3.0]
		doStuff("[1,2,3].[4,5,6]");       // Value: 32.0
		doStuff("[1,2,3]^^[4,5,6]");      // Value: [-3.0,6.0,-3.0]
		doStuff("[1,2,3]+[4,5,6]");       // Value: [5.0,7.0,9.0]
		doStuff("[[1,2],[3,4]]");         // Value: [[1.0,2.0],[3.0,4.0]]
		doStuff("[[1,2],[3,4]]*[1,0]");   // Value: [1.0,3.0]
		doStuff("[1,0]*[[1,2],[3,4]]");   // Value: [1.0,2.0]
		doStuff("[[1,2],[3,4]]*[[1,2],[3,4]]");   // Value: [[7.0,10.0],[15.0,22.0]]
		doStuff("x=[1,2,3]");             // Value: [1.0,2.0,3.0]
		doStuff("x+x");                   // Value: [2.0,4.0,6.0]
		doStuff("x.x");                 // Value: 14.0
		doStuff("x^x");                  // Value: [0.0,0.0,0.0]
		doStuff("ele(x,2)");              // Value: 2.0
		doStuff("y=[[1,2],[3,4]]");       // Value: [[1.0,2.0],[3.0,4.0]]
		doStuff("y * y");                 // Value: [[7.0,10.0],[15.0,22.0]]
		doStuff("ele(y,[1,2])");          // Value: 2.0
	}

	public static void doStuff(String str)	{
		try	{
			Node node = j.parse(str);
			Object value = j.evaluate(node);
			System.out.println(str + "\tvalue " + value.toString());
		}
		catch(ParseException e) { System.out.println("Parse error "+e.getMessage()); }		
		catch(Exception e) { System.out.println("evaluation error "+e.getMessage()); e.printStackTrace(); }		
	}
}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
/**
 * Examples using vectors and matricies
 */
public class MatrixExample {
	static MatrixJep j;
	
	public static void main(String args[])	{
		j = new MatrixJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.setAllowAssignment(true);

		// parse and evaluate each equation in turn
		
		doStuff("[1,2,3]");               // Value: [1.0,2.0,3.0]
		doStuff("[1,2,3].[4,5,6]");       // Value: 32.0
		doStuff("[1,2,3]^[4,5,6]");      // Value: [-3.0,6.0,-3.0]
		doStuff("[1,2,3]+[4,5,6]");       // Value: [5.0,7.0,9.0]
		doStuff("[[1,2],[3,4]]");         // Value: [[1.0,2.0],[3.0,4.0]]
		doStuff("[[1,2],[3,4]]*[1,0]");   // Value: [1.0,3.0]
		doStuff("[1,0]*[[1,2],[3,4]]");   // Value: [1.0,2.0]
		doStuff("[[1,2],[3,4]]*[[1,2],[3,4]]");   // Value: [[7.0,10.0],[15.0,22.0]]
		// vectors and matricies can be used with assignment
		doStuff("x=[1,2,3]");             // Value: [1.0,2.0,3.0]
		doStuff("x+x");                   // Value: [2.0,4.0,6.0]
		doStuff("x . x");                 // Value: 14.0
		doStuff("x^x");                  // Value: [0.0,0.0,0.0]
		doStuff("y=[[1,2],[3,4]]");       // Value: [[1.0,2.0],[3.0,4.0]]
		doStuff("y * y");                 // Value: [[7.0,10.0],[15.0,22.0]]
		// accessing the elements on an array or vector
		doStuff("ele(x,2)");              // Value: 2.0
		doStuff("ele(y,[1,2])");          // Value: 2.0
		// using differentation
		doStuff("x=2");					  // 2.0
		doStuff("y=[x^3,x^2,x]");		  // [8.0,4.0,2.0]
		doStuff("z=diff(y,x)");			  // [12.0,4.0,1.0]
		doStuff("diff([x^3,x^2,x],x)");
		System.out.println("dim(z) "+((MatrixVariableI) j.getVar("z")).getDimensions());
	}

	public static void doStuff(String str)	{
		try	{
			Node node = j.parse(str);
			Node proc = j.preprocess(node);
			Node simp = j.simplify(proc);
			Object value = j.evaluate(simp);
			//j.println(proc);
			j.print(simp);
			System.out.print("\t dim "+((MatrixNodeI) simp).getDim());
			System.out.println("\tvalue " + value.toString());
		}
		catch(ParseException e) { System.out.println("Parse error "+e.getMessage()); }		
		catch(Exception e) { System.out.println("evaluation error "+e.getMessage()); e.printStackTrace(); }		
	}
}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.rpe.*;
/**
 * Examples using vectors and matricies
 */
public class RpExample {
	static JEP j;
	
	public static void main(String args[])	{
		j = new JEP();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.setAllowAssignment(true);

		// parse and evaluate each equation in turn
		
		doStuff("1*2*3+4*5*6+7*8*9");
		doAll(new String[]{"x1=1","x2=2","x3=3","x4=4","x5=5","x6=6","x7=7","x8=8","x9=9",
			"x1*x2*x3+x4*x5*x6+x7*x8*x9"});
		doAll(new String[]{"x=0.7","cos(x)^2+sin(x)^2"});
	}

	public static void extendedPrint(RpCommandList list) throws ParseException
	{
		int num = list.getNumCommands();
		for(int i=0;i<num;++i)
		{
			RpCommand com=list.getCommand(i);
			int type = com.getType();
			int ref = com.getRef();
			if(type == RpEval.CONST) {
				double val = com.getConstantValue();
				System.out.println("Constant\t"+val+"\t"+ref);
			}
			else if(type == RpEval.VAR) {
				Variable var = com.getVariable();
				System.out.println("Variable\t"+var.toString()+"\t"+ref);
			}
			else if(type == RpEval.FUN) {
				String name = com.getFunction();
				System.out.println("Function\t"+name+"\t"+ref);
			}
			else {
				System.out.println("Operator\t"+com.toString());
			}
		}
	}

	public static void doStuff(String str)	{
		try	{
			Node node = j.parse(str);

			RpEval rpe = new RpEval(j);
			RpCommandList list = rpe.compile(node);
			double res = rpe.evaluate(list);

			// conversion to String
			System.out.println("Expression:\t"+str+"\nresult\t" + res);
			
			// List of commands
			System.out.println("Commands:");
			//System.out.println(list.toString());
			extendedPrint(list);
			System.out.println();
		}
		catch(ParseException e) { System.out.println("Parse error "+e.getMessage()); }		
		catch(Exception e) { System.out.println("evaluation error "+e.getMessage()); e.printStackTrace(); }		
	}

	public static void doAll(String str[])	{
		try	{
			RpEval rpe = new RpEval(j);

			for(int i=0;i<str.length;++i)
			{
				Node node = j.parse(str[i]);
				RpCommandList list = rpe.compile(node);
				double res = rpe.evaluate(list);

				// conversion to String
				System.out.println("Expression "+i+":\t"+str[i]+"\nresult\t" + res);
			
				// List of commands
				System.out.println("Commands:");
				//System.out.println(list.toString());
				extendedPrint(list);
				System.out.println();
			}

		}
		catch(ParseException e) { System.out.println("Parse error "+e.getMessage()); }		
		catch(Exception e) { System.out.println("evaluation error "+e.getMessage()); e.printStackTrace(); }		
	}
}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.mrpe.MRpCommandList;
import org.lsmp.djep.mrpe.MRpEval;
import org.lsmp.djep.mrpe.MRpRes;
import org.lsmp.djep.vectorJep.values.*;
/**
 * Examples using fast reverse polish calculator with vectors and matrices
 */
public class MRpExample {
	static MatrixJep mj;
	static MRpEval rpe;
	
	public static void main(String args[])	{
		mj = new MatrixJep();
		mj.addStandardConstants();
		mj.addStandardFunctions();
		mj.addComplex();
		mj.setAllowUndeclared(true);
		mj.setImplicitMul(true);
		mj.setAllowAssignment(true);
		rpe = new MRpEval(mj);
		// parse and evaluate each equation in turn
		
		doStuff("[1,2,3]");               // Value: [1.0,2.0,3.0]
		doStuff("[1,2,3].[4,5,6]");       // Value: 32.0
		doStuff("[1,2,3]^[4,5,6]");      // Value: [-3.0,6.0,-3.0]
		doStuff("[1,2,3]+[4,5,6]");       // Value: [5.0,7.0,9.0]
		doStuff("[[1,2],[3,4]]");         // Value: [[1.0,2.0],[3.0,4.0]]
		doStuff("[[1,2],[3,4]]*[1,0]");   // Value: [1.0,3.0]
		doStuff("[1,0]*[[1,2],[3,4]]");   // Value: [1.0,2.0]
		doStuff("[[1,2],[3,4]]*[[1,2],[3,4]]");   // Value: [[7.0,10.0],[15.0,22.0]]
		// vectors and matrices can be used with assignment
		doStuff("x=[1,2,3]");             // Value: [1.0,2.0,3.0]
		doStuff("x+x");                   // Value: [2.0,4.0,6.0]
		doStuff("x . x");                 // Value: 14.0
		doStuff("x^x");                  // Value: [0.0,0.0,0.0]
		doStuff("y=[[1,2],[3,4]]");       // Value: [[1.0,2.0],[3.0,4.0]]
		doStuff("y * y");                 // Value: [[7.0,10.0],[15.0,22.0]]
		// accessing the elements on an array or vector
//		doStuff("ele(x,2)");              // Value: 2.0
//		doStuff("ele(y,[1,2])");          // Value: 2.0
		// using differentation
//		doStuff("x=2");					  // 2.0
//		doStuff("y=[x^3,x^2,x]");		  // [8.0,4.0,2.0]
//		doStuff("z=diff(y,x)");			  // [12.0,4.0,1.0]
//		doStuff("diff([x^3,x^2,x],x)");
//		System.out.println("dim(z) "+((MatrixVariableI) mj.getVar("z")).getDimensions());
	}

	public static void doStuff(String str)	{
		try	{
			Node node = mj.parse(str);
			Node proc = mj.preprocess(node);
			Node simp = mj.simplify(proc);

	
			MRpCommandList list = rpe.compile(simp);
			MRpRes res = rpe.evaluate(list);

			mj.print(node);
			
			// conversion to String
			System.out.println("\nres " + res.toString());
			
			// conversion to MatrixValueI
			MatrixValueI mat = res.toVecMat(); 
			System.out.println("matrix " + mat.toString());
			
			// conversion to array
			if(res.getDims().is1D())
			{
				double vecArray[] = (double []) res.toArray();
				System.out.print("[");
				for(int i=0;i<vecArray.length;++i) System.out.print(""+vecArray[i]+" ");
				System.out.println("]");
			}
			else if(res.getDims().is2D())
			{
				double matArray[][] = (double [][]) res.toArray();
				System.out.print("[");
				for(int i=0;i<matArray.length;++i) {
					System.out.print("[");
					for(int j=0;j<matArray[i].length;++j)
						System.out.print(""+matArray[i][j]+" ");
					System.out.print("]");
				}
				System.out.println("]");
			}
			// List of commands
			System.out.println("Commands");
			System.out.println(list.toString());
		}
		catch(ParseException e) { System.out.println("Parse error "+e.getMessage()); }		
		catch(Exception e) { System.out.println("evaluation error "+e.getMessage()); e.printStackTrace(); }		
	}
}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.mrpe.MRpCommandList;
import org.lsmp.djep.mrpe.MRpEval;
import org.lsmp.djep.vectorJep.*;
/**
 * Compares the speed of matrix operations
 * using mrpe, vectorJep and matrixJep.
 */
public class MRpSpeed {
	static MatrixJep mj;
	static VectorJep vj;
	static int num_itts = 100000; // for normal use
//	static int num_itts = 1000;	  // for use with profiler
		
	public static void main(String args[])	{
		if(args.length>0)
			num_itts = Integer.parseInt(args[0]);
		System.out.println("VectorJep, MatrixJep, MRPEval Speed comparison");
		System.out.println("Number of iterations: "+num_itts);
		long t1 = System.currentTimeMillis();
		initVec();
		long t2 = System.currentTimeMillis();
		System.out.println("Vec initialise "+(t2-t1));
		initMat();
		long t3 = System.currentTimeMillis();
		System.out.println("Mat initialise "+(t3-t2));

		doRawAdd();		
		doObjAdd();		
		doRawMult();		
		doObjMult();		

		doAll(new String[]{"y=[[1,2,3],[4,5,6],[7,8,9]]"},"y*y");

		doAll(new String[]{},"y=[[1,2,3],[4,5,6],[7,8,9]]");
		doAll(new String[]{"y=[[1,2,3],[4,5,6],[7,8,9]]"},"z=y*y");
		doAll(new String[0],"[[1,2,3],[4,5,6],[7,8,9]]*[[1,2,3],[4,5,6],[7,8,9]]");

		doAll(new String[]{"y=[[1,2,3],[4,5,6],[7,8,9]]"},"y+y");
		doAll(new String[]{"y=[[1,2,3],[4,5,6],[7,8,9]]"},"y-y");

		doAll(new String[]{"y=[[1,2,3],[4,5,6],[7,8,9]]"},"y*y+y");
		
		doAll(new String[]{"x=[1,2,3]","y=[[1,2,3],[4,5,6],[7,8,9]]"},"x*y");
		doAll(new String[]{"x=[1,2,3]","y=[[1,2,3],[4,5,6],[7,8,9]]"},"y*x");
		
		doAll(new String[]{"y=[1,2,3]"},"y+y");
		doAll(new String[]{"y=[1,2,3]"},"y . y");
		doAll(new String[]{"y=[1,2,3]"},"y^^y");
		
		doAll(new String[]{"y=[[1,2],[3,4]]"},"y*y");
		doAll(new String[]{"y=[[1,2],[3,4]]"},"y+y");
		doAll(new String[]{"y=[[1,2],[3,4]]"},"y-y");
		doAll(new String[]{"y=[[1,2],[3,4]]"},"y*y+y");
		
		doAll(new String[]{"x=[1,2]","y=[[1,2],[3,4]]"},"x*y");
		doAll(new String[]{"x=[1,2]","y=[[1,2],[3,4]]"},"y*x");
		
		doAll(new String[0],"1*2*3+4*5*6+7*8*9");
		doAll(new String[]{"x1=1","x2=2","x3=3","x4=4","x5=5","x6=6","x7=7","x8=8","x9=9"},
			"x1*x2*x3+x4*x5*x6+x7*x8*x9");
		doAll(new String[]{"y=[1,2,3,4,5]"},"y+y");
		doAll(new String[]{"y=[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]]"},"y*y");
		doAll(new String[]{"x=0.7"},"cos(x)^2+sin(x)^2");
	
		for(int scale=2;scale<=6;++scale) {
			StringBuffer sb = new StringBuffer("y=[");
			int k=1;
			for(int i=0;i<scale;++i) {
				if(i>0)  sb.append(',');
				sb.append('[');
				for(int j=0;j<scale;++j) {
					if(j>0) sb.append(',');
					sb.append(k);
					++k;
				}
				sb.append(']');
			}
			sb.append(']');
			doAll(new String[]{sb.toString()},"y*y");
		}
	}
	
	public static void doAll(String eqns[],String eqn2)
	{
		System.out.println("\nTesting speed for <"+eqn2+"> Where ");
		for(int i=0;i<eqns.length;++i) System.out.println("\t"+eqns[i]);
		long v = doVec(eqns,eqn2);
		long m = doMat(eqns,eqn2);
		long r = doRpe(eqns,eqn2);
		if(m!=0 && r!=0)
			System.out.println("v/m "+v/m+" v/r "+v/r+" m/r "+m/r);
		//System.out.println("<tr><td>"+eqn2+"</td><td>"+v+"</td><td>"+m+"</td><td>"+r+"</td></tr>");
	}

	static void initVec()
	{
		vj = new VectorJep();
		vj.addStandardConstants();
		vj.addStandardFunctions();
		vj.addComplex();
		vj.setAllowUndeclared(true);
		vj.setImplicitMul(true);
		vj.setAllowAssignment(true);
	}
	
	static long doVec(String eqns[],String eqn2)
	{
	//	System.out.println("vec init"+(t4-t3));
		try
		{
			for(int i=0;i<eqns.length;++i)	{
				Node node2 = vj.parse(eqns[i]);
				vj.evaluate(node2);
			}
			Node node = vj.parse(eqn2);
			long t1 = System.currentTimeMillis();
	//		System.out.println("vec parse"+(t1-t4));
			for(int i=0;i<num_itts;++i)
				vj.evaluate(node);
			long t2 = System.currentTimeMillis();
			Object res = vj.evaluate(node);
			System.out.print("Using VectorJep:\t"+(t2-t1));
			System.out.println("\t"+res.toString());			
			return t2-t1;
		}
		catch(Exception e) {System.out.println("Error"+e.getMessage());}
		return 0;
	}
	
	static void initMat()
	{
		mj = new MatrixJep();
		mj.addStandardConstants();
		mj.addStandardFunctions();
		mj.addComplex();
		mj.setAllowUndeclared(true);
		mj.setImplicitMul(true);
		mj.setAllowAssignment(true);
	}
	
	static long doMat(String eqns[], String eqn2)
	{
		try
		{
			for(int i=0;i<eqns.length;++i)	{
				Node node2 = mj.simplify(mj.preprocess(mj.parse(eqns[i])));
				mj.evaluate(node2);
			}
			Node node3 = mj.simplify(mj.preprocess(mj.parse(eqn2)));
			long t1 = System.currentTimeMillis();
	//		System.out.println("mat parse"+(t1-t4));
			for(int i=0;i<num_itts;++i)
				mj.evaluateRaw(node3);
			long t2 = System.currentTimeMillis();
			System.out.print("Using MatrixJep:\t"+(t2-t1));
			Object res = mj.evaluate(node3);
			System.out.println("\t"+res.toString());			
			return t2-t1;
		}
		catch(Exception e) {System.out.println("Error"+e.getMessage());}
		return 0;
	}
	
	static long doRpe(String eqns[], String eqn2)
	{
		try
		{
			for(int i=0;i<eqns.length;++i)	{
				Node node2 = mj.simplify(mj.preprocess(mj.parse(eqns[i])));
				mj.evaluate(node2);
			}
			Node node3 = mj.simplify(mj.preprocess(mj.parse(eqn2)));
			MRpEval rpe = new MRpEval(mj);
			MRpCommandList list = rpe.compile(node3);
			long t1 = System.currentTimeMillis();
	//		System.out.println("mat parse"+(t1-t4));
			for(int i=0;i<num_itts;++i)
				rpe.evaluate(list);
			long t2 = System.currentTimeMillis();
			System.out.print("Using MRpEval:\t\t"+(t2-t1));
			Object res = rpe.evaluate(list);
			System.out.println("\t"+res.toString());			
			rpe.cleanUp();
			return t2-t1;
		}
		catch(Exception e) {System.out.println("Error"+e.getMessage());e.printStackTrace();}
		return 0;
	}


	static void doRawAdd()
	{
		double mat1[][] = new double[][]{{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};
		double mat2[][] = new double[][]{{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};
		double mat3[][] = new double[3][3];
		
		long t1 = System.currentTimeMillis();
		for(int i=0;i<num_itts;++i)
		{
			for(int row=0;row<3;++row)
				for(int col=0;col<3;++col)
					mat3[row][col] = mat1[row][col]+mat2[row][col];
		}
		long t2 = System.currentTimeMillis();
		System.out.println("RawAdd:"+(t2-t1)+"\tTime to add two double[3][3] arrays");
	}

	static void doRawMult()
	{
		double mat1[][] = new double[][]{{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};
		double mat2[][] = new double[][]{{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};
		double mat3[][] = new double[3][3];
		
		long t1 = System.currentTimeMillis();
		for(int i=0;i<num_itts;++i)
		{
			for(int row=0;row<3;++row)
				for(int col=0;col<3;++col)
				{
					mat3[row][col] = mat1[row][0] * mat2[0][col];
					for(int j=1;j<3;++j)
						mat3[row][col] += mat1[row][j] * mat2[j][col];
				}
		}
		long t2 = System.currentTimeMillis();
		System.out.println("RawMult:"+(t2-t1)+"\tTime to multiply two double[3][3] arrays");
	}

	static void doObjAdd()
	{
		Double mat1[][] = new Double[][]{{new Double(1.0),new Double(2.0),new Double(3.0)},{new Double(4.0),new Double(5.0),new Double(6.0)},{new Double(7.0),new Double(8.0),new Double(9.0)}};
		Double mat2[][] = new Double[][]{{new Double(1.0),new Double(2.0),new Double(3.0)},{new Double(4.0),new Double(5.0),new Double(6.0)},{new Double(7.0),new Double(8.0),new Double(9.0)}};
		Double mat3[][] = new Double[3][3];
		
		long t1 = System.currentTimeMillis();
		for(int i=0;i<num_itts;++i)
		{
			for(int row=0;row<3;++row)
				for(int col=0;col<3;++col)
					mat3[row][col] = new Double(mat1[row][col].doubleValue()+mat2[row][col].doubleValue());
		}
		long t2 = System.currentTimeMillis();
		System.out.println("ObjAdd:"+(t2-t1)+"\tTime to add two Double[3][3] arrays");
	}

	static void doObjMult()
	{
		Double mat1[][] = new Double[][]{{new Double(1.0),new Double(2.0),new Double(3.0)},
					{new Double(4.0),new Double(5.0),new Double(6.0)},
					{new Double(7.0),new Double(8.0),new Double(9.0)}};
		Double mat2[][] = new Double[][]{{new Double(1.0),new Double(2.0),new Double(3.0)},
				{new Double(4.0),new Double(5.0),new Double(6.0)},
				{new Double(7.0),new Double(8.0),new Double(9.0)}};
		Double mat3[][] = new Double[3][3];
		
		long t1 = System.currentTimeMillis();
		for(int i=0;i<num_itts;++i)
		{
			for(int row=0;row<3;++row)
				for(int col=0;col<3;++col)
				{
//					mat2[row][col] = new Double(mat1[row][0].doubleValue() * mat1[0][col].doubleValue());
					double tmp = mat1[row][0].doubleValue() * mat2[0][col].doubleValue();
					for(int j=1;j<3;++j)
//						mat2[row][col] = new Double(mat2[row][col].doubleValue() + 
//							mat1[row][j].doubleValue() * mat1[j][col].doubleValue());
						tmp +=  
							mat1[row][j].doubleValue() * mat2[j][col].doubleValue();
					mat3[row][col] = new Double(tmp);	
				}
		}
		long t2 = System.currentTimeMillis();
		System.out.println("ObjMult:"+(t2-t1)+"\tTime to multiply two Double[3][3] arrays");
	}
}
/* @author rich
 * Created on 21-Mar-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;
import org.lsmp.djep.djep.DPrintVisitor;
import org.lsmp.djep.xjep.*;
import org.nfunk.jep.*;
import java.text.NumberFormat;
import java.util.Enumeration;
/**
 * @author Rich Morris
 * Created on 21-Mar-2005
 */
public class XJepConsole extends Console
{
	private static final long serialVersionUID = -3239922790774093668L;
	protected NumberFormat format=null;
	protected boolean verbose = false;
	
	public static void main(String[] args)
	{
		Console c = new XJepConsole();
		c.run(args);
	}
	
	public String getPrompt()
	{
		return "XJep > ";
	}

	public void initialise()
	{
		j = new XJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setAllowAssignment(true);
		j.setImplicitMul(true);
	}

	public void printHelp()
	{
		super.printHelp();
		println("'setMaxLen 80'\tensures all lines and < 80 chars");
		println("'setDP 3'\tonly prints 3 decimal places");
		println("'setFullBrackets true'\tprints equations with full bracketing");
		println("'setComplexI true'\tprint complex numbers in form x+iy");
		println("'invalidate'\tmarks all variables as invalid, forcing reevaluation");
		println("eg 'x=5','y=2*x' gives value 10, 'invalidate', 'x=6', 'y' gives value 12");
	}

	public void printIntroText()
	{
		println("XJep Console");
		super.printStdHelp();
	}

	public void printOps()
	{
		println("Known operators");
		Operator ops[] = j.getOperatorSet().getOperators();
		int maxPrec = -1;
		for(int i=0;i<ops.length;++i)
			if(((XOperator) ops[i]).getPrecedence()>maxPrec) maxPrec=((XOperator) ops[i]).getPrecedence();
		for(int jj=-1;jj<=maxPrec;++jj)
			for(int i=0;i<ops.length;++i)
				if(((XOperator) ops[i]).getPrecedence()==jj)
					println(((XOperator) ops[i]).toFullString());
	}

	public boolean testSpecialCommands(String command)
	{
		if(!super.testSpecialCommands(command)) return false;
		XJep xj = (XJep) this.j;

		if( command.equals("invalidate"))
		{
			resetVars();
			return false;
		}

		if(command.startsWith("setMaxLen"))
		{
			String words[] = split(command);
			int len = Integer.parseInt(words[1]);
			xj.getPrintVisitor().setMaxLen(len);
			return false;
		}
		if(command.startsWith("setDp"))
		{
			String words[] = split(command);
			int dp = Integer.parseInt(words[1]);
			
			format = NumberFormat.getInstance();
			xj.getPrintVisitor().setNumberFormat(format);
			format.setMaximumFractionDigits(dp);
			format.setMinimumFractionDigits(dp);

			return false;
		}
		if(command.startsWith("setFullBrackets"))
		{
			String words[] = split(command);
			if(words.length>1 && words[1].equals("true"))
				xj.getPrintVisitor().setMode(PrintVisitor.FULL_BRACKET,true);
			else
				xj.getPrintVisitor().setMode(PrintVisitor.FULL_BRACKET,true);
			return false;
		}
		if(command.startsWith("setComplexI"))
		{
			String words[] = split(command);
			if(words.length>1 && words[1].equals("true"))
				xj.getPrintVisitor().setMode(PrintVisitor.COMPLEX_I,true);
			else
				xj.getPrintVisitor().setMode(PrintVisitor.COMPLEX_I,true);
			return false;
		}
		if(command.startsWith("verbose"))
		{
			String words[] = split(command);
			if(words.length<2)
				println("verbose should be on or off");
			else if(words[1].equals("on"))
				verbose = true;
			else if(words[1].equals("off"))
				verbose = true;
			else
				println("verbose should be on or off");
			return false;
		}

		return true;
	}

	public void processEquation(Node node) throws ParseException
	{
		XJep xj = (XJep) j;
		if(xj.getPrintVisitor().getMode(PrintVisitor.FULL_BRACKET))	{
			print("Node:\t"); 
			xj.println(node);
		}
		Node processed = xj.preprocess(node);
		if(processed==null) return;
		if(xj.getPrintVisitor().getMode(PrintVisitor.FULL_BRACKET))	{
			print("Processed:\t"); 
			xj.println(processed);
		}
		Node simp = xj.simplify(processed);
		print("Simplified:\t"); 
		println(xj.toString(simp));
		Object val = xj.evaluate(simp);
		String s = xj.getPrintVisitor().formatValue(val);
		println("Value:\t\t"+s);
	}

	public void printVars() {
		PrintVisitor pv = ((XJep) j).getPrintVisitor();
		SymbolTable st = j.getSymbolTable();
		pv.setMode(DPrintVisitor.PRINT_PARTIAL_EQNS,!verbose);

		println("Variables:");
		for(Enumeration  loop = st.keys();loop.hasMoreElements();)
		{
			String s = (String) loop.nextElement();
			XVariable var = (XVariable) st.getVar(s);
			println("\t"+var.toString(pv));
		}
		pv.setMode(DPrintVisitor.PRINT_PARTIAL_EQNS,true);
	}

	public void resetVars()
	{
		this.j.getSymbolTable().clearValues();
	}

}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;

/**
 * Examples using differentation
 */
public class XJepExample {

	public static void main(String args[])
	{
		/* initilisation */
		XJep j = new XJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setAllowAssignment(true);
		j.setImplicitMul(true);

		try
		{
			Node node10 = j.parse("x=3");
			Node node11 = j.preprocess(node10);
			System.out.println(j.evaluate(node11));
			Node node12 = j.parse("y=x^2");
			Node node13 = j.preprocess(node12);
			System.out.println(j.evaluate(node13));
			Node node14 = j.parse("z=y+x");
			Node node15 = j.simplify(j.preprocess(node14));
			System.out.println(j.evaluate(node15));

			// If a variable is changed then any expresion tree
			// it depends on needs to be re-evaluated to bring
			// values of other variables upto date
			j.setVarValue("x",new Double(4));
			System.out.println(j.evaluate(node13));
			System.out.println(j.evaluate(node15));
			System.out.println("z: "+j.getVarValue("z").toString());
			
			// the findVarValue method will automatically
			// re-calculate the value of variables specified by
			// equations if needed. However a lazy
			
			j.setVarValue("x",new Double(5));
			System.out.println("j.setVarValue(\"x\",new Double(5));");
			System.out.println("j.findVarValue(y): "+j.calcVarValue("y").toString());
			System.out.println("j.findVarValue(z): "+j.calcVarValue("z").toString());

			// if j.getSymbolTable().clearValues();
			// is called before values of equations are set
			// then the values of intermediate equations
			// are automatically calculated, so you can jump
			// straight to the chase: no need to calculate 
			// y explititly to find the value of z.
			j.getSymbolTable().clearValues();
			j.setVarValue("x",new Double(6));
			System.out.println("j.setVarValue(\"x\",new Double(6));");
			System.out.println("j.findVarValue(z): "+j.calcVarValue("z").toString());

			j.getSymbolTable().clearValues();
			j.setVarValue("x",new Double(7));
			System.out.println(j.evaluate(node15));
			System.out.println("z: "+j.getVarValue("z").toString());
			
			// now see if reentrancy works
			
			j.restartParser("x=1; // semi colon; in comment \ny=2; z=3;");
			Node node21;
			while((node21 = j.continueParsing()) != null)
				j.println(node21);
		}
		catch(ParseException e)
		{
			System.out.println("Error with parsing");
		}
		catch(Exception e)
		{
			System.out.println("Error with evaluation");
		}
	}
}
/* @author rich
 * Created on 28-Mar-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;

import java.util.Observable;
import java.util.Observer;
import java.util.Enumeration;
import org.nfunk.jep.SymbolTable;
import org.nfunk.jep.Variable;
import org.nfunk.jep.Node;
/**
 * @author Rich Morris
 * Created on 28-Mar-2005
 */
public class ObserverConsole extends DJepConsole implements Observer
{
	private static final long serialVersionUID = 5393968786564920519L;

	public void update(Observable arg0, Object arg1)
	{
		if(arg0 instanceof Variable)
		{
			if(arg1 instanceof Node)
				println("Equation changed: "+arg0);
			else
				println("Var changed: "+arg0);
		}
		else if(arg0 instanceof SymbolTable.StObservable)
		{
			println("New var: "+arg1);
			((Variable) arg1).addObserver(this);
		}
	}

	public void initialise()
	{
		super.initialise();
		SymbolTable st = j.getSymbolTable();
		st.addObserver(this);
		st.addObserverToExistingVariables(this);

		for(Enumeration en = st.elements();en.hasMoreElements();) {
			Variable var = (Variable) en.nextElement();
			println("Existing variable "+var);
			//var.addObserver(this);
		}
	}

	public static void main(String args[]) {
		Console c = new ObserverConsole();
		c.run(args);
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

/*****************************************************************************

JEP - Java Math Expression Parser 2.24
	  December 30 2002
	  (c) Copyright 2002, Nathan Funk
	  See LICENSE.txt for license information.

*****************************************************************************/

/**
 * Console - JEP Example Applet
 * Copyright (c) 2000 Nathan Funk
 *
 * @author Nathan Funk , Richard Morris
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import java.io.*;
import java.util.*;
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/**
* This class implements a simple command line utility for evaluating
* mathematical expressions.
* <pre>
*   Usage: java org.lsmp.djepExamples.Console [expression]
* </pre>
* If an argument is passed, it is interpreted as an expression
* and evaluated. Otherwise, a prompt is printed, and the user can enter
* expressions to be evaluated. 
* 
* <p>
* This class and its subclasses can also be run as a java applet 
* which displays a textarea for interactive input.
* <p>
* This class has been designed to be sub classed to allow different
* consol applications.
* The methods
* <pre>
* public void initialise()
* public void processEquation(Node node) throws Exception
* public boolean testSpecialCommands(String command)
* public void printPrompt()
* public void printIntroText()
* public void printHelp()
* </pre>
* can all be overwritten.
* </p>
* <p>
* Furthermore main should be overwritten. For example
* <pre> 
* 	public static void main(String args[]) {
*		Console c = new DJepConsole();
*		c.run(args);
*	}
*</pre>
*<p>
*The main input loop is approximately
*<pre>
* initialise();
* printIntroText();
* print(getPrompt());
* String command;
* while((command = getCommand()) != null) 
* {
*	if(command.equals("quit") || command.equals("exit"))
*		break;
*	if(!testSpecialCommands(command)) continue;
*   try {
*	  Node n = j.parse(command);
*	  processEquation(n);
*   } catch(Exception e) {}
*	print(getPrompt());
* }
*</pre>
*/

public class Console extends Applet implements KeyListener {
	
	private static final long serialVersionUID = 9035584745289937584L;

	/** Main JEP object */
	protected JEP j;	
	
	/** The input reader */
	private BufferedReader br;

	/** Text area for user input in applets. */
	protected TextArea ta = null;
		
	/** Constructor */
	public Console() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}

	/** Applet initialization */
		
	public void init() 
	{
		initialise();
		this.setLayout(new BorderLayout(1,1));
		ta = new TextArea("",10,80,TextArea.SCROLLBARS_BOTH);
		ta.setEditable(true);
		ta.addKeyListener(this);
		add("Center",ta);
		printIntroText();
		print(getPrompt());
	}

	/** sets up all the needed objects. */
	public void initialise()
	{
		j = new JEP();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setAllowAssignment(true);
		j.setImplicitMul(true);
	}

	/** Creates a new Console object and calls run() */
	public static void main(String args[]) {
		Console c = new Console();
		c.run(args);
	}

	/** The main entry point with command line arguments 
	 */
	public void run(String args[]) {
		initialise();
		 
		if (args.length>0) {
			for (int i=1; i<args.length; i++)
			{
				processCommand(args[i]);
			}
		}
		else
			inputLoop();
	}

	/**
	 * The main input loop for interactive operation.
	 * Repeatedly calls getCommand() and processCommand().
	 */
	public void inputLoop() {
		String command="";
				
		printIntroText();
		print(getPrompt());
		while((command = getCommand()) != null) 
		{
			if( !processCommand(command)) break;
			print(getPrompt());
		}
	}
	
	/** 
	 * Process a single command.
	 * <ol>
	 * <li>Tests for exit, quit, and help.</li>
	 * <li>Tests for any special commands used by sub classes.
	 * {@link #testSpecialCommands(String)}</li>
	 * <li>Parses the command.</li>
	 * <li>Processes the node. {@link #processEquation(Node)}<li>
	 * <li>Checks for errors. {@link #handleError(Exception)}</li>
	 * </ol>
	 * 
	 * @param command The line to be processed
	 * @return false if un-recoverable error or 'quit' or 'exit'
	 */
	public boolean processCommand(String command) 
	{	
		if(command.equals("quit") || command.equals("exit"))
			return false;

		if(command.equals("help"))	{
			printHelp();
			return true;
		}

		if(command.equals("functions"))	{
			printFuns();
			return true;
		}

		if(command.equals("operators"))	{
			printOps();
			return true;
		}

		if(command.equals("variables"))	{
			printVars();
			return true;
		}
		if(!testSpecialCommands(command)) return true;
			
		try {
			Node n = j.parse(command);
			processEquation(n);
		}
		catch(Exception e) { return handleError(e); }
		
		return true;
	}


	
	/** Performs the required operation on a node. 
	 * Typically evaluates the node and prints the value.
	 * 
	 * @param node Node representing expression
	 * @throws ParseException if a Parse or evaluation error
	 */ 
	public void processEquation(Node node) throws ParseException
	{
		Object res = j.evaluate(node);
		println(res);
	}

	
	/**
	 * Get a command from the input.
	 * @return null if an IO error or EOF occurs.
	 */
	protected String getCommand() {
		String s=null;
		
		if (br == null)	return null;

		try
		{
			if ( (s = br.readLine()) == null) return null;
		}
		catch(IOException e)
		{
			println("IOError exiting"); return null;
		}
		return s;
	}

	/** Prints the prompt string. */
	public String getPrompt() { return "JEP > "; }

	/** Prints a standard help message. 
	 * Type 'quit' or 'exit' to quit, 'help' for help.
	 **/
	public final void printStdHelp() {
		if(ta == null)
			println("Type 'quit' or 'exit' to quit, 'help' for help.");
		else 
			println("Type 'help' for help.");
	}		

	/** Print help message. */
	public void printHelp() { 
		printStdHelp();
		println("'functions' lists defined functions"); 
		println("'operators' lists defined operators"); 
		println("'variables' lists variables and constants"); 
	}

	/** Prints introductory text. */
	public void printIntroText() {
		println("JEP Console.");
		printStdHelp();
	}

	/** Prints a list of defined functions. */
	public void printFuns() {
		FunctionTable ft = j.getFunctionTable();
		println("Known functions:");
		for(Enumeration  loop = ft.keys();loop.hasMoreElements();)
		{
			String s = (String) loop.nextElement();
			println("\t"+s);
		}
	}

	/** Prints a list of defined operators. */
	public void printOps() {
		OperatorSet opset = j.getOperatorSet();
		Operator ops[] = opset.getOperators();
		println("Known operators:");
		for(int i=0;i<ops.length;++i)
			println("\t"+ops[i].toString());
	}

	/** Prints a list of variable. */
	public void printVars() {
		SymbolTable st = j.getSymbolTable();
		println("Variables:");
		for(Enumeration  loop = st.keys();loop.hasMoreElements();)
		{
			String s = (String) loop.nextElement();
			Object val = st.getValue(s);
			println("\t"+s+"\t"+val);
		}
	}
	/**
	 * Checks for special commands used by subclasses.
	 * For example a subclass may have a verbose mode
	 * switched on of off using the command
	 * <pre>verbose on</pre>
	 * This method can be used detected this input, 
	 * perform required actions and skip normal processing by returning true.
	 * 
	 * @param command
	 * @return true indicates normal processing should continue (default) false if the command is special and no further processing should be performed (parsing and evaluating)
     * @see #split(String)
	 */
	public boolean testSpecialCommands(String command)	{ return true; }		

	/**
	 * Handle an error in the parse and evaluate routines.
	 * @param e
	 * @return false if the error cannot be recovered and the program should exit
	 */
	public boolean handleError(Exception e)
	{
		if(e instanceof ParseException) { 
			println("Parse Error: "+e.getMessage()); }
		else
			println("Error: "+e.getClass().getName()+" "+e.getMessage());

		return true;
	}

	/** Splits a string on spaces.
	 * 
	 * @param s the input string
	 * @return an array of the tokens in the string
	 */	
	public String[] split(String s)
	{
		StringTokenizer st = new StringTokenizer(s);
		int tokCount = st.countTokens();
		String res[] = new String[tokCount];
		int pos=0;
		while (st.hasMoreTokens()) {
			res[pos++]=st.nextToken();
		}
		return res;	
	}

	/** Prints a line of text no newline.
	 * Subclasses should call this method rather than 
	 * System.out.print to allow for output to different places.
	 * 
	 */
	public void print(Object o)
	{
		String s=null;
		if(o == null) s = "null";
		else s = o.toString();
		
		if(ta != null)
			ta.append(s);
		else
			System.out.print(s);
	}

	/** Prints a line of text no newline.
	 * Subclasses should call this method rather than 
	 * System.out.print to allow for output to different places.
	 */
	public void println(Object o)
	{
		String s=null;
		if(o == null) s = "null";
		else s = o.toString();
		
		if(ta != null)
			ta.append(s + "\n");
		else
			System.out.println(s);
	}

	/**
	 * Handles keyRelease events
	 */
	public void keyReleased(KeyEvent event)
	{
		int code = event.getKeyCode();
		if(code == KeyEvent.VK_ENTER)
		{
			int cpos = ta.getCaretPosition();
			String alltext = ta.getText();
			String before = alltext.substring(0,cpos-1);
			int startOfLine = before.lastIndexOf('\n');
			if(startOfLine > 0)
					before = before.substring(startOfLine+1);
			String prompt = getPrompt();
			String line=null;
			if(before.startsWith(prompt))
			{
				line = before.substring(prompt.length());					
				this.processCommand(line);
			}
//			System.out.println("line ("+line+")");
			//if(!flag) this.exit();
			this.print(getPrompt());
		}
	}

	public void keyPressed(KeyEvent arg0)
	{
	}

	public void keyTyped(KeyEvent arg0)
	{
	}

	public String getAppletInfo()
	{
		return "Jep Console applet\n" +
			"R Morris Mar 2005\n" +
			"See http://www.singsurf.org/djep/";
	}

}
/* @author rich
 * Created on 21-Mar-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;

import org.lsmp.djep.vectorJep.*;

/**
 * @author Rich Morris
 * Created on 21-Mar-2005
 */
public class VectorConsole extends Console
{
	private static final long serialVersionUID = -2335406063822614650L;

	public static void main(String[] args) 
	{
		Console c = new VectorConsole();
		c.run(args);
	}

	public String getPrompt()
	{
		return "VectorJep > ";
	}

	public void initialise()
	{
		j = new VectorJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
	}

	public void printHelp()
	{
		super.printHelp();
		println("Dot product: [1,2,3].[4,5,6]");
		println("Cross product: [1,2,3]^^[4,5,6]");
		println("Matrix Multiplication: [[1,2],[3,4]]*[[1,2],[3,4]]");
		println("setEleMult: sets element by element mode for multiplication");	
		println("setMatrixMult: sets matrix multiplication");	
	}

	public void printIntroText()
	{
		println("VectorJep: matrix and vector calculations in Jep");
		println("eg. [1,2,3].[4,5,6] [[1,2],[3,4]]*[1,0]");
		printStdHelp();
	}

	public boolean testSpecialCommands(String command)
	{
		if(command.equals("setEleMult"))
		{
			((VectorJep)j).setElementMultiply(true);
			return false;
		}
		if(command.equals("setMatrixMult"))
		{
			((VectorJep)j).setElementMultiply(true);
			return false;
		}
		return true;
	}

}
/* @author rich
 * Created on 01-Apr-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;

import java.util.Enumeration;
import java.util.Vector;

import org.lsmp.djep.matrixJep.MatrixJep;
import org.lsmp.djep.matrixJep.MatrixVariableI;
import org.lsmp.djep.mrpe.MRpCommandList;
import org.lsmp.djep.mrpe.MRpEval;
import org.lsmp.djep.mrpe.MRpRes;
import org.lsmp.djep.vectorJep.VectorJep;
import org.lsmp.djep.vectorJep.values.MVector;
import org.lsmp.djep.vectorJep.values.Scaler;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.Variable;

/**
 * @author Rich Morris
 * Created on 01-Apr-2005
 */
public class MRpSurfExample {
	MatrixJep mj;
	VectorJep vj;
	MRpEval mrpe=null;
	MRpCommandList allCommands[];
	Node allEqns[];
	Node vecEqns[];
//	LVars psVars[];
	MatrixVariableI xVar,yVar;
	Variable xVVar,yVVar;
	int xref,yref;

	double xmin = -1.0,xmax = 1.0,ymin=1.0,ymax=1.0;
	int xsteps = 1000,ysteps = 1000;

	public static void main(String args[]) {
		timePrint("\tStart");
		MRpSurfExample surf = new MRpSurfExample();
		timePrint("\tDone init");
		try {
		surf.equationChanged("th=pi*x;phi=pi*y;f=[cos(th) cos(phi),sin(th) cos(phi),sin(phi)];");
		surf.vecEquationChanged(new String[]{"th=pi*x;","phi=pi*y;","[cos(th) cos(phi),sin(th) cos(phi),sin(phi)];"});
		timePrint("\tDone parse");

		surf.calcMRPE();
		surf.mrpe.cleanUp();
		timePrint("\tDone mrpe");
		
		surf.calcMJ();
		timePrint("\tDone MJ");
		
		surf.calcVJ();
		timePrint("\tDone VJ");
		} catch(Exception e) { System.out.println(e.getClass().getName()+": "+e.getMessage()); }
	}
	static long oldTime = 0;
	public static void timePrint(String msg) {
		long time = System.currentTimeMillis();
		long timediff = time-oldTime;
		oldTime = time;
		System.out.println(""+timediff+"\t"+msg);
	}
	public MRpSurfExample() {
		vj = new VectorJep();
		vj.setAllowAssignment(true);
		vj.setAllowUndeclared(true);
		vj.setImplicitMul(true);
		vj.addComplex();
		vj.addStandardConstants();
		vj.addStandardFunctions();

		mj = new MatrixJep();
		mj.setAllowAssignment(true);
		mj.setAllowUndeclared(true);
		mj.setImplicitMul(true);
		mj.addComplex();
		mj.addStandardConstants();
		mj.addStandardFunctions();
		mj.addStandardDiffRules();
		mrpe = new MRpEval(mj);
	}

	public void equationChanged(String text)
	{
		mj.restartParser(text);
		try
		{
			Vector coms = new Vector();
			Vector eqns = new Vector();
			Node n;
			while((n = mj.continueParsing())!=null) {
				Node n2 = mj.preprocess(n);
				MRpCommandList com = mrpe.compile(n2);
				coms.add(com);
				eqns.add(n2);
			}
			int i=0;
			allCommands = new MRpCommandList[coms.size()];
			for(Enumeration en=coms.elements();en.hasMoreElements();++i)
				allCommands[i] = (MRpCommandList) en.nextElement();
			i=0;
			allEqns = new Node[eqns.size()];
			for(Enumeration en=eqns.elements();en.hasMoreElements();++i)
				allEqns[i] = (Node) en.nextElement();
			xVar = (MatrixVariableI) mj.getVar("x");
			yVar = (MatrixVariableI) mj.getVar("y");
			xref = mrpe.getVarRef(xVar);
			yref = mrpe.getVarRef(yVar);

		}
		catch(ParseException e) {System.out.println(e.getMessage());}
	}

	public void vecEquationChanged(String lines[])
	{
		try
		{
			vecEqns = new Node[lines.length];
			for(int i=0;i<lines.length;++i) {
				Node n2 = vj.parse(lines[i]);
				vecEqns[i]=n2;
			}
			xVVar = vj.getVar("x");
			yVVar = vj.getVar("y");
		}
		catch(ParseException e) {e.getMessage();}
	}


	public void calcMRPE() {
		double topRes[]=null;

		for(int i=0;i<=xsteps;++i) {
			double x = xmin + ((xmax - xmin)*i)/xsteps;
			mrpe.setVarValue(xref,x);
			for(int j=0;j<=ysteps;++j) {
				double y = ymin + ((ymax - ymin)*j)/ysteps;
				mrpe.setVarValue(yref,y);

				MRpRes res=null;
				for(int k=0;k<allCommands.length;++k)
					res = mrpe.evaluate(allCommands[k]);
				topRes = (double []) res.toArray();
				
				//System.out.println("["+x+","+y+"]->["+topRes[0]+","+topRes[1]+","+topRes[2]+"]");
			}
		}
		System.out.println("res "+topRes[0]+","+topRes[1]+","+topRes[2]);
	}

	public void calcMJ() throws ParseException {
		Object topRes[]=null;

		Scaler xVal = (Scaler) xVar.getMValue();
		Scaler yVal = (Scaler) yVar.getMValue();
		xVar.setValidValue(true);
		yVar.setValidValue(true);
		for(int i=0;i<=xsteps;++i) {
			double x = xmin + ((xmax - xmin)*i)/xsteps;
			xVal.setEle(0,new Double(x));
			for(int j=0;j<=ysteps;++j) {
				double y = ymin + ((ymax - ymin)*j)/ysteps;
				yVal.setEle(0,new Double(y));

				Object res=null;
				for(int k=0;k<allEqns.length;++k)
					res = mj.evaluate(allEqns[k]);
				topRes = ((MVector) res).getEles();
				
				//System.out.println("["+x+","+y+"]->["+topRes[0]+","+topRes[1]+","+topRes[2]+"]");
			}
		}
		System.out.println("res "+topRes[0]+","+topRes[1]+","+topRes[2]);
	}

	public void calcVJ() throws ParseException,Exception {
		Object topRes[]=null;
		for(int i=0;i<=xsteps;++i) {
			double x = xmin + ((xmax - xmin)*i)/xsteps;
			xVVar.setValue(new Double(x));
			for(int j=0;j<=ysteps;++j) {
				double y = ymin + ((ymax - ymin)*j)/ysteps;
				yVVar.setValue(new Double(y));

				Object res=null;
				for(int k=0;k<vecEqns.length;++k)
					res = vj.evaluate(vecEqns[k]);
				topRes = ((MVector) res).getEles();
				
				//System.out.println("["+x+","+y+"]->["+topRes[0]+","+topRes[1]+","+topRes[2]+"]");
			}
		}
		System.out.println("res "+topRes[0]+","+topRes[1]+","+topRes[2]);
	}
}
/* @author rich
 * Created on 21-Mar-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;

import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.lsmp.djep.matrixJep.*;
/**
 * @author Rich Morris
 * Created on 21-Mar-2005
 */
public class MatrixConsole extends DJepConsole
{
	private static final long serialVersionUID = -4768856862892634425L;

	public static void main(String[] args)
	{
		Console c = new MatrixConsole();
		c.run(args);
	}
	
	public String getPrompt()
	{
		return "MatrixJep > ";
	}

	public void initialise()
	{
		j = new MatrixJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.setAllowAssignment(true);
		((MatrixJep) j).addStandardDiffRules();
	}

	public void printHelp()
	{
		super.printHelp();
		println("Dot product: [1,2,3].[4,5,6]");
		println("Cross product: [1,2,3]^[4,5,6]");
		println("Matrix Multiplication: [[1,2],[3,4]]*[[1,2],[3,4]]");
	}

	public void printIntroText()
	{
		println("MatrixJep: advanced vector and matrix handling");
		super.printStdHelp();
	}

	public void processEquation(Node node) throws ParseException
	{
		MatrixJep mj = (MatrixJep) j;
		
		if(verbose) {
			print("Parsed:\t\t"); 
			println(mj.toString(node));
		}
		Node processed = mj.preprocess(node);
		if(verbose) {
			print("Processed:\t"); 
			println(mj.toString(processed));
		}
					
		Node simp = mj.simplify(processed);
		if(verbose) {
			print("Simplified:\t"); 
			println(mj.toString(simp));
		}	
		
		Object val = mj.evaluate(simp);
		String s = mj.getPrintVisitor().formatValue(val);
		println("Value:\t\t"+s);
	}
}
/* @author rich
 * Created on 21-Mar-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;
import org.lsmp.djep.jama.JamaUtil;

/**
 * has support for Jama matrix operations
 * @author Rich Morris
 * Created on 21-Mar-2005
 * @see <a href="http://math.nist.gov/javanumerics/jama/">http://math.nist.gov/javanumerics/jama/</a>
 */
public class JamaConsole extends VectorConsole
{
	private static final long serialVersionUID = -4256036388099114905L;

	public static void main(String[] args)
	{
		Console c = new JamaConsole();
		c.run(args);
	}
	
	public void initialise()
	{
		super.initialise();
		JamaUtil.addStandardFunctions(j);
	}

	public void printHelp()
	{
		super.printHelp();
		println("inverse([[1,2],[3,4]])");
		println("rank([[1,2],[3,4]])");
		println("z = solve(x,y) solves x*z = y");
	}

	public void printIntroText()
	{
		super.printIntroText();
		println("Adds Jama matrix ops: inverse, solve, rank");
	}

}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;
import org.lsmp.djep.djep.*;

/**
 * Examples using differentation
 */
public class DiffExample {

	public static void main(String args[])
	{
		/* initilisation */
		DJep j = new DJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setAllowAssignment(true);
		j.setImplicitMul(true);
		j.addStandardDiffRules();

		try
		{
			// parse the string
			Node node = j.parse("sin(x^2)");
			// differentiate wrt x
			Node diff = j.differentiate(node,"x");
			// print
			j.println(diff);
			// simplify
			Node simp = j.simplify(diff);
			// print
			j.println(simp);
			
			// This time the differentation is specified by
			// the diff(eqn,var) function
			Node node2 = j.parse("diff(cos(x^3),x)");
			// To actually make diff do its work the
			// equation needs to be preprocessed
			Node processed = j.preprocess(node2);
			j.println(processed);
			// finally simplify
			Node simp2 = j.simplify(processed);
			j.println(simp2);
			
			// Now combine assignment and differentation
			Node node3 = j.parse("y=x^5");
			j.preprocess(node3);
			Node node4 = j.parse("diff(y^2+x,x)");
			Node simp3 = j.simplify(j.preprocess(node4));

			j.println(simp3); // default printing will be 2*y*5*x^4+1

			PrintVisitor pv = j.getPrintVisitor();
			pv.setMode(DPrintVisitor.PRINT_PARTIAL_EQNS,false);
			j.println(simp3); // no expansion will be 2*y*dy/dx+1

			pv.setMode(DPrintVisitor.PRINT_PARTIAL_EQNS,true);
			pv.setMode(DPrintVisitor.PRINT_VARIABLE_EQNS,true);
			j.println(simp3); // full expansion: 2*x^5*5*x^4+1

			pv.setMode(DPrintVisitor.PRINT_VARIABLE_EQNS,false);

//			Node node5 = j.parse("y");
//			j.println(node5);
//			((DPrintVisitor)j.getPrintVisitor()).setPrintVariableEquations(true);
//			j.println(node5);
			
			j.getSymbolTable().setVarValue("x",new Double(5));
			System.out.println(j.evaluate(simp3));
			j.evaluate(node3);
			System.out.println(j.getSymbolTable().getVar("y").getValue());
			j.getSymbolTable().setVarValue("x",new Double(0));
			System.out.println(j.evaluate(simp));
			
			Node node10 = j.parse("x=3");
			Node node11 = j.preprocess(node10);
			System.out.println(j.evaluate(node11));
			Node node12 = j.parse("y=x^2");
			Node node13 = j.preprocess(node12);
			System.out.println(j.evaluate(node13));
			Node node14 = j.parse("z=diff(y,x)");
			Node node15 = j.simplify(j.preprocess(node14));
			System.out.println(j.evaluate(node15));

			// If a variable is changed then any expresion tree
			// it depends on needs to be re-evaluated to bring
			// values of other variables upto date
			j.setVarValue("x",new Double(4));
			System.out.println(j.evaluate(node13));
			System.out.println(j.evaluate(node15));
			System.out.println("z: "+j.getVarValue("z").toString());
			
			// the findVarValue method will automatically
			// re-calculate the value of variables specified by
			// equations if needed. However a lazy
			
			j.setVarValue("x",new Double(5));
			System.out.println("j.setVarValue(\"x\",new Double(5));");
			System.out.println("j.findVarValue(y): "+j.calcVarValue("y").toString());
			System.out.println("j.findVarValue(z): "+j.calcVarValue("z").toString());

			// if j.getSymbolTable().clearValues();
			// is called before values of equations are set
			// then the values of intermediate equations
			// are automatically calculated, so you can jump
			// straight to the chase: no need to calculate 
			// y explititly to find the value of z.
			j.getSymbolTable().clearValues();
			j.setVarValue("x",new Double(6));
			System.out.println("j.setVarValue(\"x\",new Double(6));");
			System.out.println("j.findVarValue(z): "+j.calcVarValue("z").toString());

			j.getSymbolTable().clearValues();
			j.setVarValue("x",new Double(7));
			System.out.println(j.evaluate(node15));
			System.out.println("z: "+j.getVarValue("z").toString());
		}
		catch(ParseException e)
		{
			System.out.println("Error with parsing");
		}
		catch(Exception e)
		{
			System.out.println("Error with evaluation");
		}
	}
}
/* @author rich
 * Created on 21-Mar-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;

import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.lsmp.djep.groupJep.*;
import org.lsmp.djep.groupJep.groups.*;
import org.lsmp.djep.groupJep.interfaces.*;
import org.lsmp.djep.groupJep.values.*;
import org.nfunk.jep.type.Complex;
import java.math.*;

/**
 * Console application with handling for abstract groups 
 * @author Rich Morris
 * Created on 21-Mar-2005
 */
public class GroupConsole extends Console
{
	private static final long serialVersionUID = -3097491397108691409L;

	public static void main(String args[]) {
		Console c = new GroupConsole();
		c.run(args);
	}

	public String getPrompt()
	{
		return "GroupJep > ";
	}

	public void initialise()
	{
		j = new GroupJep(new Rationals()); 
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.addStandardConstants();
		j.addStandardFunctions();
	}

	public void initialise(Group g)
	{
		j = new GroupJep(g); 
		j.setAllowAssignment(true);
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.addStandardConstants();
		j.addStandardFunctions();
	}

	public void printIntroText()
	{
		println("GroupJep: evaluation over abstract groups");
		printGroup();
		super.printStdHelp();
	}

	public void printGroup()
	{
		println("Current Group: "+((GroupJep) j).getGroup().toString());
	}
	public void processEquation(Node node) throws ParseException
	{
		Object value = j.evaluate(node);
		if(value instanceof HasComplexValueI)
			println(value.toString()+"="
				+((HasComplexValueI) value).getComplexValue());
		else
			println(value);
	}

	public boolean testSpecialCommands(String command)
	{
		GroupJep gj = (GroupJep) j;
		if(!super.testSpecialCommands(command)) return false;
		String words[] = split(command);
		if(words.length==0) return true;
		if(words[0].equals("group"))
		{
			if(words.length == 1) {	}
			else if(words[1].equals("Z")) {
				initialise(new Integers());
			}
			else if(words[1].equals("Q"))
			{
				initialise(new Rationals());
			}
			else if(words[1].equals("R") && words.length == 3)
			{
				initialise(new BigReals(
							Integer.parseInt(words[2]),
							BigDecimal.ROUND_HALF_EVEN ));
			}
			else if(words[1].equals("R") && words.length == 2)
			{
				initialise(new Reals());
			}
			else if(words[1].equals("P") && words.length == 3)
			{
				initialise(new PermutationGroup(
							Integer.parseInt(words[2]))
							);
			}
			else if(words[1].equals("Zn") && words.length == 3)
			{
				initialise(new Zn(new BigInteger(words[2]))); 
			} 
			else if(words[1].equals("Qu"))
			{
				initialise(new Quaternions());
			}
			else
			{
				println("invalid group spec "+command);
				return false;
			}
			printGroup();
			return false;
		}



		if(words[0].equals("extend"))
		{
			RingI ring = (RingI) gj.getGroup();

			if(words.length < 2)
				println("extend must have at least one argument");
			else if(words.length == 2) /* Add a free variable */
			{
				initialise(new ExtendedFreeGroup(ring, words[1]));
			}
			else /* extend by an algebraic number */
			{
				int deg = words.length-3;
				Number coeffs[] = new Number[deg+1];
				for(int i=0;i<=deg;++i)
					coeffs[i] = ring.valueOf(words[words.length-i-1]);
				Polynomial p1 = new Polynomial(ring,words[1],coeffs);

				initialise(new AlgebraicExtension(ring, p1));
			}
			printGroup();
			return false;
		}
		
		if(words[0].equals("setRootVal"))
		{
			String symbol = words[1];
			Complex val = new Complex(Double.parseDouble(words[2]),Double.parseDouble(words[3]));
			GroupI g = gj.getGroup();
			if(g instanceof FreeGroup) {
				boolean flag = ((FreeGroup) g).setRootVal(symbol,val);
				if(!flag) println("Failed to set root value, could not find symbol");
			}
			return false;
		}
		return true;
	}

	public void printHelp()
	{
		super.printHelp();
		println("'group'\tprints the current group");
		println("'group G'\tchanges underlying group to G");
		println("'group Z'\tintegers (arbitrary precision)");
		println("'group Q'\trationals");
		println("'group R'\treals, represented as Doubles.");
		println("'group R 3'\treals represented as BigDecimals with 3 decimal places");
		println("'group P 3'\tpermutation group on three symbols");
		println("\t[1,3,2]+[3,2,1] -> (3,1,2)");
		println("'group Zn 5'\tintegers modulo 5");
		println("'group Qu'\tQuarternions");
		println("'extend x'\textends current group by adding symbol x, i.e. a free group");
		println("\tsuch a group can be considered as the ring of polynomials");
		println("\tsimplification happens automatically");
		println("'extend t a b c'\talgebraic extensions generated by t");
		println("\twhere t is a root of the polynomial a t^2 + b t +c=0");
		println("\te.g  group extend t 1 0 1 gives complex numbers, t^2+1=0.");
		println("\tfor these groups there is a natural mapping to complex numbers and complex result is also printed.");
		println("'setRootVal t re im'\tsets the value of free variable 't' in a free group to complex number re+i im");
	}

}
/* @author rich
 * Created on 21-Mar-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djepExamples;

import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.lsmp.djep.djep.*;
import org.lsmp.djep.xjep.PrintVisitor;

/**
 * @author Rich Morris
 * Created on 21-Mar-2005
 */
public class DJepConsole extends XJepConsole
{
	private static final long serialVersionUID = -5801701990800128777L;
	public void initialise()
	{
		j = new DJep();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setAllowAssignment(true);
		j.setImplicitMul(true);
		((DJep) j).addStandardDiffRules();
	}

	public void printHelp()
	{
		super.printHelp();
		println("'diff(x^2,x)' to differentiate x^2 with respect to x");
		println("'verbose on', 'verbose off' switch verbose mode on or off");
	}

	public void printIntroText()
	{
		println("DJep: differentiation in JEP. e.g. diff(x^2,x)");
		printStdHelp();
	}

	public String getPrompt()
	{
		return "DJep > ";
	}

	public void processEquation(Node node) throws ParseException
	{
		DJep dj = (DJep) this.j;
		if(verbose) {
			print("Parsed:\t\t"); 
			println(dj.toString(node));
		}
		Node processed = dj.preprocess(node);
		if(verbose) {
			print("Processed:\t"); 
			println(dj.toString(processed));
		}
					
		Node simp = dj.simplify(processed);
		if(verbose) 
			print("Simplified:\t"); 
		println(dj.toString(simp));
			
		if(verbose) {
			print("Full Brackets, no variable expansion:\n\t\t");
			dj.getPrintVisitor().setMode(PrintVisitor.FULL_BRACKET,true);
			dj.getPrintVisitor().setMode(DPrintVisitor.PRINT_PARTIAL_EQNS,false);
			println(dj.toString(simp));
			dj.getPrintVisitor().setMode(DPrintVisitor.PRINT_PARTIAL_EQNS,true);
			dj.getPrintVisitor().setMode(PrintVisitor.FULL_BRACKET,false);
		}

		Object val = dj.evaluate(simp);
		String s = dj.getPrintVisitor().formatValue(val);
		println("Value:\t\t"+s);
	}

	
	/** Creates a new Console object and calls run() */
	public static void main(String args[]) {
		Console c = new DJepConsole();
		c.run(args);
	}

}
/* @author rich
 * Created on 26-Feb-2004
 */

package org.lsmp.djepExamples;
import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.xjep.*;
/**
 * Examples using vectors and matrices
 */
public class VectorPrint {
	static XJep j;
//	static PrintVisitor pv;
	
	public static void main(String args[])	{
		j = new XJep(new VectorJep());

		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		j.setAllowUndeclared(true);
		j.setImplicitMul(true);
		j.setAllowAssignment(true);

		// parse and evaluate each equation in turn

		doStuff("3^2");		
		doStuff("[1,2,3]");               // Value: [1.0,2.0,3.0]
		doStuff("[1,2,3].[4,5,6]");       // Value: 32.0
		doStuff("[1,2,3]^^[4,5,6]");      // Value: [-3.0,6.0,-3.0]
		doStuff("[1,2,3]+[4,5,6]");       // Value: [5.0,7.0,9.0]
		doStuff("[[1,2],[3,4]]");         // Value: [[1.0,2.0],[3.0,4.0]]
		doStuff("[[1,2],[3,4]]*[1,0]");   // Value: [1.0,3.0]
		doStuff("[1,0]*[[1,2],[3,4]]");   // Value: [1.0,2.0]
		doStuff("x=[1,2,3]");             // Value: [1.0,2.0,3.0]
		doStuff("x+x");                   // Value: [2.0,4.0,6.0]
		doStuff("x . x");                 // Value: 14.0
		doStuff("x^^x");                  // Value: [0.0,0.0,0.0]
		doStuff("ele(x,2)");              // Value: 2.0
		doStuff("y=[[1,2],[3,4]]");       // Value: [[1.0,2.0],[3.0,4.0]]
		doStuff("y * y");                 // Value: [[7.0,10.0],[15.0,22.0]]
		doStuff("ele(y,[1,2])");          // Value: 2.0
	}

	public static void doStuff(String str)	{
		try	{
			Node node = j.parse(str);
			Object value = j.evaluate(node);
			j.print(node);
			System.out.println("\tvalue " + value.toString());
		}
		catch(ParseException e) { System.out.println("Parse error "+e.getMessage()); }		
		catch(Exception e) { 
			System.out.println("evaluation error "+e.getMessage()); 
			e.printStackTrace(); }		
	}
}
/* @author rich
 * Created on 10-Dec-2004
 */
package org.lsmp.djep.vectorJep;

import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import org.lsmp.djep.vectorJep.function.*;
import org.lsmp.djep.vectorJep.values.*;
/**
 * @author Rich Morris
 * Created on 10-Dec-2004
 */
public class VectorEvaluator extends EvaluatorVisitor {

	public VectorEvaluator(SymbolTable st) {
		super(st);
	}

	/**
	 * Visit a function node. The values of the child nodes
	 * are first pushed onto the stack. Then the function class associated
	 * with the node is used to evaluate the function.
	 * <p>
	 * If a function implements SpecialEvaluationI then the
	 * evaluate method of PFMC is called.
	 */
	public Object visit(ASTFunNode node, Object data) throws ParseException {
		if (node == null)
			return null;
		PostfixMathCommandI pfmc = node.getPFMC();

		// check if the function class is set
		if (pfmc == null)
			throw new ParseException(
				"No function class associated with " + node.getName());

		int numChild = node.jjtGetNumChildren();
		
		// Some operators (=) need a special method for evaluation
		// as the pfmc.run method does not have enough information
		// in such cases we call the evaluate method which passes
		// all available info. Note evaluating the children is
		// the responsibility of the evaluate method. 
		if (pfmc instanceof SpecialEvaluationI) {
			return ((SpecialEvaluationI) node.getPFMC()).evaluate(
				node,data,this,stack,this.symTab);
		}
		if(pfmc instanceof CallbackEvaluationI) {
			Object value = ((CallbackEvaluationI) pfmc).evaluate(node,this);
			stack.push(value);
			return value;
		}
		if (debug == true) {
			System.out.println(
				"Stack size before childrenAccept: " + stack.size());
		}

		// evaluate all children (each leaves their result on the stack)

		data = node.childrenAccept(this, data);

		if (debug == true) {
			System.out.println(
				"Stack size after childrenAccept: " + stack.size());
		}

		if (pfmc.getNumberOfParameters() == -1) {
			// need to tell the class how many parameters it can take off
			// the stack because it accepts a variable number of params
			pfmc.setCurNumberOfParameters(numChild);
		}

		// try to run the function

		if(pfmc instanceof UnaryOperatorI ||
		pfmc instanceof BinaryOperatorI ||
		pfmc instanceof NaryOperatorI || 
		pfmc instanceof Comparative)
			pfmc.run(stack);
		else if(numChild == 0)
		{
			pfmc.run(stack);
		}
		else /* perform operations element by element */
		{
			if(stack.peek() instanceof MatrixValueI)
			{
				MatrixValueI args[] = new MatrixValueI[node.jjtGetNumChildren()];
				args[numChild-1] = (MatrixValueI) stack.pop();
				Dimensions lastDim = args[numChild-1].getDim();
				for(int i=numChild-2;i>=0;--i)
				{
					Object val = stack.pop();
					if(!(val instanceof MatrixValueI))
						throw new ParseException("All arguments of function must be same dimension");
					args[i]=(MatrixValueI) val;
					if(!lastDim.equals(args[i].getDim()))
						throw new ParseException("All arguments of function must be same dimension");
				}
				MatrixValueI res = Tensor.getInstance(lastDim);
				for(int i=0;i<lastDim.numEles();++i)
				{
					for(int j=0;j<numChild;++j)
						stack.push(args[j].getEle(i));
					pfmc.run(stack);
					res.setEle(i,stack.pop());
				}
				stack.push(res);
			}
			else pfmc.run(stack);
		}

		if (debug == true) {
			System.out.println("Stack size after run: " + stack.size());
		}

		return data;
	}

}
/* @author rich
 * Created on 07-Mar-2004
 */
package org.lsmp.djep.vectorJep;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import org.lsmp.djep.vectorJep.function.*;
/**
 * @author Rich Morris
 * Created on 07-Mar-2004
 */
public class VOperatorSet extends OperatorSet {

	/**
	 * 
	 */
	public VOperatorSet() {
		super();
		OP_ADD.setPFMC(new MAdd());
		OP_SUBTRACT.setPFMC(new MSubtract());
		OP_MULTIPLY.setPFMC(new MMultiply());
		OP_DIVIDE.setPFMC(new MDivide());
//		OP_MULTIPLY.setPFMC(new ElementMultiply());
		OP_POWER.setPFMC(new VPower());
		OP_UMINUS.setPFMC(new MUMinus());
		OP_DOT.setPFMC(new MDot());
		OP_CROSS.setPFMC(new ExteriorProduct());
		OP_LIST.setPFMC(new VList());
		OP_ELEMENT.setPFMC(new ArrayAccess());
//		OP_RANGE.setPFMC(new VRange());
	}

	/** When set the multiplication of vectors and matricies will be element by element.
	 * Otherwise multiplication will be matrix multiplication (the default).
	 * 
	 * @param flag
	 */
	public void setElementMultiply(boolean flag)
	{
		if(flag)
		{
			OP_MULTIPLY.setPFMC(new ElementMultiply());
			OP_DIVIDE.setPFMC(new ElementDivide());
			OP_GT.setPFMC(new ElementComparative(Comparative.GT));
			OP_LT.setPFMC(new ElementComparative(Comparative.LT));
			OP_EQ.setPFMC(new ElementComparative(Comparative.EQ));
			OP_LE.setPFMC(new ElementComparative(Comparative.LE));
			OP_GE.setPFMC(new ElementComparative(Comparative.GE));
			OP_NE.setPFMC(new ElementComparative(Comparative.NE));
		}
		else
		{
			OP_MULTIPLY.setPFMC(new MMultiply());
			OP_DIVIDE.setPFMC(new Divide());
			OP_GT.setPFMC(new Comparative(Comparative.GT));
			OP_LT.setPFMC(new Comparative(Comparative.LT));
			OP_EQ.setPFMC(new Comparative(Comparative.EQ));
			OP_LE.setPFMC(new Comparative(Comparative.LE));
			OP_GE.setPFMC(new Comparative(Comparative.GE));
			OP_NE.setPFMC(new Comparative(Comparative.NE));
		}
	}
}
/* @author rich
 * Created on 25-Oct-2003
 */
package org.lsmp.djep.vectorJep;


/**
 * A class to represent a set of dimensions.
 * Might be 1 for 0-dimensional numbers.
 * [3] for a 3D vector
 * [3,3] for a matrix
 * @author rich
 * Created on 25-Oct-2003
 */
public class Dimensions
{
	private int dims[];
	public static final Dimensions UNKNOWN = new Dimensions(-1);
	public static final Dimensions ONE = new Dimensions(1);
	public static final Dimensions TWO = new Dimensions(2);
	public static final Dimensions THREE = new Dimensions(3);
	
	private Dimensions() {}	
	/** Sets the dimension to a single number. Implies its a Scaler or MVector. */
	private Dimensions(int d) {	dims = new int[] {d};	}
	/** Use this method for matrices. */
	private Dimensions(int d1,int d2) {	dims = new int[] {d1,d2}; }
	/** Construct a dimension set from an array. */
	private Dimensions(int d[])	
	{
		dims = new int[d.length];
		System.arraycopy(d,0,dims,0,d.length);
	}
	/**
	 * Factory method returns a Dimension for vector of given length.
	 * For 1,2,3 returns ONE,TWO or THREE otherwise create a new object.
	 */ 
	public static Dimensions valueOf(int d)
	{ 
		switch(d) {
			case 1: return Dimensions.ONE;
			case 2: return Dimensions.TWO;
			case 3: return Dimensions.THREE;
			default:
				return new Dimensions(d);
		}
	}
	/** returns dimensions for a matrix. **/
	public static Dimensions valueOf(int rows,int cols)
	{ 
		return new Dimensions(rows,cols);
	}
	/** return a dimension [d,inDim[0],...,inDim[n]] */
	public static Dimensions valueOf(int d,Dimensions inDim)
	{ 
		Dimensions res = new Dimensions();
		res.dims = new int[inDim.rank()+1];
		res.dims[0]=d;
		for(int i=0;i<inDim.rank();++i)
			res.dims[i+1]=inDim.dims[i];
		return res;
	}

	/** return a dimension [inDim[0],...,inDim[n],d] */
	public static Dimensions valueOf(Dimensions inDim,int d)
	{ 
		Dimensions res = new Dimensions();
		res.dims = new int[inDim.rank()+1];
		for(int i=0;i<inDim.rank();++i)
			res.dims[i]=inDim.dims[i];
		res.dims[inDim.rank()+1]=d;
		return res;
	}

	/** returns a dimensions with given dimensions. */
	public static Dimensions valueOf(int dims[])
	{
		if(dims.length == 1) return valueOf(dims[0]);
		if(dims.length == 2) return valueOf(dims[0],dims[1]);
		return new Dimensions(dims);
	}

	/** get the first dimension, 1 for numbers, 
	    or the length of a vector. 
	    for a matrix [[1,2,3],[4,5,6]] first dim is number of rows eg 2 */
	public int getFirstDim() {	return dims[0];	}
	/** get the last dimension, 1 for numbers, 
		or the length of a vector. 
	    for a matrix [[1,2,3],[4,5,6]] last dim is number of cols eg 3 
	 */
	public int getLastDim() {	return dims[dims.length-1];	}
	public int getIthDim(int i) { return dims[i]; }
	
	/** Is it 0D, ie a simple number. **/
	public boolean is0D() { return dims.length == 1 && dims[0] == 1; }
	/** Is it 1D, ie a vector [1,2,3]. **/
	public boolean is1D() {	return dims.length == 1 && dims[0] != 1; }
	/** Is it 2D, ie a matrix [[1,2,3],[4,5,6]]. **/
	public boolean is2D() {	return dims.length == 2; }
	/**
	 * The total number of elements.
	 * Produce of all the dimensions.
	 */
	public int numEles()
	{
		int res=1;
		for(int i=0;i<dims.length;++i) res *= dims[i];
		return res; 	
	}
	/** rank of dimensions 0 for numbers, 1 for vectors, 2 for matrices */
	public int rank()
	{
		if(is0D()) return 0;
		return dims.length; 
	}
	/** A string representation.
	 * Either 1,n,[m,n],[l,m,n] etc.
	 */
	public String toString()
	{
		if(is0D()) return String.valueOf(dims[0]);
		if(is1D()) return String.valueOf(dims[0]);
		StringBuffer sb = new StringBuffer("["+dims[0]);
		for(int i=1;i<dims.length;++i)
			sb.append(","+dims[i]);
		sb.append("]");
		return sb.toString();
	}

	/** Two dimensions are equal if the element of dims are the same. */
	public boolean equals(Dimensions dims2)
	{
		if(dims2 == null) return false;
		if( dims.length != dims2.dims.length) return false;
		for(int i=0;i<dims.length;++i)
		{ if(dims[i] != dims2.dims[i]) return false;} 
		return true;  
	}

	/** apparently your should always override hashcode when you
	 * override equals (Effective Java, Bloch).
	 */
	public int hashcode()
	{
		int res =17;
		for(int i=0;i<dims.length;++i)
			res = 37*res + dims[i];
		return res;
	}
	
	public boolean equals(Object arg)
	{
		if(arg == null) return false;
		if(arg instanceof Dimensions) return equals((Dimensions) arg);
		return false;
	}

}
/* @author rich
 * Created on 19-Dec-2003
 */
package org.lsmp.djep.vectorJep;

import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.function.*;
import org.lsmp.djep.vectorJep.values.*;

/**
 * An extension of JEP with support for basic vectors and matrices.
 * Use this class instead of JEP if you wish to use vectors and matrices.
 *  
 * @author Rich Morris
 * Created on 19-Dec-2003
 */
public class VectorJep extends JEP {

	
	public VectorJep() {
		super();
		
		opSet = new VOperatorSet();
		this.ev = new VectorEvaluator(this.getSymbolTable());
		this.parser.setInitialTokenManagerState(ParserConstants.NO_DOT_IN_IDENTIFIERS);
	}

	public void addStandardFunctions()
	{
		super.addStandardFunctions();
		super.addFunction("ele",new VEle());
		super.addFunction("len",new Length());
		super.addFunction("size",new Size());
		super.addFunction("id",new Id());
		super.addFunction("diag",new Diagonal());
		super.addFunction("getdiag",new GetDiagonal());
		super.addFunction("trans",new Transpose());
		super.addFunction("det",new Determinant());
		super.addFunction("trace",new Trace());
		super.addFunction("vsum",new VSum());
		super.addFunction("Map",new VMap());
		super.addFunction("GenMat",new GenMat());
	}


	public VectorJep(JEP j) {
		super(j);
	}

	/** Evaluate a node. If the result is a scaler it
	 * will be unwrapped, i.e. it will return a Double and not a Scaler.
	 */
	public Object evaluate(Node node) throws ParseException
	{
		Object res = ev.getValue(node,this.getSymbolTable());
		if(res instanceof Scaler)
			return ((Scaler) res).getEle(0);
		return res;
	}

	/** Evaluate a node. Does not unwrap scalers. */
	public Object evaluateRaw(Node node) throws Exception
	{
		Object res = ev.getValue(node,this.getSymbolTable());
		return res;
	}

	/**	When set the multiplication of vectors and matrices will be element by element.
	 * Otherwise multiplication will be matrix multiplication (the default).
	 */
	public void setElementMultiply(boolean value) {
		((VOperatorSet) opSet).setElementMultiply(value);
	}

}
/* @author rich
 * Created on 07-Jul-2003
 */
package org.lsmp.djep.vectorJep.values;
import org.lsmp.djep.vectorJep.*;

//import JSci.maths.DoubleMatrix;
//import JSci.physics.relativity.Rank1Tensor;

/**
 * Represents a matrix.
 * 
 * @author Rich Morris
 * Created on 07-Jul-2003
 * @version 2.3.0.2 now extends number
 * @version 2.3.1.1 Bug with non square matrices fixed.
 * @since 2.3.2 Added equals method.
 */
public class Matrix implements MatrixValueI 
{
	public MatrixValueI copy() {
		Matrix tmp = new Matrix(this.rows,this.cols);
		tmp.setEles(this);
		return tmp;
	}
	// want package access to simplify addition of matrices
	int rows=0;
	int cols=0;
	Object data[][] = null;
	Dimensions dims;
	
	private Matrix() {}
	/** Construct a matrix with given rows and cols. */
	protected Matrix(int rows,int cols)
	{
		this.rows = rows;
		this.cols = cols;
		data = new Object[rows][cols];
		dims = Dimensions.valueOf(rows,cols);
	}
	public static MatrixValueI getInstance(int rows,int cols) {
		return new Matrix(rows,cols);
	}
	/**
	 * Construct a Matrix from a set of row vectors.
	 * @param vecs
	 */
/*
	public Matrix(MVector[] vecs) throws ParseException
	{
		if(vecs==null) { throw new ParseException("Tried to create a matrix with null row vectors"); } 
		rows = vecs.length;
		if(rows==0) {  throw new ParseException("Tried to create a matrix with zero row vectors"); }		
		
		// now check that each vector has the same size.
		
		cols = vecs[0].size();
		for(int i = 1;i<rows;++i)
			if(cols != vecs[i].size())
				throw new ParseException("Each vector must be of the same size");
	
		data = new Object[rows][cols];
		for(int i = 0;i<rows;++i)
			for(int j=0;j<cols;++j)
			{
				data[i][j]= vecs[i].elementAt(j);
				if(data[i][j] == null)
					throw new ParseException("Null element in vector");
			}
	}
*/
	/**
	 * Returns a string representation of matrix. Uses [[a,b],[c,d]] syntax.  
	 */
	public String toString()
	{
		StringBuffer sb = new StringBuffer();
		sb.append('[');
		for(int i = 0;i<rows;++i)
		{
			if(i>0) sb.append(',');
			sb.append('[');
			for(int j=0;j<cols;++j)
			{
				if(j>0)sb.append(',');
				sb.append(data[i][j]);
			}
			sb.append(']');
		}
		sb.append(']');
		return sb.toString();
	}
	public Dimensions getDim() { return dims; }
	public int getNumEles() { return rows*cols; }
	public int getNumRows() { return rows; }
	public int getNumCols() { return cols; }

	public void setEle(int n,Object value) 
	{
		int i = n / cols;
		int j = n % cols;
		data[i][j] = value;
	}
	public void setEle(int i,int j,Object value) 
	{
		data[i][j] = value;
	}
	public Object getEle(int n)
	{
		int i = n / cols;
		int j = n % cols;
		return data[i][j];
	}
	public Object getEle(int i,int j) 
	{
		return data[i][j];
	}
	
	public Object[][] getEles()
	{
		return data;
	}
	/** sets the elements to those of the arguments. */
	public void setEles(MatrixValueI val)
	{
		if(!dims.equals(val.getDim())) return;
		for(int i=0;i<rows;++i)
			System.arraycopy(((Matrix) val).data[i],0,data[i],0,cols);
	}

	/** value of ele(1,1). */	
	//public int intValue() {return ((Number) data[0][0]).intValue();	}
	/** value of ele(1,1). */	
	//public long longValue() {return ((Number) data[0][0]).longValue();	}
	/** value of ele(1,1). */	
	//public float floatValue() {	return ((Number) data[0][0]).floatValue();	}
	/** value of ele(1,1). */	
	//public double doubleValue() {return ((Number) data[0][0]).doubleValue();	}
	/** Are two matrices equal, element by element 
	 * Overrides Object.
	 */
	public boolean equals(Object obj) {
		if(!(obj instanceof Matrix)) return false;
		Matrix mat = (Matrix) obj;
		if(!mat.getDim().equals(getDim())) return false;
		for(int i=0;i<rows;++i)
			for(int j=0;j<cols;++j)
				if(!data[i][j].equals(mat.data[i][j])) return false;
		return true;
	}
	
	/**
	 * Always override hashCode when you override equals.
	 * Effective Java, Joshua Bloch, Sun Press
	 */
	public int hashCode() {
		int result = 17;
//		long xl = Double.doubleToLongBits(this.re);
//		long yl = Double.doubleToLongBits(this.im);
//		int xi = (int)(xl^(xl>>32));
//		int yi = (int)(yl^(yl>>32));
		for(int i=0;i<rows;++i)
			for(int j=0;j<cols;++j)
			result = 37*result+ data[i][j].hashCode();
		return result;
	}
	

}
/* @author rich
 * Created on 07-Jul-2003
 */
package org.lsmp.djep.vectorJep.values;
import org.lsmp.djep.vectorJep.*;

/**
 * Represents tensor (generalisation of Matrix/Vector).
 * @author Rich Morris
 * Created on 07-Jul-2003
 * @version 1.3.0.2 now extends number
 */
public class Tensor implements MatrixValueI {
	private Object values[]=null;
	private Dimensions dims;
	//DoubleMatrix jsciMat;
	
	private Tensor() {}

	/** Creates a Tensor with the given dimension. **/
	public Tensor(Dimensions dims)
	{
		values = new Object[dims.numEles()];
		this.dims = dims;
	}

	/** Creates a Tensor with same dimension as the arguments. **/
	public Tensor(Tensor t)
	{
		values = new Object[t.getDim().numEles()];
		this.dims = t.getDim();
	}
	
	public MatrixValueI copy() {
		Tensor tmp = new Tensor(this);
		tmp.setEles(tmp);
		return tmp;
	}
	/** Creates a tensor with dimensions [len,dims[0],...,dims[n]] **/
	public Tensor(int len,Dimensions dims)
	{
		values = new Object[len*dims.numEles()];
		this.dims = Dimensions.valueOf(len,dims);
	}

	public Dimensions getDim() { return dims; }
	public int getNumEles() { return values.length; }
	public void setEle(int i,Object value) { values[i]=value; }
	public Object getEle(int i) { return values[i];	}
	/** sets the elements to those of the arguments. */
	public void setEles(MatrixValueI val)
	{
		if(!dims.equals(val.getDim())) return;
		System.arraycopy(((Tensor) val).values,0,values,0,getNumEles());
	}

	/** Factory method to return a new Vector, Matrix or Tensor
	 * with the given dimensions.
	 */	
	public static MatrixValueI getInstance(Dimensions dims)
	{
		switch(dims.rank())
		{
			case 0: return new Scaler();
			case 1: return new MVector(dims.getFirstDim());
			case 2: return new Matrix(dims.getFirstDim(),dims.getLastDim());
			default:
					return new Tensor(dims);
		}
	}
	
	private static MatrixValueI getInstance(int rows,Dimensions dims)
	{
		switch(dims.rank())
		{
			case 0: return new MVector(rows);
			case 1: return new Matrix(rows,dims.getFirstDim());
			default:
					return new Tensor(Dimensions.valueOf(rows,dims));
		}
	}

	private int curEle =0;
	/** Recursive procedure to print the tensor with lots of brackets. **/
	protected void bufferAppend(StringBuffer sb,int currank)
	{
		sb.append("[");
		if(currank+1 >= dims.rank())
		{
			// bottom of tree
			for(int i=0;i<dims.getIthDim(currank);++i)
			{
				if(i!=0) sb.append(",");
				sb.append(getEle(curEle++));
			}
		}
		else
		{
			// not bottom of tree
			for(int i=0;i<dims.getIthDim(currank);++i)
			{
				if(i!=0) sb.append(",");
				bufferAppend(sb,currank+1);
			}
		}
		sb.append("]");
	}
	/**
	 * Returns a string rep of tensor. Uses [[a,b],[c,d]] syntax.  
	 */
	public String toString()
	{
		StringBuffer sb = new StringBuffer();
		curEle = 0;
		bufferAppend(sb,0);
		return sb.toString();
	}

	/** value of constant ele(1). */	
	//public int intValue() {return ((Number) values[0]).intValue();	}
	/** value of constant ele(1). */	
	//public long longValue() {return ((Number) values[0]).longValue();	}
	/** value of constant ele(1). */	
	//public float floatValue() {	return ((Number) values[0]).floatValue();	}
	/** value of constant ele(1). */	
	//public double doubleValue() {return ((Number) values[0]).doubleValue();	}

	public boolean equals(Object obj) {
		if(!(obj instanceof Tensor)) return false;
		Tensor tens = (Tensor) obj;
		if(!tens.getDim().equals(getDim())) return false;
		for(int i=0;i<values.length;++i)
				if(!values[i].equals(tens.values[i])) return false;
		return true;
	}

	/**
	 * Always override hashCode when you override equals.
	 * Efective Java, Joshua Bloch, Sun Press
	 */
	public int hashCode() {
		int result = 17;
		for(int i=0;i<values.length;++i)
			result = 37*result+ values[i].hashCode();
		return result;
	}
}
/* @author rich
 * Created on 02-Nov-2003
 */
package org.lsmp.djep.vectorJep.values;

import org.lsmp.djep.vectorJep.*;

/**
 * Interface defining methods needed to work with vectors and matricies.
 * @author Rich Morris
 * Created on 02-Nov-2003
 */
public interface MatrixValueI {
	/** Returns the dimension of this object. */
	public Dimensions getDim();
	/** The total number of elements. */
	public int getNumEles();
	/** sets the i-th element, treats data a a linear array. */
	public void setEle(int i,Object value);
	/** gets the i-th element, treats data a a linear array. */
	public Object getEle(int i);
	/** sets the elements to those of the arguments. */
	public void setEles(MatrixValueI val);
	/** returns a copy of this value. */
	public MatrixValueI copy();
}
/* @author rich
 * Created on 04-Nov-2003
 */
package org.lsmp.djep.vectorJep.values;

import org.lsmp.djep.vectorJep.*;
import org.nfunk.jep.type.Complex;

/**
 * Degenerate i.e. rank 0 Tensor. Just has a single element.
 * @author Rich Morris
 * Created on 04-Nov-2003
 * @version 1.3.0.2 now extends number
 * TODO don't implement number! So what if a scaler is a boolean
 */
public class Scaler extends Number implements MatrixValueI {

	private static final long serialVersionUID = 336717881577257953L;
	Object value;
	protected Scaler() {
		value = new Double(0.0);
	}
	protected Scaler(Object o) {
		value = o;
	}
	public static MatrixValueI getInstance(Object o) {
		return new Scaler(o);
	}
	public Dimensions getDim() {return Dimensions.ONE; }
	public int getNumEles() { return 1;	}
	public void setEle(int i, Object value) {if(value!=null) this.value = value;}
	public Object getEle(int i) {return value; }
//	public void setValue(Object value) { this.value = value;}
//	public Object getValue() {return value; }
	public String toString() { return value.toString(); }
	/** sets the elements to those of the arguments. */
	public void setEles(MatrixValueI val)
	{
		if(!(val.getDim().equals(Dimensions.ONE))) return;
		value = val.getEle(0);
	}
	
	/** value of constant coeff. */	
	public int intValue() {
		if(value instanceof Complex) return ((Complex) value).intValue();
		if(value instanceof Boolean) return ((Boolean) value).booleanValue()?1:0;
		return ((Number) value).intValue(); // throws a cast exception if not a number
	}
	/** value of constant coeff. */	
	public long longValue() {
		if(value instanceof Complex) return ((Complex) value).longValue();
		if(value instanceof Boolean) return ((Boolean) value).booleanValue()?1l:0l;
		return ((Number) value).longValue(); // throws a cast exception if not a number
	}
	/** value of constant coeff. */	
	public float floatValue() {	
		if(value instanceof Complex) return ((Complex) value).floatValue();
		if(value instanceof Boolean) return ((Boolean) value).booleanValue()?1f:0f;
		return ((Number) value).floatValue(); // throws a cast exception if not a number
	}
	/** value of constant coeff. */	
	public double doubleValue() {
		if(value instanceof Complex) return ((Complex) value).doubleValue();
		if(value instanceof Boolean) return ((Boolean) value).booleanValue()?1d:0d;
		return ((Number) value).doubleValue();	 // throws a cast exception if not a number
	}

	public boolean equals(Object obj) {
		if(!(obj instanceof Scaler)) return false;
		Scaler s = (Scaler) obj;
		if(!s.getDim().equals(getDim())) return false;
		if(!value.equals(s.value)) return false;
		return true;
	}
	
	/**
	 * Always override hashCode when you override equals.
	 * Effective Java, Joshua Bloch, Sun Press
	 */
	public int hashCode() {
		int result = 17;
			result = 37*result+ value.hashCode();
		return result;
	}

	public MatrixValueI copy() {
		return new Scaler(value);
	}
}
/* @author rich
 * Created on 07-Jul-2003
 */
package org.lsmp.djep.vectorJep.values;

import org.lsmp.djep.vectorJep.*;

/**
 * A Vector of elements.
 * @author Rich Morris
 * Created on 07-Jul-2003
 * @version 1.3.0.2 now extends number
 */

public class MVector implements MatrixValueI
{
	private Object data[] = null;
	private Dimensions dim;
	//DoubleMatrix jsciMat;
	
	private MVector() {}
	/** constructs a vector of a given size. **/
	public MVector(int size)
	{
		data = new Object[size];
		dim = Dimensions.valueOf(size);
	}
	/** Creates a vector of a given size. */
	public static MatrixValueI getInstance(int size)
	{
		return new MVector(size);
	}
	/** Creates a vector from an array of elements. */
	private static MatrixValueI getInstance(Object[] eles)
	{
		if(eles.length == 1)
			return Scaler.getInstance(eles[0]);
		MVector res = new MVector(eles.length);
		for(int i=0;i<eles.length;++i)
			res.setEle(i,eles[i]);
		return res;
	}

	public String toString()
	{
		StringBuffer sb = new StringBuffer();
		sb.append('[');
		for(int i = 0;i<data.length;++i)
		{
				if(i>0) sb.append(',');
				sb.append(data[i]);
		}
		sb.append(']');
		return sb.toString();
	}

	public Dimensions getDim() { return dim; }	
	public int getNumEles() { return data.length; }
	public void setEle(int i,Object value) { data[i] = value; }
	public Object getEle(int i) { return data[i];	}
	/** sets the elements to those of the arguments. */
	public void setEles(MatrixValueI val)
	{
		if(!dim.equals(val.getDim())) return;
		System.arraycopy(((MVector) val).data,0,data,0,getNumEles());
	}
	public Object[] getEles() { return data; }
	/** value of constant ele(1). */	
	//public int intValue() {return ((Number) data[0]).intValue();	}
	/** value of constant ele(1). */	
	//public long longValue() {return ((Number) data[0]).longValue();	}
	/** value of constant ele(1). */	
	//public float floatValue() {	return ((Number) data[0]).floatValue();	}
	/** value of constant ele(1). */	
	//public double doubleValue() {return ((Number) data[0]).doubleValue();	}

	public boolean equals(Object obj) {
		if(!(obj instanceof MVector)) return false;
		MVector vec = (MVector) obj;
		if(!vec.getDim().equals(getDim())) return false;
		for(int i=0;i<data.length;++i)
				if(!data[i].equals(vec.data[i])) return false;
		return true;
	}

	/**
	 * Always override hashCode when you override equals.
	 * Effective Java, Joshua Bloch, Sun Press
	 */
	public int hashCode() {
		int result = 17;
		for(int i=0;i<data.length;++i)
			result = 37*result+ data[i].hashCode();
		return result;
	}
	
	public MatrixValueI copy() {
		MVector tmp = new MVector(this.data.length);
		tmp.setEles(this);
		return tmp;
	}
}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import java.util.Stack;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * Transpose a matrix.
 * trans([[1,2],[3,4]]) -> [[1,3],[2,4]]
 * 
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class Transpose extends PostfixMathCommand implements UnaryOperatorI
{
	public Transpose()
	{
		super();
		this.numberOfParameters = 1;
	}

	public Dimensions calcDim(Dimensions ldim)
	{
		return Dimensions.valueOf(ldim.getLastDim(),ldim.getFirstDim());
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		if(!(res instanceof Matrix))
			throw new ParseException("transpose: result must be a matrix");
		if(!(lhs instanceof Matrix))
			throw new ParseException("transpose: argument must be a matrix");
		Matrix resmat = (Matrix) res;
		Matrix mat = (Matrix) lhs;
		if( resmat.getNumCols() != mat.getNumRows()
		 ||	resmat.getNumRows() != mat.getNumCols())
		 	throw new ParseException("transpose, dimension of result is wrong res "+resmat.getDim()+" arg "+mat.getDim());
		for(int i=0;i<resmat.getNumRows();++i)
		{
			for(int j=0;j<resmat.getNumCols();++j)
				resmat.setEle(i,j,mat.getEle(j,i));
		}
		return res;
	}

	public void run(Stack s) throws ParseException
	{
		MatrixValueI obj = (MatrixValueI) s.pop();
		MatrixValueI res = Tensor.getInstance(calcDim(obj.getDim()));
		calcValue(res,obj);
		s.push(res);
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.lsmp.djep.vectorJep.function;

import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;

/**
 * A enhanced version of List, allows matrices and tensors.
 * During evaluation this function converts lists of values into the appropriate 
 * @see org.lsmp.djep.vectorJep.values.MatrixValueI MatrixValueI
 * type.
 * 
 * @author Rich Morris
 * Created on 27-Nov-2003
 */
public class VRange extends org.nfunk.jep.function.Range
	implements NaryOperatorI
{
	public VRange()
	{
		numberOfParameters = -1;
	}

	/** Calculates the dimension of this node with given dimensions of children. */
	public Dimensions calcDim(Dimensions dims[]) throws ParseException
	{
		return Dimensions.UNKNOWN;
	}
	
	/** Calculates the value of this node.
	 * 
	 */
	public MatrixValueI calcValue(MatrixValueI res,
		MatrixValueI inputs[]) throws ParseException
	{
		Object out;
		
		if(inputs.length == 2)
		{
			Object lastObj = inputs[1];
			Object firstObj  = inputs[0];
			double last = ((Number) lastObj).doubleValue();
			double first = ((Number) firstObj).doubleValue();
			double diff = last-first;
			int steps = 1+(int) diff;
			out=genRange(first,1.0,steps);
		}
		else if(inputs.length == 3)
		{
			Object incObj = inputs[2];
			Object lastObj = inputs[1];
			Object firstObj  = inputs[0];
			double inc = ((Number) incObj).doubleValue();
			double last = ((Number) lastObj).doubleValue();
			double first = ((Number) firstObj).doubleValue();
			double diff = (last-first)/inc;
			int steps = 1+(int) diff;
			out=genRange(first,inc,steps);
		}
		else if(inputs.length == 4)
		{
			Object stepsObj = inputs[4];
			//Object incObj = inputs[3];
			Object lastObj = inputs[2];
			Object firstObj  = inputs[0];
			int steps = ((Number) stepsObj).intValue();
			double last = ((Number) lastObj).doubleValue();
			double first = ((Number) firstObj).doubleValue();
			double inc = (last-first)/(steps-1);
			out=genRange(first,inc,steps);
		}
		else throw new ParseException("Range:only a maximum of four arguments can be specified");

		throw new ParseException("VRange: calcValue not implemented");
	}

	public Object genRange(double low, double inc, int steps) {
		MVector res = new MVector(steps);
		for(int i=0;i<steps;++i)
			res.setEle(i,new Double(low+inc*i));
		return res;
	}
	
	
}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import java.util.Stack;

import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * Creates an identity matrix.
 * id(3) -> [[1,0,0],[0,1,0],[0,0,1]]
 * 
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class Id extends PostfixMathCommand
{
	public Id()	{
		this.numberOfParameters = 1;
	}

	public void run(Stack s) throws ParseException
	{
		Object obj = s.pop();
		int n = ((Number) obj).intValue();
		Matrix mat = (Matrix) Matrix.getInstance(n,n);
		for(int i=0;i<n;++i)
		{
			for(int j=0;j<n;++j)
				mat.setEle(i,j,new Double(0.0));
			mat.setEle(i,i,new Double(1.0));
		}
		s.push(mat);
	}
}
/* @author rich
 * Created on 15-Nov-2003
 */
package org.lsmp.djep.vectorJep.function;

import java.util.*;
import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * ele(x,i) returns the i-th element of a vector x.
 * ele(m,[i,j]) returns the (i-th,j-th) element of a matrix m. 
 * Note this follows the mathematical indexing convention with indices starting from 1
 * rather than the computer science convention with indices starting from 0.
 * Hence
 * <code>
 * a = [1,2,3,4];
 * ele(a,1); // returns 1
 * m = [[1,2],[3,4]];
 * ele(m,[2,2]); // return 4
 * </code>
 * 
 * New parser feature allow a[] notation to be used.
 * <code>
 * a=[1,2,3,4];
 * a[3]; // returns 3
 * b=[[1,2],[3,4]];
 * b[1,2]; // returns 2
 * </code>
 * 
 * @author Rich Morris
 * Created on 15-Nov-2003
 */
public class VEle extends PostfixMathCommand implements BinaryOperatorI {

	public VEle() {
		super();
		numberOfParameters = 2;
	}

	public Dimensions calcDim(Dimensions ldim, Dimensions rdim)
		throws ParseException {
		return Dimensions.ONE;
	}

	public MatrixValueI calcValue(MatrixValueI res,
		MatrixValueI param1,MatrixValueI param2) throws ParseException
	{
//		Number num = (Number) rhs.getEle(0);
//		res.setEle(0,lhs.getEle(num.intValue()-1));		

		if(param1 instanceof MVector)
		{
			if(param2 instanceof Scaler)
			{
				int index = ((Number) param2.getEle(0)).intValue()-1;
				Object val = ((MVector) param1).getEle(index);
				res.setEle(0,val); 
			}
			else if(param2 instanceof MVector)
			{
				MVector vec = (MVector) param2;
				if(vec.getDim().equals(Dimensions.ONE))
				{
					int d1 = ((Number) vec.getEle(0)).intValue();
					if( d1<1 || d1 > ((MVector) param1).getNumEles())
						throw new ParseException("ArrayAccess: array indices "+d1+" out of range 1.."+param1.getDim());
					Object val = ((MVector) param1).getEle(d1-1);
					res.setEle(0,val);
				}
			}
			else throw new ParseException("Bad second argument to ele, expecting a double "+param2.toString());
		}
		else if(param1 instanceof Matrix)
		{
			if(param2 instanceof MVector)
			{
				MVector vec = (MVector) param2;
				if(vec.getDim().equals(Dimensions.TWO))
				{
					int d1 = ((Number) vec.getEle(0)).intValue();
					int d2 = ((Number) vec.getEle(1)).intValue();
					if( d1<1 || d1 > ((Matrix) param1).getNumRows()
					 ||	d2<1 || d2 > ((Matrix) param1).getNumCols() )
						throw new ParseException("ArrayAccess: array indices "+d1+", "+d2+" out of range 1.."+param1.getDim());

					Object val = ((Matrix) param1).getEle(d1-1,d2-1);
					res.setEle(0,val);
				}
			}
			else throw new ParseException("Bad second argument to ele, expecting [i,j] "+param2.toString());
		}
		else if(param1 instanceof Tensor)
		{
			throw new ParseException("Sorry don't know how to find elements for a tensor");
		}
		else
			throw new ParseException("ele requires a vector matrix or tensor for first argument it has "+param1.toString());
		return res;
	}
	
	public void run(Stack stack) throws ParseException 
	{
		checkStack(stack); // check the stack
	
		Object param1,param2;
	 
		// get the parameter from the stack
	        
		param2 = stack.pop();
		param1 = stack.pop();
	            
		if(param1 instanceof MVector)
		{
			if(param2 instanceof Number)
			{
				Object val = ((MVector) param1).getEle(((Number) param2).intValue()-1);
				stack.push(val);
				return; 
			}
			else if(param2 instanceof MVector)
			{
				MVector vec = (MVector) param2;
				if(vec.getDim().equals(Dimensions.ONE))
				{
					int d1 = ((Number) vec.getEle(0)).intValue();
					if( d1<1 || d1 > ((MVector) param1).getNumEles())
						throw new ParseException("ArrayAccess: array indices "+d1+" out of range 1.."+((MVector) param1).getDim());
					Object val = ((MVector) param1).getEle(d1-1);
					stack.push(val);
					return; 
				}
			}
			throw new ParseException("Bad second argument to ele, expecting a double "+param2.toString());
		}
		else if(param1 instanceof Matrix)
		{
			if(param2 instanceof MVector)
			{
				MVector vec = (MVector) param2;
				if(vec.getDim().equals(Dimensions.TWO))
				{
					int d1 = ((Number) vec.getEle(0)).intValue();
					int d2 = ((Number) vec.getEle(1)).intValue();
					if( d1<1 || d1 > ((Matrix) param1).getNumRows()
					 ||	d2<1 || d2 > ((Matrix) param1).getNumCols() )
						throw new ParseException("ArrayAccess: array indices "+d1+", "+d2+" out of range 1.."+((Matrix) param1).getDim());
					Object val = ((Matrix) param1).getEle(d1-1,d2-1);
					stack.push(val);
					return; 
				}
			}
			else throw new ParseException("Bad second argument to ele, expecting [i,j] "+param2.toString());
		}
		else if(param1 instanceof Tensor)
		{
			throw new ParseException("Sorry don't know how to find elements for a tensor");
		}
		throw new ParseException("ele requires a vector matrix or tensor for first argument it has "+param1.toString());
	}
}
/* @author rich
 * Created on 02-Nov-2003
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommandI;
/**
 * A matrix enabled unary operator.
 * This interface is primarilary used in the matrixJep package
 * but is here for convienience.
 *  
 * @author Rich Morris
 * Created on 02-Nov-2003
 */
public interface UnaryOperatorI extends PostfixMathCommandI {
	/** Find the dimensions of this operator when applied to arguments with given dimensions. */
	public Dimensions calcDim(Dimensions ldim);
	/** Calculates the value of this operator for given input with results stored in res.
	 * res is returned. Using this method is slightly faster
	 * than the standard run method as it eliminates the construction
	 * of tempoary objects.
	 */
	public MatrixValueI calcValue(
		MatrixValueI res,
		MatrixValueI lhs) throws ParseException;
}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import java.util.Stack;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * Returns the size of an Scaler, Vector or Matrix.
 * <pre>
 * size(7) -> 1
 * size([1,2,3]) -> 3
 * size([[1,2,3],[4,5,6]]) -> [2,3]
 * size([[[1,2],[3,4],[5,6]],[[7,8],[9,10],[11,12]]]) -> [2,3,2]
 * </pre>
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class Size extends PostfixMathCommand implements UnaryOperatorI
{
	public Size()
	{
		super();
		this.numberOfParameters = 1;
	}

	public Dimensions calcDim(Dimensions ldim)
	{
		int rank = ldim.rank();
		if(rank == 0) return Dimensions.ONE;
		return Dimensions.valueOf(rank);
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		Dimensions dims = lhs.getDim();
		if(dims.is0D())
		{
			res.setEle(0,new Integer(1));
			return res;
		}
		for(int i=0;i<dims.rank();++i)
		{
			res.setEle(i,new Integer(dims.getIthDim(i)));
		}
		return res;
	}

	public void run(Stack s) throws ParseException
	{
		Object obj = s.pop();
		MatrixValueI res = null;
		if(obj instanceof Scaler)
		{
			res = Scaler.getInstance(new Integer(1)); 
		}
		else if(obj instanceof MVector)
			res = Scaler.getInstance(new Integer(((MVector) obj).getNumEles()));
		else if(obj instanceof MatrixValueI)
		{
			Dimensions inDim = ((MatrixValueI) obj).getDim();
			res = MVector.getInstance(inDim.rank());
			for(int i=0;i<inDim.rank();++i)
				res.setEle(i,new Integer(inDim.getIthDim(i)));
		}
		else
			res = Scaler.getInstance(new Integer(1));
		s.push(res); 
	}

}
/* @author rich
 * Created on 27-Jul-2003
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.Subtract;
/**
 * An extension of the Add command to allow it to add MVector's and Matrix's.
 * @author Rich Morris
 * Created on 27-Jul-2003
 */
public class MSubtract extends Subtract implements BinaryOperatorI {

	public Dimensions calcDim(Dimensions ldim,Dimensions rdim)
	{
		if(ldim.equals(rdim)) return ldim;
		return null;
	}

	/** calculates the value.
	 * @param res - results will be stored in this object
	 * @param lhs - lhs value
	 * @param rhs - rhs value
	 * @return res
	 */
	public MatrixValueI calcValue(MatrixValueI res,MatrixValueI lhs,MatrixValueI rhs) throws ParseException
	{
		int len = res.getNumEles();
		for(int i=0;i<len;++i)
			res.setEle(i,super.sub(lhs.getEle(i),rhs.getEle(i)));
		return res;
	}
	/**
	 * Adds two objects.
	 */
	
	public Object sub(Object param1, Object param2) throws ParseException 
	{
		if(param1 instanceof MVector && param2 instanceof MVector)
			return sub((MVector) param1,(MVector) param2);
		if(param1 instanceof Matrix && param2 instanceof Matrix)
			return sub((Matrix) param1,(Matrix) param2);
		else if(param1 instanceof Tensor && param2 instanceof Tensor)
			return sub((Tensor) param1,(Tensor) param2);
		else
			return super.sub(param1,param2);
	}
	
	/** Adds two vectors. */
	public MVector sub(MVector lhs,MVector rhs) throws ParseException
	{
		if(lhs.getNumEles() != rhs.getNumEles()) throw new ParseException("Miss match in sizes ("+lhs.getNumEles()+","+rhs.getNumEles()+") when trying to add vectors!");
		MVector res = new MVector(lhs.getNumEles());
		return (MVector) calcValue(res,lhs,rhs);			
	}

	/** Adds two matrices. */
	public Matrix sub(Matrix lhs,Matrix rhs) throws ParseException
	{
		if(lhs.getNumRows() != rhs.getNumRows()) throw new ParseException("Miss match in number of rows ("+lhs.getNumRows()+","+rhs.getNumRows()+") when trying to add vectors!");
		if(lhs.getNumCols() != rhs.getNumCols()) throw new ParseException("Miss match in number of cols ("+lhs.getNumCols()+","+rhs.getNumCols()+") when trying to add vectors!");
		Matrix res = (Matrix) Matrix.getInstance(lhs.getNumRows(),lhs.getNumCols());
		return (Matrix) calcValue(res,lhs,rhs);			
	}

	/** Adds two matrices. */
	public Tensor sub(Tensor lhs,Tensor rhs) throws ParseException
	{
		if(lhs.getNumEles() != rhs.getNumEles()) throw new ParseException("Miss match in sizes ("+lhs.getNumEles()+","+rhs.getNumEles()+") when trying to add vectors!");
		Tensor res = new Tensor(lhs.getDim());
		return (Tensor) calcValue(res,lhs,rhs);			
	}
}
/*****************************************************************************

JEP - Java Math Expression Parser 2.24
	  December 30 2002
	  (c) Copyright 2002, Nathan Funk
	  See LICENSE.txt for license information.

*****************************************************************************/
package org.lsmp.djep.vectorJep.function;

import java.util.*;

import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;

import org.nfunk.jep.*;

/**
 * The MDot operator. 
 * @author Rich Morris
 * Created on 23-Feb-2004
 */
public class MDot extends MMultiply implements BinaryOperatorI
{
	public MDot() {
		numberOfParameters = 2;
	}
	public Dimensions calcDim(Dimensions l,Dimensions r) {
		if(l.equals(r) && l.is1D()) return Dimensions.ONE;
		return null;
	}
	
	/** calculates the value.
	 * @param res - results will be stored in this object
	 * @param lhs - lhs value
	 * @param rhs - rhs value
	 * @return res
	 */
	public MatrixValueI calcValue(MatrixValueI res,MatrixValueI lhs,MatrixValueI rhs) throws ParseException
	{
		return calcValue((Scaler) res,(MVector) lhs,(MVector) rhs);
	}

	public Scaler calcValue(Scaler res,MVector lhs,MVector rhs) throws ParseException
	{
		int len = lhs.getNumEles();
		Object val = mul(lhs.getEle(0),rhs.getEle(0));
		for(int i=1;i<len;++i)
			val = add.add(val,mul(lhs.getEle(i),rhs.getEle(i)));
		res.setEle(0,val);
		return res;
	}

	public void run(Stack stack) throws ParseException 
	{
		checkStack(stack); // check the stack

		Object param1,param2;
 
		// get the parameter from the stack
        
		param2 = stack.pop();
		param1 = stack.pop();
            
			// multiply it with the product
                
		stack.push(dot(param1, param2));

		return;
	}

	/** returns param1 . param2. Defaults to scaler multiplication if parameters are not vectors. */
	public Object dot(Object param1, Object param2)	throws ParseException
	{
		if(param1 instanceof MVector && param2 instanceof MVector)
			return dot((MVector) param1,(MVector) param2);
		return super.mul(param1,param2);
	}
	
	/** returns lhs . rhs */
	public Object dot(MVector lhs, MVector rhs) throws ParseException
	{
		if(!lhs.getDim().equals(rhs.getDim())) throw new ParseException("Dot: Miss match in sizes ("+lhs.getDim()+","+rhs.getDim()+")");
		Scaler res = (Scaler) Scaler.getInstance(new Double(0.0));
		calcValue(res,lhs,rhs);
		return res.getEle(0);
	}
}
/* @author rich
 * Created on 27-Jul-2003
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.Add;
/**
 * An extension of the Add command to allow it to add MVector's and Matrix's.
 * @author Rich Morris
 * Created on 27-Jul-2003
 */
public class MAdd extends Add implements BinaryOperatorI {

	public Dimensions calcDim(Dimensions ldim,Dimensions rdim)
	{
		if(ldim.equals(rdim)) return ldim;
		return null;
	}

	/** calculates the value.
	 * @param res - results will be stored in this object
	 * @param lhs - lhs value
	 * @param rhs - rhs value
	 * @return res
	 */
	public MatrixValueI calcValue(MatrixValueI res,MatrixValueI lhs,MatrixValueI rhs) throws ParseException
	{
		int len = res.getNumEles();
		for(int i=0;i<len;++i)
			res.setEle(i,super.add(lhs.getEle(i),rhs.getEle(i)));
		return res;
	}
	/**
	 * Adds two objects.
	 */
	
	public Object add(Object param1, Object param2) throws ParseException 
	{
		if(param1 instanceof MVector && param2 instanceof MVector)
			return add((MVector) param1,(MVector) param2);
		else if(param1 instanceof Matrix && param2 instanceof Matrix)
			return add((Matrix) param1,(Matrix) param2);
		else if(param1 instanceof Tensor && param2 instanceof Tensor)
			return add((Tensor) param1,(Tensor) param2);
		else
			return super.add(param1,param2);
	}
	
	/** Adds two vectors. */
	public MVector add(MVector lhs,MVector rhs) throws ParseException
	{
		if(lhs.getNumEles() != rhs.getNumEles()) throw new ParseException("Miss match in sizes ("+lhs.getNumEles()+","+rhs.getNumEles()+") when trying to add vectors!");
		MVector res = new MVector(lhs.getNumEles());
		return (MVector) calcValue(res,lhs,rhs);			
	}

	/** Adds two matrices. */
	public Matrix add(Matrix lhs,Matrix rhs) throws ParseException
	{
		if(lhs.getNumRows() != rhs.getNumRows()) throw new ParseException("Miss match in number of rows ("+lhs.getNumRows()+","+rhs.getNumRows()+") when trying to add vectors!");
		if(lhs.getNumCols() != rhs.getNumCols()) throw new ParseException("Miss match in number of cols ("+lhs.getNumCols()+","+rhs.getNumCols()+") when trying to add vectors!");
		Matrix res = (Matrix) Matrix.getInstance(lhs.getNumRows(),lhs.getNumCols());
		return (Matrix) calcValue(res,lhs,rhs);			
	}

	/** Adds two tensors. */
	public Tensor add(Tensor lhs,Tensor rhs) throws ParseException
	{
		if(lhs.getNumEles() != rhs.getNumEles()) throw new ParseException("Miss match in sizes ("+lhs.getNumEles()+","+rhs.getNumEles()+") when trying to add vectors!");
		Tensor res = new Tensor(lhs.getDim());
		return (Tensor) calcValue(res,lhs,rhs);			
	}
}
/* @author rich
 * Created on 14-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.CallbackEvaluationI;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * Generate vectors and matrices.
 * First argument gives the size of the vector or matrix
 * second argument is the function to use to generate elements of vector or matrix.
 * Third argument (if present gives free variables used in the function, these will
 * run from 1 to number of rows or columns).
 * For example
 * <pre>
 * GenMat(3,1) -> [1,1,1]
 * GenMat(3,ii,ii) -> [1,2,3]
 * GenMat(3,rand()) -> [0.343,0.974,0.567]
 * GenMat([2,2],ii+jj,[ii,jj]) -> [[2,3],[3,4]]
 * </pre>
 * Note the free variables should not be the same name as variables already
 * in use, in particular i is often set to be the complex root of unity, and should be avoided.
 * 
 * @author Rich Morris
 * Created on 14-Feb-2005
 */
public class GenMat extends PostfixMathCommand implements CallbackEvaluationI
{
	public GenMat()
	{
		super();
		this.numberOfParameters = -1;
	}

	public boolean checkNumberOfParameters(int n) {
		return (n == 2 || n == 3);
	}

	public Object evaluate(
		Node node,
		EvaluatorI pv)
		throws ParseException
	{
		Object sizeObj = pv.eval(node.jjtGetChild(0));
		int sizes[] = null;
		if( sizeObj instanceof Scaler)
		{
			sizes = new int[1];
			sizes[0] = ((Number) sizeObj).intValue();
		}
		else if( sizeObj instanceof MVector)
		{
			MVector vec = (MVector) sizeObj;
			int n = vec.getNumEles();
			sizes = new int[n];
			for(int i=0;i<n;++i)
				sizes[i] = ((Number) vec.getEle(i)).intValue();
		}
		else if(sizeObj instanceof MatrixValueI)
			throw new ParseException("GenMat: First arg should be scaler or vector");
		else
		{
			sizes = new int[1];
			sizes[0] = ((Number) sizeObj).intValue();
		}
		
		// Create result object
		Dimensions dim = Dimensions.valueOf(sizes);
		MatrixValueI res = Tensor.getInstance(dim);
		
		if(node.jjtGetNumChildren() == 2)
		{
			// no need to set variables
			for(int i=0;i<res.getNumEles();++i)
			{
				Object val = pv.eval(node.jjtGetChild(1));
				res.setEle(i,val);
			}
			return res;
		}
		
		// Need to set variables
		
		Variable vars[] = VMap.getVars(node.jjtGetChild(2));
		if(vars.length != sizes.length)
			throw new ParseException("GenMat: number of variables must match number of dimensions");
		if(vars.length == 1)
		{
			for(int i=0;i<sizes[0];++i)
			{
				vars[0].setValue(new Integer(i+1));
				Object val = pv.eval(node.jjtGetChild(1));
				res.setEle(i,val);
			}
			return res;
		}
		else if(vars.length == 2)
		{
			Matrix mat = (Matrix) res;
			for(int i=0;i<sizes[0];++i)
			{
				vars[0].setValue(new Integer(i+1));
				for(int j=0;j<sizes[1];++j)
				{
					vars[1].setValue(new Integer(j+1));
					Object val = pv.eval(node.jjtGetChild(1));
					mat.setEle(i,j,val);
				}
			}
			return res;
		}
		else
			throw new ParseException("GenMat: can currently only generate vectors and matrices");
	}
}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import java.util.Stack;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.*;

/**
 * Adds the elements of a vector or matrix.
 * vsum([1,2,3]) -> 6
 * vsum([[1,2],[3,4]]) -> 10
 * 
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class VSum extends PostfixMathCommand implements UnaryOperatorI
{
	Add add = new Add();
	
	public VSum()
	{
		super();
		this.numberOfParameters = 1;
	}

	public Dimensions calcDim(Dimensions ldim)
	{
		return Dimensions.ONE;
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		if(!(res instanceof Scaler))
			throw new ParseException("vsum: result must be a scaler");

		Object val = lhs.getEle(0);
			for(int i=1;i<lhs.getNumEles();++i)
				val = add.add(val,lhs.getEle(i));
			res.setEle(0,val);
		
		return res;
	}
	public void run(Stack s) throws ParseException
	{
		MatrixValueI obj = (MatrixValueI) s.pop();
		MatrixValueI res = Scaler.getInstance(new Double(0.0));
		calcValue(res,obj);
		s.push(res);
	}

}
/* @author rich
 * Created on 10-Dec-2004
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * Multiplies any number of Vectors or Matrices element by element.
 * TODO could be much more efficient when called through run.
 * 
 * @author Rich Morris
 * Created on 10-Dec-2004
 */
public class ElementDivide extends Divide implements BinaryOperatorI {

	public Dimensions calcDim(Dimensions ldim,Dimensions rdim)
	{
		if(ldim.equals(rdim)) return ldim;
		return null;
	}

	/**
	 * Multiply the inputs element by element putting the results in res.
	 */
	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs,MatrixValueI rhs)
		throws ParseException {

			int len = res.getNumEles();
			for(int i=0;i<len;++i)
			{
				res.setEle(i,super.div(lhs.getEle(i),rhs.getEle(i)));
			}
			return res;
	}

	/**
	 * Multiply arguments element by element. Returns result.
	 */
	public Object div(Object param1, Object param2) throws ParseException {

		if(param1 instanceof MatrixValueI && param2 instanceof MatrixValueI)
		{
			return div((MatrixValueI) param1,(MatrixValueI) param2);
		}
		else if(param1 instanceof MatrixValueI)
		{
			MatrixValueI l = (MatrixValueI) param1;
			MatrixValueI res = Tensor.getInstance(l.getDim());
			for(int i=0;i<res.getNumEles();++i)
				res.setEle(i,super.div(l.getEle(i),param2));
			return res;
		}
		else if(param2 instanceof MatrixValueI)
		{
			MatrixValueI r = (MatrixValueI) param2;
			MatrixValueI res = Tensor.getInstance(r.getDim());
			for(int i=0;i<res.getNumEles();++i)
				res.setEle(i,super.div(param1,r.getEle(i)));
			return res;
		}
		return super.div(param1,param2);
	}

	public Object div(MatrixValueI param1, MatrixValueI param2) throws ParseException 
	{
		Dimensions dims = this.calcDim(param1.getDim(),param2.getDim());
		MatrixValueI res = Tensor.getInstance(dims);
		return this.calcValue(res,param1,param2);
	}

}
/* @author rich
 * Created on 14-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.CallbackEvaluationI;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * evaluates a function on every element of a vector or matrix.
 * Map(x^2,x,[1,2,3]) -> [1,4,9]
 * Map(x^y,[x,y],[1,2,3],[1,2,3]) -> [1,4,27]
 * First argument is a equation, second argument is the name or names of variables.
 * Third and subsequent arguments are vectors or matrices, they must have the same dimensions
 * and the number of subsequent arguments must match the number of variables specified in the second argument.
 * 
 * @author Rich Morris
 * Created on 14-Feb-2005
 */
public class VMap
	extends PostfixMathCommand
	implements NaryOperatorI, CallbackEvaluationI
{

	/**
	 * 
	 */
	public VMap()
	{
		super();
		this.numberOfParameters = -1;
	}

	public Dimensions calcDim(Dimensions[] dims) throws ParseException
	{
		return dims[2];
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI[] inputs)
		throws ParseException
	{
		return null;
	}

	public static Variable[] getVars(Node varsNode) throws ParseException
	{
		Variable vars[]=null;
		if(varsNode instanceof ASTFunNode 
			&& ((ASTFunNode) varsNode).getPFMC() instanceof VList )
		{
			int nVars = varsNode.jjtGetNumChildren();
			vars = new Variable[nVars];
			for(int i=0;i<nVars;++i)
			{
				Node n = varsNode.jjtGetChild(i);
				if(n instanceof ASTVarNode)
				{
					vars[i] = ((ASTVarNode) n).getVar();
				}
				else
					throw new ParseException("Map: second argument should be list of variables");
			}
		}
		else if(varsNode instanceof ASTVarNode)
		{
			vars = new Variable[1];
			vars[0] = ((ASTVarNode) varsNode).getVar();
		}
		else
			throw new ParseException("Map: second argument should be a variable or list of variables");
		return vars;
	}
	
	public boolean checkNumberOfParameters(int n) {
		return (n >= 3);
	}

	public Object evaluate(
		Node node,
		EvaluatorI pv)
		throws ParseException
	{
		int nChild = node.jjtGetNumChildren();
		if(nChild <3)
			throw new ParseException("Map must have three or more arguments");
		
		// First find the variables
		Variable vars[] = getVars(node.jjtGetChild(1));
			
		if(nChild != vars.length + 2)
			throw new ParseException("Map: number of arguments should match number of variables + 2");

		// Now evaluate third and subsequent arguments
		MatrixValueI inputs[] = new MatrixValueI[nChild-2];
		Dimensions dim=null;
		for(int i=0;i<nChild-2;++i)
		{
			Object out = pv.eval(node.jjtGetChild(i+2));
			if(out instanceof MatrixValueI)
			{
				inputs[i] = (MatrixValueI) out;
				if(i==0) dim = inputs[0].getDim();
				else
				{
					if(!dim.equals(inputs[i].getDim()))
						throw new ParseException("Map: dimensions of thrid and subsequent arguments must match");
				}
			}
			else
				throw new ParseException("Map: third and following arguments should be vectos or matricies");
		}

		// Now evaluate the function for each element
		MatrixValueI res = Tensor.getInstance(dim);
		for(int i=0;i<dim.numEles();++i)
		{
			for(int j=0;j<vars.length;++j)
				vars[j].setValue(inputs[j].getEle(i));
			Object val = pv.eval(node.jjtGetChild(0));
			res.setEle(i,val);
		}
		return res;
	}

}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import java.util.Stack;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.*;

/**
 * Calculate the Determinant of a matrix
 * det([[1,2],[3,4]]) -> 1*4-2*3 = -2
 * 
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class Determinant extends PostfixMathCommand implements UnaryOperatorI
{
	Add add = new Add();
	Subtract sub = new Subtract();
	Multiply mul = new Multiply();
	
	public Determinant()
	{
		super();
		this.numberOfParameters = 1;
	}

	public Dimensions calcDim(Dimensions ldim)
	{
		return Dimensions.ONE;
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		if(!(res instanceof Scaler))
			throw new ParseException("det: result must be a scaler");
		if(!(lhs instanceof Matrix))
			throw new ParseException("det: argument must be a matrix");
		Matrix mat = (Matrix) lhs;
		if( mat.getNumRows()!= mat.getNumCols())
		 	throw new ParseException("det: argument must be a square matrix "+mat);

		if(mat.getNumRows() == 2)
		{
			res.setEle(0,sub.sub(
				mul.mul(mat.getEle(0,0),mat.getEle(1,1)),
				mul.mul(mat.getEle(1,0),mat.getEle(0,1))));
		}
		else if(mat.getNumRows() == 3)
		{	
			// | a b c |
			// | d e f | -> a e j + b f g + c d h - a f h - b d i - c e g
			// | g h i |
			Object r1 = 
				mul.mul(mat.getEle(0,0),mul.mul(mat.getEle(1,1),mat.getEle(2,2)));
			Object r2 = 
				mul.mul(mat.getEle(0,1),mul.mul(mat.getEle(1,2),mat.getEle(2,0)));
			Object r3 = 
				mul.mul(mat.getEle(0,2),mul.mul(mat.getEle(1,0),mat.getEle(2,1)));
			Object r4 = 
				mul.mul(mat.getEle(0,0),mul.mul(mat.getEle(1,2),mat.getEle(2,1)));
			Object r5 = 
				mul.mul(mat.getEle(0,1),mul.mul(mat.getEle(1,0),mat.getEle(2,2)));
			Object r6 = 
				mul.mul(mat.getEle(0,2),mul.mul(mat.getEle(1,1),mat.getEle(2,0)));

			Object r7 =	add.add(r1,add.add(r2,r3));
			Object r8 = add.add(r4,add.add(r5,r6));
			res.setEle(0,sub.sub(r7,r8));
		}
		else
		{
			Object[][] m = mat.getEles();
			res.setEle(0,det(m));
		}
//			throw new ParseException("Sorry can only calculate determinants for 2 by 2 and 3 by 3 matricies");
		return res;
	}

	/** returns a matrix excluding the specifyed row and column */
	public static Object[][] dropRowCol(Object[][] mat,int xrow,int xcol)
	{
		int nrows = mat.length;
		int ncols = mat[0].length;
		Object res[][] = new Object[nrows-1][ncols-1];
		int currow = 0;
		for(int i=0;i<nrows;++i)
		{
			if(i != xrow)
			{
				int curcol = 0;
				for(int j=0;j<ncols;++j)
				{
					if(j != xcol)
					{
						res[currow][curcol] = mat[i][j];
						++curcol;
					}
				}
				++currow;
			}
		}
		return res;
	}
	/** Calculates the determinant of an array 
	 * Uses the fact that
	 * | a b c |
	 * | d e f | = a | e f | - b | d f | + c | d e |
	 * | g h i |     | h i |     | g i |     | g i |  
	 */
	public Object det(Object[][] mat) throws ParseException
	{
		if(mat.length == 1) return mat[0][0];
		if(mat.length == 2) {
			return sub.sub(
				mul.mul(mat[0][0],mat[1][1]),
				mul.mul(mat[1][0],mat[0][1]));
		}
		Object res = new Double(0.0);
		for(int i=0;i<mat.length;++i)
		{
			Object[][] m = dropRowCol(mat,0,i);
			Object det = det(m);
			if(i%2 == 0)
				res = add.add(res,mul.mul(mat[0][i],det));
			else
				res = sub.sub(res,mul.mul(mat[0][i],det));
		}
		return res;
	}
	public void run(Stack s) throws ParseException
	{
		MatrixValueI obj = (MatrixValueI) s.pop();
		MatrixValueI res = Tensor.getInstance(calcDim(obj.getDim()));
		calcValue(res,obj);
		s.push(res);
	}

}
/*
Created 16-May-2006 - Richard Morris
*/
package org.lsmp.djep.vectorJep.function;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.MVector;
import org.lsmp.djep.vectorJep.values.Matrix;
import org.lsmp.djep.vectorJep.values.MatrixValueI;
import org.lsmp.djep.vectorJep.values.Tensor;
import org.nfunk.jep.ASTVarNode;
import org.nfunk.jep.EvaluatorI;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.Variable;
import org.nfunk.jep.function.LValueI;

/**
 * A postfix MathCommand which facilitates the getting and setting of vector and matrix elements.
 * The class implements the set method of LValueI., read access is handled by parent VEle class.
 * For examples
 * <code>
 * a=[1,2,3];
 * a[2]=4;
 * b=[[1,2],[3,4]];
 * b[2,1]=5; 
 * </code>
 * @author Richard Morris
 * TODO implement setting slices a[3:5]=[3,4,5] a[1,]=[1,3]
 */
public class ArrayAccess extends VEle implements LValueI {

	public ArrayAccess() {
		super();
		// TODO Auto-generated constructor stub
	}

	/**
	 * Sets the LValue. For the equation a[2]=5
	 */
	public void set(EvaluatorI pv,Node node, Object value) throws ParseException {
		Node lhs = node.jjtGetChild(0);
		// TODO Auto-generated method stub
		if(! (lhs instanceof ASTVarNode))
			throw new ParseException("ArrayAccess: lhs of operator must be a Variable");
		Variable var = ((ASTVarNode) lhs).getVar();
		MatrixValueI varVal = (MatrixValueI) var.getValue();
		Object indicies = pv.eval(node.jjtGetChild(1));
		if(varVal instanceof MVector)
		{
			if(indicies instanceof Number)
			{
				((MVector) varVal).setEle(((Number) indicies).intValue()-1,value);
				return; 
			}
			else if(indicies instanceof MVector)
			{
				MVector vec = (MVector) indicies;
				if(vec.getDim().equals(Dimensions.ONE))
				{
					int d1 = ((Number) vec.getEle(0)).intValue();
					if(d1<1 || d1 > ((MVector) varVal).getNumEles())
						throw new ParseException("ArrayAccess: array index "+d1+" out of range 1.."+varVal.getDim());
					((MVector) varVal).setEle(d1-1,value);
					return;
				}
			}
			throw new ParseException("ArrayAccess: Bad second argument expecting a double "+indicies.toString());
		}
		else if(varVal instanceof Matrix)
		{
			if(indicies instanceof MVector)
			{
				MVector vec = (MVector) indicies;
				if(vec.getDim().equals(Dimensions.TWO))
				{
					int d1 = ((Number) vec.getEle(0)).intValue();
					int d2 = ((Number) vec.getEle(1)).intValue();
					if( d1<1 || d1 > ((Matrix) varVal).getNumRows()
					 ||	d2<1 || d2 > ((Matrix) varVal).getNumCols() )
						throw new ParseException("ArrayAccess: array indices "+d1+", "+d2+" out of range 1.."+varVal.getDim());
						((Matrix) varVal).setEle(d1-1,d2-1,value);
					return; 
				}
			}
			else throw new ParseException("ArrayAccess:Bad second argument, expecting [i,j] "+indicies.toString());
		}
		else if(indicies instanceof Tensor)
		{
			throw new ParseException("ArrayAccess: Sorry don't know how to set an elements for a tensor");
		}
		throw new ParseException("ArrayAccess: requires a vector matrix or tensor for first argument it has "+varVal.toString());

	}

}
/* @author rich
 * Created on 10-Dec-2004
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * Multiplies any number of Vectors or Matricies element by element.
 * TODO could be much more efficient when called through run.
 * 
 * @author Rich Morris
 * Created on 10-Dec-2004
 */
public class ElementMultiply extends Multiply implements NaryOperatorI {

	public Dimensions calcDim(Dimensions[] dims) throws ParseException {
		int len = dims.length;
		if(len==0) throw new ParseException("ElementMultiply called with 0 arguments");
		if(len==1) return dims[0];
		
		Dimensions firstDim = dims[0];
		for(int i=1;i<len;++i)
			if(!firstDim.equals(dims[i]))
				throw new ParseException("ElementMultiply: dimensions of each argument should be the same");
		
		return firstDim;
	}

	/**
	 * Multiply the inputs element by element putting the results in res.
	 */
	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI[] inputs)
		throws ParseException {

			int numArgs = inputs.length;
			int len = res.getNumEles();
			for(int i=0;i<len;++i)
			{
				Object ele = inputs[0].getEle(i);
				for(int j=1;j<numArgs;++j)
					ele = super.mul(ele,inputs[j].getEle(i));
				res.setEle(i,ele);
			}
			return res;
	}

	/**
	 * Multiply arguments element by element. Returns result.
	 */
	public Object mul(Object param1, Object param2) throws ParseException {

		if(param1 instanceof MatrixValueI && param2 instanceof MatrixValueI)
		{
			return mul((MatrixValueI) param1,(MatrixValueI) param2);
		}
		else if(param1 instanceof MatrixValueI)
		{
			MatrixValueI l = (MatrixValueI) param1;
			MatrixValueI res = Tensor.getInstance(l.getDim());
			for(int i=0;i<res.getNumEles();++i)
				res.setEle(i,super.mul(l.getEle(i),param2));
			return res;
		}
		else if(param2 instanceof MatrixValueI)
		{
			MatrixValueI r = (MatrixValueI) param2;
			MatrixValueI res = Tensor.getInstance(r.getDim());
			for(int i=0;i<res.getNumEles();++i)
				res.setEle(i,super.mul(param1,r.getEle(i)));
			return res;
		}
		return super.mul(param1,param2);
	}

	public Object mul(MatrixValueI param1, MatrixValueI param2) throws ParseException 
	{
		Dimensions dims = this.calcDim(new Dimensions[]{param1.getDim(),param2.getDim()});
		MatrixValueI res = Tensor.getInstance(dims);
		return this.calcValue(res,new MatrixValueI[]{param1,param2});
	}

}
/* @author rich
 * Created on 27-Jul-2003
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import java.util.*;

/**
 * An extension of the Multiply to with vectors and matricies.
 * Must faster (1/3) if used with MatrixJep and calcValue routines.
 * Note vector * vector treated as col_vec * row_vec -> matrix.
 *  
 * @author Rich Morris
 * Created on 27-Jul-2003
 * TODO add handeling of tensors
 * @since 2.3.2 Improved error reporting
 */
public class MDivide extends Divide implements BinaryOperatorI {
	
	protected Add add = new Add();
	protected Subtract sub = new Subtract();
	
	public MDivide()
	{
		//add = (Add) Operator.OP_ADD.getPFMC();
		//sub = (Subtract) Operator.OP_SUBTRACT.getPFMC();
		numberOfParameters = 2;
	}

	/**
	 *  need to redo this as the standard jep version assumes commutivity.
	 */	
	public void run(Stack stack) throws ParseException 
	{
		checkStack(stack); // check the stack
		//if(this.curNumberOfParameters!=2) throw new ParseException("Multiply: should have two children its got "+stack.size());
		Object param2 = stack.pop();
		Object param1 = stack.pop();
		Object product = div(param1, param2);
		stack.push(product);
		return;
	}

	/**
	 * Multiply two objects.
	 */

	public Object div(Object param1, Object param2) throws ParseException 
	{
		if(param1 instanceof MatrixValueI && param2 instanceof MatrixValueI)
		{
			return div((MatrixValueI) param1,(MatrixValueI) param2);
		}
		else if(param1 instanceof MatrixValueI)
		{
			MatrixValueI l = (MatrixValueI) param1;
			MatrixValueI res = Tensor.getInstance(l.getDim());
			for(int i=0;i<res.getNumEles();++i)
				res.setEle(i,super.div(l.getEle(i),param2));
			return res;
		}
		else if(param2 instanceof MatrixValueI)
		{
			MatrixValueI r = (MatrixValueI) param2;
			MatrixValueI res = Tensor.getInstance(r.getDim());
			for(int i=0;i<res.getNumEles();++i)
				res.setEle(i,super.div(param1,r.getEle(i)));
			return res;
		}
		return super.div(param1,param2);
	}
		
	/**
	 * Multiply two objects.
	 */

	public Object mul(MatrixValueI param1, MatrixValueI param2) throws ParseException 
	{
		Dimensions dims = this.calcDim(param1.getDim(),param2.getDim());
		MatrixValueI res = Tensor.getInstance(dims);
		return this.calcValue(res,param1,param2);
	}

	public Dimensions calcDim(Dimensions l,Dimensions r) throws ParseException
	{
		int rrank = r.rank();
		if(rrank!=0) throw new ParseException("MDivide: right hand side must be a scaler. It has dimension "+r.toString());
		return l;
	}

	public MatrixValueI calcValue(MatrixValueI res,MatrixValueI param1,MatrixValueI param2) throws ParseException
	{
		if(param2 instanceof Scaler)
		{
			for(int i=0;i<param1.getDim().numEles();++i)
				res.setEle(i,super.div(param1.getEle(i),param2.getEle(0)));
		}
		else throw new ParseException("MDivide: right hand side must be a scaler. It has dimension "+param2.getDim().toString());
		return res;
	}
}
/* @author rich
 * Created on 02-Nov-2003
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommandI;

/**
 * A matrix enabled operator with N arguments.
 * This interface is primarilary used in the matrixJep package
 * but is here for convienience.
 *  
 * @author Rich Morris
 * Created on 02-Nov-2003
 */
public interface NaryOperatorI extends PostfixMathCommandI {
	/** Find the dimensions of this operator when applied to arguments with given dimensions. */
	public Dimensions calcDim(Dimensions dims[]) throws ParseException;
	/** Calculates the value of this operator for given input with results stored in res.
	 * res is returned.
	 */
	public MatrixValueI calcValue(MatrixValueI res,
		MatrixValueI inputs[]) throws ParseException;
}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import java.util.Stack;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * Creates a diagonal matrix, with a given vector as diagonals elements.
 * diag([1,2,3]) -> [[1,0,0],[0,2,0],[0,0,3]]
 * 
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class Diagonal extends PostfixMathCommand implements UnaryOperatorI
{
	public Diagonal()
	{
		super();
		this.numberOfParameters = 1;
	}

	public Dimensions calcDim(Dimensions ldim)
	{
		return Dimensions.valueOf(ldim.numEles(),ldim.numEles());
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		Matrix mat = (Matrix) res;
		int n = lhs.getNumEles();
		for(int i=0;i<n;++i)
		{
			for(int j=0;j<n;++j)
				mat.setEle(i,j,new Double(0.0));
			mat.setEle(i,i,lhs.getEle(i));
		}
		return res;
	}

	public void run(Stack s) throws ParseException
	{
		MatrixValueI obj = (MatrixValueI) s.pop();
		MatrixValueI res = Tensor.getInstance(calcDim(obj.getDim()));
		calcValue(res,obj);
		s.push(res);
	}

}
/* @author rich
 * Created on 02-Nov-2003
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommandI;

/**
 * A matrix enabled binary operator.
 * This interface is primarilary used in the matrixJep package
 * but is here for convienience.
 *  
 * @author Rich Morris
 * Created on 02-Nov-2003
 */
public interface BinaryOperatorI extends PostfixMathCommandI {
	/** Find the dimensions of this operator when applied to arguments with given dimensions. */
	public Dimensions calcDim(Dimensions ldim,Dimensions rdim) throws ParseException;
	/** Calculates the value of this operator for given input with results stored in res.
	 * res is returned. Using this method is slightly faster
	 * than the standard run method as it eliminates the construction
	 * of tempoary objects.
	 */
	public MatrixValueI calcValue(
		MatrixValueI res,
		MatrixValueI lhs,
		MatrixValueI rhs) throws ParseException;
}
/* @author rich
 * Created on 27-Jul-2003
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.UMinus;
/**
 * Unitary minus for matrices.
 * @author Rich Morris
 * Created on 27-Jul-2003
 */
public class MUMinus extends UMinus implements UnaryOperatorI {

	public Dimensions calcDim(Dimensions ldim)
	{
		return ldim;
	}

	/** calculates the value.
	 * @param res - results will be stored in this object
	 * @param lhs - the value to be negated
	 * @return res
	 */
	public MatrixValueI calcValue(MatrixValueI res,MatrixValueI lhs) throws ParseException
	{
		int len = res.getNumEles();
		for(int i=0;i<len;++i)
			res.setEle(i,super.umin(lhs.getEle(i)));
		return res;
	}


	/**
	 * Negate an objects.
	 */
	
	public Object umin(Object param1) throws ParseException 
	{
		if(param1 instanceof MVector)
			return umin((MVector) param1);
		if(param1 instanceof Matrix)
			return umin((Matrix) param1);
		return super.umin(param1);
	}
	
	/** negate a vector. */
	public MVector umin(MVector lhs) throws ParseException
	{
		MVector res = new MVector(lhs.getNumEles());
		return (MVector) calcValue(res,lhs);
	}

	/** negate a matrix. */
	public Matrix umin(Matrix lhs) throws ParseException
	{
		Matrix res = (Matrix) Matrix.getInstance(lhs.getNumRows(),lhs.getNumCols());
		return (Matrix) calcValue(res,lhs);			
	}

	/** negate a tensor. */
	public Tensor umin(Tensor lhs) throws ParseException
	{
		Tensor res = new Tensor(lhs);
		return (Tensor) calcValue(res,lhs);			
	}
}
/* @author rich
 * Created on 26-Nov-2003
 */
package org.lsmp.djep.vectorJep.function;

import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.*;
import java.util.*;
/**
 * An overloaded power function, if both arguments are vectors returns
 * the exteriour product, else return standard power.
 * @author Rich Morris
 * Created on 26-Nov-2003
 */
public class VPower extends PostfixMathCommand implements BinaryOperatorI 
{
	private static Power pow = new Power();
	private static ExteriorProduct cross = new ExteriorProduct();

	public VPower() {
		super();
		this.numberOfParameters = 2;
	}
	public Dimensions calcDim(Dimensions ldim,Dimensions rdim) throws ParseException
	{
		if(ldim.equals(Dimensions.ONE) && rdim.equals(Dimensions.ONE))
			return Dimensions.ONE;
		if(ldim.equals(Dimensions.THREE) && rdim.equals(Dimensions.THREE))
			return Dimensions.THREE;
		throw new ParseException("Power: both sides must be either 0 dimensional or 3D vectors");
	}

	public MatrixValueI calcValue(
		MatrixValueI res,
		MatrixValueI lhs,
		MatrixValueI rhs) throws ParseException
	{
		if(lhs.getDim().equals(Dimensions.ONE)
		 && rhs.getDim().equals(Dimensions.ONE))
		{
			res.setEle(0,pow.power(lhs.getEle(0),rhs.getEle(0)));
			return res;
		}
		if(lhs.getDim().equals(Dimensions.THREE)
		 && rhs.getDim().equals(Dimensions.THREE))
		{
			return cross.calcValue(res,lhs,rhs);
		}
		throw new ParseException("Power: both sides must be either 0 dimensional or 3D vectors");
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack); // check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		if(param1 instanceof MVector && param2 instanceof MVector)
			inStack.push(cross.crosspower(param1, param2));
		else 
			inStack.push(pow.power(param1,param2));
	}

}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import java.util.Stack;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.*;

/**
 * Calculate the trace of a matrix
 * trace([[1,2],[3,4]]) -> 1+4 = 5
 * 
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class Trace extends PostfixMathCommand implements UnaryOperatorI
{
	Add add = new Add();
	Multiply mul = new Multiply();
	
	public Trace()
	{
		super();
		this.numberOfParameters = 1;
	}

	public Dimensions calcDim(Dimensions ldim)
	{
		return Dimensions.ONE;
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		if(!(res instanceof Scaler))
			throw new ParseException("trace: result must be a scaler");
		if(!(lhs instanceof Matrix))
			throw new ParseException("trace: argument must be a matrix");
		Matrix mat = (Matrix) lhs;
		if( mat.getNumRows()!= mat.getNumCols())
		 	throw new ParseException("trace: argument must be a square matrix "+mat);

		if(mat.getNumRows() == 2)
		{
			res.setEle(0,add.add(mat.getEle(0,0),mat.getEle(1,1)));
		}
		else if(mat.getNumRows() == 3)
		{	
			res.setEle(0,add.add(mat.getEle(0,0),add.add(mat.getEle(1,1),mat.getEle(2,2))));
		}
		else
		{
			Object val = mat.getEle(0,0);
			for(int i=1;i<mat.getNumRows();++i)
				val = add.add(val,mat.getEle(i,i));
			res.setEle(0,val);
		}
		return res;
	}
	public void run(Stack s) throws ParseException
	{
		MatrixValueI obj = (MatrixValueI) s.pop();
		MatrixValueI res = Scaler.getInstance(new Double(0.0));
		calcValue(res,obj);
		s.push(res);
	}

}
/* @author rich
 * Created on 10-Dec-2004
 */
package org.lsmp.djep.vectorJep.function;
import java.util.Stack;

import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * Multiplies any number of Vectors or Matrices element by element.
 * TODO could be much more efficient when called through run.
 * 
 * @author Rich Morris
 * Created on 10-Dec-2004
 */
public class ElementComparative extends Comparative implements BinaryOperatorI {

	public ElementComparative(int index) {super(index);}
	public Dimensions calcDim(Dimensions ldim,Dimensions rdim)
	{
		if(ldim.equals(rdim)) return ldim;
		return null;
	}

	/**
	 * Multiply the inputs element by element putting the results in res.
	 */
	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs,MatrixValueI rhs)
		throws ParseException {

			int len = res.getNumEles();
			for(int i=0;i<len;++i)
			{
				boolean val=false;
				switch(id)
				{
				case LT: val = lt(lhs.getEle(i),rhs.getEle(i)); break;
				case GT: val = gt(lhs.getEle(i),rhs.getEle(i)); break;
				case LE: val = le(lhs.getEle(i),rhs.getEle(i)); break;
				case GE: val = ge(lhs.getEle(i),rhs.getEle(i)); break;
				case NE: val = ne(lhs.getEle(i),rhs.getEle(i)); break;
				case EQ: val = eq(lhs.getEle(i),rhs.getEle(i)); break;
				}
				res.setEle(i,val?new Double(1):new Double(0));
			}
			return res;
	}
	public void run(Stack inStack) throws ParseException {
		Object rhsObj = inStack.pop(); 
		Object lhsObj = inStack.pop();
		if(lhsObj instanceof MatrixValueI && rhsObj instanceof MatrixValueI)
		{
			MatrixValueI lhs = (MatrixValueI) lhsObj;
			MatrixValueI rhs = (MatrixValueI) rhsObj;
			if(!lhs.getDim().equals(rhs.getDim()))
				throw new ParseException("ElementComparative: dimensions of both sides must be equal");
			Dimensions dims = this.calcDim(lhs.getDim(),lhs.getDim());
			MatrixValueI res = Tensor.getInstance(dims);
			calcValue(res,lhs,rhs);
			inStack.push(res);
		}
		else
			throw new ParseException("ElementComparative: arguments must be a Matric or Vector type");
	}


}
/*****************************************************************************

JEP - Java Math Expression Parser 2.24
	  December 30 2002
	  (c) Copyright 2002, Nathan Funk
	  See LICENSE.txt for license information.

*****************************************************************************/
package org.lsmp.djep.vectorJep.function;

import java.util.*;

import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * An overloaded operator, either cross product or power.
 * If the arguments are 3D vectors then treat as cross product.
 * Otherwise treet as power.
 * @author Rich Morris
 * Created on 27-Jul-2003
 */
public class ExteriorProduct extends PostfixMathCommand implements BinaryOperatorI
{
	private Subtract sub = new Subtract();
	private Multiply mul = new Multiply();
	
	public ExteriorProduct()
	{
		numberOfParameters = 2;
	}

	public Dimensions calcDim(Dimensions ldim,Dimensions rdim) throws ParseException
	{
		if(ldim.equals(Dimensions.THREE)&&rdim.equals(Dimensions.THREE))
			return Dimensions.THREE;
		throw new ParseException("^ only implemented for three dimensions vectors");
	}

	public MatrixValueI calcValue(
		MatrixValueI res,
		MatrixValueI lhs,
		MatrixValueI rhs) throws ParseException
	{
		res.setEle(0,sub.sub(
				mul.mul(lhs.getEle(1),rhs.getEle(2)),
				mul.mul(lhs.getEle(2),rhs.getEle(1))));
		res.setEle(1,sub.sub(
				mul.mul(lhs.getEle(2),rhs.getEle(0)),
				mul.mul(lhs.getEle(0),rhs.getEle(2))));
		res.setEle(2,sub.sub(
				mul.mul(lhs.getEle(0),rhs.getEle(1)),
				mul.mul(lhs.getEle(1),rhs.getEle(0))));
		return res;
		
	}

	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack); // check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		inStack.push(crosspower(param1, param2));
	}
	
	public Object crosspower(Object param1, Object param2)
		throws ParseException
	{
		if(param1 instanceof MVector && param2 instanceof MVector)
			return exteriorProduct((MVector) param1,(MVector) param2);
		throw new ParseException("Sorry: can currently only do cross product on 3D vectors");
	}
	
	public Object exteriorProduct(MVector lhs, MVector rhs) throws ParseException
	{
		if(!lhs.getDim().equals(Dimensions.THREE)
		 || !lhs.getDim().equals(Dimensions.THREE) )
		 	throw new ParseException("Cross: Miss match in sizes ("+lhs.getDim()+","+rhs.getDim()+")");
		MVector res = new MVector(3);
		return calcValue(res,lhs,rhs);
	}
}
/* @author rich
 * Created on 27-Jul-2003
 */
package org.lsmp.djep.vectorJep.function;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import java.util.*;

/**
 * An extension of the Multiply to with vectors and matricies.
 * Must faster (1/3) if used with MatrixJep and calcValue routines.
 * Note vector * vector treated as col_vec * row_vec -> matrix.
 *  
 * @author Rich Morris
 * Created on 27-Jul-2003
 * TODO add handeling of tensors
 * @since 2.3.2 Improved error reporting
 */
public class MMultiply extends Multiply implements BinaryOperatorI {
	
	protected Add add = new Add();
	protected Subtract sub = new Subtract();
	
	public MMultiply()
	{
		//add = (Add) Operator.OP_ADD.getPFMC();
		//sub = (Subtract) Operator.OP_SUBTRACT.getPFMC();
		numberOfParameters = 2;
	}




	/**
	 *  need to redo this as the standard jep version assumes commutivity.
	 */	
	public void run(Stack stack) throws ParseException 
	{
		checkStack(stack); // check the stack
		//if(this.curNumberOfParameters!=2) throw new ParseException("Multiply: should have two children its got "+stack.size());
		Object param2 = stack.pop();
		Object param1 = stack.pop();
		Object product = mul(param1, param2);
		stack.push(product);
		return;
	}

	/**
	 * Multiply two objects.
	 */

	public Object mul(Object param1, Object param2) throws ParseException 
	{
		if(param1 instanceof MatrixValueI && param2 instanceof MatrixValueI)
		{
			return mul((MatrixValueI) param1,(MatrixValueI) param2);
		}
		else if(param1 instanceof MatrixValueI)
		{
			MatrixValueI l = (MatrixValueI) param1;
			MatrixValueI res = Tensor.getInstance(l.getDim());
			for(int i=0;i<res.getNumEles();++i)
				res.setEle(i,super.mul(l.getEle(i),param2));
			return res;
		}
		else if(param2 instanceof MatrixValueI)
		{
			MatrixValueI r = (MatrixValueI) param2;
			MatrixValueI res = Tensor.getInstance(r.getDim());
			for(int i=0;i<res.getNumEles();++i)
				res.setEle(i,super.mul(param1,r.getEle(i)));
			return res;
		}
		return super.mul(param1,param2);
	}
		
	/**
	 * Multiply two objects.
	 */

	public Object mul(MatrixValueI param1, MatrixValueI param2) throws ParseException 
	{
		Dimensions dims = this.calcDim(param1.getDim(),param2.getDim());
		MatrixValueI res = Tensor.getInstance(dims);
		return this.calcValue(res,param1,param2);
	}

	public Dimensions calcDim(Dimensions l,Dimensions r) throws ParseException
	{
		int lrank = l.rank();
		int rrank = r.rank();
		
		switch(lrank)
		{
		case 0: // Scaler res
			return r;
		case 1: // Vector * ?
			switch(rrank)
			{
			case 0: // Vector * Scaler -> Vector
				return l;
			case 1: // Vector * Vector -> Matrix
				return Dimensions.valueOf(l.getFirstDim(),r.getFirstDim());
			case 2: // Vector * Matrix -> Vector
				if(l.getLastDim() == r.getFirstDim())
					 return Dimensions.valueOf(r.getLastDim());
				break;
			default: // Tensor res
				throw new ParseException("Sorry I don't know how to multiply a vector by a tensor");
			}
			break;
		case 2: // Matrix * ?
			switch(rrank)
			{
			case 0: // Matrix * Scaler -> Matrix
				return l;
			case 1: // Matrix * Vector -> Vector
				if(l.getLastDim() == r.getFirstDim())
					 return Dimensions.valueOf(l.getFirstDim());
				break;
			case 2: // Matrix * Matrix -> Matrix
				if(l.getLastDim() == r.getFirstDim()) return Dimensions.valueOf(l.getFirstDim(),r.getLastDim());
				break;
			default: // Tensor res
				//throw new ParseException("Sorry I don't know how to multiply a matrix by a tensor");
				
			}
			break;
		default: // Tensor res
			switch(rrank)
			{
			case 0: // Scaler res
				return l;
//			case 1: // Vector res
//				throw new ParseException("Sorry I don't know how to multiply a tensor by a vector");
//			case 2: // Matrix res
//				throw new ParseException("Sorry I don't know how to multiply a tensor by a matrix");
//			default: // Tensor res
//				throw new ParseException("Sorry I don't know how to multiply a tensor by a tensor");
			}
		}
		throw new ParseException("Dimensions for multiply do not match: "+l+" "+r);
	}

	public MatrixValueI calcValue(MatrixValueI res,MatrixValueI param1,MatrixValueI param2) throws ParseException
	{
		if(param1 instanceof Scaler)
		{	
			if(param2 instanceof Scaler)	
			{ // Scaler * Scaler -> Scaler
				res.setEle(0,super.mul(param1.getEle(0),param2.getEle(0)));
			}
			else if(param2 instanceof MVector)
			{
			 // Scaler * Vector -> Vector
				for(int i=0;i<param2.getDim().getFirstDim();++i)
					res.setEle(i,super.mul(param1.getEle(0),param2.getEle(i)));
			}
			else if(param2 instanceof Matrix) // Scaler * Matrix -> Matrix
			{
				Matrix r = (Matrix) param2;
				Matrix mres = (Matrix) res;
				for(int i=0;i<r.getNumRows();++i)
					for(int j=0;j<r.getNumCols();++j)
					mres.setEle(i,j,super.mul(param1.getEle(0),r.getEle(i,j)));
			}
			else
			{ // Tensor res
				for(int i=0;i<param2.getDim().numEles();++i)
					res.setEle(i,super.mul(param1.getEle(0),param2.getEle(i)));
			}
		}
		else if(param1 instanceof MVector)
		{
			if(param2 instanceof Scaler) // Vector * Scaler -> Vector
			{
				for(int i=0;i<param1.getDim().getFirstDim();++i)
					res.setEle(i,super.mul(param1.getEle(i),param2.getEle(0)));
			}
			else if(param2 instanceof MVector) // Vector * Vector -> Matrix
			{
				Matrix mat = (Matrix) res;
				for(int i=0;i<param1.getDim().getFirstDim();++i)
					for(int j=0;j<param2.getDim().getFirstDim();++j)
						mat.setEle(i,j,super.mul(param1.getEle(i),param2.getEle(j)));
			}
			else if(param2 instanceof Matrix) // Vector * Matrix -> Vector
			{
				MVector lhs = (MVector) param1;
				Matrix rhs = (Matrix) param2;
				if(lhs.getNumEles() != rhs.getNumRows()) throw new ParseException("Multiply Matrix , Vector: Miss match in sizes ("+lhs.getNumEles()+","+rhs.getNumRows()+")!");
				for(int i=0;i<rhs.getNumCols();++i)
				{
					Object val = super.mul(lhs.getEle(0),rhs.getEle(0,i));
					for(int j=1;j<rhs.getNumRows();++j)
						val = add.add(val,
								super.mul(lhs.getEle(j),rhs.getEle(j,i)));
					res.setEle(i,val);
				}
			}
			else
			{
				throw new ParseException("Sorry I don't know how to multiply a vector by a tensor");
			}
		}
		else if(param1 instanceof Matrix)
		{
			if(param2 instanceof Scaler) // Matrix * Scaler -> Matrix
			{
				Matrix l = (Matrix) param1;
				Matrix mres = (Matrix) res;
				for(int i=0;i<l.getNumRows();++i)
					for(int j=0;j<l.getNumCols();++j)
					mres.setEle(i,j,super.mul(l.getEle(i,j),param2.getEle(0)));
			}
			else if(param2 instanceof MVector) // Matrix * Vector -> Vector
			{	
				Matrix lhs = (Matrix) param1;
				MVector rhs = (MVector) param2;
				if(lhs.getNumCols() != rhs.getNumEles()) throw new ParseException("Mat * Vec: Miss match in sizes ("+lhs.getNumCols()+","+rhs.getNumEles()+") when trying to add vectors!");
				for(int i=0;i<lhs.getNumRows();++i)
				{
					Object val = super.mul(lhs.getEle(i,0),rhs.getEle(0));
					for(int j=1;j<lhs.getNumCols();++j)
						val = add.add(val,super.mul(lhs.getEle(i,j),rhs.getEle(j)));
					res.setEle(i,val);
				}
			}
			else if(param2 instanceof Matrix) // Matrix * Matrix -> Matrix
			{
				Matrix lhs = (Matrix) param1;
				Matrix rhs = (Matrix) param2;
				Matrix mres = (Matrix) res;
				if(lhs.getNumCols() != rhs.getNumRows()) throw new ParseException("Multiply matrix,matrix: Miss match in number of dims ("+lhs.getNumCols()+","+rhs.getNumRows()+")!");
				int lnr = lhs.getNumRows();
				int lnc = lhs.getNumCols();
				int rnc = rhs.getNumCols();
				Object ldata[][] = lhs.getEles();
				Object rdata[][] = rhs.getEles();
				Object resdata[][] = mres.getEles();
				for(int i=0;i<lnr;++i)
					for(int j=0;j<rnc;++j)
					{
						Object val = mul(ldata[i][0],rdata[0][j]);
						for(int k=1;k<lnc;++k)
							val = add.add(val,
								mul(ldata[i][k],rdata[k][j]));
						resdata[i][j] = val;
					}
			}
			else // Tensor res
				throw new ParseException("Sorry I don't know how to multiply a matrix by a tensor");
		}
		else
		{
			if(param2 instanceof Scaler)
			{
				for(int i=0;i<param1.getDim().numEles();++i)
					res.setEle(i,super.mul(param1.getEle(i),param2.getEle(0)));
			}
			else
				throw new ParseException("Sorry I don't know how to multiply a tensor by a vector");
		}
		return res;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.lsmp.djep.vectorJep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;

/**
 * A enhanced version of List, allows matrices and tensors.
 * During evaluation this function converts lists of values into the appropriate 
 * @see org.lsmp.djep.vectorJep.values.MatrixValueI MatrixValueI
 * type.
 * 
 * @author Rich Morris
 * Created on 27-Nov-2003
 */
public class VList extends org.nfunk.jep.function.List 
	implements NaryOperatorI
{
	public VList()
	{
		numberOfParameters = -1;
	}

	/** Calculates the dimension of this node with given dimensions of children. */
	public Dimensions calcDim(Dimensions dims[]) throws ParseException
	{
		return Dimensions.valueOf(dims.length,dims[0]);
	}
	
	/** Calculates the value of this node.
	 * 
	 */
	public MatrixValueI calcValue(MatrixValueI res,
		MatrixValueI inputs[]) throws ParseException
	{
		int eleSize = inputs[0].getNumEles();
		for(int i=0;i<inputs.length;++i)
		{
			for(int j=0;j<eleSize;++j)
			{
				res.setEle(i*eleSize+j,inputs[i].getEle(j));
			}
		}
		return res;
	}
	
	public void run(Stack inStack) throws ParseException 
	{
		checkStack(inStack); // check the stack
		if(curNumberOfParameters <1)
			throw new ParseException("Empty list");
		Object param1 = inStack.pop();
		
		if(param1 instanceof Vector)
		{
			Vector vec1 = (Vector) param1;
			int rows = curNumberOfParameters;
			int cols = vec1.size();
			Matrix res = (Matrix) Matrix.getInstance(rows,cols);
			for(int j=0;j<cols;++j)
				res.setEle(rows-1,j,vec1.elementAt(j));					
			for(int i=rows-2;i>=0;--i)
			{
				Vector vec = (Vector) inStack.pop();
				for(int j=0;j<cols;++j)
					res.setEle(i,j,vec.elementAt(j));					
			}
			inStack.push(res);
			return;
		}
		else if(param1 instanceof MatrixValueI)
		{
			MatrixValueI mat1 = (MatrixValueI) param1;
			int rows = curNumberOfParameters;
			int neles = mat1.getNumEles();
			MatrixValueI res = Tensor.getInstance(Dimensions.valueOf(rows,mat1.getDim()));
			for(int j=0;j<neles;++j)
				res.setEle((rows-1)*neles+j,mat1.getEle(j));				
			for(int i=rows-2;i>=0;--i)
			{
				MatrixValueI mat = (MatrixValueI) inStack.pop();
				for(int j=0;j<neles;++j)
					res.setEle(i*neles+j,mat.getEle(j));				
			}
			inStack.push(res);
			return;
		}
		else
		{
			MVector res = new MVector(curNumberOfParameters);
			res.setEle(curNumberOfParameters-1,param1);
			for(int i=curNumberOfParameters-2;i>=0;--i)
			{
				Object param = inStack.pop();
				res.setEle(i,param);
			}
			inStack.push(res);
			return;
		}
	}
}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import java.util.Stack;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * Extracts diagonal from a square matrix.
 * getDiag([[1,0,0],[0,2,0],[0,0,3]]) -> [1,2,3]
 * 
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class GetDiagonal extends PostfixMathCommand implements UnaryOperatorI
{
	public GetDiagonal()
	{
		super();
		this.numberOfParameters = 1;
	}

	public Dimensions calcDim(Dimensions ldim)
	{
		return Dimensions.valueOf(ldim.getFirstDim());
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		MVector vec = (MVector) res;
		Matrix mat = (Matrix) lhs;
		if( vec.getNumEles() != mat.getNumRows()
		 ||	vec.getNumEles() != mat.getNumCols())
		 	throw new ParseException("getDiag requires a square matrix");
		for(int i=0;i<vec.getNumEles();++i)
		{
			vec.setEle(i,mat.getEle(i,i));
		}
		return res;
	}

	public void run(Stack s) throws ParseException
	{
		MatrixValueI obj = (MatrixValueI) s.pop();
		MatrixValueI res = Tensor.getInstance(calcDim(obj.getDim()));
		calcValue(res,obj);
		s.push(res);
	}

}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.vectorJep.function;

import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import java.util.Stack;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;

/**
 * Returns the length of a vector. 
 * If the argument is a scaler, matrix or tensor returns total number of elements.
 * <pre>
 * len(5) -> 1
 * len([1,2,3]) -> 3
 * len([[1,2],[3,4],[5,6]]) -> 6
 * </pre>
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class Length extends PostfixMathCommand implements UnaryOperatorI
{
	public Dimensions calcDim(Dimensions ldim)
	{
		return Dimensions.ONE;
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		int neles = lhs.getNumEles();
		res.setEle(0,new Integer(neles));
		return res;
	}

	public void run(Stack aStack) throws ParseException
	{
		Object obj = aStack.pop();
		MatrixValueI res = null;
		if(obj instanceof MatrixValueI)
		{
			res = Scaler.getInstance(new Integer(((MatrixValueI) obj).getNumEles()));
		}
		else
			res = Scaler.getInstance(new Integer(1));
		aStack.push(res);
	}

	public Length()
	{
		super();
		this.numberOfParameters = 1;
	}
}
/* @author rich
 * Created on 15-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.jama;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;
/**
 * Utility functions for adding Jama matrix functions.
 * To add these functions to a VectorJep or MatrixJep instance use
 * <pre>
 * VectorJep j = new VectorJep();
 * j.addStandardFunctions();
 * ...
 * JamaUtil.addStandardFunctions(j);
 * </pre>
 * 
 * @author Rich Morris
 * Created on 15-Feb-2005
 * @see <a href="http://math.nist.gov/javanumerics/jama/">http://math.nist.gov/javanumerics/jama/</a>
 */
public final class JamaUtil
{
	public static Jama.Matrix toJama(Matrix m) throws ParseException
	{
		int rows = m.getNumRows();
		int cols = m.getNumCols();
		Object data[][] = m.getEles();
		double A[][] = new double[rows][cols];
		for(int i=0;i<rows;++i)
			for(int j=0;j<cols;++j)
			{
				Object ele = data[i][j];
				if(ele instanceof Number)
					A[i][j] = ((Number) ele).doubleValue();
				else
					throw new ParseException("Only real matricies are supported");
			}
		return new Jama.Matrix(A);
	}

	public static Jama.Matrix toJamaCol(MVector m) throws ParseException
	{
		int rows =1;
		int cols = m.getNumEles();
		double A[][] = new double[rows][cols];
		
			for(int j=0;j<cols;++j)
			{
				Object ele = m.getEle(j);
				if(ele instanceof Number)
					A[0][j] = ((Number) ele).doubleValue();
				else
					throw new ParseException("Only real matricies are supported");
			}
		return new Jama.Matrix(A);
	}

	public static Jama.Matrix toJamaRow(MVector m) throws ParseException
	{
		int rows = m.getNumEles();
		int cols =1;
		double A[][] = new double[rows][cols];
		
			for(int i=0;i<rows;++i)
			{
				Object ele = m.getEle(i);
				if(ele instanceof Number)
					A[i][0] = ((Number) ele).doubleValue();
				else
					throw new ParseException("Only real matricies are supported");
			}
		return new Jama.Matrix(A);
	}

	public static Matrix fromJama(Jama.Matrix A,Matrix m)
	{
		int rows = A.getRowDimension();
		int cols = A.getRowDimension();
		double in[][] = A.getArray();
		Object out[][] = m.getEles();
		for(int i=0;i<rows;++i)
			for(int j=0;j<cols;++j)
				out[i][j] = new Double(in[i][j]);
		return m;
	}
	public static Matrix fromJama(Jama.Matrix A)
	{
		int rows = A.getRowDimension();
		int cols = A.getRowDimension();
		Matrix m = (Matrix) Matrix.getInstance(rows,cols);
		double in[][] = A.getArray();
		Object out[][] = m.getEles();
		for(int i=0;i<rows;++i)
			for(int j=0;j<cols;++j)
				out[i][j] = new Double(in[i][j]);
		return m;
	}
	
	public static void addStandardFunctions(JEP j)
	{
		j.addFunction("inverse",new Inverse());
		j.addFunction("rank",new Rank());
		j.addFunction("solve",new Solve());
	}
}
/* @author rich
 * Created on 15-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.jama;

import java.util.Stack;

import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;
import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.vectorJep.function.*;

/**
 * Find the inverses of a matrix.
 * Serves a wrapper around the Jama linear algebra function.
 * @see <a href="http://math.nist.gov/javanumerics/jama/">http://math.nist.gov/javanumerics/jama/</a>
 * 
 * @author Rich Morris
 * Created on 15-Feb-2005
 */
public class Inverse extends PostfixMathCommand implements UnaryOperatorI 
{
	public Inverse()
	{
		this.numberOfParameters = 1;
	}


	public void run(Stack s) throws ParseException
	{
		Object o = s.pop();
		if(!(o instanceof Matrix))
			throw new ParseException("inverse: can only be applied to a matrix");
		Jama.Matrix m = JamaUtil.toJama((Matrix) o);
		Jama.Matrix inv = m.inverse();
		Matrix res = JamaUtil.fromJama(inv);
		s.push(res);
	}

	public Dimensions calcDim(Dimensions ldim)
	{
		int rows = ldim.getFirstDim();
		int cols = ldim.getLastDim();
		if(rows < cols) return Dimensions.valueOf(rows,rows);
		else if(rows > cols) return Dimensions.valueOf(cols,cols);
		else return ldim;
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		if(!(lhs instanceof Matrix))
			throw new ParseException("inverse: can only be applied to a matrix");
		if(!(res instanceof Matrix))
			throw new ParseException("inverse: result should be a matrix");
		Jama.Matrix m = JamaUtil.toJama((Matrix) lhs);
		Jama.Matrix inv = m.inverse();
		JamaUtil.fromJama(inv,(Matrix) res);
		return res;
	}

}
/* @author rich
 * Created on 15-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.jama;

import java.util.Stack;

import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;
import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.vectorJep.function.*;

/**
 * Find the rank of a matrix.
 * Serves a wrapper around the Jama linear algebra function.
 * @see <a href="http://math.nist.gov/javanumerics/jama/">http://math.nist.gov/javanumerics/jama/</a>
 * 
 * @author Rich Morris
 * Created on 15-Feb-2005
 */
public class Rank extends PostfixMathCommand implements UnaryOperatorI 
{
	public Rank()
	{
		this.numberOfParameters = 1;
	}


	public void run(Stack s) throws ParseException
	{
		Object o = s.pop();
		if(!(o instanceof Matrix))
			throw new ParseException("inverse: can only be applied to a matrix");
		Jama.Matrix m = JamaUtil.toJama((Matrix) o);
		int rank = m.rank();
		s.push(new Integer(rank));
	}

	public Dimensions calcDim(Dimensions ldim)
	{
		return Dimensions.ONE;
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs)
		throws ParseException
	{
		if(!(lhs instanceof Matrix))
			throw new ParseException("inverse: can only be applied to a matrix");
		if(!(res instanceof Matrix))
			throw new ParseException("inverse: result should be a matrix");
		Jama.Matrix m = JamaUtil.toJama((Matrix) lhs);
		int rank = m.rank();
		res.setEle(0,new Integer(rank));
		return res;
	}

}
/* @author rich
 * Created on 15-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.jama;

import java.util.Stack;

import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;
import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.vectorJep.function.*;

/**
 * z = solve(x,y) solves x*z = y where x,y,z are real matricies.
 * Serves a wrapper around the Jama linear algebra function.
 * @see <a href="http://math.nist.gov/javanumerics/jama/">http://math.nist.gov/javanumerics/jama/</a>
 * 
 * @author Rich Morris
 * Created on 15-Feb-2005
 */
public class Solve extends PostfixMathCommand implements BinaryOperatorI 
{
	public Solve()
	{
		this.numberOfParameters = 2;
	}


	public void run(Stack s) throws ParseException
	{
		Object r = s.pop();
		if(!(r instanceof Matrix))
			throw new ParseException("solve: can only be applied to a matrix");
		Object l = s.pop();
		if(!(l instanceof Matrix))
			throw new ParseException("solve: can only be applied to a matrix");
		Jama.Matrix m = JamaUtil.toJama((Matrix) l);
		Jama.Matrix b = JamaUtil.toJama((Matrix) r);
		Jama.Matrix solve = m.solve(b);
		Matrix res = JamaUtil.fromJama(solve);
		s.push(res);
	}

	public Dimensions calcDim(Dimensions ldim,Dimensions rdim)
	{
		int rows = ldim.getLastDim();
		int cols = rdim.getLastDim();
		return Dimensions.valueOf(rows,cols);
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI lhs,MatrixValueI rhs)
		throws ParseException
	{
		if(!(lhs instanceof Matrix))
			throw new ParseException("solve: can only be applied to a matrix");
		if(!(res instanceof Matrix))
			throw new ParseException("inverse: result should be a matrix");
		Jama.Matrix m = JamaUtil.toJama((Matrix) lhs);
		Jama.Matrix b = JamaUtil.toJama((Matrix) rhs);
		Jama.Matrix solve = m.solve(b);
		JamaUtil.fromJama(solve,(Matrix) res);
		return res;
	}

}
/* @author rich
 * Created on 04-May-2004
 */
package org.lsmp.djep.mrpe;

import org.lsmp.djep.vectorJep.Dimensions;




/** A list of commands evaluated in sequence by the evaluator.  */
public final class MRpCommandList {
	
	/** Data type for the command string */
	static final class MRpCommand {
		short command;
		short aux1; 
		short aux2; 
		MRpCommand(short command,short aux){
			this.command = command; this.aux1 = aux; this.aux2 = -1;
		}
		MRpCommand(short command,short aux1,short aux2){
			this.command = command; this.aux1 = aux1; this.aux2 = aux2;
		}
		public String toString() {
			switch(command)
			{
				case MRpEval.CONST: return "Constant\tnum "+aux1;
				case MRpEval.VAR: return "Variable\ttype "+MRpEval.dimTypeToDimension(aux1)+"\tnum "+aux2;
				case MRpEval.ADD: return "ADD\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.SUB: return "SUB\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.MUL: return "MUL\ttype "+MRpEval.dimTypeToDimension(aux1)+" by "+MRpEval.dimTypeToDimension(aux2);

				case MRpEval.DIV: return "DIV\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.MOD: return "MOD\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.POW: return "POW\ttype "+MRpEval.dimTypeToDimension(aux1);

				case MRpEval.AND: return "AND\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.OR: return "OR\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.NOT: return "NOT\ttype "+MRpEval.dimTypeToDimension(aux1);

				case MRpEval.LT: return "LT\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.GT: return "GT\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.LE: return "LE\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.GE: return "GE\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.NE: return "NE\ttype "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.EQ: return "EQ\ttype "+MRpEval.dimTypeToDimension(aux1);
	
				case MRpEval.ASSIGN: return "Assign type "+MRpEval.dimTypeToDimension(aux1)+" no "+aux2;
				case MRpEval.LIST: return "List type "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.DOT: return "Dot type "+MRpEval.dimTypeToDimension(aux1);
				case MRpEval.CROSS: return "Cross type "+MRpEval.dimTypeToDimension(aux1);

				case MRpEval.FUN: return "Function\tnum "+aux1;
				case MRpEval.UMINUS: return "UMinus\ttype "+MRpEval.dimTypeToDimension(aux1);
			}
			return "Warning unknown command: "+command+" "+aux1+" "+aux2;
		}
	}

	/** Incremental size for list of commands **/
	private static final int STACK_INC=10;
	/** List of commands **/
	MRpCommand commands[] = new MRpCommand[STACK_INC];
	/** Current position in the command Stack. **/
	private short commandPos;
	/** The return type at end of evaluation */
	private int finalType;
	/** The Dimensions of the result */
	private Dimensions resultDim;
	/** Package private constructor */
	MRpCommandList() {}
	/** Adds a command to the list */
	final void addCommand(short command,short aux)
	{
		if(commandPos == commands.length)
		{
			MRpCommand newCommands[] = new MRpCommand[commands.length+STACK_INC];
			System.arraycopy(commands,0,newCommands,0,commands.length);
			commands = newCommands;
		}
		commands[commandPos]=new MRpCommand(command,aux);
		++commandPos;
	}
	/** Adds a command to the list */
	final void addCommand(short command,short aux1,short aux2)
	{
		if(commandPos == commands.length)
		{
			MRpCommand newCommands[] = new MRpCommand[commands.length+STACK_INC];
			System.arraycopy(commands,0,newCommands,0,commands.length);
			commands = newCommands;
		}
		commands[commandPos]=new MRpCommand(command,aux1,aux2);
		++commandPos;
	}
	/** number of commands in list. */
	public int getNumCommands() { return commandPos;}
	/** The return type of argument. */
	int getFinalType() {	return finalType;	}
	void setResultDim(Dimensions dim) { 
		resultDim = dim;
		finalType = MRpEval.getDimType(dim);
	}
	/** converts list to a string. */	
	public String toString() {
		StringBuffer sb = new StringBuffer();
		for(int i=0;i<commandPos;++i) {
			sb.append(commands[i].toString());
			sb.append("\n");
		}
		return sb.toString();
	}
	/** The dimensions of the result */
	public Dimensions getDimsOfResult() { return resultDim; }
}
/* @author rich
 * Created on 04-May-2004
 */
package org.lsmp.djep.mrpe;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.values.MatrixValueI;
import org.lsmp.djep.vectorJep.values.Tensor;
import org.nfunk.jep.ParseException;

/**
 * The base type for values returned by evaluate.
 * 
 * @author Rich Morris
 * Created on 04-May-2004
 */
public abstract class MRpRes {
	/** The Dimension of the object */
	public abstract Dimensions getDims();
	/** 
	 * Copy the value into res.
	 * 
	 * @param res The object values will be copied into, must be of correct type.
	 * @throws ParseException if the res is not of the same type.
	 */
	public abstract void copyToVecMat(MatrixValueI res) throws ParseException;
	/**
	 * Converts to a MatrixValueI object. 
	 * @return a new MatrixValueI with values filled in.
	 * @throws ParseException should not happen!
	 */
	public final MatrixValueI toVecMat()  throws ParseException {
		MatrixValueI res = Tensor.getInstance(getDims());
		copyToVecMat(res);
		return res;
	}
	/**
	 * Returns an array of doubles with the values filled in. 
	 * @return the array either double[] or double[][]
	 */
	public abstract Object toArray();

	public double doubleValue() {return 0.0;};
}
/* @author rich
 * Created on 14-Apr-2004
 */
package org.lsmp.djep.mrpe;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.xjep.*;
import java.util.*;
/**
 * A fast evaluation algorithm for equations using Vectors and Matrix over the Doubles.
 * This is based around reverse polish notation (hence the name M Rp Eval)
 * and is optimised for speed at every opportunity.
 * <p>
 * To use do
 * <pre>
 * MatrixJep j = ...;
 * Node node = ...; 
 * MRpEval rpe = new MRpEval(j);
 * MRpCommandList list = rpe.compile(node);
 * MRpRes rpRes = rpe.evaluate(list);
 * System.out.println(rpRes.toString());
 * MatrixValueI mat = rpRes.toVecMat();
 * rpe.cleanUp();
 * </pre>
 * 
 * <p>
 * The real use of this class is when an equation (or set of equations)
 * need to be repeatedly evaluated with different values for the variables.
 * MRpEval use an internal store for variable values different from those
 * used in the main Jep classes. Changes in the Jep variable values, 
 * say by calling {@link org.nfunk.jep.JEP#setVarValue JEP.setVarValue},
 * are reflected
 * in changes in MRpEval variables, (the converse does not hold).
 * A more efficient way is to use <code>int ref=getVarRef(var)</code>
 * to return an index number of the variable and then calling
 * <code>setVarVal(ref,value)</code> to set its value.
 * For example
 * <pre>
 * MRpCommandList list = rpe.compile(node);
 * int ref = rpe.getVarRef(j.getVar("x"));
 * for(double x=-1.;x<1.001;x+=0.1) {
 *      rpe.setVarVal(ref,x);
 *      rpe.evaluate(list);
 * }
 * </pre>
 * 
 * <p>
 * Combining mrpe with differentation requires special techniques
 * to cope with that fact that internal equations are used
 * <p>
 * The compile methods converts the expression represented by node
 * into a string of commands. For example the expression "1+2*3" will
 * be converted into the sequence of commands
 * <pre>
 * Constant no 1 (pushes constant onto stack)
 * Constant no 2
 * Constant no 3
 * Multiply scalers (multiplies last two entries on stack)
 * Add scalers (adds last two entries on stack)
 * </pre>
 * The evaluate method executes these methods sequentially
 * using a stack (actually a set of stacks)
 * and returns the last object on the stack. 
 * <p>
 * A few cautionary notes: the values returned by evaluate
 * are references to internal variables, their values will change
 * at the next call to compile or evaluate.
 * Its very unlikely to be thread safe. It only works over doubles;
 * expressions with complex numbers or strings will cause problems.
 * It is tuned to work best for expressions involving scalers and 2, 3 and 4 dimensional vectors and matricies,
 * larger vectors and matrices will be noticeably slower.
 * The cleanUp function should be used when you no longer need
 * the evaluator, this stops the evaluator listening to Variable
 * through the java.util.Observer interface.
 * <p>
 * <b>Implementation notes</b>
 * A lot of things have been done to make it as fast as possible:
 * <ul>
 * <li>Everything is final which maximises the possibility for in-lining.</li>
 * <li>All object creation happens during compile.</li>
 * <li>All calculations done using double values.</li>
 * <li>Vectors and Matrices are instances of VecObj and MatObj optimised for speed.
 * For instance a 2 by 2 matrix is an instance of Mat22Obj whose elements
 * are represented by the fields a,b,c,d. This eliminates bound checking on arrays.
 * </li>
 * <li>Each possible vector and matrix operation has been hand coded, and there are
 * a lot of methods (27 just for matrix multiplication!).</li>
 * <li>The values of variables are kept on local arrays for fast access. 
 * These values are kept in sync with the main Jep Variables by using
 * the java.util.Observer interface.</li> 
 * </ul>
 *  
 * <p>
 * For each type of vector or matrix (i.e. 2D vecs, 3D vecs, 4D vecs, 2 by 2 matrices ... 4 by 4 matrices.
 * there is a corresponding class V2Obj, M22Obj etc.
 * which stores the values and another class V2Store, M22Store etc.
 * Each Store class contains a stack, a heap and a array of variable values.
 * During evaluation objects are pushed and popped from the stack
 * when a new object is needed it is taken from the heap.
 * The operation is illustrated by the add method for 2 by 2 matrices.
 * <pre>
 * private final class M22Store
 * {
 *  ....
 *  final void add(){
 *   M22Obj r = stack[--sp]; // pop from stack
 *   M22Obj l = stack[--sp]; // pop from stack
 *	 M22Obj res = heap[hp++]; // result is next entry in heap
 *	 res.a = l.a+r.a;	// add each componant
 *	 res.b = l.b+r.b;
 *	 res.c = l.c+r.c;
 *	 res.d = l.d+r.d;
 *	 stack[sp++]=res;	// push result onto stack
 *  }
 * }
 * </pre>
 *
 * @author Rich Morris
 * Created on 14-Apr-2004
 */
public final class MRpEval implements ParserVisitor {

	private MatrixOperatorSet opSet;

	public MRpEval(MatrixJep mjep) {
		this.opSet = (MatrixOperatorSet) mjep.getOperatorSet();
	}

	private MRpEval() {}
	
	/** compile an expression of the type var = node. */
	public final MRpCommandList compile(MatrixVariableI var,Node node) throws ParseException
	{
		MRpCommandList list = compile(node);
		ObjStore store = getStoreByDim(var.getDimensions());
		short vRef = (short) store.addVar(var);
		store.decStack();
		list.addCommand(ASSIGN,getDimType(var.getDimensions()),vRef);
		return list;
	}
	
	/**
	 * Compile the expressions to produce a set of commands in reverse Polish notation.
	 */
	public final MRpCommandList compile(Node node) throws ParseException
	{
		curCommandList = new MRpCommandList();

		node.jjtAccept(this,null);

		scalerStore.alloc();
		v2Store.alloc();
		v3Store.alloc();
		v4Store.alloc();
		vnStore.alloc();
		m22Store.alloc();
		m23Store.alloc();
		m24Store.alloc();
		m32Store.alloc();
		m33Store.alloc();
		m34Store.alloc();
		m42Store.alloc();
		m43Store.alloc();
		m44Store.alloc();
		mnnStore.alloc();

		Dimensions dims = ((MatrixNodeI) node).getDim();
		curCommandList.setResultDim(dims);
//		returnObj = Tensor.getInstance(dims);
//		if(dims.is2D())
//			returnMat = (Matrix) returnObj;
		return curCommandList;
	}

	/** Index for each command */
	static final short CONST = 0;
	static final short VAR = 1;

	static final short ADD = 2;
	static final short SUB = 3;
	static final short MUL = 4;
	
	static final short DIV = 5;
	static final short MOD = 6;
	static final short POW = 7;

	static final short AND = 8;
	static final short OR  = 9;
	static final short NOT = 10;

	static final short LT = 11;
	static final short LE = 12;
	static final short GT = 13;
	static final short GE = 14;
	static final short NE = 15;
	static final short EQ = 16;
	
	static final short LIST = 17;
	static final short DOT = 18;
	static final short CROSS = 19;

	static final short ASSIGN = 20;
	static final short VLIST = 21;
	static final short MLIST = 22;
	static final short FUN = 23;
	static final short UMINUS = 24;

	static final short FUN2 = 25;
	static final short FUN3 = 26;
	static final short FUN4 = 27;
	static final short POWN = 28;
	static final short RECIP = 29;

	/** Constant type scalers - used in the aux field of RpCommand */
	private static final short SCALER = 0; // Scalers
	private static final short V2 = 2; // 2D vect
	private static final short V3 = 3;
	private static final short V4 = 4;
	private static final short Vn = 5; // n D vec
	private static final short M22 = 6; // 2 by 2 mat
	private static final short M23 = 7; // 2 by 3 mat
	private static final short M24 = 8;
	private static final short M32 = 9;
	private static final short M33 = 10;
	private static final short M34 = 11;
	private static final short M42 = 12;
	private static final short M43 = 13;
	private static final short M44 = 14;
	private static final short Mnn = 15; // other mats
	private static final short Dtens = 16; // tensors
	
	/** Standard functions **/
	
	private static final short SIN = 1;
	private static final short COS = 2;
	private static final short TAN = 3;
	private static final short ASIN = 4;
	private static final short ACOS = 5;
	private static final short ATAN = 6;
	private static final short SINH = 7;
	private static final short COSH = 8;
	private static final short TANH = 9;
	private static final short ASINH = 10;
	private static final short ACOSH = 11;
	private static final short ATANH = 12;
	
	private static final short ABS = 13;
	private static final short EXP = 14;
	private static final short LOG = 15;
	private static final short LN = 16;
	private static final short SQRT = 17;
	
	private static final short SEC = 18;
	private static final short COSEC = 19;
	private static final short COT = 20;
	// 2 argument functions
	private static final short ATAN2 = 21;

	// 3 argument functions
	private static final short IF = 22;


	/** Hashtable for function name lookup **/
	
	private static final Hashtable functionHash = new Hashtable();
	{
		functionHash.put("sin",new Short(SIN));
		functionHash.put("cos",new Short(COS));
		functionHash.put("tan",new Short(TAN));
		functionHash.put("asin",new Short(ASIN));
		functionHash.put("acos",new Short(ACOS));
		functionHash.put("atan",new Short(ATAN));
		functionHash.put("sinh",new Short(SINH));
		functionHash.put("cosh",new Short(COSH));
		functionHash.put("tanh",new Short(TANH));
		functionHash.put("asinh",new Short(ASINH));
		functionHash.put("acosh",new Short(ACOSH));
		functionHash.put("atanh",new Short(ATANH));

		functionHash.put("abs",new Short(ABS));
		functionHash.put("exp",new Short(EXP));
		functionHash.put("log",new Short(LOG));
		functionHash.put("ln",new Short(LN));
		functionHash.put("sqrt",new Short(SQRT));

		functionHash.put("sec",new Short(SEC));
		functionHash.put("cosec",new Short(COSEC));
		functionHash.put("cot",new Short(COT));
		functionHash.put("atan2",new Short(ATAN2));
		functionHash.put("if",new Short(IF));
	}
	/** Contains the constant values **/
	private double constVals[] = new double[0];
	/**
	 * Finds the reference number used for this variable.
	 * @param var
	 * @return an index used to refer to the variable
	 * @throws ParseException
	 */
	public int getVarRef(Variable var) throws ParseException
	{
		Dimensions dims = ((MatrixVariableI)var).getDimensions();
		ObjStore store = getStoreByDim(dims);
		int ref = store.addVar((MatrixVariableI) var);
		return ref;
	}
	/**
	 * Finds the reference number used for this variable.
	 * @param var
	 * @return an index used to refer to the variable
	 * @throws ParseException
	 */
	public int getVarRef(MatrixVariableI var) throws ParseException
	{
		Dimensions dims = var.getDimensions();
		ObjStore store = getStoreByDim(dims);
		int ref = store.addVar(var);
		return ref;
	}

	/**
	 * Sets value of rpe variable.
	 * 
	 * @param ref the reference number for the variable 
	 * (found using {@link #getVarRef(org.lsmp.djep.matrixJep.MatrixVariableI)})
	 * @param val
	 * @throws ParseException
	 */
	public final void setVarValue(int ref,MatrixValueI val)
		throws ParseException
	{
		ObjStore store = getStoreByDim(val.getDim());
		store.setVarValue(ref,val);
	}
	/**
	 * Sets value of rpe variable. 
	 * Only applies to scaler (double variables).
	 * 
	 * @param ref the reference number for the variable
	 * (found using {@link #getVarRef(org.lsmp.djep.matrixJep.MatrixVariableI)})
	 * @param val the value
	 */
	public final void setVarValue(int ref,double val)
	{
		scalerStore.setVarValue(ref,val);
	}
	
	private final static class ScalerObj extends MRpRes {
		double a;
		private ScalerObj(double val) {a =val; }
		public final Dimensions getDims() { return Dimensions.ONE; }
		public final void copyToVecMat(MatrixValueI res)  throws ParseException {
			if(! res.getDim().is0D()) throw new ParseException("CopyToVecMat: dimension of argument "+res.getDim()+" is not equal to dimension of object "+getDims());
			res.setEle(0,new Double(a));
		}
		public final String toString() { return String.valueOf(a); }
		public Object toArray() { return new double[]{a}; }
		public final double doubleValue() { return a; }
	}
	private ScalerObj scalerRes = new ScalerObj(0.0);
	
	private abstract static class VecObj extends MRpRes {
		public final void copyToVecMat(MatrixValueI res)  throws ParseException {
			if(! getDims().equals(res.getDim())) throw new ParseException("CopyToVecMat: dimension of argument "+res.getDim()+" is not equal to dimension of object "+getDims());
			copyToVec((MVector) res);
		}
		public abstract void copyToVec(MVector res);
		abstract double[] toArrayVec();
		public Object toArray() { return toArrayVec();	}
		/**
		 * Sets the value of th vector frm an array.
		 */
//		public abstract void fromArray(double array[]);
	}
	
	private abstract static class MatObj extends MRpRes  {
		public final void copyToVecMat(MatrixValueI res)  throws ParseException {
			if(! getDims().equals(res.getDim())) throw new ParseException("CopyToVecMat: dimension of argument "+res.getDim()+" is not equal to dimension of object "+getDims());
			copyToMat((Matrix) res);
		}
		public abstract void copyToMat(Matrix res);
		abstract double[][] toArrayMat();
		public Object toArray() { return toArrayMat();	}
	}
	/**
	 * Base class for storage for each type of data.
	 * Each subclass should define
	 * <pre>
	 * private Obj stack[];
	 * private Obj heap[];
	 * private Obj vars[]= new Obj[0];
	 * </pre>
	 * where Obj is an Object of the specific type, eg V2Obj.
	 * Memory for the data is allocated from the heap
	 * and the stack is the current data used for calculations.
	 * Data for Variables is stored in vars and references to the Variables
	 * in varRefs. 
	 */
	private abstract static class ObjStore implements Observer {
		/** Contains references to Variables of this type */
		Hashtable varRefs = new Hashtable();
		/** The stack pointer */
		int sp=0;
		/** Maximum size of stack */
		int stackMax=0;
		/** The heap pointer */ 
		int hp=0;
		final void incStack()	{sp++; if(sp > stackMax) stackMax = sp;	}
		final void incHeap()	{hp++;}
		final void decStack()	throws ParseException {--sp; if(sp <0 ) throw new ParseException("RPEval: stack error");}
		/** call this to reset pointers as first step in evaluation */
		final void reset() { sp = 0; hp = 0; }
		/** Add a reference to this variable. 
		 * @return the index of variable in table
		 */
		final int addVar(MatrixVariableI var){
			Object index = varRefs.get(var);
			if(index==null)
			{
				int size = varRefs.size();
				expandVarArray(var);
				varRefs.put(var,new Integer(size));
				copyFromVar(var,size);
				((Variable) var).addObserver(this);
				return size;
			}
			return ((Integer) index).intValue();
		}
		/** Callback function for Observable Variables.
		 * Called whenever the value of a variable is changed
		 * so the private list of variables is kept in sync.
		 */
		final public void update(Observable obs, Object arg1) 
		{
			MatrixVariableI var = (MatrixVariableI) obs;
			Object index = varRefs.get(var);
			copyFromVar(var,((Integer) index).intValue());
		}
		abstract public void setVarValue(int ref,MatrixValueI val);
		/** allocates space needed */
		abstract void alloc();
		/** removed store from list of listeners. */
		final void cleanUp()
		{
			for(Enumeration e=varRefs.keys();e.hasMoreElements();)
			{
				Variable var = (Variable) e.nextElement();
				var.deleteObserver(this);
			}
			varRefs.clear();
		}
		/** Copy variable values into into private storage */
		abstract void copyFromVar(MatrixVariableI var,int i);
		/** Copy values from private storage into JEP variables */
//		abstract void copyToVar(MatrixVariableI var,int i);
		/** expand size of array used to hold variable values. */
		abstract void expandVarArray(MatrixVariableI var);
		/** add two objects of same type */
		abstract void add();
		/** subtract two objects of same type */
		abstract void sub();
		/** subtract two objects of same type */
		abstract void uminus();
		/** multiply by a scaler either of left or right */
		abstract void mulS();
		/** convert a set of scaler values into object of this type */
		abstract void makeList();
		/** assign a variable to stack value
		 * @param i index of variable */
		abstract void assign(int i);
	}

	private final class ScalerStore extends ObjStore {
		double stack[]=new double[0];
		double vars[]= new double[0];
		final void alloc() { 
			stack = new double[stackMax];
		}
		final void expandVarArray(MatrixVariableI var)
		{ 
			double newvars[] = new double[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			vars = newvars;
		}
		final void copyFromVar(MatrixVariableI var,int i)
		{
			if(var.hasValidValue())
			{
				Scaler val = (Scaler) var.getMValue();
				vars[i]=val.doubleValue();
			}
		}
		public void setVarValue(int ref, double val) {
			vars[ref] = val;
		}
		public final void setVarValue(int ref,MatrixValueI val)
		{
				vars[ref]=((Scaler) val).doubleValue();
		}
		final void add(){
			double r = stack[--sp];
			stack[sp-1] += r;
		}
		final void sub(){
			double r = stack[--sp];
			stack[sp-1] -= r;
		}
		final void uminus(){
			double r = stack[--sp];
			stack[sp++] = -r;
		}
		final void mulS(){
			double r = stack[--sp];
			stack[sp-1] *= r;
		} 
		final void divS(){
			double r = stack[--sp];
			stack[sp-1] /= r;
		} 
		final void mod(){
			double r = stack[--sp];
			stack[sp-1] %= r;
		} 
		final void pow(){
			double r = stack[--sp];
			short s = (short) r;
			if(r==s) {
				if(r>=0) { powN(s); return; }
				else { powN((short) -s); recroprical(); return; }
			}
			double l = stack[--sp];
			stack[sp++] = Math.pow(l,r);
		} 
		/**
		 * Code adapted form http://mindprod.com/jgloss/power.html
		 * @author Patricia Shanahan pats@acm.org
		 * almost identical to the method Knuth gives on page 462 of The Art of Computer Programming Volume 2 Seminumerical Algorithms.
		 */
		
		final void powN(short n){
			double r = stack[--sp];
			switch(n){
				case 0: r = 1.0; break;
				case 1: break;
				case 2: r *= r; break;
				case 3: r *= r*r; break;
				case 4: r *= r*r*r; break;
				case 5: r *= r*r*r*r; break;
				case 6: r *= r*r*r*r*r; break;
				case 7: r *= r*r*r*r*r*r; break;
				case 8: r *= r*r*r*r*r*r*r; break;
				default:
				   {
					   short bitMask = n;
					   double evenPower = r;
					   double result;
					   if ( (bitMask & 1) != 0 )
					      result = r;
					   else
					      result = 1;
					   bitMask >>>= 1;
					   while ( bitMask != 0 ) {
					      evenPower *= evenPower;
					      if ( (bitMask & 1) != 0 )
					         result *= evenPower;
					      bitMask >>>= 1;
					   } // end while
					r = result;
				   }
			}
			stack[sp++] = r;
		} 
		final void recroprical(){
			double r = stack[--sp];
				stack[sp++] = 1/r;
		}

		final void makeList() {
		} 
		final void assign(int i) {
			vars[i] = stack[--sp]; ++sp;
		} 
		final void and(){
			double r = stack[--sp];
			double l = stack[--sp];
			if((l != 0.0) && (r != 0.0))
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void or(){
			double r = stack[--sp];
			double l = stack[--sp];
			if((l != 0.0) || (r != 0.0))
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void not(){
			double r = stack[--sp];
			if(r == 0.0)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void lt(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l < r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void gt(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l > r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void le(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l <= r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void ge(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l >= r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void eq(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l == r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void neq(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l != r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
	}
	ScalerStore scalerStore = new ScalerStore();

	/** Base class for vector type storage */
	private abstract class VecStore extends ObjStore {
		abstract void copyVar(int i,MVector val);
		final void copyFromVar(MatrixVariableI var,int i)
		{
			if(var.hasValidValue())
			{
				MVector val = (MVector) ((MatrixVariable) var).getMValue();
				copyVar(i,val);
			}
		}
		
		public final void setVarValue(int ref, MatrixValueI val) {
			copyVar(ref,(MVector) val);
		}
	}

	private static final class V2Obj extends VecObj {
		double a,b;

		private static Dimensions dims = Dimensions.TWO;
		public Dimensions getDims() { return dims;	}
		public String toString() { return "["+a+","+b+"]"; }
		public void fromVec(MVector val){
			a = ((Double) val.getEle(0)).doubleValue();
			b = ((Double) val.getEle(1)).doubleValue();
		}
		public void copyToVec(MVector val){
			val.setEle(0,new Double(a));
			val.setEle(1,new Double(b));
		}
		public double[] toArrayVec() { return new double[]{a,b}; }
	}
	private final class V2Store extends VecStore {
		V2Obj stack[];
		V2Obj heap[];
		V2Obj vars[]= new V2Obj[0];
		final void alloc() { 
			heap = new V2Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new V2Obj();
			stack = new V2Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new V2Obj();
		}

		final void expandVarArray(MatrixVariableI var)
		{ 
			V2Obj newvars[] = new V2Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new V2Obj();
			vars = newvars;
		}
		final void copyVar(int i,MVector vec) { vars[i].fromVec(vec); }
		final void add(){
			V2Obj r = stack[--sp];
			V2Obj l = stack[--sp];
			V2Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			stack[sp++]=res;	
		}
		final void sub(){
			V2Obj r = stack[--sp];
			V2Obj l = stack[--sp];
			V2Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			stack[sp++]=res;	
		}
		final void uminus(){
			V2Obj r = stack[--sp];
			V2Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			V2Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			V2Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			stack[sp++]=res;
		} 
		final void divS()
		{
			V2Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			V2Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			stack[sp++]=res;
		} 
		final void mulV2() { // treat as complex mult
			V2Obj r = stack[--sp];
			V2Obj l = stack[--sp];
			V2Obj res = heap[hp++];
			res.a = l.a*r.a-l.a*r.b;
			res.b = l.a*r.b+l.b*r.a;
			stack[sp++]=res;	
		}
		final void makeList() {
			V2Obj res = heap[hp++];
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i)
		{
			V2Obj r = stack[--sp];  ++sp;
			V2Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
		} 
		final void eq(){
			V2Obj r = stack[--sp];
			V2Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b)
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private V2Store v2Store = new V2Store();

	private static final class V3Obj extends VecObj {
		double a,b,c;

		private static Dimensions dims = Dimensions.THREE;
		public Dimensions getDims() { return dims;	}
		public String toString() { return "["+a+","+b+","+c+"]"; }
		public void fromVec(MVector val){
			a = ((Double) val.getEle(0)).doubleValue();
			b = ((Double) val.getEle(1)).doubleValue();
			c = ((Double) val.getEle(2)).doubleValue();
		}
		public void copyToVec(MVector val){
			val.setEle(0,new Double(a));
			val.setEle(1,new Double(b));
			val.setEle(2,new Double(c));
		}
		public double[] toArrayVec() { return new double[]{a,b,c}; }
	}
	private final class V3Store extends VecStore {
		V3Obj stack[];
		V3Obj heap[];
		V3Obj vars[]= new V3Obj[0];
		final void alloc() { 
			heap = new V3Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new V3Obj();
			stack = new V3Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new V3Obj();
		}
		final void expandVarArray(MatrixVariableI var)
		{ 
			V3Obj newvars[] = new V3Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new V3Obj();
			vars = newvars;
		}
		final void copyVar(int i,MVector vec) { vars[i].fromVec(vec); }
		final void add(){
			V3Obj r = stack[--sp];
			V3Obj l = stack[--sp];
			V3Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;
			stack[sp++]=res;	
		}
		final void sub(){
			V3Obj r = stack[--sp];
			V3Obj l = stack[--sp];
			V3Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;
			stack[sp++]=res;	
		}
		final void uminus(){
			V3Obj r = stack[--sp];
			V3Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			V3Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			V3Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			stack[sp++]=res;
		} 
		final void divS()
		{
			V3Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			V3Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			V3Obj res = heap[hp++];
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			V3Obj r = stack[--sp];  ++sp;
			V3Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
		} 
		final void eq(){
			V3Obj r = stack[--sp];
			V3Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c ) 
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private V3Store v3Store = new V3Store();

	private static final class V4Obj extends VecObj {
		double a,b,c,d;

		private static Dimensions dims = Dimensions.valueOf(4);
		public Dimensions getDims() { return dims;	}
		public String toString() { return "["+a+","+b+","+c+","+d+"]"; }
		public void fromVec(MVector val){
			a = ((Double) val.getEle(0)).doubleValue();
			b = ((Double) val.getEle(1)).doubleValue();
			c = ((Double) val.getEle(2)).doubleValue();
			d = ((Double) val.getEle(3)).doubleValue();
		}
		public void copyToVec(MVector val){
			val.setEle(0,new Double(a));
			val.setEle(1,new Double(b));
			val.setEle(2,new Double(c));
			val.setEle(3,new Double(d));
		}
		public double[] toArrayVec() { return new double[]{a,b,c,d}; }
	}
	private final class V4Store extends VecStore {
		V4Obj stack[];
		V4Obj heap[];
		V4Obj vars[]= new V4Obj[0];
		final void alloc() { 
			heap = new V4Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new V4Obj();
			stack = new V4Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new V4Obj();
		}
		final void expandVarArray(MatrixVariableI var)
		{ 
			V4Obj newvars[] = new V4Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new V4Obj();
			vars = newvars;
		}
		final void copyVar(int i,MVector vec) { vars[i].fromVec(vec); }
		final void add(){
			V4Obj r = stack[--sp];
			V4Obj l = stack[--sp];
			V4Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;
			res.d = l.d+r.d;
			stack[sp++]=res;	
		}
		final void sub(){
			V4Obj r = stack[--sp];
			V4Obj l = stack[--sp];
			V4Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;
			res.d = l.d-r.d;
			stack[sp++]=res;	
		}
		final void uminus(){
			V4Obj r = stack[--sp];
			V4Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			V4Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			V4Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			stack[sp++]=res;
		} 
		final void divS()
		{
			V4Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			V4Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			V4Obj res = heap[hp++];
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			V4Obj r = stack[--sp];  ++sp;
			V4Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
		} 
		final void eq(){
			V4Obj r = stack[--sp];
			V4Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d) 
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private V4Store v4Store = new V4Store();

	private static final class VnObj extends VecObj {
		double data[];
	
		VnObj(int len) { data = new double[len]; }
		VnObj(double vec[]) { data = vec; }
		
		public Dimensions getDims() { return Dimensions.valueOf(data.length);	}
		public String toString() { 
			StringBuffer sb = new StringBuffer("[");
			for(int i=0;i<data.length;++i){
				if(i>0) sb.append(",");
				sb.append(data[i]);
			}
			sb.append("]");
			return sb.toString();
		}
		public void fromVec(MVector val){
			for(int i=0;i<data.length;++i)
				data[i] = ((Double) val.getEle(i)).doubleValue();
		}
		public void copyToVec(MVector val){
			for(int i=0;i<data.length;++i)
				val.setEle(i,new Double(data[i]));
		}
		double[] toArrayVec() { return data; }
		public Object toArray() { 
			double res[] = new double[data.length];
			System.arraycopy(data,0,res,0,data.length);
			return res;
		}
	}
	private final class VnStore extends VecStore {
		VnObj stack[];
		VnObj vars[]= new VnObj[0];
		final void alloc() { 
			stack = new VnObj[stackMax];
		}
		final void expandVarArray(MatrixVariableI var)
		{ 
			VnObj newvars[] = new VnObj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new VnObj(var.getDimensions().getFirstDim());
			vars = newvars;
		}
		final void copyVar(int i,MVector vec) { vars[i].fromVec(vec); }
		final void add(){
			VnObj r = stack[--sp];
			VnObj l = stack[--sp];
			VnObj res = new VnObj(l.data.length);
			for(int i=0;i<l.data.length;++i)
				res.data[i]=l.data[i]+r.data[i];
			stack[sp++]=res;	
		}
		final void sub(){
			VnObj r = stack[--sp];
			VnObj l = stack[--sp];
			VnObj res = new VnObj(l.data.length);
			for(int i=0;i<l.data.length;++i)
				res.data[i]=l.data[i]-r.data[i];
			stack[sp++]=res;	
		}
		final void uminus(){
			VnObj r = stack[--sp];
			VnObj res = new VnObj(r.data.length);
			for(int i=0;i<r.data.length;++i)
				res.data[i]=-r.data[i];
			stack[sp++]=res;	
		}
		final void mulS()
		{
			VnObj r = stack[--sp];
			double l = scalerStore.stack[--scalerStore.sp];
			VnObj res = new VnObj(r.data.length);
			for(int i=0;i<r.data.length;++i)
				res.data[i]=l * r.data[i];
			stack[sp++]=res;
		} 
		final void divS()
		{
			VnObj l = stack[--sp];
			double r = scalerStore.stack[--scalerStore.sp];
			VnObj res = new VnObj(l.data.length);
			for(int i=0;i<l.data.length;++i)
				res.data[i]=l.data[i]/r;
			stack[sp++]=res;
		} 
		final void makeList(int num) {
			VnObj res = new VnObj(num);
			for(int i=num-1;i>=0;--i)
				res.data[i] = scalerStore.stack[--scalerStore.sp]; 
			stack[sp++]=res;
		} 
		final void makeList() {
			throw new UnsupportedOperationException("VnObj: makeList cannot be called with no arguments");
		} 
		final void assign(int j) {
			VnObj r = stack[sp-1];
			VnObj res = vars[j];
			for(int i=0;i<r.data.length;++i)
				res.data[i]=r.data[i];
		} 
		final void eq(){
			VnObj r = stack[--sp];
			VnObj l = stack[--sp];
			for(int i=0;i<r.data.length;++i){
				if(l.data[i]!=r.data[i]){
					scalerStore.stack[scalerStore.sp++] = 0.0;
					return;
				}
			}
			scalerStore.stack[scalerStore.sp++] = 1.0;
		}
	}
	private VnStore vnStore = new VnStore();
	
	private static abstract class MatStore extends ObjStore {
		abstract void copyVar(int i,Matrix val);
		final void copyFromVar(MatrixVariableI var,int i)
		{
			if(var.hasValidValue())
			{
				Matrix val = (Matrix) ((MatrixVariable) var).getMValue();
				copyVar(i,val);
			}
		}
		
/*		final void copyVars(){
			int i=0;
			for(Enumeration e=varRefs.elements();e.hasMoreElements();)
			{
				MatrixVariable var = (MatrixVariable) e.nextElement();
				Matrix val = (Matrix) var.getMValue();
				if(var.hasValidValue())
					copyVar(i,val);
				++i;
			}
		}
*/
		final public void setVarValue(int ref, MatrixValueI val) {
			copyVar(ref,(Matrix) val);
		}
	}
	private static final class M22Obj extends MatObj {
		double a,b, c,d;

		static Dimensions dims = Dimensions.valueOf(2,2);
		public Dimensions getDims() { return dims;	}
		public String toString() { 
			return "[["+a+","+b+"],"+ 
					"["+c+","+d+"]]"; 
		}
		public void fromMat(Matrix val){
			a = ((Double) val.getEle(0,0)).doubleValue();
			b = ((Double) val.getEle(0,1)).doubleValue();
			c = ((Double) val.getEle(1,0)).doubleValue();
			d = ((Double) val.getEle(1,1)).doubleValue();
		}
		public void copyToMat(Matrix val){
			val.setEle(0,0,new Double(a));
			val.setEle(0,1,new Double(b));
			val.setEle(1,0,new Double(c));
			val.setEle(1,1,new Double(d));
		}
		public double[][] toArrayMat() { return new double[][]{{a,b},{c,d}}; }
	}
	private final class M22Store extends MatStore {
		M22Obj stack[];
		M22Obj heap[];
		M22Obj vars[]= new M22Obj[0];
		final void alloc() { 
			heap = new M22Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new M22Obj();
			stack = new M22Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new M22Obj();
		}
		final void expandVarArray(MatrixVariableI var)
		{ 
			M22Obj newvars[] = new M22Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new M22Obj();
			vars = newvars;
		}
		final void copyVar(int i,Matrix val){vars[i].fromMat(val);}
		final void add(){
			M22Obj r = stack[--sp];
			M22Obj l = stack[--sp];
			M22Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;
			res.d = l.d+r.d;
			stack[sp++]=res;	
		}
		final void sub(){
			M22Obj r = stack[--sp];
			M22Obj l = stack[--sp];
			M22Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;
			res.d = l.d-r.d;
			stack[sp++]=res;	
		}
		final void uminus(){
			M22Obj r = stack[--sp];
			M22Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			M22Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			M22Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			stack[sp++]=res;
		}
		final void divS()
		{
			M22Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			M22Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			stack[sp++]=res;
		} 
		final void assign(int i)
		{
			M22Obj r = stack[--sp];  ++sp;
			M22Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
		} 
		final void makeList() {
			M22Obj res = heap[hp++];
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void eq(){
			M22Obj r = stack[--sp];
			M22Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d ) 
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private M22Store m22Store = new M22Store();

	private static final class M23Obj extends MatObj {
		double a,b,c, d,e,f;

		static Dimensions dims = Dimensions.valueOf(2,3);
		public Dimensions getDims() { return dims;	}
		public String toString() { 
			return "[["+a+","+b+","+c+"],"+ 
					"["+d+","+e+","+f+"]]"; 
		}
		final void fromMat(Matrix val){
				a = ((Double) val.getEle(0,0)).doubleValue();
				b = ((Double) val.getEle(0,1)).doubleValue();
				c = ((Double) val.getEle(0,2)).doubleValue();

				d = ((Double) val.getEle(1,0)).doubleValue();
				e = ((Double) val.getEle(1,1)).doubleValue();
				f = ((Double) val.getEle(1,2)).doubleValue();
		}
		public void copyToMat(Matrix val){
			val.setEle(0,0,new Double(a));
			val.setEle(0,1,new Double(b));
			val.setEle(0,2,new Double(c));
			val.setEle(1,0,new Double(d));
			val.setEle(1,1,new Double(e));
			val.setEle(1,2,new Double(f));
		}
		public double[][] toArrayMat() { return new double[][]{{a,b,c},{d,e,f}}; }
	}
	private final class M23Store extends MatStore {
		M23Obj stack[];
		M23Obj heap[];
		M23Obj vars[]= new M23Obj[0];
		final void alloc() { 
			heap = new M23Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new M23Obj();
			stack = new M23Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new M23Obj();
			}
		final void expandVarArray(MatrixVariableI var)
		{ 
			M23Obj newvars[] = new M23Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new M23Obj();
			vars = newvars;
		}
		final void copyVar(int i,Matrix val){vars[i].fromMat(val);}
		final void add(){
			M23Obj r = stack[--sp];
			M23Obj l = stack[--sp];
			M23Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;

			res.d = l.d+r.d;
			res.e = l.e+r.e;
			res.f = l.f+r.f;
			stack[sp++]=res;	
		}
		final void sub(){
			M23Obj r = stack[--sp];
			M23Obj l = stack[--sp];
			M23Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;

			res.d = l.d-r.d;
			res.e = l.e-r.e;
			res.f = l.f-r.f;
			stack[sp++]=res;	
		}
		final void uminus(){
			M23Obj r = stack[--sp];
			M23Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			res.e = -r.e;
			res.f = -r.f;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			M23Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			M23Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			res.e = l * r.e;
			res.f = l * r.f;
			stack[sp++]=res;
		}
		final void divS()
		{
			M23Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			M23Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			res.e = l.e/r;
			res.f = l.f/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			M23Obj res = heap[hp++];
			res.f = scalerStore.stack[--scalerStore.sp]; 
			res.e = scalerStore.stack[--scalerStore.sp]; 
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			M23Obj r = stack[sp-1]; 
			M23Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
			res.e = r.e;
			res.f = r.f;
		} 
		final void eq(){
			M23Obj r = stack[--sp];
			M23Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d 
			  && l.e == r.e && l.f == r.f ) 
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private M23Store m23Store = new M23Store();

	private static final class M24Obj extends MatObj {
		double a,b,c,d, e,f,g,h;

		static Dimensions dims = Dimensions.valueOf(2,4);
		public Dimensions getDims() { return dims;	}
		public String toString() { 
			return "[["+a+","+b+","+c+","+d+"],"+ 
					"["+e+","+f+","+g+","+h+"]]";
		}
		final void fromMat(Matrix val){
				a = ((Double) val.getEle(0,0)).doubleValue();
				b = ((Double) val.getEle(0,1)).doubleValue();
				c = ((Double) val.getEle(0,2)).doubleValue();
				d = ((Double) val.getEle(0,3)).doubleValue();

				e = ((Double) val.getEle(1,0)).doubleValue();
				f = ((Double) val.getEle(1,1)).doubleValue();
				g = ((Double) val.getEle(1,2)).doubleValue();
				h = ((Double) val.getEle(1,3)).doubleValue();
		}
		public void copyToMat(Matrix val){
			val.setEle(0,0,new Double(a));
			val.setEle(0,1,new Double(b));
			val.setEle(0,2,new Double(c));
			val.setEle(0,3,new Double(d));
			val.setEle(1,0,new Double(e));
			val.setEle(1,1,new Double(f));
			val.setEle(1,2,new Double(g));
			val.setEle(1,3,new Double(h));
		}
		public double[][] toArrayMat() { return new double[][]{{a,b,c,d},{e,f,g,h}}; }
	}
	private final class M24Store extends MatStore {
		M24Obj stack[];
		M24Obj heap[];
		M24Obj vars[]= new M24Obj[0];
		final void alloc() { 
			heap = new M24Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new M24Obj();
			stack = new M24Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new M24Obj();
			}
		final void expandVarArray(MatrixVariableI var)
		{ 
			M24Obj newvars[] = new M24Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new M24Obj();
			vars = newvars;
		}
		final void copyVar(int i,Matrix val){vars[i].fromMat(val);}
		final void add(){
			M24Obj r = stack[--sp];
			M24Obj l = stack[--sp];
			M24Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;

			res.d = l.d+r.d;
			res.e = l.e+r.e;
			res.f = l.f+r.f;

			res.g = l.g+r.g;
			res.h = l.h+r.h;
			stack[sp++]=res;	
		}
		final void sub(){
			M24Obj r = stack[--sp];
			M24Obj l = stack[--sp];
			M24Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;

			res.d = l.d-r.d;
			res.e = l.e-r.e;
			res.f = l.f-r.f;

			res.g = l.g-r.g;
			res.h = l.h-r.h;
			stack[sp++]=res;	
		}
		final void uminus(){
			M24Obj r = stack[--sp];
			M24Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			res.e = -r.e;
			res.f = -r.f;
			res.g = -r.g;
			res.h = -r.h;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			M24Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			M24Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			res.e = l * r.e;
			res.f = l * r.f;
			res.g = l * r.g;
			res.h = l * r.h;
			stack[sp++]=res;
		}
		final void divS()
		{
			M24Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			M24Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			res.e = l.e/r;
			res.f = l.f/r;
			res.g = l.g/r;
			res.h = l.h/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			M24Obj res = heap[hp++];
			res.h = scalerStore.stack[--scalerStore.sp]; 
			res.g = scalerStore.stack[--scalerStore.sp]; 
			res.f = scalerStore.stack[--scalerStore.sp]; 
			res.e = scalerStore.stack[--scalerStore.sp]; 
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			M24Obj r = stack[sp-1]; 
			M24Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
			res.e = r.e;
			res.f = r.f;
			res.g = r.g;
			res.h = r.h;
		} 
		final void eq(){
			M24Obj r = stack[--sp];
			M24Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d 
			  && l.e == r.e && l.f == r.f && l.g == r.g && l.h == r.h ) 
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private M24Store m24Store = new M24Store();

	private static final class M32Obj extends MatObj {
		double a,b, c,d, e,f;

		static Dimensions dims = Dimensions.valueOf(3,2);
		public Dimensions getDims() { return dims;	}
		public String toString() { 
			return "[["+a+","+b+"],"+ 
					"["+c+","+d+"],"+ 
					"["+e+","+f+"]]"; 
		}
		final void fromMat(Matrix val){
				a = ((Double) val.getEle(0,0)).doubleValue();
				b = ((Double) val.getEle(0,1)).doubleValue();

				c = ((Double) val.getEle(1,0)).doubleValue();
				d = ((Double) val.getEle(1,1)).doubleValue();

				e = ((Double) val.getEle(2,0)).doubleValue();
				f = ((Double) val.getEle(2,1)).doubleValue();
		}
		public void copyToMat(Matrix val){
			val.setEle(0,0,new Double(a));
			val.setEle(0,1,new Double(b));
			val.setEle(1,0,new Double(c));
			val.setEle(1,1,new Double(d));
			val.setEle(2,0,new Double(e));
			val.setEle(2,1,new Double(f));
		}
		public double[][] toArrayMat() { return new double[][]{{a,b},{c,d},{e,f}}; }
	}
	private final class M32Store extends MatStore {
		M32Obj stack[];
		M32Obj heap[];
		M32Obj vars[]= new M32Obj[0];
		final void alloc() { 
			heap = new M32Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new M32Obj();
			stack = new M32Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new M32Obj();
		}
		final void expandVarArray(MatrixVariableI var)
		{ 
			M32Obj newvars[] = new M32Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new M32Obj();
			vars = newvars;
		}
		final void copyVar(int i,Matrix val){vars[i].fromMat(val);}
		final void add(){
			M32Obj r = stack[--sp];
			M32Obj l = stack[--sp];
			M32Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;

			res.d = l.d+r.d;
			res.e = l.e+r.e;
			res.f = l.f+r.f;
			stack[sp++]=res;	
		}
		final void sub(){
			M32Obj r = stack[--sp];
			M32Obj l = stack[--sp];
			M32Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;
			res.d = l.d-r.d;
			res.e = l.e-r.e;
			res.f = l.f-r.f;
			stack[sp++]=res;	
		}
		final void uminus(){
			M32Obj r = stack[--sp];
			M32Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			res.e = -r.e;
			res.f = -r.f;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			M32Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			M32Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			res.e = l * r.e;
			res.f = l * r.f;
			stack[sp++]=res;
		}
		final void divS()
		{
			M32Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			M32Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			res.e = l.e/r;
			res.f = l.f/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			M32Obj res = heap[hp++];
			res.f = scalerStore.stack[--scalerStore.sp]; 
			res.e = scalerStore.stack[--scalerStore.sp]; 
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			M32Obj r = stack[sp-1]; 
			M32Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
			res.e = r.e;
			res.f = r.f;
		} 
		final void eq(){
			M32Obj r = stack[--sp];
			M32Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d 
			  && l.e == r.e && l.f == r.f ) 
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private M32Store m32Store = new M32Store();

	private static final class M33Obj extends MatObj {
		double a,b,c, d,e,f, g,h,i;
		static Dimensions dims = Dimensions.valueOf(3,3);
		public Dimensions getDims() { return dims;	}
		public void copyToMat(Matrix val){
			val.setEle(0,0,new Double(a));
			val.setEle(0,1,new Double(b));
			val.setEle(0,2,new Double(c));
			val.setEle(1,0,new Double(d));
			val.setEle(1,1,new Double(e));
			val.setEle(1,2,new Double(f));
			val.setEle(2,0,new Double(g));
			val.setEle(2,1,new Double(h));
			val.setEle(2,2,new Double(i));
		}
		public String toString() { 
			return "[["+a+","+b+","+c+"],"+ 
					"["+d+","+e+","+f+"],"+ 
					"["+g+","+h+","+i+"]]"; 
		}
		final void fromMat(Matrix val){
				a = ((Double) val.getEle(0,0)).doubleValue();
				b = ((Double) val.getEle(0,1)).doubleValue();
				c = ((Double) val.getEle(0,2)).doubleValue();

				d = ((Double) val.getEle(1,0)).doubleValue();
				e = ((Double) val.getEle(1,1)).doubleValue();
				f = ((Double) val.getEle(1,2)).doubleValue();

				g = ((Double) val.getEle(2,0)).doubleValue();
				h = ((Double) val.getEle(2,1)).doubleValue();
				i = ((Double) val.getEle(2,2)).doubleValue();
		}
		public double[][] toArrayMat() { return new double[][]{{a,b,c},{d,e,f},{g,h,i}}; }
	}
	private final class M33Store extends MatStore {
		M33Obj stack[];
		M33Obj heap[];
		M33Obj vars[]= new M33Obj[0];
		final void alloc() { 
			heap = new M33Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new M33Obj();
			stack = new M33Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new M33Obj();
			}
		final void expandVarArray(MatrixVariableI var)
		{ 
			M33Obj newvars[] = new M33Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new M33Obj();
			vars = newvars;
		}
		final void copyVar(int i,Matrix val){vars[i].fromMat(val);}
		final void add(){
			M33Obj r = stack[--sp];
			M33Obj l = stack[--sp];
			M33Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;

			res.d = l.d+r.d;
			res.e = l.e+r.e;
			res.f = l.f+r.f;

			res.g = l.g+r.g;
			res.h = l.h+r.h;
			res.i = l.i+r.i;
			stack[sp++]=res;	
		}
		final void sub(){
			M33Obj r = stack[--sp];
			M33Obj l = stack[--sp];
			M33Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;

			res.d = l.d-r.d;
			res.e = l.e-r.e;
			res.f = l.f-r.f;

			res.g = l.g-r.g;
			res.h = l.h-r.h;
			res.i = l.i-r.i;
			stack[sp++]=res;	
		}
		final void uminus(){
			M33Obj r = stack[--sp];
			M33Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			res.e = -r.e;
			res.f = -r.f;
			res.g = -r.g;
			res.h = -r.h;
			res.i = -r.i;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			M33Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			M33Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			res.e = l * r.e;
			res.f = l * r.f;
			res.g = l * r.g;
			res.h = l * r.h;
			res.i = l * r.i;
			stack[sp++]=res;
		} 		
		final void divS()
		{
			M33Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			M33Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			res.e = l.e/r;
			res.f = l.f/r;
			res.g = l.g/r;
			res.h = l.h/r;
			res.i = l.i/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			M33Obj res = heap[hp++];
			res.i = scalerStore.stack[--scalerStore.sp]; 
			res.h = scalerStore.stack[--scalerStore.sp]; 
			res.g = scalerStore.stack[--scalerStore.sp]; 
			res.f = scalerStore.stack[--scalerStore.sp]; 
			res.e = scalerStore.stack[--scalerStore.sp]; 
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			M33Obj r = stack[sp-1]; 
			M33Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
			res.e = r.e;
			res.f = r.f;
			res.g = r.g;
			res.h = r.h;
			res.i = r.i;
		} 
		final void eq(){
			M33Obj r = stack[--sp];
			M33Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d 
			  && l.e == r.e && l.f == r.f && l.g == r.g && l.h == r.h 
			  && l.i == r.i ) 
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private M33Store m33Store = new M33Store();

	private static final class M34Obj extends MatObj {
		double a,b,c,d, e,f,g,h, i,j,k,l;
		private static Dimensions dims = Dimensions.valueOf(3,4);
		public Dimensions getDims() { return dims;	}
		public void copyToMat(Matrix val){
			val.setEle(0,0,new Double(a));
			val.setEle(0,1,new Double(b));
			val.setEle(0,2,new Double(c));
			val.setEle(0,3,new Double(d));
			val.setEle(1,0,new Double(e));
			val.setEle(1,1,new Double(f));
			val.setEle(1,2,new Double(g));
			val.setEle(1,3,new Double(h));
			val.setEle(2,0,new Double(i));
			val.setEle(2,1,new Double(j));
			val.setEle(2,2,new Double(k));
			val.setEle(2,3,new Double(l));
		}
		public String toString() { 
			return "[["+a+","+b+","+c+","+d+"],"+ 
					"["+e+","+f+","+g+","+h+"],"+ 
					"["+i+","+j+","+k+","+l+"]]"; 
		}
		final void fromMat(Matrix val){
				a = ((Double) val.getEle(0,0)).doubleValue();
				b = ((Double) val.getEle(0,1)).doubleValue();
				c = ((Double) val.getEle(0,2)).doubleValue();
				d = ((Double) val.getEle(0,3)).doubleValue();

				e = ((Double) val.getEle(1,0)).doubleValue();
				f = ((Double) val.getEle(1,1)).doubleValue();
				g = ((Double) val.getEle(1,2)).doubleValue();
				h = ((Double) val.getEle(1,3)).doubleValue();

				i = ((Double) val.getEle(2,0)).doubleValue();
				j = ((Double) val.getEle(2,1)).doubleValue();
				k = ((Double) val.getEle(2,2)).doubleValue();
				l = ((Double) val.getEle(2,3)).doubleValue();
		}
		public double[][] toArrayMat() { return new double[][]{{a,b,c,d},{e,f,g,h},{i,j,k,l}}; }
	}
	private final class M34Store extends MatStore {
		M34Obj stack[];
		M34Obj heap[];
		M34Obj vars[]= new M34Obj[0];
		final void alloc() { 
			heap = new M34Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new M34Obj();
			stack = new M34Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new M34Obj();
			}
		final void expandVarArray(MatrixVariableI var)
		{ 
			M34Obj newvars[] = new M34Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new M34Obj();
			vars = newvars;
		}
		final void copyVar(int i,Matrix val){vars[i].fromMat(val);}
		final void add(){
			M34Obj r = stack[--sp];
			M34Obj l = stack[--sp];
			M34Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;
			res.d = l.d+r.d;

			res.e = l.e+r.e;
			res.f = l.f+r.f;
			res.g = l.g+r.g;
			res.h = l.h+r.h;

			res.i = l.i+r.i;
			res.j = l.j+r.j;
			res.k = l.k+r.k;
			res.l = l.l+r.l;
			stack[sp++]=res;	
		}
		final void sub(){
			M34Obj r = stack[--sp];
			M34Obj l = stack[--sp];
			M34Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;
			res.d = l.d-r.d;

			res.e = l.e-r.e;
			res.f = l.f-r.f;
			res.g = l.g-r.g;
			res.h = l.h-r.h;

			res.i = l.i-r.i;
			res.j = l.j-r.j;
			res.k = l.k-r.k;
			res.l = l.l-r.l;
			stack[sp++]=res;	
		}
		final void uminus(){
			M34Obj r = stack[--sp];
			M34Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			res.e = -r.e;
			res.f = -r.f;
			res.g = -r.g;
			res.h = -r.h;
			res.i = -r.i;
			res.j = -r.j;
			res.k = -r.k;
			res.l = -r.l;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			M34Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			M34Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			res.e = l * r.e;
			res.f = l * r.f;
			res.g = l * r.g;
			res.h = l * r.h;
			res.i = l * r.i;
			res.j = l * r.j;
			res.k = l * r.k;
			res.l = l * r.l;
			stack[sp++]=res;
		} 
		final void divS()
		{
			M34Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			M34Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			res.e = l.e/r;
			res.f = l.f/r;
			res.g = l.g/r;
			res.h = l.h/r;
			res.i = l.i/r;
			res.j = l.j/r;
			res.k = l.k/r;
			res.l = l.l/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			M34Obj res = heap[hp++];
			res.l = scalerStore.stack[--scalerStore.sp]; 
			res.k = scalerStore.stack[--scalerStore.sp]; 
			res.j = scalerStore.stack[--scalerStore.sp]; 
			res.i = scalerStore.stack[--scalerStore.sp]; 
			res.h = scalerStore.stack[--scalerStore.sp]; 
			res.g = scalerStore.stack[--scalerStore.sp]; 
			res.f = scalerStore.stack[--scalerStore.sp]; 
			res.e = scalerStore.stack[--scalerStore.sp]; 
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			M34Obj r = stack[sp-1]; 
			M34Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
			res.e = r.e;
			res.f = r.f;
			res.g = r.g;
			res.h = r.h;
			res.i = r.i;
			res.j = r.j;
			res.k = r.k;
			res.l = r.l;
		} 
		final void eq(){
			M34Obj r = stack[--sp];
			M34Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d 
			  && l.e == r.e && l.f == r.f && l.g == r.g && l.h == r.h 
			  && l.i == r.i && l.j == r.j && l.k == r.k && l.l == r.l ) 
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private M34Store m34Store = new M34Store();

	private static final class M42Obj extends MatObj {
		double a,b, c,d, e,f, g,h;

		private static Dimensions dims = Dimensions.valueOf(4,2);
		public Dimensions getDims() { return dims;	}
		public void copyToMat(Matrix val){
			val.setEle(0,0,new Double(a));
			val.setEle(0,1,new Double(b));
			val.setEle(1,0,new Double(c));
			val.setEle(1,1,new Double(d));
			val.setEle(2,0,new Double(e));
			val.setEle(2,1,new Double(f));
			val.setEle(3,0,new Double(g));
			val.setEle(3,1,new Double(h));
		}
		public String toString() { 
			return "[["+a+","+b+"],"+ 
					"["+c+","+d+"],"+ 
					"["+e+","+f+"],"+ 
					"["+g+","+h+"]]"; 
		}
		final void fromMat(Matrix val){
				a = ((Double) val.getEle(0,0)).doubleValue();
				b = ((Double) val.getEle(0,1)).doubleValue();

				c = ((Double) val.getEle(1,0)).doubleValue();
				d = ((Double) val.getEle(1,1)).doubleValue();

				e = ((Double) val.getEle(2,0)).doubleValue();
				f = ((Double) val.getEle(2,1)).doubleValue();

				g = ((Double) val.getEle(3,0)).doubleValue();
				h = ((Double) val.getEle(3,1)).doubleValue();
		}
		public double[][] toArrayMat() { return new double[][]{{a,b},{c,d},{e,f},{g,h}}; }
	}
	private final class M42Store extends MatStore {
		M42Obj stack[];
		M42Obj heap[];
		M42Obj vars[]= new M42Obj[0];
		final void alloc() { 
			heap = new M42Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new M42Obj();
			stack = new M42Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new M42Obj();
			}
		final void expandVarArray(MatrixVariableI var)
		{ 
			M42Obj newvars[] = new M42Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new M42Obj();
			vars = newvars;
		}
		final void copyVar(int i,Matrix val){vars[i].fromMat(val);}
		final void add(){
			M42Obj r = stack[--sp];
			M42Obj l = stack[--sp];
			M42Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;

			res.c = l.c+r.c;
			res.d = l.d+r.d;

			res.e = l.e+r.e;
			res.f = l.f+r.f;

			res.g = l.g+r.g;
			res.h = l.h+r.h;
			stack[sp++]=res;	
		}
		final void sub(){
			M42Obj r = stack[--sp];
			M42Obj l = stack[--sp];
			M42Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;

			res.d = l.d-r.d;
			res.e = l.e-r.e;
			res.f = l.f-r.f;

			res.g = l.g-r.g;
			res.h = l.h-r.h;
			stack[sp++]=res;	
		}
		final void uminus(){
			M42Obj r = stack[--sp];
			M42Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			res.e = -r.e;
			res.f = -r.f;
			res.g = -r.g;
			res.h = -r.h;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			M42Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			M42Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			res.e = l * r.e;
			res.f = l * r.f;
			res.g = l * r.g;
			res.h = l * r.h;
			stack[sp++]=res;
		}
		final void divS()
		{
			M42Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			M42Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			res.e = l.e/r;
			res.f = l.f/r;
			res.g = l.g/r;
			res.h = l.h/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			M42Obj res = heap[hp++];
			res.h = scalerStore.stack[--scalerStore.sp]; 
			res.g = scalerStore.stack[--scalerStore.sp]; 
			res.f = scalerStore.stack[--scalerStore.sp]; 
			res.e = scalerStore.stack[--scalerStore.sp]; 
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			M42Obj r = stack[sp-1]; 
			M42Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
			res.e = r.e;
			res.f = r.f;
			res.g = r.g;
			res.h = r.h;
		} 
		final void eq(){
			M42Obj r = stack[--sp];
			M42Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d 
			  && l.e == r.e && l.f == r.f && l.g == r.g && l.h == r.h )
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private M42Store m42Store = new M42Store();

	private static final class M43Obj extends MatObj {
		double a,b,c, d,e,f, g,h,i, j,k,l;

		private static Dimensions dims = Dimensions.valueOf(4,3);
		public Dimensions getDims() { return dims;	}
		public void copyToMat(Matrix val){
			val.setEle(0,0,new Double(a));
			val.setEle(0,1,new Double(b));
			val.setEle(0,2,new Double(c));
			val.setEle(1,0,new Double(d));
			val.setEle(1,1,new Double(e));
			val.setEle(1,2,new Double(f));
			val.setEle(2,0,new Double(g));
			val.setEle(2,1,new Double(h));
			val.setEle(2,2,new Double(i));
			val.setEle(3,0,new Double(j));
			val.setEle(3,1,new Double(k));
			val.setEle(3,2,new Double(l));
		}
		public String toString() { 
			return "[["+a+","+b+","+c+"],"+ 
					"["+d+","+e+","+f+"],"+ 
					"["+g+","+h+","+i+"],"+ 
					"["+j+","+k+","+l+"]]"; 
		}
		final void fromMat(Matrix val){
				a = ((Double) val.getEle(0,0)).doubleValue();
				b = ((Double) val.getEle(0,1)).doubleValue();
				c = ((Double) val.getEle(0,2)).doubleValue();

				d = ((Double) val.getEle(1,0)).doubleValue();
				e = ((Double) val.getEle(1,1)).doubleValue();
				f = ((Double) val.getEle(1,2)).doubleValue();

				g = ((Double) val.getEle(2,0)).doubleValue();
				h = ((Double) val.getEle(2,1)).doubleValue();
				i = ((Double) val.getEle(2,2)).doubleValue();

				j = ((Double) val.getEle(3,0)).doubleValue();
				k = ((Double) val.getEle(3,1)).doubleValue();
				l = ((Double) val.getEle(3,2)).doubleValue();
		}
		public double[][] toArrayMat() { return new double[][]{{a,b,c},{d,e,f},{g,h,i},{j,k,l}}; }
	}
	private final class M43Store extends MatStore {
		M43Obj stack[];
		M43Obj heap[];
		M43Obj vars[]= new M43Obj[0];
		final void alloc() { 
			heap = new M43Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new M43Obj();
			stack = new M43Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new M43Obj();
			}
		final void expandVarArray(MatrixVariableI var)
		{ 
			M43Obj newvars[] = new M43Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new M43Obj();
			vars = newvars;
		}
		final void copyVar(int i,Matrix val){vars[i].fromMat(val);}
		final void add(){
			M43Obj r = stack[--sp];
			M43Obj l = stack[--sp];
			M43Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;

			res.d = l.d+r.d;
			res.e = l.e+r.e;
			res.f = l.f+r.f;

			res.g = l.g+r.g;
			res.h = l.h+r.h;
			res.i = l.i+r.i;

			res.j = l.j+r.j;
			res.k = l.k+r.k;
			res.l = l.l+r.l;
			stack[sp++]=res;	
		}
		final void sub(){
			M43Obj r = stack[--sp];
			M43Obj l = stack[--sp];
			M43Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;

			res.d = l.d-r.d;
			res.e = l.e-r.e;
			res.f = l.f-r.f;

			res.g = l.g-r.g;
			res.h = l.h-r.h;
			res.i = l.i-r.i;

			res.j = l.j-r.j;
			res.k = l.k-r.k;
			res.l = l.l-r.l;
			stack[sp++]=res;	
		}
		final void uminus(){
			M43Obj r = stack[--sp];
			M43Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			res.e = -r.e;
			res.f = -r.f;
			res.g = -r.g;
			res.h = -r.h;
			res.i = -r.i;
			res.j = -r.j;
			res.k = -r.k;
			res.l = -r.l;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			M43Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			M43Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			res.e = l * r.e;
			res.f = l * r.f;
			res.g = l * r.g;
			res.h = l * r.h;
			res.i = l * r.i;
			res.j = l * r.j;
			res.k = l * r.k;
			res.l = l * r.l;
			stack[sp++]=res;
		}
		final void divS()
		{
			M43Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			M43Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			res.e = l.e/r;
			res.f = l.f/r;
			res.g = l.g/r;
			res.h = l.h/r;
			res.i = l.i/r;
			res.j = l.j/r;
			res.k = l.k/r;
			res.l = l.l/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			M43Obj res = heap[hp++];
			res.l = scalerStore.stack[--scalerStore.sp]; 
			res.k = scalerStore.stack[--scalerStore.sp]; 
			res.j = scalerStore.stack[--scalerStore.sp]; 
			res.i = scalerStore.stack[--scalerStore.sp]; 
			res.h = scalerStore.stack[--scalerStore.sp]; 
			res.g = scalerStore.stack[--scalerStore.sp]; 
			res.f = scalerStore.stack[--scalerStore.sp]; 
			res.e = scalerStore.stack[--scalerStore.sp]; 
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			M43Obj r = stack[sp-1]; 
			M43Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
			res.e = r.e;
			res.f = r.f;
			res.g = r.g;
			res.h = r.h;
			res.i = r.i;
			res.j = r.j;
			res.k = r.k;
			res.l = r.l;
		} 
		final void eq(){
			M43Obj r = stack[--sp];
			M43Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d 
			  && l.e == r.e && l.f == r.f && l.g == r.g && l.h == r.h 
			  && l.i == r.i && l.j == r.j && l.k == r.k && l.l == r.l ) 
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private M43Store m43Store = new M43Store();

	private static final class M44Obj extends MatObj {
		double a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p;

		private static Dimensions dims = Dimensions.valueOf(4,4);
		public Dimensions getDims() { return dims;	}
		public void copyToMat(Matrix val){
			val.setEle(0,0,new Double(a));
			val.setEle(0,1,new Double(b));
			val.setEle(0,2,new Double(c));
			val.setEle(0,3,new Double(d));
			val.setEle(1,0,new Double(e));
			val.setEle(1,1,new Double(f));
			val.setEle(1,2,new Double(g));
			val.setEle(1,3,new Double(h));
			val.setEle(2,0,new Double(i));
			val.setEle(2,1,new Double(j));
			val.setEle(2,2,new Double(k));
			val.setEle(2,3,new Double(l));
			val.setEle(3,0,new Double(m));
			val.setEle(3,1,new Double(n));
			val.setEle(3,2,new Double(o));
			val.setEle(3,3,new Double(p));
		}
		public String toString() { 
			return "[["+a+","+b+","+c+","+d+"],"+ 
					"["+e+","+f+","+g+","+h+"],"+ 
					"["+i+","+j+","+k+","+l+"],"+ 
					"["+m+","+n+","+o+","+p+"]]"; 
		}
		final void fromMat(Matrix val){
				a = ((Double) val.getEle(0,0)).doubleValue();
				b = ((Double) val.getEle(0,1)).doubleValue();
				c = ((Double) val.getEle(0,2)).doubleValue();
				d = ((Double) val.getEle(0,3)).doubleValue();

				e = ((Double) val.getEle(1,0)).doubleValue();
				f = ((Double) val.getEle(1,1)).doubleValue();
				g = ((Double) val.getEle(1,2)).doubleValue();
				h = ((Double) val.getEle(1,3)).doubleValue();

				i = ((Double) val.getEle(2,0)).doubleValue();
				j = ((Double) val.getEle(2,1)).doubleValue();
				k = ((Double) val.getEle(2,2)).doubleValue();
				l = ((Double) val.getEle(2,3)).doubleValue();

				m = ((Double) val.getEle(3,0)).doubleValue();
				n = ((Double) val.getEle(3,1)).doubleValue();
				o = ((Double) val.getEle(3,2)).doubleValue();
				p = ((Double) val.getEle(3,3)).doubleValue();
		}
		public double[][] toArrayMat() { return new double[][]{{a,b,c,d},{e,f,g,h},{i,j,k,l},{m,n,o,p}}; }
	}
	private final class M44Store extends MatStore {
		M44Obj stack[];
		M44Obj heap[];
		M44Obj vars[]= new M44Obj[0];
		final void alloc() { 
			heap = new M44Obj[hp]; 
			for(int i=0;i<hp;++i) heap[i]=new M44Obj();
			stack = new M44Obj[stackMax];
			for(int i=0;i<stackMax;++i) stack[i]=new M44Obj();
			M44Obj newvars[] = new M44Obj[varRefs.size()];
			System.arraycopy(vars,0,newvars,0,vars.length);
			for(int i=vars.length;i<varRefs.size();++i) newvars[i]=new M44Obj();
			vars = newvars;
			}
		final void expandVarArray(MatrixVariableI var)
		{ 
			M44Obj newvars[] = new M44Obj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			newvars[vars.length]=new M44Obj();
			vars = newvars;
		}
		final void copyVar(int i,Matrix val){vars[i].fromMat(val);}
		final void add(){
			M44Obj r = stack[--sp];
			M44Obj l = stack[--sp];
			M44Obj res = heap[hp++];
			res.a = l.a+r.a;
			res.b = l.b+r.b;
			res.c = l.c+r.c;
			res.d = l.d+r.d;

			res.e = l.e+r.e;
			res.f = l.f+r.f;
			res.g = l.g+r.g;
			res.h = l.h+r.h;

			res.i = l.i+r.i;
			res.j = l.j+r.j;
			res.k = l.k+r.k;
			res.l = l.l+r.l;

			res.m = l.m+r.m;
			res.n = l.n+r.n;
			res.o = l.o+r.o;
			res.p = l.p+r.p;
			stack[sp++]=res;	
		}
		final void sub(){
			M44Obj r = stack[--sp];
			M44Obj l = stack[--sp];
			M44Obj res = heap[hp++];
			res.a = l.a-r.a;
			res.b = l.b-r.b;
			res.c = l.c-r.c;
			res.d = l.d-r.d;

			res.e = l.e-r.e;
			res.f = l.f-r.f;
			res.g = l.g-r.g;
			res.h = l.h-r.h;

			res.i = l.i-r.i;
			res.j = l.j-r.j;
			res.k = l.k-r.k;
			res.l = l.l-r.l;

			res.m = l.m-r.m;
			res.n = l.n-r.n;
			res.o = l.o-r.o;
			res.p = l.p-r.p;
			stack[sp++]=res;	
		}
		final void uminus(){
			M44Obj r = stack[--sp];
			M44Obj res = heap[hp++];
			res.a = -r.a;
			res.b = -r.b;
			res.c = -r.c;
			res.d = -r.d;
			res.e = -r.e;
			res.f = -r.f;
			res.g = -r.g;
			res.h = -r.h;
			res.i = -r.i;
			res.j = -r.j;
			res.k = -r.k;
			res.l = -r.l;
			res.m = -r.m;
			res.n = -r.n;
			res.o = -r.o;
			res.p = -r.p;
			stack[sp++]=res;	
		}
		final void mulS()
		{
			M44Obj r = stack[--sp]; 
			double l = scalerStore.stack[--scalerStore.sp];
			M44Obj res = heap[hp++]; 
			res.a = l * r.a;
			res.b = l * r.b;
			res.c = l * r.c;
			res.d = l * r.d;
			res.e = l * r.e;
			res.f = l * r.f;
			res.g = l * r.g;
			res.h = l * r.h;
			res.i = l * r.i;
			res.j = l * r.j;
			res.k = l * r.k;
			res.l = l * r.l;
			res.m = l * r.m;
			res.n = l * r.n;
			res.o = l * r.o;
			res.p = l * r.p;
			stack[sp++]=res;
		} 
		final void divS()
		{
			M44Obj l = stack[--sp]; 
			double r = scalerStore.stack[--scalerStore.sp];
			M44Obj res = heap[hp++]; 
			res.a = l.a/r;
			res.b = l.b/r;
			res.c = l.c/r;
			res.d = l.d/r;
			res.e = l.e/r;
			res.f = l.f/r;
			res.g = l.g/r;
			res.h = l.h/r;
			res.i = l.i/r;
			res.j = l.j/r;
			res.k = l.k/r;
			res.l = l.l/r;
			res.m = l.m/r;
			res.n = l.n/r;
			res.o = l.o/r;
			res.p = l.p/r;
			stack[sp++]=res;
		} 
		final void makeList() {
			M44Obj res = heap[hp++];
			res.p = scalerStore.stack[--scalerStore.sp]; 
			res.o = scalerStore.stack[--scalerStore.sp]; 
			res.n = scalerStore.stack[--scalerStore.sp]; 
			res.m = scalerStore.stack[--scalerStore.sp]; 
			res.l = scalerStore.stack[--scalerStore.sp]; 
			res.k = scalerStore.stack[--scalerStore.sp]; 
			res.j = scalerStore.stack[--scalerStore.sp]; 
			res.i = scalerStore.stack[--scalerStore.sp]; 
			res.h = scalerStore.stack[--scalerStore.sp]; 
			res.g = scalerStore.stack[--scalerStore.sp]; 
			res.f = scalerStore.stack[--scalerStore.sp]; 
			res.e = scalerStore.stack[--scalerStore.sp]; 
			res.d = scalerStore.stack[--scalerStore.sp]; 
			res.c = scalerStore.stack[--scalerStore.sp]; 
			res.b = scalerStore.stack[--scalerStore.sp]; 
			res.a = scalerStore.stack[--scalerStore.sp];
			stack[sp++]=res;
		} 
		final void assign(int i) {
			M44Obj r = stack[sp-1]; 
			M44Obj res = vars[i]; 
			res.a = r.a;
			res.b = r.b;
			res.c = r.c;
			res.d = r.d;
			res.e = r.e;
			res.f = r.f;
			res.g = r.g;
			res.h = r.h;
			res.i = r.i;
			res.j = r.j;
			res.k = r.k;
			res.l = r.l;
			res.m = r.m;
			res.n = r.n;
			res.o = r.o;
			res.p = r.p;
		} 
		final void eq(){
			M44Obj r = stack[--sp];
			M44Obj l = stack[--sp];
			if(l.a == r.a && l.b == r.b && l.c == r.c && l.d == r.d 
			  && l.e == r.e && l.f == r.f && l.g == r.g && l.h == r.h 
			  && l.i == r.i && l.j == r.j && l.k == r.k && l.l == r.l 
			  && l.m == r.m && l.n == r.n && l.o == r.o && l.p == r.p )
				scalerStore.stack[scalerStore.sp++] = 1.0;
			else
				scalerStore.stack[scalerStore.sp++] = 0.0;
		}
	}
	private M44Store m44Store = new M44Store();

	final static Dimensions dimTypeToDimension(int dt) {
		switch(dt)
		{
			case SCALER:  return Dimensions.ONE;
			case V2:  return Dimensions.TWO;
			case V3:  return Dimensions.THREE;
			case V4:  return Dimensions.valueOf(4);
			case M22: return Dimensions.valueOf(2,2);
			case M23: return Dimensions.valueOf(2,3);
			case M24: return Dimensions.valueOf(2,4);
			case M32: return Dimensions.valueOf(3,2);
			case M33: return Dimensions.valueOf(3,3);
			case M34: return Dimensions.valueOf(3,4);
			case M42: return Dimensions.valueOf(4,2);
			case M43: return Dimensions.valueOf(4,3);
			case M44: return Dimensions.valueOf(4,4);
		}
		return null;
	}
	/** Gets the type of dimension **/
	static final short getDimType(Dimensions dims)
	{
		if(dims.is0D())
			return SCALER;
		else if(dims.is1D())
		{
			switch(dims.getFirstDim())
			{
			case 2: return V2;
			case 3: return V3;
			case 4: return V4;
			default: return Vn;
			}
		}
		else if(dims.is2D())
		{
			switch(dims.getFirstDim())
			{
			case 2:
				switch(dims.getLastDim())
				{
					case 2:	return M22;
					case 3:	return M23;
					case 4:	return M24;
				}
				break;
			case 3:
				switch(dims.getLastDim())
				{
					case 2:	return M32;
					case 3:	return M33;
					case 4:	return M34;
				}
				break;
			case 4:
				switch(dims.getLastDim())
				{
					case 2:	return M42;
					case 3:	return M43;
					case 4:	return M44;
				}
				break;
			}
			return Mnn;
		}
		return Dtens;
	}
	
	private final ObjStore getStoreByDim(Dimensions dims) throws ParseException
	{
		switch(getDimType(dims))
		{
			case SCALER:  return scalerStore;
			case V2:  return v2Store;
			case V3:  return v3Store;
			case V4:  return v4Store;
			case Vn:  return vnStore;
			case M22: return m22Store;
			case M23: return m23Store;
			case M24: return m24Store;
			case M32: return m32Store;
			case M33: return m33Store;
			case M34: return m34Store;
			case M42: return m42Store;
			case M43: return m43Store;
			case M44: return m44Store;
			case Mnn: return mnnStore;
			default:
			throw new ParseException("Sorry, can only handle scaler, 2, 3 and 4 dimensional vectors and matrices");
		}
	}

	private static final class MnnObj extends MatObj {
		double data[][];
		int rows,cols;
		MnnObj(int row,int col) { data = new double[row][col]; rows=row; cols=col;}
		MnnObj(double mat[][]) { data = mat; rows=mat.length; cols=mat[0].length;}
			
		public Dimensions getDims() { return Dimensions.valueOf(rows,cols);}
		public String toString() { 
			StringBuffer sb = new StringBuffer("[");
			for(int i=0;i<rows;++i){
				if(i>0) sb.append(',');
				sb.append('[');
				for(int j=0;j<cols;++j){
					if(j>0) sb.append(',');
					sb.append(data[i][j]);
				}
				sb.append(']');
			}
			sb.append(']');
			return sb.toString();
		}
		public void fromMat(Matrix val){
			for(int i=0;i<rows;++i)
				for(int j=0;j<cols;++j)
					data[i][j] = ((Double) val.getEle(i,j)).doubleValue();
		}
		public void copyToMat(Matrix val){
			for(int i=0;i<rows;++i)
				for(int j=0;j<cols;++j)
					val.setEle(i,j,new Double(data[i][j]));
		}
		double[][] toArrayMat() { return data; }
		public Object toArray() { 
			double res[][] = new double[rows][cols];
			for(int i=0;i<rows;++i)
				System.arraycopy(data[i],0,res[i],0,cols);
			return res;
		}
	}
	private final class MnnStore extends MatStore {
		MnnObj stack[];
		MnnObj vars[]= new MnnObj[0];
		final void alloc() { 
			stack = new MnnObj[stackMax];
		}
		final void expandVarArray(MatrixVariableI var)
		{ 
			MnnObj newvars[] = new MnnObj[vars.length+1];
			System.arraycopy(vars,0,newvars,0,vars.length);
			Dimensions dims = var.getDimensions();
			newvars[vars.length]=new MnnObj(dims.getFirstDim(),dims.getLastDim());
			vars = newvars;
		}
		final void copyVar(int i,Matrix mat) { vars[i].fromMat(mat); }
		final void add(){
			MnnObj r = stack[--sp];
			MnnObj l = stack[--sp];
			MnnObj res = new MnnObj(l.rows,l.cols);
			for(int i=0;i<l.rows;++i)
				for(int j=0;j<l.cols;++j)
					res.data[i][j]=l.data[i][j]+r.data[i][j];
			stack[sp++]=res;	
		}
		final void sub(){
			MnnObj r = stack[--sp];
			MnnObj l = stack[--sp];
			MnnObj res = new MnnObj(l.rows,l.cols);
			for(int i=0;i<l.rows;++i)
				for(int j=0;j<l.cols;++j)
					res.data[i][j]=l.data[i][j]-r.data[i][j];
			stack[sp++]=res;	
		}
		final void uminus(){
			MnnObj r = stack[--sp];
			MnnObj res = new MnnObj(r.rows,r.cols);
			for(int i=0;i<r.rows;++i)
				for(int j=0;j<r.cols;++j)
					res.data[i][j]=-r.data[i][j];
			stack[sp++]=res;	
		}
		final void mulS()
		{
			MnnObj r = stack[--sp];
			double l = scalerStore.stack[--scalerStore.sp];
			MnnObj res = new MnnObj(r.rows,r.cols);
			for(int i=0;i<r.rows;++i)
				for(int j=0;j<r.cols;++j)
					res.data[i][j]=l* r.data[i][j];
			stack[sp++]=res;
		} 
		final void divS()
		{
			MnnObj l = stack[--sp];
			double r = scalerStore.stack[--scalerStore.sp];
			MnnObj res = new MnnObj(l.rows,l.cols);
			for(int i=0;i<l.rows;++i)
				for(int j=0;j<l.cols;++j)
					res.data[i][j]=l.data[i][j]/r;
			stack[sp++]=res;
		} 
		final void makeList(int rows,int cols) {
			MnnObj res = new MnnObj(rows,cols);
			for(int i=rows-1;i>=0;--i)
				for(int j=cols-1;j>=0;--j)
					res.data[i][j]= scalerStore.stack[--scalerStore.sp]; 
			stack[sp++]=res;
		} 
		final void makeList() {
			throw new UnsupportedOperationException("VnObj: makeList cannot be called with no arguments");
		} 
		final void assign(int k) {
			MnnObj r = stack[sp-1];
			MnnObj res = vars[k];
			for(int i=0;i<r.rows;++i)
				for(int j=0;j<r.cols;++j)
					res.data[i][j]=r.data[i][j];
		} 
		final void eq(){
			MnnObj r = stack[--sp];
			MnnObj l = stack[--sp];
			for(int i=0;i<r.rows;++i)
				for(int j=0;j<r.cols;++j)
					if(l.data[i][j]!=r.data[i][j]){
						scalerStore.stack[scalerStore.sp++] = 0.0;
						return;
				}
			scalerStore.stack[scalerStore.sp++] = 1.0;
		}
	}
	private MnnStore mnnStore = new MnnStore();
	
	private final void incByDim(Dimensions dims) throws ParseException {
		getStoreByDim(dims).incStack();
	}
	private final void decByDim(Dimensions dims) throws ParseException {
		getStoreByDim(dims).decStack();
	}
	private final void incheapByDim(Dimensions dims) throws ParseException	{
		getStoreByDim(dims).incHeap();
	}
		

	

	/** Temporary holder for command list used during compilation */
	private MRpCommandList curCommandList;
	
	
	public final Object visit(ASTStart node, Object data) throws ParseException {
		throw new ParseException("RpeEval: Start node encountered");
	}
	public final Object visit(SimpleNode node, Object data) throws ParseException {
		throw new ParseException("RpeEval: Simple node encountered");
	}

	final void addConstant(Object obj) throws ParseException {
		double val;
		if(obj instanceof Number)
			val = ((Number) obj).doubleValue();
		else
			throw new ParseException("RpeEval: only constants of double type allowed");
		
		scalerStore.incStack();
		for(short i=0;i<constVals.length;++i)
		{
			if(val == constVals[i])
			{
				curCommandList.addCommand(CONST,i);
				return;
			}
		}
		// create a new const
		double newConst[] = new double[constVals.length+1];
		System.arraycopy(constVals,0,newConst,0,constVals.length);
		newConst[constVals.length] = val;
		curCommandList.addCommand(CONST,(short) constVals.length);
		constVals = newConst;
	}

	public final Object visit(ASTConstant node, Object data) throws ParseException {
		addConstant(node.getValue());
		return null;
	}

	public final Object visit(ASTVarNode node, Object data) throws ParseException {
		MatrixVariableI var = (MatrixVariableI) node.getVar();
		if(var.isConstant()) {
			addConstant(var.getMValue());
			return null;
		}
		Dimensions dims = var.getDimensions();
		// find appropriate table
		ObjStore store = getStoreByDim(dims);
		short vRef = (short) store.addVar(var);
		store.incStack();
		curCommandList.addCommand(VAR,getDimType(dims),vRef);
		return null;
	}

	public final Object visit(ASTFunNode node, Object data) throws ParseException 
	{
		ASTMFunNode mnode = (ASTMFunNode) node;
		MatrixNodeI leftnode=null;
		MatrixNodeI rightnode=null;
		int nChild = mnode.jjtGetNumChildren();
		Dimensions dims = mnode.getDim();
		Dimensions ldims = null,rdims=null;

		if(node.isOperator() && node.getOperator() == opSet.getAssign()) {}
		else if(node.isOperator() && node.getOperator() == opSet.getPower()) {}
		else
			node.childrenAccept(this,null);

		if(nChild>=1)
		{
			leftnode = (MatrixNodeI) node.jjtGetChild(0);
			ldims = leftnode.getDim();
		}
		if(nChild>=2)
		{
			rightnode = (MatrixNodeI) node.jjtGetChild(1);
			rdims = rightnode.getDim();
		}

		if(mnode.isOperator())
		{
			XOperator op = (XOperator) mnode.getOperator();
			if(op.isBinary())
				if(nChild!=2)
					throw new ParseException("RpeEval: binary operator must have two children, but it has "+nChild);
			if(op.isUnary())
				if(nChild!=1)
					throw new ParseException("RpeEval: unary operator must have one child, but it has "+nChild);

			if(op == opSet.getAdd())
			{
				if(!dims.equals(ldims) || !dims.equals(rdims))
					throw new ParseException("RpeEval: dims for add must be equal");
				curCommandList.addCommand(ADD,getDimType(dims));
				decByDim(dims);
				incheapByDim(dims);
				return null;
			}
			else if(op == opSet.getSubtract())
			{
				if(!dims.equals(ldims) || !dims.equals(rdims))
					throw new ParseException("RpeEval: dims for add must be equal");
				curCommandList.addCommand(SUB,getDimType(dims));
				decByDim(dims);
				incheapByDim(dims);
				return null;
			}
			else if(op == opSet.getUMinus())
			{
				curCommandList.addCommand(UMINUS,getDimType(dims));
				incheapByDim(dims);
				return null;
			}
			else if(op == opSet.getMultiply())
			{
				decByDim(rdims);
				decByDim(ldims);
				incByDim(dims);
				incheapByDim(dims);
				curCommandList.addCommand(MUL,getDimType(ldims),getDimType(rdims));
				return null;
			}
			else if(op == opSet.getMList())
			{
				incByDim(dims);
				incheapByDim(dims);
				for(int j=0;j<dims.numEles();++j) scalerStore.decStack();
				int d = getDimType(dims);
				if(d == Vn) 
					curCommandList.addCommand(VLIST,(short) dims.getFirstDim());
				else if(d == Mnn) 
					curCommandList.addCommand(MLIST,(short) dims.getFirstDim(),(short) dims.getLastDim());
				else 
					curCommandList.addCommand(LIST,getDimType(dims)); 
				return null;
			}
			else if(op == opSet.getDot())
			{
				scalerStore.incStack();
				decByDim(rdims);
				decByDim(ldims);
				curCommandList.addCommand(DOT,getDimType(ldims)); return null;
			}
			else if(op == opSet.getCross())
			{
				if(ldims.equals(Dimensions.THREE) && rdims.equals(Dimensions.THREE))
				{
					v3Store.decStack();
					v3Store.incHeap();
					curCommandList.addCommand(CROSS,V3); return null;
				}
				else if(ldims.equals(Dimensions.TWO) && rdims.equals(Dimensions.TWO))
				{
					scalerStore.incStack();
					decByDim(ldims);
					decByDim(rdims);
					curCommandList.addCommand(CROSS,V2); return null;
				}
				else throw new ParseException("Bad dimensions for cross product "+ldims+" "+rdims);
			}
			else if(op == opSet.getAssign())
			{
				rightnode.jjtAccept(this,null);
				MatrixVariableI var = (MatrixVariableI) ((ASTMVarNode)node.jjtGetChild(0)).getVar();
				ObjStore store = getStoreByDim(dims);
				short vRef = (short) store.addVar(var);
				store.decStack();
				curCommandList.addCommand(ASSIGN,getDimType(dims),vRef);
				return null;
			}
			else if(op == opSet.getEQ())
			{
				if(!ldims.equals(rdims))throw new ParseException("Dimensions of operands for equals operator must be the same");
				scalerStore.incStack();
				decByDim(ldims);
				decByDim(rdims);
				curCommandList.addCommand(EQ,getDimType(ldims)); return null;
			}
			else if(op == opSet.getNE())
			{
				if(!ldims.equals(rdims))throw new ParseException("Dimensions of operands for not-equals operator must be the same");
				scalerStore.incStack();
				decByDim(ldims);
				decByDim(rdims);
				curCommandList.addCommand(NE,getDimType(ldims)); return null;
			}
			else if(op == opSet.getLT())
			{
				if(!ldims.is0D() || !rdims.is0D())throw new ParseException("Dimensions of operands for < operator must both be one");
				scalerStore.incStack();
				decByDim(ldims);
				decByDim(rdims);
				curCommandList.addCommand(LT,SCALER); return null;
			}
			else if(op == opSet.getGT())
			{
				if(!ldims.is0D() || !rdims.is0D())throw new ParseException("Dimensions of operands for > operator must both be one");
				scalerStore.incStack();
				decByDim(ldims);
				decByDim(rdims);
				curCommandList.addCommand(GT,SCALER); return null;
			}
			else if(op == opSet.getLE())
			{
				if(!ldims.is0D() || !rdims.is0D())throw new ParseException("Dimensions of operands for <= operator must both be one");
				scalerStore.incStack();
				decByDim(ldims);
				decByDim(rdims);
				curCommandList.addCommand(LE,SCALER); return null;
			}
			else if(op == opSet.getGE())
			{
				if(!ldims.is0D() || !rdims.is0D())throw new ParseException("Dimensions of operands for >= operator must both be one");
				scalerStore.incStack();
				decByDim(ldims);
				decByDim(rdims);
				curCommandList.addCommand(GE,SCALER); return null;
			}
			else if(op == opSet.getAnd())
			{
				if(!ldims.is0D() || !rdims.is0D())throw new ParseException("Dimensions of operands for && operator must both be one");
				scalerStore.incStack();
				decByDim(ldims);
				decByDim(rdims);
				curCommandList.addCommand(AND,SCALER); return null;
			}
			else if(op == opSet.getOr())
			{
				if(!ldims.is0D() || !rdims.is0D())throw new ParseException("Dimensions of operands for || operator must both be one");
				scalerStore.incStack();
				decByDim(ldims);
				decByDim(rdims);
				curCommandList.addCommand(OR,SCALER); return null;
			}
			else if(op == opSet.getNot())
			{
				if(!ldims.is0D())throw new ParseException("Dimension of operand for not operator must be one");
				scalerStore.incStack();
				decByDim(rdims);
				curCommandList.addCommand(NOT,SCALER); return null;
			}
			else if(op == opSet.getDivide())
			{
				if(!rdims.is0D())throw new ParseException("RHS operands of / operator must be a Scaler");
				decByDim(rdims);
				decByDim(ldims);
				incByDim(dims);
				incheapByDim(dims);
				curCommandList.addCommand(DIV,getDimType(ldims),getDimType(rdims));
				return null;
			}
			else if(op == opSet.getMod())
			{
				if(!ldims.is0D() || !rdims.is0D())throw new ParseException("Dimensions of operands for || operator must both be one");
				scalerStore.incStack();
				decByDim(ldims);
				decByDim(rdims);
				curCommandList.addCommand(MOD,SCALER); return null;
			}
			else if(op == opSet.getPower())
			{
				if(!ldims.is0D() || !rdims.is0D())throw new ParseException("Dimensions of operands for || operator must both be one");

				Node lhs = node.jjtGetChild(0);
				Node rhs = node.jjtGetChild(1);
				lhs.jjtAccept(this,null);	
				if(rhs instanceof ASTConstant) {
					Object val = ((ASTConstant) rhs).getValue();
					if(val instanceof Number) {
						double dval = ((Number) val).doubleValue();
						short sval = ((Number) val).shortValue();
						if(dval>= 0 && dval == sval)
						{
							curCommandList.addCommand(POWN,sval); 
							return null;
						}
						else if(dval == sval)
						{
							curCommandList.addCommand(POWN,(short) (-sval));
							curCommandList.addCommand(RECIP,SCALER);
						}
					}
				}
				rhs.jjtAccept(this,null);
				scalerStore.decStack();
				curCommandList.addCommand(POW,SCALER); return null;
			}
			throw new ParseException("RpeEval: Sorry unsupported operator/function: "+ mnode.getName());
		}
		// other functions
		Short val = (Short) functionHash.get(mnode.getName());
		if(val == null)
			throw new ParseException("RpeEval: Sorry unsupported operator/function: "+ mnode.getName());
		if(mnode.getPFMC().getNumberOfParameters() == 1 && nChild == 1)
		{
			scalerStore.incStack();
			decByDim(ldims);
			curCommandList.addCommand(FUN,val.shortValue()); 
			return null;
		}
		if(nChild == 1)
		{
			scalerStore.incStack();
			decByDim(ldims);
			curCommandList.addCommand(FUN,val.shortValue()); 
			return null;
		}
		else if(nChild == 2)
		{
			scalerStore.incStack();
			decByDim(ldims);
			decByDim(rdims);
			curCommandList.addCommand(FUN2,val.shortValue()); 
			return null;
		}
		else if(nChild == 3)
		{
			scalerStore.incStack();
			decByDim(ldims);
			decByDim(ldims);
			decByDim(ldims);

			curCommandList.addCommand(FUN3,val.shortValue()); 
			return null;
		}
		else if(nChild == 4)
		{
			scalerStore.incStack();
			decByDim(ldims);
			decByDim(ldims);
			decByDim(ldims);
			decByDim(ldims);
			curCommandList.addCommand(FUN4,val.shortValue()); 
			return null;
		}

		
		throw new ParseException("RpeEval: Sorry unsupported operator/function: "+ mnode.getName());
	}

	/***************************** evaluation *****************************/
	/** Evaluate the expression.
	 * 
	 * @return the value after evaluation
	 */
	public final MRpRes evaluate(MRpCommandList comList)
	{
		scalerStore.reset();
		v2Store.reset();
		v3Store.reset();
		v4Store.reset();
		vnStore.reset();
		m22Store.reset();
		m23Store.reset();
		m24Store.reset();
		m32Store.reset();
		m33Store.reset();
		m34Store.reset();
		m42Store.reset();
		m43Store.reset();
		m44Store.reset();
		mnnStore.reset();
	
		// Now actually process the commands
		int num = comList.getNumCommands();
		for(short commandNum=0;commandNum<num;++commandNum)
		{
			MRpCommandList.MRpCommand command = comList.commands[commandNum];
			short aux1 = command.aux1;
			short aux2 = command.aux2;
			switch(command.command)
			{
			case CONST:
				scalerStore.stack[scalerStore.sp++]=constVals[aux1]; break;
			case VAR:
				switch(aux1) {
				case SCALER:
					scalerStore.stack[scalerStore.sp++]=scalerStore.vars[aux2]; break;
				case V2:
					v2Store.stack[v2Store.sp++]=v2Store.vars[aux2]; break;
				case V3:
					v3Store.stack[v3Store.sp++]=v3Store.vars[aux2]; break;
				case V4:
					v4Store.stack[v4Store.sp++]=v4Store.vars[aux2]; break;
				case Vn:
					vnStore.stack[vnStore.sp++]=vnStore.vars[aux2]; break;

				case M22:
					m22Store.stack[m22Store.sp++]=m22Store.vars[aux2]; break;
				case M23:
					m23Store.stack[m23Store.sp++]=m23Store.vars[aux2]; break;
				case M24:
					m24Store.stack[m24Store.sp++]=m24Store.vars[aux2]; break;
	
				case M32:
					m32Store.stack[m32Store.sp++]=m32Store.vars[aux2]; break;
				case M33:
					m33Store.stack[m33Store.sp++]=m33Store.vars[aux2]; break;
				case M34:
					m34Store.stack[m34Store.sp++]=m34Store.vars[aux2]; break;

				case M42:
					m42Store.stack[m42Store.sp++]=m42Store.vars[aux2]; break;
				case M43:
					m43Store.stack[m43Store.sp++]=m43Store.vars[aux2]; break;
				case M44:
					m44Store.stack[m44Store.sp++]=m44Store.vars[aux2]; break;

				case Mnn:
					mnnStore.stack[mnnStore.sp++]=mnnStore.vars[aux2]; break;
				}
				break;
				
			case ADD:
				switch(aux1)
				{
				case SCALER: scalerStore.add(); break;
				case V2: v2Store.add(); break; 
				case V3: v3Store.add(); break; 
				case V4: v4Store.add(); break; 
				case Vn: vnStore.add(); break; 
	
				case M22: m22Store.add(); break; 
				case M23: m23Store.add(); break; 
				case M24: m24Store.add(); break; 
				case M32: m32Store.add(); break; 
				case M33: m33Store.add(); break; 
				case M34: m34Store.add(); break; 
				case M42: m42Store.add(); break; 
				case M43: m43Store.add(); break; 
				case M44: m44Store.add(); break; 
				case Mnn: mnnStore.add(); break; 
				}
				break;
			case SUB:
				switch(aux1)
				{
				case SCALER: scalerStore.sub(); break; 
				case V2: v2Store.sub(); break; 
				case V3: v3Store.sub(); break; 
				case V4: v4Store.sub(); break; 
				case Vn: vnStore.sub(); break; 
	
				case M22: m22Store.sub(); break; 
				case M23: m23Store.sub(); break; 
				case M24: m24Store.sub(); break; 
				case M32: m32Store.sub(); break; 
				case M33: m33Store.sub(); break; 
				case M34: m34Store.sub(); break; 
				case M42: m42Store.sub(); break; 
				case M43: m43Store.sub(); break; 
				case M44: m44Store.sub(); break; 
				case Mnn: mnnStore.sub(); break; 
				}
				break;
				
			case MUL:
				switch(aux1)
				{
				case SCALER:
					switch(aux2)
					{
					case SCALER: scalerStore.mulS(); break;
					case V2: v2Store.mulS(); break;
					case V3: v3Store.mulS(); break;
					case V4: v4Store.mulS(); break;
					case Vn: vnStore.mulS(); break;
		
					case M22: m22Store.mulS(); break;
					case M23: m23Store.mulS(); break;
					case M24: m24Store.mulS(); break;
	
					case M32: m32Store.mulS(); break;
					case M33: m33Store.mulS(); break;
					case M34: m34Store.mulS(); break;
	
					case M42: m42Store.mulS(); break;
					case M43: m43Store.mulS(); break;
					case M44: m44Store.mulS(); break;
					case Mnn: mnnStore.mulS(); break;
	
					}
					break;
					
				case V2:
					switch(aux2)
					{
					case SCALER: v2Store.mulS(); break;
					case V2: mulV2V2(); break;
					case M22: mulV2M22(); break; 
					case M23: mulV2M23(); break; 
					case M24: mulV2M24(); break;
					case Mnn: mulVnMnn(
						v2Store.stack[--v2Store.sp],
						mnnStore.stack[--mnnStore.sp]); break; 
					}
					break;
	
				case V3:
					switch(aux2)
					{
					case SCALER: v3Store.mulS(); break;
					case V3: mulV3V3(); break;
					case M32: mulV3M32(); break; 
					case M33: mulV3M33(); break; 
					case M34: mulV3M34(); break; 
					case Mnn: mulVnMnn(
						v3Store.stack[--v3Store.sp],
						mnnStore.stack[--mnnStore.sp]); break; 
					}
					break;
					
				case V4:
					switch(aux2)
					{
					case SCALER: v4Store.mulS(); break;
					case V4: mulV4V4(); break;
					case M42: mulV4M42(); break; 
					case M43: mulV4M43(); break; 
					case M44: mulV4M44(); break; 
					case Mnn: mulVnMnn(
						v4Store.stack[--v4Store.sp],
						mnnStore.stack[--mnnStore.sp]); break; 
					}
					break;
				
				case Vn:
					switch(aux2)
					{
					case SCALER: mnnStore.mulS(); break;
					case Vn: 
						VnObj r = vnStore.stack[--vnStore.sp];
						VnObj l = vnStore.stack[--vnStore.sp];
						mulVnVn(l,r);
						break;
					case Mnn: mulVnMnn(
						vnStore.stack[--vnStore.sp],
						mnnStore.stack[--mnnStore.sp]); 
						break; 
					}
					break;
				case M22:
					switch(aux2)
					{
					case SCALER: m22Store.mulS(); break;
					case V2: mulM22V2(); break;
					case M22:mulM22M22(); break; 
					case M23:mulM22M23(); break; 
					case M24:mulM22M24(); break;
					case Mnn: mulMnnMnn(
						m22Store.stack[--m22Store.sp],
						mnnStore.stack[--mnnStore.sp]); break;
					}
					break;
	
				case M23:
					switch(aux2)
					{
					case SCALER: m23Store.mulS(); break;
					case V3: mulM23V3(); break;
					case M32:mulM23M32(); break; 
					case M33:mulM23M33(); break; 
					case M34:mulM23M34(); break; 
					case Mnn: mulMnnMnn(
						m23Store.stack[--m23Store.sp],
						mnnStore.stack[--mnnStore.sp]); break;
					}
					break;
	
				case M24:
					switch(aux2)
					{
					case SCALER: m24Store.mulS(); break;
					case V4: mulM24V4(); break;
					case M42:mulM24M42(); break; 
					case M43:mulM24M43(); break; 
					case M44:mulM24M44(); break; 
					case Mnn: mulMnnMnn(
						m24Store.stack[--m24Store.sp],
						mnnStore.stack[--mnnStore.sp]); break;
					}
					break;
	
				case M32:
					switch(aux2)
					{
					case SCALER: m32Store.mulS(); break;
					case V2: mulM32V2(); break;
					case M22:mulM32M22(); break; 
					case M23:mulM32M23(); break; 
					case M24:mulM32M24(); break; 
					case Mnn: mulMnnMnn(
						m32Store.stack[--m32Store.sp],
						mnnStore.stack[--mnnStore.sp]); break;
					}
					break;
	
				case M33:
					switch(aux2)
					{
					case SCALER: m33Store.mulS(); break;
					case V3: mulM33V3(); break;
					case M32:mulM33M32(); break; 
					case M33:mulM33M33(); break; 
					case M34:mulM33M34(); break; 
					case Mnn: mulMnnMnn(
						m33Store.stack[--m33Store.sp],
						mnnStore.stack[--mnnStore.sp]); break;
					}
					break;
	
				case M34:
					switch(aux2)
					{
					case SCALER: m34Store.mulS(); break;
					case V4: mulM34V4(); break;
					case M42:mulM34M42(); break; 
					case M43:mulM34M43(); break; 
					case M44:mulM34M44(); break; 
					case Mnn: mulMnnMnn(
						m34Store.stack[--m34Store.sp],
						mnnStore.stack[--mnnStore.sp]); break;
					}
					break;
	
				case M42:
					switch(aux2)
					{
					case SCALER: m42Store.mulS(); break;
					case V2: mulM42V2(); break;
					case M22:mulM42M22(); break; 
					case M23:mulM42M23(); break; 
					case M24:mulM42M24(); break; 
					case Mnn: mulMnnMnn(
						m42Store.stack[--m42Store.sp],
						mnnStore.stack[--mnnStore.sp]); break;
					}
					break;
	
				case M43:
					switch(aux2)
					{
					case SCALER: m43Store.mulS(); break;
					case V3: mulM43V3(); break;
					case M32:mulM43M32(); break; 
					case M33:mulM43M33(); break; 
					case M34:mulM43M34(); break; 
					case Mnn: mulMnnMnn(
						m43Store.stack[--m43Store.sp],
						mnnStore.stack[--mnnStore.sp]); break;
					}
					break;
		
				case M44:
					switch(aux2)
					{
					case SCALER: m44Store.mulS(); break;
					case V4: mulM44V4(); break;
					case M42:mulM44M42(); break; 
					case M43:mulM44M43(); break; 
					case M44:mulM44M44(); break; 
					case Mnn: mulMnnMnn(
						m44Store.stack[--m44Store.sp],
						mnnStore.stack[--mnnStore.sp]); break;
					}
					break;

				case Mnn:
					switch(aux2)
					{
					case SCALER: mnnStore.mulS(); break;
					case V2:
						mulMnnVn(
							mnnStore.stack[--mnnStore.sp], 
							v2Store.stack[--v2Store.sp]); break;
					case V3:
						mulMnnVn(
							mnnStore.stack[--mnnStore.sp], 
							v3Store.stack[--v3Store.sp]); break;
					case V4:
						mulMnnVn(
							mnnStore.stack[--mnnStore.sp], 
							v4Store.stack[--v4Store.sp]); break;
					case Vn:
						mulMnnVn(
							mnnStore.stack[--mnnStore.sp], 
							vnStore.stack[--vnStore.sp]); break;
							
					case M22: mulMnnMnn(
						mnnStore.stack[--mnnStore.sp],
						m22Store.stack[--m22Store.sp]); break;
					case M23: mulMnnMnn(
						mnnStore.stack[--mnnStore.sp],
						m23Store.stack[--m23Store.sp]); break;
					case M24: mulMnnMnn(
						mnnStore.stack[--mnnStore.sp],
						m24Store.stack[--m24Store.sp]); break;
					case M32: mulMnnMnn(
						mnnStore.stack[--mnnStore.sp],
						m32Store.stack[--m32Store.sp]); break;
					case M33: mulMnnMnn(
						mnnStore.stack[--mnnStore.sp],
						m33Store.stack[--m33Store.sp]); break;
					case M34: mulMnnMnn(
						mnnStore.stack[--mnnStore.sp],
						m34Store.stack[--m34Store.sp]); break;
					case M42: mulMnnMnn(
						mnnStore.stack[--mnnStore.sp],
						m42Store.stack[--m42Store.sp]); break;
					case M43: mulMnnMnn(
						mnnStore.stack[--mnnStore.sp],
						m43Store.stack[--m43Store.sp]); break;
					case M44: mulMnnMnn(
						mnnStore.stack[--mnnStore.sp],
						m44Store.stack[--m44Store.sp]); break;
					case Mnn:
						MnnObj r = mnnStore.stack[--mnnStore.sp];
						MnnObj l = mnnStore.stack[--mnnStore.sp];
						mulMnnMnn(l,r); break;
					}
					break;
				}
				break;

			case DIV: 
				switch(aux1)
				{
				case SCALER: scalerStore.divS(); break;
				case V2: v2Store.divS(); break;
				case V3: v3Store.divS(); break;
				case V4: v4Store.divS(); break;
				case Vn: vnStore.divS(); break;
	
				case M22: m22Store.divS(); break;
				case M23: m23Store.divS(); break;
				case M24: m24Store.divS(); break;

				case M32: m32Store.divS(); break;
				case M33: m33Store.divS(); break;
				case M34: m34Store.divS(); break;

				case M42: m42Store.divS(); break;
				case M43: m43Store.divS(); break;
				case M44: m44Store.divS(); break;
				case Mnn: mnnStore.divS(); break;

				}
				break;
			case MOD: scalerStore.mod(); break;
			case POW: scalerStore.pow(); break;

			case AND: scalerStore.and(); break;
			case OR: scalerStore.or(); break;
			case NOT: scalerStore.not(); break;

			case LT: scalerStore.lt(); break;
			case LE: scalerStore.le(); break;
			case GT: scalerStore.gt(); break;
			case GE: scalerStore.ge(); break;
			case NE:
				switch(aux1)
				{
				case SCALER: scalerStore.neq(); break;
				case V2: v2Store.eq(); scalerStore.not(); break; 
				case V3: v3Store.eq(); scalerStore.not(); break; 
				case V4: v4Store.eq(); scalerStore.not(); break; 
				case M22: m22Store.eq(); scalerStore.not(); break; 
				case M23: m23Store.eq(); scalerStore.not(); break; 
				case M24: m24Store.eq(); scalerStore.not(); break; 
				case M32: m32Store.eq(); scalerStore.not(); break; 
				case M33: m33Store.eq(); scalerStore.not(); break; 
				case M34: m34Store.eq(); scalerStore.not(); break; 
				case M42: m42Store.eq(); scalerStore.not(); break; 
				case M43: m43Store.eq(); scalerStore.not(); break; 
				case M44: m44Store.eq(); scalerStore.not(); break; 
				}
				break;
			case EQ:
				switch(aux1)
				{
				case SCALER: scalerStore.eq(); break;
				case V2: v2Store.eq(); break; 
				case V3: v3Store.eq(); break; 
				case V4: v4Store.eq(); break; 
				case M22: m22Store.eq(); break; 
				case M23: m23Store.eq(); break; 
				case M24: m24Store.eq(); break; 
				case M32: m32Store.eq(); break; 
				case M33: m33Store.eq(); break; 
				case M34: m34Store.eq(); break; 
				case M42: m42Store.eq(); break; 
				case M43: m43Store.eq(); break; 
				case M44: m44Store.eq(); break; 
				}
				break;
	
			case ASSIGN:
				switch(aux1)
				{
				case SCALER: scalerStore.assign(aux2); break;
				case V2: v2Store.assign(aux2); break; 
				case V3: v3Store.assign(aux2); break; 
				case V4: v4Store.assign(aux2); break; 
				case Vn: vnStore.assign(aux2); break; 
				case M22: m22Store.assign(aux2); break; 
				case M23: m23Store.assign(aux2); break; 
				case M24: m24Store.assign(aux2); break; 
				case M32: m32Store.assign(aux2); break; 
				case M33: m33Store.assign(aux2); break; 
				case M34: m34Store.assign(aux2); break; 
				case M42: m42Store.assign(aux2); break; 
				case M43: m43Store.assign(aux2); break; 
				case M44: m44Store.assign(aux2); break; 
				case Mnn: mnnStore.assign(aux2); break; 
				}
				break;

			case LIST:
			{
				switch(aux1)
				{
				case SCALER:{
					}break;
				case V2: v2Store.makeList(); break; 
				case V3: v3Store.makeList(); break; 
				case V4: v4Store.makeList(); break; 
	
				case M22: m22Store.makeList(); break; 
				case M23: m23Store.makeList(); break; 
				case M24: m24Store.makeList(); break; 
				case M32: m32Store.makeList(); break; 
				case M33: m33Store.makeList(); break; 
				case M34: m34Store.makeList(); break; 
				case M42: m42Store.makeList(); break; 
				case M43: m43Store.makeList(); break; 
				case M44: m44Store.makeList(); break; 
	
				}
				break;
				
			}
			case VLIST:
				vnStore.makeList(aux1); break;
			case MLIST:
				mnnStore.makeList(aux1,aux2); break;
				
			case DOT:
				switch(aux1)
				{
				case V2: dotV2(); break;
				case V3: dotV3(); break;
				case V4: dotV4(); break;
				case Vn: dotVn(); break;
				}
				break;
			case CROSS:
				switch(aux1)
				{
				case V2: crossV2(); break;
				case V3: crossV3(); break;
				}
				break;
			case FUN:
				unitaryFunction(aux1); break;
			case UMINUS:
				switch(aux1)
				{
				case SCALER: scalerStore.uminus(); break; 
				case V2: v2Store.uminus(); break; 
				case V3: v3Store.uminus(); break; 
				case V4: v4Store.uminus(); break; 
				case Vn: vnStore.uminus(); break; 

				case M22: m22Store.uminus(); break; 
				case M23: m23Store.uminus(); break; 
				case M24: m24Store.uminus(); break; 
				case M32: m32Store.uminus(); break; 
				case M33: m33Store.uminus(); break; 
				case M34: m34Store.uminus(); break; 
				case M42: m42Store.uminus(); break; 
				case M43: m43Store.uminus(); break; 
				case M44: m44Store.uminus(); break; 
				case Mnn: mnnStore.uminus(); break; 
				}
				break;
			case FUN2: binaryFunction(aux1); break;
			case FUN3: trianaryFunction(aux1); break;
			case FUN4: quarteraryFunction(aux1); break;
			case POWN:
				scalerStore.powN(aux1); break;
			case RECIP:
				scalerStore.recroprical(); break;
			}
		} // end main loop

		switch(comList.getFinalType())
		{
			case SCALER: 
//				return new ScalerObj(scalerStore.stack[--scalerStore.sp]);
//				return new double[]{popScaler()};
				scalerRes.a = scalerStore.stack[--scalerStore.sp];
				return scalerRes;
			case V2:
				return v2Store.stack[--v2Store.sp];
			case V3:
				return v3Store.stack[--v3Store.sp];
			case V4: 
				return v4Store.stack[--v4Store.sp];
			case Vn: 
				return vnStore.stack[--vnStore.sp];
			case M22:
				return m22Store.stack[--m22Store.sp];
			case M23:
				return m23Store.stack[--m23Store.sp];
			case M24:
				return m24Store.stack[--m24Store.sp];
			case M32:
				return m32Store.stack[--m32Store.sp];
			case M33:
				return m33Store.stack[--m33Store.sp];
			case M34:
				return m34Store.stack[--m34Store.sp];
			case M42:
				return m42Store.stack[--m42Store.sp];
			case M43:
				return m43Store.stack[--m43Store.sp];
			case M44:
				return m44Store.stack[--m44Store.sp];
			case Mnn:
				return mnnStore.stack[--mnnStore.sp];
			default:
		}
		return null;
	}

	private final void dotV2(){
		V2Obj r = v2Store.stack[--v2Store.sp]; 
		V2Obj l = v2Store.stack[--v2Store.sp]; 
		scalerStore.stack[scalerStore.sp++]
			= l.a * r.a + l.b * r.b;
	}

	private final void crossV2(){
		V2Obj r = v2Store.stack[--v2Store.sp]; 
		V2Obj l = v2Store.stack[--v2Store.sp]; 
		scalerStore.stack[scalerStore.sp++]
			= l.a * r.b - l.b * r.a;
	}

	private final void dotV3(){
		V3Obj r = v3Store.stack[--v3Store.sp];
		V3Obj l = v3Store.stack[--v3Store.sp];
		scalerStore.stack[scalerStore.sp++]
			= l.a * r.a + l.b * r.b + l.c * r.c;
	}
	
	private final void crossV3(){
		V3Obj r = v3Store.stack[--v3Store.sp];
		V3Obj l = v3Store.stack[--v3Store.sp];
		V3Obj res = v3Store.heap[v3Store.hp++];
		res.a = l.b*r.c - l.c*r.b;
		res.b = l.c*r.a - l.a*r.c;
		res.c = l.a*r.b - l.b*r.a;
		v3Store.stack[v3Store.sp++]=res;	
	}

	private final void dotV4(){
		V4Obj r = v4Store.stack[--v4Store.sp]; 
		V4Obj l = v4Store.stack[--v4Store.sp]; 
		scalerStore.stack[scalerStore.sp++]
			= l.a * r.a + l.b * r.b + l.c * r.c + l.d * r.d;
	}
	
	private final void dotVn(){
		VnObj r = vnStore.stack[--vnStore.sp];
		VnObj l = vnStore.stack[--vnStore.sp];
		double res = l.data[0] * r.data[0];
		for(int i=1;i<l.data.length;++i) res += l.data[i]*r.data[i];
		scalerStore.stack[scalerStore.sp++]=res;
	}

	private final void mulV2V2(){
		V2Obj r = v2Store.stack[--v2Store.sp];
		V2Obj l = v2Store.stack[--v2Store.sp];
		M22Obj res = m22Store.heap[m22Store.hp++];
		res.a = l.a*r.a;
		res.b = l.a*r.b;
		res.c = l.b*r.a;
		res.d = l.b*r.b;
		m22Store.stack[m22Store.sp++]=res;	
	}

	private final void mulM22V2(){
		V2Obj r = v2Store.stack[--v2Store.sp];
		M22Obj l = m22Store.stack[--m22Store.sp];
		V2Obj res = v2Store.heap[v2Store.hp++];
		res.a = l.a*r.a+l.b*r.b;
		res.b = l.c*r.a+l.d*r.b;
		v2Store.stack[v2Store.sp++]=res;	
	}

	private final void mulV2M22(){
		M22Obj r = m22Store.stack[--m22Store.sp];
		V2Obj l = v2Store.stack[--v2Store.sp];
		V2Obj res = v2Store.heap[v2Store.hp++];
		res.a = l.a*r.a+l.b*r.c;
		res.b = l.a*r.b+l.b*r.d;
		v2Store.stack[v2Store.sp++]=res;	
	}

	private final void mulM32V2(){
		V2Obj r = v2Store.stack[--v2Store.sp];
		M32Obj l = m32Store.stack[--m32Store.sp];
		V3Obj res = v3Store.heap[v3Store.hp++];
		res.a = l.a*r.a+l.b*r.b;
		res.b = l.c*r.a+l.d*r.b;
		res.c = l.e*r.a+l.f*r.b;
		v3Store.stack[v3Store.sp++]=res;	
	}

	private final void mulV2M23(){
		M23Obj r = m23Store.stack[--m23Store.sp];
		V2Obj l = v2Store.stack[--v2Store.sp];
		V3Obj res = v3Store.heap[v3Store.hp++];
		res.a = l.a*r.a+l.b*r.d;
		res.b = l.a*r.b+l.b*r.e;
		res.c = l.a*r.c+l.b*r.f;
		v3Store.stack[v3Store.sp++]=res;	
	}

	private final void mulM42V2(){
		V2Obj r = v2Store.stack[--v2Store.sp];
		M42Obj l = m42Store.stack[--m42Store.sp];
		V4Obj res = v4Store.heap[v4Store.hp++];
		res.a = l.a*r.a + l.b*r.b;
		res.b = l.c*r.a + l.d*r.b;
		res.c = l.e*r.a + l.f*r.b;
		res.d = l.g*r.a + l.h*r.b;
		v4Store.stack[v4Store.sp++]=res;	
	}
		
	private final void mulV2M24(){
		M24Obj r = m24Store.stack[--m24Store.sp];
		V2Obj l = v2Store.stack[--v2Store.sp];
		V4Obj res = v4Store.heap[v4Store.hp++];
		res.a = l.a*r.a+l.b*r.e;
		res.b = l.a*r.b+l.b*r.f;
		res.c = l.a*r.c+l.b*r.g;
		res.d = l.a*r.d+l.b*r.h;
	
		v4Store.stack[v4Store.sp++]=res;	
	}
	
	// V3 
	private final void mulM23V3(){
		V3Obj r = v3Store.stack[--v3Store.sp];
		M23Obj l = m23Store.stack[--m23Store.sp];
		V2Obj res = v2Store.heap[v2Store.hp++];
		res.a = l.a*r.a+l.b*r.b+l.c*r.c;
		res.b = l.d*r.a+l.e*r.b+l.f*r.c;
		v2Store.stack[v2Store.sp++]=res;	
	}
		
	private final void mulV3M32(){
		M32Obj r = m32Store.stack[--m32Store.sp];
		V3Obj l = v3Store.stack[--v3Store.sp];
		V2Obj res = v2Store.heap[v2Store.hp++];
		res.a = l.a*r.a+l.b*r.c+l.c*r.e;
		res.b = l.a*r.b+l.b*r.d+l.c*r.f;
		v2Store.stack[v2Store.sp++]=res;	
	}
	
	private final void mulM33V3(){
		V3Obj r = v3Store.stack[--v3Store.sp];
		M33Obj l = m33Store.stack[--m33Store.sp];
		V3Obj res = v3Store.heap[v3Store.hp++];
		res.a = l.a*r.a+l.b*r.b+l.c*r.c;
		res.b = l.d*r.a+l.e*r.b+l.f*r.c;
		res.c = l.g*r.a+l.h*r.b+l.i*r.c;
		v3Store.stack[v3Store.sp++]=res;	
	}
	
	private final void mulV3V3(){
		V3Obj r = v3Store.stack[--v3Store.sp];
		V3Obj l = v3Store.stack[--v3Store.sp];
		M33Obj res = m33Store.heap[m33Store.hp++];
		res.a = l.a*r.a;
		res.b = l.a*r.b;
		res.c = l.a*r.c;
		res.d = l.b*r.a;
		res.e = l.b*r.b;
		res.f = l.b*r.c;
		res.g = l.c*r.a;
		res.h = l.c*r.b;
		res.i = l.c*r.c;
		m33Store.stack[m33Store.sp++]=res;	
	}

	private final void mulV3M33(){
		M33Obj r = m33Store.stack[--m33Store.sp];
		V3Obj l = v3Store.stack[--v3Store.sp];
		V3Obj res = v3Store.heap[v3Store.hp++];
		res.a = l.a*r.a+l.b*r.d+l.c*r.g;
		res.b = l.a*r.b+l.b*r.e+l.c*r.h;
		res.c = l.a*r.c+l.b*r.f+l.c*r.i;
		v3Store.stack[v3Store.sp++]=res;	
	}
	
	private final void mulM43V3(){
		V3Obj r = v3Store.stack[--v3Store.sp];
		M43Obj l = m43Store.stack[--m43Store.sp];
		V4Obj res = v4Store.heap[v4Store.hp++];
		res.a = l.a*r.a + l.b*r.b + l.c*r.c;
		res.b = l.d*r.a + l.e*r.b + l.f*r.c;
		res.c = l.g*r.a + l.h*r.b + l.i*r.c;
		res.d = l.j*r.a + l.k*r.b + l.l*r.c;
		v4Store.stack[v4Store.sp++]=res;	
	}
			
	private final void mulV3M34(){
		M34Obj r = m34Store.stack[--m34Store.sp];
		V3Obj l = v3Store.stack[--v3Store.sp];
		V4Obj res = v4Store.heap[v4Store.hp++];
		res.a = l.a*r.a+l.b*r.e+l.c*r.i;
		res.b = l.a*r.b+l.b*r.f+l.c*r.j;
		res.c = l.a*r.c+l.b*r.g+l.c*r.k;
		res.d = l.a*r.d+l.b*r.h+l.c*r.l;
		
		v4Store.stack[v4Store.sp++]=res;	
	}

	private final void mulM24V4(){
		V4Obj r = v4Store.stack[--v4Store.sp];
		M24Obj l = m24Store.stack[--m24Store.sp];
		V2Obj res = v2Store.heap[v2Store.hp++];
		res.a = l.a*r.a + l.b*r.b + l.c*r.c + l.d*r.d;
		res.b = l.e*r.a + l.f*r.b + l.g*r.c + l.h*r.d;
		v2Store.stack[v2Store.sp++]=res;	
	}
		
	private final void mulV4M42(){
		M42Obj r = m42Store.stack[--m42Store.sp];
		V4Obj l = v4Store.stack[--v4Store.sp];
		V2Obj res = v2Store.heap[v2Store.hp++];
		res.a = l.a*r.a + l.b*r.c + l.c*r.e + l.d*r.g;
		res.b = l.a*r.b + l.b*r.d + l.c*r.f + l.d*r.h;
	
		v2Store.stack[v2Store.sp++]=res;	
	}

	private final void mulM34V4(){
		V4Obj r = v4Store.stack[--v4Store.sp];
		M34Obj l = m34Store.stack[--m34Store.sp];
		V3Obj res = v3Store.heap[v3Store.hp++];
		res.a = l.a*r.a + l.b*r.b + l.c*r.c + l.d*r.d;
		res.b = l.e*r.a + l.f*r.b + l.g*r.c + l.h*r.d;
		res.c = l.i*r.a + l.j*r.b + l.k*r.c + l.l*r.d;
		v3Store.stack[v3Store.sp++]=res;	
	}
			
	private final void mulV4M43(){
		M43Obj r = m43Store.stack[--m43Store.sp];
		V4Obj l = v4Store.stack[--v4Store.sp];
		V3Obj res = v3Store.heap[v3Store.hp++];
		res.a = l.a*r.a + l.b*r.d + l.c*r.g + l.d*r.j;
		res.b = l.a*r.b + l.b*r.e + l.c*r.h + l.d*r.k;
		res.c = l.a*r.c + l.b*r.f + l.c*r.i + l.d*r.l;
		
		v3Store.stack[v3Store.sp++]=res;	
	}

	private final void mulV4V4(){
		V4Obj r = v4Store.stack[--v4Store.sp];
		V4Obj l = v4Store.stack[--v4Store.sp];
		M44Obj res = m44Store.heap[m44Store.hp++];
		res.a = l.a*r.a;
		res.b = l.a*r.b;
		res.c = l.a*r.c;
		res.d = l.a*r.d;
		res.e = l.b*r.a;
		res.f = l.b*r.b;
		res.g = l.b*r.c;
		res.h = l.b*r.d;
		res.i = l.c*r.a;
		res.j = l.c*r.b;
		res.k = l.c*r.c;
		res.l = l.c*r.d;
		res.m = l.d*r.a;
		res.n = l.d*r.b;
		res.o = l.d*r.c;
		res.p = l.d*r.d;
		m44Store.stack[m44Store.sp++]=res;	
	}

	private final void mulM44V4(){
		V4Obj r = v4Store.stack[--v4Store.sp];
		M44Obj l = m44Store.stack[--m44Store.sp];
		V4Obj res = v4Store.heap[v4Store.hp++];
		res.a = l.a*r.a + l.b*r.b + l.c*r.c + l.d*r.d;
		res.b = l.e*r.a + l.f*r.b + l.g*r.c + l.h*r.d;
		res.c = l.i*r.a + l.j*r.b + l.k*r.c + l.l*r.d;
		res.d = l.m*r.a + l.n*r.b + l.o*r.c + l.p*r.d;
		v4Store.stack[v4Store.sp++]=res;	
	}
	
	private final void mulV4M44(){
		M44Obj r = m44Store.stack[--m44Store.sp];
		V4Obj l = v4Store.stack[--v4Store.sp];
		V4Obj res = v4Store.heap[v4Store.hp++];
		res.a = l.a*r.a+l.b*r.e+l.c*r.i+l.d*r.m;
		res.b = l.a*r.b+l.b*r.f+l.c*r.j+l.d*r.n;
		res.c = l.a*r.c+l.b*r.g+l.c*r.k+l.d*r.o;
		res.d = l.a*r.d+l.b*r.h+l.c*r.l+l.d*r.p;

		v4Store.stack[v4Store.sp++]=res;	
	}


	// M22 * 
	
	private final void mulM22M22(){
		M22Obj r = m22Store.stack[--m22Store.sp]; 
		M22Obj l = m22Store.stack[--m22Store.sp];
		M22Obj res = m22Store.heap[m22Store.hp++];
		res.a = l.a * r.a + l.b * r.c;
		res.b = l.a * r.b + l.b * r.d;
	
		res.c = l.c * r.a + l.d * r.c;
		res.d = l.c * r.b + l.d * r.d;
	
		m22Store.stack[m22Store.sp++]=res;
	}
	
	private final void mulM22M23(){
		M23Obj r = m23Store.stack[--m23Store.sp]; 
		M22Obj l = m22Store.stack[--m22Store.sp];
		M23Obj res = m23Store.heap[m23Store.hp++];
		res.a = l.a * r.a + l.b * r.d;
		res.b = l.a * r.b + l.b * r.e;
		res.c = l.a * r.c + l.b * r.f;
	
		res.d = l.c * r.a + l.d * r.d;
		res.e = l.c * r.b + l.d * r.e;
		res.f = l.c * r.c + l.d * r.f;
	
		m23Store.stack[m23Store.sp++]=res;
	}
	
	private final void mulM22M24(){
		M24Obj r = m24Store.stack[--m24Store.sp]; 
		M22Obj l = m22Store.stack[--m22Store.sp];
		M24Obj res = m24Store.heap[m24Store.hp++];
		res.a = l.a * r.a + l.b * r.e;
		res.b = l.a * r.b + l.b * r.f;
		res.c = l.a * r.c + l.b * r.g;
		res.d = l.a * r.d + l.b * r.h;
	
		res.e = l.c * r.a + l.d * r.e;
		res.f = l.c * r.b + l.d * r.f;
		res.g = l.c * r.c + l.d * r.g;
		res.h = l.c * r.d + l.d * r.h;
	
		m24Store.stack[m24Store.sp++]=res;
	}
	
	// M23 *
		
	private final void mulM23M32(){
		M32Obj r = m32Store.stack[--m32Store.sp]; 
		M23Obj l = m23Store.stack[--m23Store.sp];
		M22Obj res = m22Store.heap[m22Store.hp++];
		res.a = l.a * r.a + l.b * r.c + l.c * r.e;
		res.b = l.a * r.b + l.b * r.d + l.c * r.f;
	
		res.c = l.d * r.a + l.e * r.c + l.f * r.e;
		res.d = l.d * r.b + l.e * r.d + l.f * r.f;
	
		m22Store.stack[m22Store.sp++]=res;
	}
	
	private final void mulM23M33(){
		M33Obj r = m33Store.stack[--m33Store.sp]; 
		M23Obj l = m23Store.stack[--m23Store.sp];
		M23Obj res = m23Store.heap[m23Store.hp++];
		res.a = l.a * r.a + l.b * r.d + l.c * r.g;
		res.b = l.a * r.b + l.b * r.e + l.c * r.h;
		res.c = l.a * r.c + l.b * r.f + l.c * r.i;
	
		res.d = l.d * r.a + l.e * r.d + l.f * r.g;
		res.e = l.d * r.b + l.e * r.e + l.f * r.h;
		res.f = l.d * r.c + l.e * r.f + l.f * r.i;
	
		m23Store.stack[m23Store.sp++]=res;
	}
	
	private final void mulM23M34(){
		M34Obj r = m34Store.stack[--m34Store.sp]; 
		M23Obj l = m23Store.stack[--m23Store.sp];
		M24Obj res = m24Store.heap[m24Store.hp++];
		res.a = l.a * r.a + l.b * r.e + l.c * r.i;
		res.b = l.a * r.b + l.b * r.f + l.c * r.j;
		res.c = l.a * r.c + l.b * r.g + l.c * r.k;
		res.d = l.a * r.d + l.b * r.h + l.c * r.l;
	
		res.e = l.d * r.a + l.e * r.e + l.f * r.i;
		res.f = l.d * r.b + l.e * r.f + l.f * r.j;
		res.g = l.d * r.c + l.e * r.g + l.f * r.k;
		res.h = l.d * r.d + l.e * r.h + l.f * r.l;
	
		m24Store.stack[m24Store.sp++]=res;
	}
	
	// M24 *
	
	private final void mulM24M42(){
		M42Obj r = m42Store.stack[--m42Store.sp]; 
		M24Obj l = m24Store.stack[--m24Store.sp];
		M22Obj res = m22Store.heap[m22Store.hp++];
		res.a = l.a * r.a + l.b * r.c + l.c * r.e + l.d * r.g;
		res.b = l.a * r.b + l.b * r.d + l.c * r.f + l.d * r.h;
	
		res.c = l.e * r.a + l.f * r.c + l.g * r.e + l.h * r.g;
		res.d = l.e * r.b + l.f * r.d + l.g * r.f + l.h * r.h;
	
		m22Store.stack[m22Store.sp++]=res;
	}
	
	private final void mulM24M43(){
		M43Obj r = m43Store.stack[--m43Store.sp]; 
		M24Obj l = m24Store.stack[--m24Store.sp];
		M23Obj res = m23Store.heap[m23Store.hp++];
		res.a = l.a * r.a + l.b * r.d + l.c * r.g + l.d * r.j;
		res.b = l.a * r.b + l.b * r.e + l.c * r.h + l.d * r.k;
		res.c = l.a * r.c + l.b * r.f + l.c * r.i + l.d * r.l;
	
		res.d = l.e * r.a + l.f * r.d + l.g * r.g + l.h * r.j;
		res.e = l.e * r.b + l.f * r.e + l.g * r.h + l.h * r.k;
		res.f = l.e * r.c + l.f * r.f + l.g * r.i + l.h * r.l;
	
		m23Store.stack[m23Store.sp++]=res;
	}
	
	private final void mulM24M44(){
		M44Obj r = m44Store.stack[--m44Store.sp]; 
		M24Obj l = m24Store.stack[--m24Store.sp];
		M24Obj res = m24Store.heap[m24Store.hp++];
		res.a = l.a * r.a + l.b * r.e + l.c * r.i + l.d * r.m;
		res.b = l.a * r.b + l.b * r.f + l.c * r.j + l.d * r.n;
		res.c = l.a * r.c + l.b * r.g + l.c * r.k + l.d * r.o;
		res.d = l.a * r.d + l.b * r.h + l.c * r.l + l.d * r.p;
	
		res.e = l.e * r.a + l.f * r.e + l.g * r.i + l.h * r.m;
		res.f = l.e * r.b + l.f * r.f + l.g * r.j + l.h * r.n;
		res.g = l.e * r.c + l.f * r.g + l.g * r.k + l.h * r.o;
		res.h = l.e * r.d + l.f * r.h + l.g * r.l + l.h * r.p;
	
		m24Store.stack[m24Store.sp++]=res;
	}

	// M32 * 
	
	private final void mulM32M22(){
		M22Obj r = m22Store.stack[--m22Store.sp]; 
		M32Obj l = m32Store.stack[--m32Store.sp];
		M32Obj res = m32Store.heap[m32Store.hp++];
		res.a = l.a * r.a + l.b * r.c;
		res.b = l.a * r.b + l.b * r.d;

		res.c = l.c * r.a + l.d * r.c;
		res.d = l.c * r.b + l.d * r.d;

		res.e = l.e * r.a + l.f * r.c;
		res.f = l.e * r.b + l.f * r.d;
		m32Store.stack[m32Store.sp++]=res;
	}

	private final void mulM32M23(){
		M23Obj r = m23Store.stack[--m23Store.sp]; 
		M32Obj l = m32Store.stack[--m32Store.sp];
		M33Obj res = m33Store.heap[m33Store.hp++];
		res.a = l.a * r.a + l.b * r.d;
		res.b = l.a * r.b + l.b * r.e;
		res.c = l.a * r.c + l.b * r.f;

		res.d = l.c * r.a + l.d * r.d;
		res.e = l.c * r.b + l.d * r.e;
		res.f = l.c * r.c + l.d * r.f;

		res.g = l.e * r.a + l.f * r.d;
		res.h = l.e * r.b + l.f * r.e;
		res.i = l.e * r.c + l.f * r.f;

		m33Store.stack[m33Store.sp++]=res;
	}

	private final void mulM32M24(){
		M24Obj r = m24Store.stack[--m24Store.sp]; 
		M32Obj l = m32Store.stack[--m32Store.sp];
		M34Obj res = m34Store.heap[m34Store.hp++];
		res.a = l.a * r.a + l.b * r.e;
		res.b = l.a * r.b + l.b * r.f;
		res.c = l.a * r.c + l.b * r.g;
		res.d = l.a * r.d + l.b * r.h;

		res.e = l.c * r.a + l.d * r.e;
		res.f = l.c * r.b + l.d * r.f;
		res.g = l.c * r.c + l.d * r.g;
		res.h = l.c * r.d + l.d * r.h;

		res.i = l.e * r.a + l.f * r.e;
		res.j = l.e * r.b + l.f * r.f;
		res.k = l.e * r.c + l.f * r.g;
		res.l = l.e * r.d + l.f * r.h;

		m34Store.stack[m34Store.sp++]=res;
	}

	// M33 *
	
	private final void mulM33M32(){
		M32Obj r = m32Store.stack[--m32Store.sp]; 
		M33Obj l = m33Store.stack[--m33Store.sp];
		M32Obj res = m32Store.heap[m32Store.hp++];
		res.a = l.a * r.a + l.b * r.c + l.c * r.e;
		res.b = l.a * r.b + l.b * r.d + l.c * r.f;

		res.c = l.d * r.a + l.e * r.c + l.f * r.e;
		res.d = l.d * r.b + l.e * r.d + l.f * r.f;

		res.e = l.g * r.a + l.h * r.c + l.i * r.e;
		res.f = l.g * r.b + l.h * r.d + l.i * r.f;

		m32Store.stack[m32Store.sp++]=res;
	}

	private final void mulM33M33(){
		M33Obj r = m33Store.stack[--m33Store.sp]; 
		M33Obj l = m33Store.stack[--m33Store.sp];
		M33Obj res = m33Store.heap[m33Store.hp++];
		res.a = l.a * r.a + l.b * r.d + l.c * r.g;
		res.b = l.a * r.b + l.b * r.e + l.c * r.h;
		res.c = l.a * r.c + l.b * r.f + l.c * r.i;

		res.d = l.d * r.a + l.e * r.d + l.f * r.g;
		res.e = l.d * r.b + l.e * r.e + l.f * r.h;
		res.f = l.d * r.c + l.e * r.f + l.f * r.i;

		res.g = l.g * r.a + l.h * r.d + l.i * r.g;
		res.h = l.g * r.b + l.h * r.e + l.i * r.h;
		res.i = l.g * r.c + l.h * r.f + l.i * r.i;

		m33Store.stack[m33Store.sp++]=res;
	}

	private final void mulM33M34(){
		M34Obj r = m34Store.stack[--m34Store.sp]; 
		M33Obj l = m33Store.stack[--m33Store.sp];
		M34Obj res = m34Store.heap[m34Store.hp++];
		res.a = l.a * r.a + l.b * r.e + l.c * r.i;
		res.b = l.a * r.b + l.b * r.f + l.c * r.j;
		res.c = l.a * r.c + l.b * r.g + l.c * r.k;
		res.d = l.a * r.d + l.b * r.h + l.c * r.l;

		res.e = l.d * r.a + l.e * r.e + l.f * r.i;
		res.f = l.d * r.b + l.e * r.f + l.f * r.j;
		res.g = l.d * r.c + l.e * r.g + l.f * r.k;
		res.h = l.d * r.d + l.e * r.h + l.f * r.l;

		res.i = l.g * r.a + l.h * r.e + l.i * r.i;
		res.j = l.g * r.b + l.h * r.f + l.i * r.j;
		res.k = l.g * r.c + l.h * r.g + l.i * r.k;
		res.l = l.g * r.d + l.h * r.h + l.i * r.l;

		m34Store.stack[m34Store.sp++]=res;
	}

	// M34 *

	private final void mulM34M42(){
		M42Obj r = m42Store.stack[--m42Store.sp]; 
		M34Obj l = m34Store.stack[--m34Store.sp];
		M32Obj res = m32Store.heap[m32Store.hp++];
		res.a = l.a * r.a + l.b * r.c + l.c * r.e + l.d * r.g;
		res.b = l.a * r.b + l.b * r.d + l.c * r.f + l.d * r.h;

		res.c = l.e * r.a + l.f * r.c + l.g * r.e + l.h * r.g;
		res.d = l.e * r.b + l.f * r.d + l.g * r.f + l.h * r.h;

		res.e = l.i * r.a + l.j * r.c + l.k * r.e + l.l * r.g;
		res.f = l.i * r.b + l.j * r.d + l.k * r.f + l.l * r.h;

		m32Store.stack[m32Store.sp++]=res;
	}

	private final void mulM34M43(){
		M43Obj r = m43Store.stack[--m43Store.sp]; 
		M34Obj l = m34Store.stack[--m34Store.sp];
		M33Obj res = m33Store.heap[m33Store.hp++];
		res.a = l.a * r.a + l.b * r.d + l.c * r.g + l.d * r.j;
		res.b = l.a * r.b + l.b * r.e + l.c * r.h + l.d * r.k;
		res.c = l.a * r.c + l.b * r.f + l.c * r.i + l.d * r.l;

		res.d = l.e * r.a + l.f * r.d + l.g * r.g + l.h * r.j;
		res.e = l.e * r.b + l.f * r.e + l.g * r.h + l.h * r.k;
		res.f = l.e * r.c + l.f * r.f + l.g * r.i + l.h * r.l;

		res.g = l.i * r.a + l.j * r.d + l.k * r.g + l.l * r.j;
		res.h = l.i * r.b + l.j * r.e + l.k * r.h + l.l * r.k;
		res.i = l.i * r.c + l.j * r.f + l.k * r.i + l.l * r.l;

		m33Store.stack[m33Store.sp++]=res;
	}

	private final void mulM34M44(){
		M44Obj r = m44Store.stack[--m44Store.sp]; 
		M34Obj l = m34Store.stack[--m34Store.sp];
		M34Obj res = m34Store.heap[m34Store.hp++];
		res.a = l.a * r.a + l.b * r.e + l.c * r.i + l.d * r.m;
		res.b = l.a * r.b + l.b * r.f + l.c * r.j + l.d * r.n;
		res.c = l.a * r.c + l.b * r.g + l.c * r.k + l.d * r.o;
		res.d = l.a * r.d + l.b * r.h + l.c * r.l + l.d * r.p;

		res.e = l.e * r.a + l.f * r.e + l.g * r.i + l.h * r.m;
		res.f = l.e * r.b + l.f * r.f + l.g * r.j + l.h * r.n;
		res.g = l.e * r.c + l.f * r.g + l.g * r.k + l.h * r.o;
		res.h = l.e * r.d + l.f * r.h + l.g * r.l + l.h * r.p;

		res.i = l.i * r.a + l.j * r.e + l.k * r.i + l.l * r.m;
		res.j = l.i * r.b + l.j * r.f + l.k * r.j + l.l * r.n;
		res.k = l.i * r.c + l.j * r.g + l.k * r.k + l.l * r.o;
		res.l = l.i * r.d + l.j * r.h + l.k * r.l + l.l * r.p;

		m34Store.stack[m34Store.sp++]=res;
	}

	// M42 * 

	private final void mulM42M22(){
		M22Obj r = m22Store.stack[--m22Store.sp]; 
		M42Obj l = m42Store.stack[--m42Store.sp];
		M42Obj res = m42Store.heap[m42Store.hp++];
		res.a = l.a * r.a + l.b * r.c;
		res.b = l.a * r.b + l.b * r.d;

		res.c = l.c * r.a + l.d * r.c;
		res.d = l.c * r.b + l.d * r.d;

		res.e = l.e * r.a + l.f * r.c;
		res.f = l.e * r.b + l.f * r.d;

		res.g = l.g * r.a + l.h * r.c;
		res.h = l.g * r.b + l.h * r.d;

		m42Store.stack[m42Store.sp++]=res;
	}

	
	private final void mulM42M23(){
		M23Obj r = m23Store.stack[--m23Store.sp]; 
		M42Obj l = m42Store.stack[--m42Store.sp];
		M43Obj res = m43Store.heap[m43Store.hp++];
		res.a = l.a * r.a + l.b * r.d;
		res.b = l.a * r.b + l.b * r.e;
		res.c = l.a * r.c + l.b * r.f;

		res.d = l.c * r.a + l.d * r.d;
		res.e = l.c * r.b + l.d * r.e;
		res.f = l.c * r.c + l.d * r.f;

		res.g = l.e * r.a + l.f * r.d;
		res.h = l.e * r.b + l.f * r.e;
		res.i = l.e * r.c + l.f * r.f;

		res.j = l.g * r.a + l.h * r.d;
		res.k = l.g * r.b + l.h * r.e;
		res.l = l.g * r.c + l.h * r.f;

		m43Store.stack[m43Store.sp++]=res;
	}

	private final void mulM42M24(){
		M24Obj r = m24Store.stack[--m24Store.sp]; 
		M42Obj l = m42Store.stack[--m42Store.sp];
		M44Obj res = m44Store.heap[m44Store.hp++];
		res.a = l.a * r.a + l.b * r.e;
		res.b = l.a * r.b + l.b * r.f;
		res.c = l.a * r.c + l.b * r.g;
		res.d = l.a * r.d + l.b * r.h;

		res.e = l.c * r.a + l.d * r.e;
		res.f = l.c * r.b + l.d * r.f;
		res.g = l.c * r.c + l.d * r.g;
		res.h = l.c * r.d + l.d * r.h;

		res.i = l.e * r.a + l.f * r.e;
		res.j = l.e * r.b + l.f * r.f;
		res.k = l.e * r.c + l.f * r.g;
		res.l = l.e * r.d + l.f * r.h;

		res.m = l.g * r.a + l.h * r.e;
		res.n = l.g * r.b + l.h * r.f;
		res.o = l.g * r.c + l.h * r.g;
		res.p = l.g * r.d + l.h * r.h;
		m44Store.stack[m44Store.sp++]=res;
	}

	// M43 * 

	private final void mulM43M32(){
		M32Obj r = m32Store.stack[--m32Store.sp]; 
		M43Obj l = m43Store.stack[--m43Store.sp];
		M42Obj res = m42Store.heap[m42Store.hp++];
		res.a = l.a * r.a + l.b * r.c + l.c * r.e;
		res.b = l.a * r.b + l.b * r.d + l.c * r.f;

		res.c = l.d * r.a + l.e * r.c + l.f * r.e;
		res.d = l.d * r.b + l.e * r.d + l.f * r.f;

		res.e = l.g * r.a + l.h * r.c + l.i * r.e;
		res.f = l.g * r.b + l.h * r.d + l.i * r.f;

		res.g = l.j * r.a + l.k * r.c + l.l * r.e;
		res.h = l.j * r.b + l.k * r.d + l.l * r.f;
		m42Store.stack[m42Store.sp++]=res;
	}

	private final void mulM43M33(){
		M33Obj r = m33Store.stack[--m33Store.sp]; 
		M43Obj l = m43Store.stack[--m43Store.sp];
		M43Obj res = m43Store.heap[m43Store.hp++];
		res.a = l.a * r.a + l.b * r.d + l.c * r.g;
		res.b = l.a * r.b + l.b * r.e + l.c * r.h;
		res.c = l.a * r.c + l.b * r.f + l.c * r.i;

		res.d = l.d * r.a + l.e * r.d + l.f * r.g;
		res.e = l.d * r.b + l.e * r.e + l.f * r.h;
		res.f = l.d * r.c + l.e * r.f + l.f * r.i;

		res.g = l.g * r.a + l.h * r.d + l.i * r.g;
		res.h = l.g * r.b + l.h * r.e + l.i * r.h;
		res.i = l.g * r.c + l.h * r.f + l.i * r.i;

		res.j = l.j * r.a + l.k * r.d + l.l * r.g;
		res.k = l.j * r.b + l.k * r.e + l.l * r.h;
		res.l = l.j * r.c + l.k * r.f + l.l * r.i;
		m43Store.stack[m43Store.sp++]=res;
	}

	private final void mulM43M34(){
		M34Obj r = m34Store.stack[--m34Store.sp]; 
		M43Obj l = m43Store.stack[--m43Store.sp];
		M44Obj res = m44Store.heap[m44Store.hp++];
		res.a = l.a * r.a + l.b * r.e + l.c * r.i;
		res.b = l.a * r.b + l.b * r.f + l.c * r.j;
		res.c = l.a * r.c + l.b * r.g + l.c * r.k;
		res.d = l.a * r.d + l.b * r.h + l.c * r.l;

		res.e = l.d * r.a + l.e * r.e + l.f * r.i;
		res.f = l.d * r.b + l.e * r.f + l.f * r.j;
		res.g = l.d * r.c + l.e * r.g + l.f * r.k;
		res.h = l.d * r.d + l.e * r.h + l.f * r.l;

		res.i = l.g * r.a + l.h * r.e + l.i * r.i;
		res.j = l.g * r.b + l.h * r.f + l.i * r.j;
		res.k = l.g * r.c + l.h * r.g + l.i * r.k;
		res.l = l.g * r.d + l.h * r.h + l.i * r.l;

		res.m = l.j * r.a + l.k * r.e + l.l * r.i;
		res.n = l.j * r.b + l.k * r.f + l.l * r.j;
		res.o = l.j * r.c + l.k * r.g + l.l * r.k;
		res.p = l.j * r.d + l.k * r.h + l.l * r.l;
		m44Store.stack[m44Store.sp++]=res;
	}
	
	// M44 *
	
	private final void mulM44M42(){
		M42Obj r = m42Store.stack[--m42Store.sp]; 
		M44Obj l = m44Store.stack[--m44Store.sp];
		M42Obj res = m42Store.heap[m42Store.hp++];
		res.a = l.a * r.a + l.b * r.c + l.c * r.e + l.d * r.g;
		res.b = l.a * r.b + l.b * r.d + l.c * r.f + l.d * r.h;

		res.c = l.e * r.a + l.f * r.c + l.g * r.e + l.h * r.g;
		res.d = l.e * r.b + l.f * r.d + l.g * r.f + l.h * r.h;

		res.e = l.i * r.a + l.j * r.c + l.k * r.e + l.l * r.g;
		res.f = l.i * r.b + l.j * r.d + l.k * r.f + l.l * r.h;

		res.g = l.m * r.a + l.n * r.c + l.o * r.e + l.p * r.g;
		res.h = l.m * r.b + l.n * r.d + l.o * r.f + l.p * r.h;

		m42Store.stack[m42Store.sp++]=res;
	}

	private final void mulM44M43(){
		M43Obj r = m43Store.stack[--m43Store.sp]; 
		M44Obj l = m44Store.stack[--m44Store.sp];
		M43Obj res = m43Store.heap[m43Store.hp++];
		res.a = l.a * r.a + l.b * r.d + l.c * r.g + l.d * r.j;
		res.b = l.a * r.b + l.b * r.e + l.c * r.h + l.d * r.k;
		res.c = l.a * r.c + l.b * r.f + l.c * r.i + l.d * r.l;

		res.d = l.e * r.a + l.f * r.d + l.g * r.g + l.h * r.j;
		res.e = l.e * r.b + l.f * r.e + l.g * r.h + l.h * r.k;
		res.f = l.e * r.c + l.f * r.f + l.g * r.i + l.h * r.l;

		res.g = l.i * r.a + l.j * r.d + l.k * r.g + l.l * r.j;
		res.h = l.i * r.b + l.j * r.e + l.k * r.h + l.l * r.k;
		res.i = l.i * r.c + l.j * r.f + l.k * r.i + l.l * r.l;

		res.j = l.m * r.a + l.n * r.d + l.o * r.g + l.p * r.j;
		res.k = l.m * r.b + l.n * r.e + l.o * r.h + l.p * r.k;
		res.l = l.m * r.c + l.n * r.f + l.o * r.i + l.p * r.l;

		m43Store.stack[m43Store.sp++]=res;
	}

	private final void mulM44M44(){
		M44Obj r = m44Store.stack[--m44Store.sp]; 
		M44Obj l = m44Store.stack[--m44Store.sp];
		M44Obj res = m44Store.heap[m44Store.hp++];
		res.a = l.a * r.a + l.b * r.e + l.c * r.i + l.d * r.m;
		res.b = l.a * r.b + l.b * r.f + l.c * r.j + l.d * r.n;
		res.c = l.a * r.c + l.b * r.g + l.c * r.k + l.d * r.o;
		res.d = l.a * r.d + l.b * r.h + l.c * r.l + l.d * r.p;

		res.e = l.e * r.a + l.f * r.e + l.g * r.i + l.h * r.m;
		res.f = l.e * r.b + l.f * r.f + l.g * r.j + l.h * r.n;
		res.g = l.e * r.c + l.f * r.g + l.g * r.k + l.h * r.o;
		res.h = l.e * r.d + l.f * r.h + l.g * r.l + l.h * r.p;

		res.i = l.i * r.a + l.j * r.e + l.k * r.i + l.l * r.m;
		res.j = l.i * r.b + l.j * r.f + l.k * r.j + l.l * r.n;
		res.k = l.i * r.c + l.j * r.g + l.k * r.k + l.l * r.o;
		res.l = l.i * r.d + l.j * r.h + l.k * r.l + l.l * r.p;

		res.m = l.m * r.a + l.n * r.e + l.o * r.i + l.p * r.m;
		res.n = l.m * r.b + l.n * r.f + l.o * r.j + l.p * r.n;
		res.o = l.m * r.c + l.n * r.g + l.o * r.k + l.p * r.o;
		res.p = l.m * r.d + l.n * r.h + l.o * r.l + l.p * r.p;
		m44Store.stack[m44Store.sp++]=res;
	}
	
	private final void mulVnMnn(VecObj l,MatObj r){
		double[] ldata = l.toArrayVec();
		double[][] rdata = r.toArrayMat();
		int rrows = rdata.length;
		int rcols = rdata[0].length;
		double res[]=new double[rcols];
			for(int j=0;j<rcols;++j){
				double ele = ldata[0] * rdata[0][j];
				for(int k=1;k<rrows;++k)
					ele += ldata[k] * rdata[k][j];
				res[j]=ele;
			}
		pushVec(res);
	}

	private final void mulMnnVn(MatObj l,VecObj r){
		double[][] ldata = l.toArrayMat();
		double[] rdata = r.toArrayVec();
		int lrows = ldata.length;
		int lcols = ldata[0].length;
		double res[]=new double[lrows];
		for(int i=0;i<lrows;++i){
			double ele = ldata[i][0] * rdata[0];
				for(int k=1;k<lcols;++k)
					ele += ldata[i][k] * rdata[k];
				res[i]=ele;
			}
		pushVec(res);
	}

	private final void mulVnVn(VecObj l,VecObj r){
		double[] ldata = l.toArrayVec();
		double[] rdata = r.toArrayVec();
		int rows = ldata.length;
		int cols = rdata.length;
		double res[][]=new double[rows][cols];
		for(int i=0;i<rows;++i){
				for(int j=0;j<cols;++j)
					res[i][j]=ldata[i]*rdata[j];
		}
		pushMat(res);
	}

private final void mulMnnMnn(MatObj l,MatObj r){
	double[][] ldata = l.toArrayMat();
	double[][] rdata = r.toArrayMat();
	int lrows = ldata.length;
	int rrows = rdata.length;
	int rcols = rdata[0].length;
	double res[][]=new double[lrows][rcols];
	for(int i=0;i<lrows;++i)
		for(int j=0;j<rcols;++j){
			double ele = ldata[i][0] * rdata[0][j];
			for(int k=1;k<rrows;++k)
				ele += ldata[i][k] * rdata[k][j];
			res[i][j]=ele;
		}
	pushMat(res);
}
	private final void pushVec(double[] vec)
	{
		switch(vec.length) {
			case 2:
			{ 	V2Obj v2 = v2Store.heap[v2Store.hp++];
				v2.a = vec[0]; v2.b = vec[1];
				v2Store.stack[v2Store.sp++]=v2;
				break;
			}
			case 3:
			{ 	V3Obj v3 = v3Store.heap[v3Store.hp++];
				v3.a = vec[0]; v3.b = vec[1]; v3.c = vec[2];
				v3Store.stack[v3Store.sp++]=v3;
				break;
			}
			case 4:
			{ 	V4Obj v4 = v4Store.heap[v4Store.hp++];
				v4.a = vec[0]; v4.b = vec[1]; v4.c = vec[2]; v4.d = vec[3];
				v4Store.stack[v4Store.sp++]=v4;
				break;
			}
			default:
				vnStore.stack[vnStore.sp++] = new VnObj(vec);
				break;
		}
	}

	private final void pushMat(double[][] mat)
	{
		switch(mat.length) {
			case 2:
			switch(mat[0].length) {
				case 2:	{
			 	M22Obj m22 = m22Store.heap[m22Store.hp++];
				m22.a = mat[0][0]; m22.b = mat[0][1];
				m22.c = mat[1][0]; m22.d = mat[1][1];
				m22Store.stack[m22Store.sp++]=m22;
				return;
				}
				case 3:	{
			 	M23Obj m23 = m23Store.heap[m23Store.hp++];
				m23.a = mat[0][0]; m23.b = mat[0][1]; m23.c = mat[0][2];
				m23.d = mat[1][0]; m23.e = mat[1][1]; m23.f = mat[1][2];
				m23Store.stack[m23Store.sp++]=m23;
				return;
				}
				case 4:	{ 
				M24Obj m24 = m24Store.heap[m24Store.hp++];
				m24.a = mat[0][0]; m24.b = mat[0][1]; m24.c = mat[0][2]; m24.d = mat[0][3];
				m24.e = mat[1][0]; m24.f = mat[1][1]; m24.g = mat[1][2]; m24.h = mat[1][3];
				m24Store.stack[m24Store.sp++]=m24;
				return;
				}
			}
			break;

			case 3:
			switch(mat[0].length) {
				case 2:	{
				M32Obj m32 = m32Store.heap[m32Store.hp++];
				m32.a = mat[0][0]; m32.b = mat[0][1];
				m32.c = mat[1][0]; m32.d = mat[1][1];
				m32.e = mat[2][0]; m32.f = mat[2][1];
				m32Store.stack[m32Store.sp++]=m32;
				return;
				}
				case 3:	{
				M33Obj m33 = m33Store.heap[m33Store.hp++];
				m33.a = mat[0][0]; m33.b = mat[0][1]; m33.c = mat[0][2];
				m33.d = mat[1][0]; m33.e = mat[1][1]; m33.f = mat[1][2];
				m33.g = mat[2][0]; m33.h = mat[2][1]; m33.i = mat[2][2];
				m33Store.stack[m33Store.sp++]=m33;
				return;
				}
				case 4:	{ 
				M34Obj m34 = m34Store.heap[m34Store.hp++];
				m34.a = mat[0][0]; m34.b = mat[0][1]; m34.c = mat[0][2]; m34.d = mat[0][3];
				m34.e = mat[1][0]; m34.f = mat[1][1]; m34.g = mat[1][2]; m34.h = mat[1][3];
				m34.i = mat[2][0]; m34.j = mat[2][1]; m34.k = mat[2][2]; m34.l = mat[2][3];
				m34Store.stack[m34Store.sp++]=m34;
				return;
				}
			}
			break;
			
			case 4:
			switch(mat[0].length) {
				case 2:	{
				M42Obj m42 = m42Store.heap[m42Store.hp++];
				m42.a = mat[0][0]; m42.b = mat[0][1];
				m42.c = mat[1][0]; m42.d = mat[1][1];
				m42.e = mat[2][0]; m42.f = mat[2][1];
				m42.g = mat[3][0]; m42.h = mat[3][1];
				m42Store.stack[m42Store.sp++]=m42;
				return;
				}
				case 3:	{
				M43Obj m43 = m43Store.heap[m43Store.hp++];
				m43.a = mat[0][0]; m43.b = mat[0][1]; m43.c = mat[0][2];
				m43.d = mat[1][0]; m43.e = mat[1][1]; m43.f = mat[1][2];
				m43.g = mat[2][0]; m43.h = mat[2][1]; m43.i = mat[2][2];
				m43.j = mat[3][0]; m43.k = mat[3][1]; m43.l = mat[3][2];
				m43Store.stack[m43Store.sp++]=m43;
				return;
				}
				case 4:	{ 
				M44Obj m44 = m44Store.heap[m44Store.hp++];
				m44.a = mat[0][0]; m44.b = mat[0][1]; m44.c = mat[0][2]; m44.d = mat[0][3];
				m44.e = mat[1][0]; m44.f = mat[1][1]; m44.g = mat[1][2]; m44.h = mat[1][3];
				m44.i = mat[2][0]; m44.j = mat[2][1]; m44.k = mat[2][2]; m44.l = mat[2][3];
				m44.m = mat[3][0]; m44.n = mat[3][1]; m44.o = mat[3][2]; m44.p = mat[3][3];
				m44Store.stack[m44Store.sp++]=m44;
				return;
				}
			} // end switch
			break;
		} // end switch
		mnnStore.stack[mnnStore.sp++]=new MnnObj(mat);
	} 
	
	private static double LOG10 = Math.log(10.0);

	private final void unitaryFunction(short fun)
	{
		double r = scalerStore.stack[--scalerStore.sp];
		switch(fun) {
			case SIN: r = Math.sin(r); break;
			case COS: r = Math.cos(r); break;
			case TAN: r = Math.tan(r); break;

			case ASIN: r = Math.asin(r); break;
			case ACOS: r = Math.acos(r); break;
			case ATAN: r = Math.atan(r); break;

			case SINH: r = (Math.exp(r)-Math.exp(-r))/2; break;
			case COSH: r = (Math.exp(r)+Math.exp(-r))/2; break;
			case TANH: 
				{double ex = Math.exp(r*2);
				 r = (ex-1)/(ex+1); break;
				}

			case ASINH: r = Math.log(r+Math.sqrt(1+r*r)); break;
			case ACOSH: r = Math.log(r+Math.sqrt(r*r-1)); break;
			case ATANH: r = Math.log((1+r)/(1-r))/2.0; break;

			case ABS: r = Math.abs(r); break;
			case EXP: r = Math.exp(r); break;
			case LOG: r = Math.log(r) / LOG10; break;
			case LN:  r = Math.log(r); break;
			case SQRT: r = Math.sqrt(r); break;

			case SEC: r = 1.0/Math.cos(r); break;
			case COSEC:  r = 1.0/Math.sin(r); break;
			case COT: r = 1.0/Math.tan(r); break;
		}
		scalerStore.stack[scalerStore.sp++] = r;
	}
	private final void binaryFunction(short fun){
		double r = scalerStore.stack[--scalerStore.sp];
		double l = scalerStore.stack[--scalerStore.sp];
		switch(fun) {
		case ATAN2: r = Math.atan2(l,r); break;
		}
		scalerStore.stack[scalerStore.sp++] = r;
	}
	private final void trianaryFunction(short fun)
	{
		double a = scalerStore.stack[--scalerStore.sp];
		double r = scalerStore.stack[--scalerStore.sp];
		double l = scalerStore.stack[--scalerStore.sp];
		switch(fun) {
		case IF: r = (l>0.0?r:a); break;
		}
		scalerStore.stack[scalerStore.sp++] = r;
		
	}
	private final void quarteraryFunction(short fun)
	{
		double b = scalerStore.stack[--scalerStore.sp];
		double a = scalerStore.stack[--scalerStore.sp];
		double r = scalerStore.stack[--scalerStore.sp];
		double l = scalerStore.stack[--scalerStore.sp];
		switch(fun) {
		case IF: r = (l>0.0?r: (l<0.0?a:b)); break;
		}
		scalerStore.stack[scalerStore.sp++] = r;
		
	}

	/**Removes observers and other cleanup needed when evaluator no longer used.
	 */
	public void cleanUp()
	{
		scalerStore.cleanUp();
		v2Store.cleanUp();
		v3Store.cleanUp();
		v4Store.cleanUp();
		vnStore.cleanUp();
		m22Store.cleanUp();
		m23Store.cleanUp();
		m24Store.cleanUp();
		m32Store.cleanUp();
		m33Store.cleanUp();
		m34Store.cleanUp();
		m42Store.cleanUp();
		m43Store.cleanUp();
		m44Store.cleanUp();
		mnnStore.cleanUp();
	}
}
/* @author rich
 * Created on 07-Mar-2004
 */
package org.lsmp.djep.groupJep;
import org.nfunk.jep.*;
import org.lsmp.djep.groupJep.function.*;
import org.nfunk.jep.function.*;
/**
 * The set of operators used in the parser.
 * Actual function and suported operators are 
 * defined by the group and the interfaces it supports.
 *
 * @author Rich Morris
 * Created on 07-Mar-2004
 */
public class GOperatorSet extends OperatorSet {

	/**
	 * TODO Should really change the properties of operators, might muck up simplification.
	 */
	public GOperatorSet(GroupI group) {
		super();
		OP_ADD.setPFMC(new GAdd(group));
		OP_SUBTRACT.setPFMC(new GSubtract(group));
		OP_MULTIPLY.setPFMC(new GMultiply(group));
		OP_DIVIDE.setPFMC(new GDivide(group));
		OP_MOD.setPFMC(new GMod(group));
		OP_POWER.setPFMC(new GPower(group));
		OP_UMINUS.setPFMC(new GUMinus(group));
		OP_LT.setPFMC(new GComparative(group,Comparative.LT));
		OP_GT.setPFMC(new GComparative(group,Comparative.GT));
		OP_LE.setPFMC(new GComparative(group,Comparative.LE));
		OP_GE.setPFMC(new GComparative(group,Comparative.GE));
		OP_NE.setPFMC(new GComparative(group,Comparative.NE));
		OP_EQ.setPFMC(new GComparative(group,Comparative.EQ));

		OP_AND.setPFMC(new GLogical(Logical.AND));
		OP_AND.setPFMC(new GLogical(Logical.OR));
		OP_OR.setPFMC(new GNot());
		OP_LIST.setPFMC(new GList(group));
	}

}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep;
import org.nfunk.jep.type.*;
import org.nfunk.jep.*;
/**
 * Represents a group with an identity, and addition operator.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public interface GroupI {
	/** Returns the identity element under + */
	public Number getZERO();
	/** Get Inverse of a number */
	public Number getInverse(Number num);
	/** Get sum of the numbers */
	public Number add(Number a,Number b);
	/** Get the difference of the numbers.
	 * i.e. a + (-b) */
	public Number sub(Number a,Number b);
	/** whether two numbers are equal */
	public boolean equals(Number a,Number b);
	/** returns number given by the string */
	public Number valueOf(String s);
	/** returns a number factory for creating group elements from strings.
	 * Most groups which are subclasses of {@link org.lsmp.djep.groupJep.groups.Group Group} do not need to
	 * implement this method. */
	public NumberFactory getNumberFactory();
	/** adds the standard constants for this group */
	public void addStandardConstants(JEP j);
	/** adds the standard function for this group */
	public void addStandardFunctions(JEP j);
	/** For groups like rings of polynomials this determins if a given element is a constant polynomial. */	
	public boolean isConstantPoly(Number a);

}
/* @author rich
 * Created on 19-Dec-2003
 */
package org.lsmp.djep.groupJep;

import org.nfunk.jep.*;
import org.nfunk.jep.type.Complex;
import org.lsmp.djep.groupJep.values.*;
/**
 * An extension of JEP which allows calculations over arbitary groups,
 * such as the integers(exact answers) and rationals.
 *  
 * @author Rich Morris
 * Created on 19-Dec-2003
 */
public class GroupJep extends JEP {
	protected GroupI group;
	/** 
	 * Create a new GroupJep instance with calculations over the given group.
	 * 
	 * @param group The group to calculate over.
	 */
	public GroupJep(GroupI group) {
		super();
		this.group = group;
		super.numberFactory = group.getNumberFactory();
		opSet = new GOperatorSet(group);
	}
	private GroupJep() {}
	public void addStandardFunctions()
	{
//		Certinally don't want the jep standard functions
//		super.addStandardFunctions();
		group.addStandardFunctions(this);
	}

	public void addStandardConstants()
	{
		group.addStandardConstants(this);
	}

	public GroupJep(JEP j) {
		super(j);
	}

	public GroupI getGroup()
	{
		return group;
	}

	/** 
	 * Calcuates the value of the expression and returns the 
	 * result as a complex number.
	 */
	public Complex getComplexValue() {
		Object num = this.getValueAsObject();
		if(num instanceof Complex) return (Complex) num;
		else if(num instanceof HasComplexValueI)
			return ((HasComplexValueI) num).getComplexValue();
		else if(num instanceof Number)
			return new Complex((Number) num);
		return super.getComplexValue();
	}

	/**
	 * A utility function which returns the complex aproximation of a number.
	 * @see HasComplexValueI
	 * @param num the object to be converted
	 * @return the complex aproximation or null if conversion to complex is not posible. 
	 **/
	public static Complex complexValueOf(Object num)
	{
		if(num instanceof Complex) return (Complex) num;
		else if(num instanceof HasComplexValueI)
			return ((HasComplexValueI) num).getComplexValue();
		else if(num instanceof Number)
			return new Complex((Number) num);
		else return null;
	}

}
/* @author rich
 * Created on 05-Oct-2004
 */
package org.lsmp.djep.groupJep;

import org.nfunk.jep.*;
import org.lsmp.djep.groupJep.values.*;
import org.lsmp.djep.groupJep.groups.*;
import org.lsmp.djep.xjep.*;
/**
 * Constructs a polynomial from a JEP equation.
 * 
 * @author Rich Morris
 * Created on 05-Oct-2004
 */
public class PolynomialVisitor extends DoNothingVisitor {
	private OperatorSet opSet;
	private FreeGroup fg;
	/**
	 * 
	 */
	public PolynomialVisitor(JEP j) {
		super();
		opSet = j.getOperatorSet();
	}

	/**
	 * calculates a polynomial representing the node.
	 * @param node The top node of the expression
	 * @param fg The group the polynomial is an element of.
	 * @return the polynomial representing the equation
	 * @throws ParseException if the node cannot be converted to a Polynomial
	 */
	public Polynomial calcPolynomial(Node node,FreeGroup fg) throws ParseException
	{
		this.fg = fg;
		return (Polynomial) node.jjtAccept(this,null);
	}

	public Object visit(ASTFunNode node, Object data) throws ParseException {
		int nchild = node.jjtGetNumChildren();
		Polynomial children[] = new Polynomial[nchild];
		for(int i=0;i<nchild;++i)
			children[i]= (Polynomial) node.jjtGetChild(i).jjtAccept(this,data);
			
		Operator op = node.getOperator();
		if(op == null) throw new ParseException("Function "+node.getName()+" cannot be converted to a polynomial");
		if(op == opSet.getAdd())
		{
			return fg.add(children[0],children[1]);
		}
		if(op == opSet.getSubtract())
		{
			return fg.sub(children[0],children[1]);
		}
		if(op == opSet.getMultiply())
		{
			return fg.mul(children[0],children[1]);
		}
		throw new ParseException("Operator "+op.getName()+" not supported");
	}

	public Object visit(ASTVarNode node, Object data) throws ParseException {
		if(fg.getSymbol().equals(node.getName()))
		{
			return fg.getTPoly();
		}
		Variable var = node.getVar();
		if(!var.hasValidValue())
			throw new ParseException("Variable "+var.getName()+" does not have a valid value");
	
		return fg.valueOf(new Number[]{(Number) var.getValue()});
	}

	public Object visit(ASTConstant node, Object data) throws ParseException {
		return fg.valueOf(new Number[]{(Number) node.getValue()});
	}

}
/* @author rich
 * Created on 15-Mar-2004
 */
package org.lsmp.djep.groupJep.interfaces;

/**
 * Group implements a List function [a,b,c].
 * @author Rich Morris
 * Created on 15-Mar-2004
 */
public interface HasListI {
	public Number list(Number eles[]);
}
/* @author rich
 * Created on 06-Mar-2004
 */
package org.lsmp.djep.groupJep.interfaces;

/**
 * Group has a mod operator a % b.
 * 
 * @author Rich Morris
 * Created on 06-Mar-2004
 */
public interface HasModI {
	public Number mod(Number a,Number b);
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.interfaces;

/**
 * A RingI which has a multiplicative indentity.
 * Does not add any functionality as RingI defines the
 * public Number getMulIdentity();
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public interface IntegralDomainI extends RingI {
	/** get multiplicative identity */
	//public Number getMulIdentity();
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.interfaces;

/**
 * Defines the operations on a ring, i.e. an abelian group
 * under + with a closed * operator and * distributitive over +.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public interface RingI extends AbelianGroupI {
	/** Returns the product of two numbers, a*b */
	public Number mul(Number a,Number b);
	/** Get multiplicative identity i.e. 1.
	 * Strictly speaking a ring need not have a mul indentity.
	 * However most useful ones do, and they are not
	 * all integral domains. */
	public Number getONE();

}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.interfaces;

/**
 * An IntergralDomainI which also has a notion of division,
 * which is not necessarily closed i.e. the integers.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public interface HasDivI {
	/** get division of two numbers. i.e. a * ( b^-1).
	 * Strictly speeking  */
	public Number div(Number a,Number b);
}
/* @author rich
 * Created on 06-Mar-2004
 */
package org.lsmp.djep.groupJep.interfaces;

/**
 * Group has a power operator a ^ b.
 * 
 * @author Rich Morris
 * Created on 06-Mar-2004
 */
public interface HasPowerI {
	public Number pow(Number a,Number b);
}
/* @author rich
 * Created on 06-Mar-2004
 */
package org.lsmp.djep.groupJep.interfaces;

/**
 * Groups which have a total ordering, i.e <, >= make sense.
 * @see java.lang.Comparable
 * @author Rich Morris
 * Created on 06-Mar-2004
 */
public interface OrderedSetI {
	/** Returns -1,0,1 depending on whether a is less than, equal to or greater than b. */
	public int compare(Number a,Number b);
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.interfaces;

/**
 * Represents a field.
 * Abelian group for + with inverse 0.
 * Elements excluding 0 form a abelian group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public interface FieldI extends IntegralDomainI,HasDivI {
	/** get mul inverse */
	public Number getMulInverse(Number num);
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.interfaces;

import org.lsmp.djep.groupJep.*;

/**
 * Represents a abelian (commutative) group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public interface AbelianGroupI extends GroupI {
}
/* @author rich
 * Created on 09-Mar-2004
 */
package org.lsmp.djep.groupJep.values;
import org.lsmp.djep.groupJep.interfaces.*;
import org.lsmp.djep.groupJep.*;
import org.nfunk.jep.type.*;
/**
 * The ring of polynomials over a ring R.
 * 
 * @author Rich Morris
 * Created on 09-Mar-2004
 */
public class Polynomial extends Number {
	private RingI baseRing;
	private String symbol;
	private Number coeffs[];
	private int degree;
	/**
	 * Construct a polynomial over a ring.
	 * In general the valueOf method should be used to construct a new polynomial.
	 * 
	 * @param baseRing the underlying ring of the polynomial.
	 * @param symbol the symbol used to display the polynomial
	 * @param coeffs an array of coeficients in the base ring coeff[0] is constant, coeff[1] is coefficient of t etc.
	 */
	public Polynomial(RingI baseRing,String symbol,Number coeffs[]) {
		this.baseRing = baseRing;
		this.symbol = symbol;
		int deg=0;
		for(int i=coeffs.length-1;i>0;--i)
			if(!baseRing.equals(coeffs[i],baseRing.getZERO()))
			{
				deg=i;
				break;
			}
		if(deg == coeffs.length-1)
			this.coeffs = coeffs;
		else
		{
			this.coeffs = new Number[deg+1];
			System.arraycopy(coeffs,0,this.coeffs,0,deg+1);
		}
		this.degree = deg;
	}

	/** Sub classes can change the coefficients. Other methods
	 * should treat polynomials as imutable. */
	protected void setCoeffs(Number coeffs[])
	{
		this.coeffs = coeffs;
		this.degree = coeffs.length-1;
	}
	/** Factory method to create a polynomial with the given coefficients.
	 * Sub classes should overwrite this method to costruct objects of the correct type. */
	protected Polynomial valueOf(Number lcoeffs[])
	{
		Polynomial p = new Polynomial(baseRing,symbol,lcoeffs);
		return p;
	}
	public Polynomial add(Polynomial poly)
	{
		int deg = degree > poly.degree ? degree : poly.degree;
		Number lcoeffs[] = new Number[deg+1];
		for(int i=0;i<=deg;++i)
		{
			if(i<=degree && i <= poly.degree)
				lcoeffs[i] = baseRing.add(coeffs[i],poly.coeffs[i]);
			else if(i<=degree)
				lcoeffs[i] = coeffs[i];
			else
				lcoeffs[i] = poly.coeffs[i];
		}
		return valueOf(lcoeffs);
	}

	public Polynomial sub(Polynomial poly)
	{
		int deg = degree > poly.degree ? degree : poly.degree;
		Number lcoeffs[] = new Number[deg+1];
		for(int i=0;i<=deg;++i)
		{
			if(i<=degree && i <= poly.degree)
				lcoeffs[i] = baseRing.sub(coeffs[i],poly.coeffs[i]);
			else if(i<=degree)
				lcoeffs[i] = coeffs[i];
			else
				lcoeffs[i] = baseRing.getInverse(poly.coeffs[i]);
		}
		return valueOf(lcoeffs);
	}
	
	public Polynomial mul(Polynomial poly)
	{
		int deg = degree + poly.degree;
		Number lcoeffs[] = new Number[deg+1];
		for(int i=0;i<=deg;++i)
			lcoeffs[i] = baseRing.getZERO();

		for(int i=0;i<=degree;++i)
			for(int j=0;j<=poly.degree;++j)
			{
				lcoeffs[i+j] = baseRing.add(lcoeffs[i+j],
					baseRing.mul(coeffs[i],poly.coeffs[j]));			
			}
		return valueOf(lcoeffs);
	}

	public Polynomial div(Polynomial poly)
	{
		if(!poly.isConstantPoly())
			throw new IllegalArgumentException("Can currently only divide by numbers and not polynomials");
		
		int deg = coeffs.length-1;
		Number lcoeffs[] = new Number[deg+1];
		for(int i=0;i<deg+1;++i)
			lcoeffs[i] = ((HasDivI) baseRing).div(coeffs[i],poly.getCoeff(0));

		return valueOf(lcoeffs);
	}
	
	
	public Polynomial pow(int exp)
	{
		if(exp == 0) return valueOf(new Number[]{baseRing.getONE()});
		if(exp == 1) return valueOf(this.getCoeffs());
		if(exp < 0)
			throw new IllegalArgumentException("Tried to raise a Polynomial to a negative power");

		Polynomial res = valueOf(new Number[]{baseRing.getONE()});
		Polynomial currentPower = this;
		
		while(exp != 0)
		{
			if((exp & 1) == 1)
				res = res.mul(currentPower);
			exp >>= 1;
			if(exp == 0) break;
			currentPower = currentPower.mul(currentPower);
		}
		return res;
	}
	private boolean needsBrackets(String s)
	{
		int i1 = s.indexOf('+');
		int i2 = s.lastIndexOf('-');
		return ( (i1 !=-1) || (i2>0) );
	}
	public String toString()
	{
		if(degree==0) return coeffs[0].toString();
		StringBuffer sb = new StringBuffer("");
		for(int i=degree;i>=0;--i)
		{
			String s = coeffs[i].toString();

			// don't bother if a zero coeff
			if(s.equals("0") ||
			  this.baseRing.equals(coeffs[i],baseRing.getZERO()))
				continue;

			// apart from first add a + sign if positive
			if(i!=degree && !s.startsWith("-")) sb.append("+");
			
			// always print the final coeff (if non zero)
			if( i==0 ) {
				String s1 = coeffs[i].toString();
				sb.append(s1);
				//if(s1.startsWith("(") && s1.endsWith(")"))
				//{
				//		sb.append(s1.substring(1,s1.length()-1));
				//}
				//else 	sb.append(s1);
				break;
			}
			// if its -1 t^i just print -
			if(s.equals("-1")) 
				sb.append("-");
			else if(s.equals("1")  ||
				this.baseRing.equals(
					coeffs[i],
					baseRing.getONE()))
				{} // don't print 1
			else {
				if(needsBrackets(coeffs[i].toString()))
				{
					sb.append("(");
					sb.append(coeffs[i].toString());
					sb.append(")");
				}
				else
					sb.append(coeffs[i].toString());
				//sb.append(stripBrackets(coeffs[i]));
				sb.append(" ");
			}
			if(i>=2) sb.append(symbol+"^"+i);
			else if(i==1) sb.append(symbol);
		}
		sb.append("");
		return sb.toString();
	}
	
	public int getDegree() { return degree; }
	public String getSymbol() { return symbol; }
	/** Returns the coefficients of polynomial.
	 * TODO use defensive copying
	 * @return the array of coefficients, constant coefficient is element 0.
	 */
	public Number[] getCoeffs() { return coeffs; }
	public Number getCoeff(int i) { return coeffs[i]; }
	public RingI getBaseRing() { return baseRing; }

	/** value of constant coeff. */	
	public int intValue() {return coeffs[0].intValue();	}
	/** value of constant coeff. */	
	public long longValue() {return coeffs[0].longValue();	}
	/** value of constant coeff. */	
	public float floatValue() {	return coeffs[0].floatValue();	}
	/** value of constant coeff. */	
	public double doubleValue() {return coeffs[0].doubleValue();	}

	/** Is this a constant polynomial? **/
	public boolean isConstantPoly() {
		if( coeffs.length > 1) return false;
		return baseRing.isConstantPoly(coeffs[0]);
	}
	public boolean equals(Polynomial n)
	{
		if(this.getDegree()!=n.getDegree()) return false;
		for(int i=0;i<=this.getDegree();++i)
			if(!baseRing.equals(this.getCoeff(i),n.getCoeff(i)))
				return false;
		return true;
	}

	/** returns the complex value of this polynomial. 
	 * Where the value of the symbol is replaced by rootVal. 
	 */
	public Complex calculateComplexValue(Complex rootVal) {
		Number val = coeffs[this.getDegree()];
		Complex cval = GroupJep.complexValueOf(val);
		
		for(int i=this.getDegree()-1;i>=0;--i)
		{
			Number val2 = coeffs[i];
			Complex cval2 = GroupJep.complexValueOf(val2);
			Complex prod = cval.mul(rootVal);
			cval = prod.add(cval2);
		}
		return cval;
	}

	public Number calculateValue(Number rootVal) {
		Number val = coeffs[this.getDegree()];
		
		for(int i=this.getDegree()-1;i>=0;--i)
		{
			Number val2 = coeffs[i];
			Number prod = baseRing.mul(val,rootVal);
			val = baseRing.add(prod,val2);
		}
		return val;
	}

}
/* @author rich
 * Created on 09-Mar-2004
 */
package org.lsmp.djep.groupJep.values;

import org.lsmp.djep.groupJep.groups.FreeGroup;
import org.nfunk.jep.type.*;

/**
 * An element of a free group with one generator.
 *
 * @see org.lsmp.djep.groupJep.groups.FreeGroup
 * @author Rich Morris
 * Created on 09-Mar-2004
 */
public class FreeGroupElement extends Polynomial implements HasComplexValueI {

	FreeGroup group;

	/**
	 * An element of a free group with one generator.
	 * @param K the free group.
	 * @param coeffs array of coefficients for this element c0 + c1 t + ... + cn t^n 
	 */
	public FreeGroupElement(FreeGroup K, Number coeffs[]) {
		super(K.getBaseRing(),K.getSymbol(),coeffs);
		this.group = K;
	}

//	public AlgebraicNumber(RingI baseRing,Polynomial poly,Number coeffs[]) {
//		this(new AlgebraicExtension(baseRing,poly),coeffs);
//	}

	/** sub classes should overwrite this to make the correct type. */
	protected Polynomial valueOf(Number lcoeffs[])
	{
		FreeGroupElement g = new FreeGroupElement(group,lcoeffs);
		return g;
	}

	/** Returns an approximation to the complex number representing this algebraic number. 
	 * This only gives meaningful results if setRootValue has been called
	 * or if it is a quadratic extension (t^2+b t+c) or if it is a simple n-th root (t^n+a).
	 * In the last two cases the root value is calculated automatically. 
	 * @return Complex(Nan) if currently unable to calculate it. */

	public Complex getComplexValue() {
			return calculateComplexValue(group.getRootVal());
	}
}
/* @author rich
 * Created on 15-Mar-2004
 */
package org.lsmp.djep.groupJep.values;
import org.lsmp.djep.groupJep.*;
/**
 * @author Rich Morris
 * Created on 15-Mar-2004
 */
public class Permutation extends Number {

	protected GroupI group;
	protected Integer perm[];
	protected int len;
	/**
	 * 
	 */
	public Permutation(GroupI group,Integer perm[]) {
		super();
		this.group = group;
		this.perm = perm;
		this.len = perm.length;
	}

	public Permutation add(Permutation p1)
	{
		Integer res[] = new Integer[p1.perm.length];
		for(int i=0;i<len;++i)
		 	res[i]= p1.perm[this.perm[i].intValue()-1];
		return valueOf(res);
	}

	
	public Permutation getInverse() {
		Integer res[] = new Integer[len];
		for(int i=0;i<len;++i)
			res[this.perm[i].intValue()-1]= new Integer(i+1);
		return valueOf(res);
	}
	
	public Permutation sub(Permutation p1)
	{
		return this.add(p1.getInverse());
	}

	public boolean equals(Permutation p1)
	{
		for(int i=0;i<len;++i)
			if(this.perm[i] != p1.perm[i])
				return false;
		return true;	
	}

	public Permutation valueOf(Integer p[])
	{
		return new Permutation(this.group,p);
	}

	public Permutation valueOf(Number p[])
	{
		Integer res[] = new Integer[p.length];
		for(int i=0;i<p.length;++i)
			res[i]=(Integer) p[i];
		return new Permutation(this.group,res);
	}
	
	public String toString()
	{
		StringBuffer sb = new StringBuffer();
		sb.append("[");
		for(int i=0;i<this.perm.length;++i)
		{
			if(i>0) sb.append(",");
			sb.append(this.perm[i].toString());
		}
		sb.append("]");
		return sb.toString();
	}
	/** Just returns 0. Minimal implematation for compatability with Number. */
	public double doubleValue() {return 0;	}
	public float floatValue() {return 0;	}
	public int intValue() {	return 0;	}
	public long longValue() {return 0;	}
}
/* @author rich
 * Created on 09-Mar-2004
 */
package org.lsmp.djep.groupJep.values;

import org.lsmp.djep.groupJep.groups.AlgebraicExtension;

/**
 * An element of the algrabraic extension K(t).
 * a0 + a1 t + a(n-1) t^(n-1) 
 * where t is defined to be the the solution of a polynomial equation.
 *
 * @see AlgebraicExtension
 * @author Rich Morris
 * Created on 09-Mar-2004
 */
public class AlgebraicExtensionElement extends FreeGroupElement {

	AlgebraicExtension ae;

	/**
	 * An element of the algebraic extension K(t).
	 * a0 + a1 t + a(n-1) t^(n-1) 
	 * where t is defined to be the the solution of a polynomial equation.
	 * If the degree of the polynomial specified by coeffs is greater
	 * than n then the polynomial will be reduced by using
	 * the equation t^n = ..... 
	 * @param K the algebraic extension.
	 * @param coeffs array of coefficients for this algebraic number. c0 + c1 t + ... + cn t^n 
	 */
	public AlgebraicExtensionElement(AlgebraicExtension K, Number coeffs[])
	{
		super(K,coeffs);
		this.ae = K;
		int deg_p = ae.getPoly().getDegree();
		while(this.getCoeffs().length > deg_p)
		{
			Polynomial poly2 = ae.getSubsPoly();
			int deg_c = this.getCoeffs().length-1;
			// coeffs = (a_m s^(m-n)+...+a_n) s^n + (a_(n-1) s^(n-1)+...+a_0)
			//        = p1 * s^n + p2;
			//        = p2 - p1 * q;
			Number p1Coeffs[] = new Number[deg_c-deg_p+1];
			Number p2Coeffs[] = new Number[deg_p];
			System.arraycopy(this.getCoeffs(),deg_p,p1Coeffs,0,deg_c-deg_p+1);
			System.arraycopy(this.getCoeffs(),0,p2Coeffs,0,deg_p);
			Polynomial p1 = new Polynomial(ae.getBaseRing(),ae.getPoly().getSymbol(),p1Coeffs);
			Polynomial p2 = new Polynomial(ae.getBaseRing(),ae.getPoly().getSymbol(),p2Coeffs);
			Polynomial p3 = p1.mul(poly2);
			Polynomial p4 = p3.add(p2);
			super.setCoeffs(p4.getCoeffs());
		}
	}

	/** sub classes should overwrite this to make the correct type. */
	protected Polynomial valueOf(Number lcoeffs[])
	{
		AlgebraicExtensionElement g = new AlgebraicExtensionElement(ae,lcoeffs);
		return g;
	}
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.values;
import java.math.*;
/**
 * A Rational number with full precision. Represented as quotien of two
 * numbers (always in most reduced form with posative denominator).
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class Rational extends Number implements Comparable {

	private BigInteger numerator;
	private BigInteger denominator;
	/**
	 */
	private Rational() {	}
	
	public Rational(BigInteger num) { 
		numerator = num; denominator = BigInteger.ONE; 
	}
	
	/** Rationals will always be represented in most reduced
	 * form with a positive denominator.
	 */
	public Rational(BigInteger num,BigInteger den) {
		BigInteger gcd = num.gcd(den);
		if(gcd.equals(BigInteger.ZERO))	{
			numerator = denominator = BigInteger.ZERO;
		}
		else if(den.signum() > 0){
			numerator = num.divide(gcd);
			denominator = den.divide(gcd); 
		}
		else {
			numerator = num.divide(gcd).negate();
			denominator = den.divide(gcd).negate(); 
		}
	}
	
	public int intValue()
	{
		if(denominator.equals(BigInteger.ZERO))
		{
			int sign = numerator.signum();
			if(sign == 0)
				return Integer.MAX_VALUE;
			else if(sign > 0 )
				return Integer.MAX_VALUE;
			else
				return Integer.MIN_VALUE;
		}
		return numerator.divide(denominator).intValue();
	}
	public long longValue()
	{
		return numerator.divide(denominator).longValue();
	}
	public float floatValue()
	{
		if(denominator.equals(BigInteger.ZERO))
		{
			int sign = numerator.signum();
			if(sign == 0)
				return Float.NaN;
			else if(sign > 0 )
				return Float.POSITIVE_INFINITY;
			else
				return Float.NEGATIVE_INFINITY;
		}
		return numerator.divide(denominator).floatValue();
	}
	public double doubleValue()
	{
		if(denominator.equals(BigInteger.ZERO))
		{
			int sign = numerator.signum();
			if(sign == 0)
				return Double.NaN;
			else if(sign > 0 )
				return Double.POSITIVE_INFINITY;
			else
				return Double.NEGATIVE_INFINITY;
		}
		return numerator.divide(denominator).doubleValue();
	}
	
	public Rational add(Rational arg)
	{
		BigInteger ad = this.numerator.multiply(arg.denominator); 
		BigInteger bc = this.denominator.multiply(arg.numerator); 
		BigInteger bd = this.denominator.multiply(arg.denominator);
		BigInteger top = ad.add(bc);
		return new Rational(top,bd);
	}

	public Rational sub(Rational arg)
	{
		BigInteger ad = this.numerator.multiply(arg.denominator); 
		BigInteger bc = this.denominator.multiply(arg.numerator); 
		BigInteger bd = this.denominator.multiply(arg.denominator);
		BigInteger top = ad.subtract(bc);
		return new Rational(top,bd);
	}

	public Rational mul(Rational arg)
	{
		BigInteger ac = this.numerator.multiply(arg.numerator); 
		BigInteger bd = this.denominator.multiply(arg.denominator);
		return new Rational(ac,bd);
	}

	public Rational div(Rational arg)
	{
		BigInteger ad = this.numerator.multiply(arg.denominator); 
		BigInteger bc = this.denominator.multiply(arg.numerator);
		return new Rational(ad,bc);
	}
	
	public Rational pow(Rational arg)
	{
		if(!arg.denominator.equals(BigInteger.ONE))
			throw new ArithmeticException("Can only raise rationals to integer powers");
		int exponant = arg.numerator.intValue();
		if(exponant == 0)
			return new Rational(BigInteger.ONE);
		else if(exponant > 0)
		{
			BigInteger top = this.numerator.pow(exponant); 
			BigInteger bot = this.denominator.pow(exponant);
			return new Rational(top,bot);
		}
		else
		{   // (a/b)^(-c) -> (b/a)^c -> (b^c/a^c)
			BigInteger top = this.numerator.pow(-exponant); 
			BigInteger bot = this.denominator.pow(-exponant);
			return new Rational(bot,top);
		}
	}

	public Rational negate()
	{
			return new Rational(numerator.negate(),denominator);
	}
	
	public Rational inverse()
	{
			return new Rational(denominator,numerator);
	}
	
	public static Number valueOf(String s) {
		int pos = s.indexOf('/');
		if(pos==-1)	return new Rational(new BigInteger(s));
		
		return new Rational(
				new BigInteger(s.substring(pos-1)),
				new BigInteger(s.substring(pos+1,-1))); 
	}
	/**
	 * * Returns the bottom half of the rational.
	 */
	public BigInteger getDenominator() {
		return denominator;
	}

	/**
	 * Returns the top half of the rational.
	 */
	public BigInteger getNumerator() {
		return numerator;
	}

	public String toString() {
		if(denominator.equals(BigInteger.ONE))
			return numerator.toString();
		
		return numerator.toString() +"/" + denominator.toString();
	}
	
	public int compareTo(Object arg)
	{
		Rational num = (Rational) arg;
		if(this.denominator.compareTo(num.denominator) == 0)
		{
			return this.numerator.compareTo(num.numerator);
		}
		BigInteger ad = this.numerator.multiply(num.denominator); 
		BigInteger bc = this.denominator.multiply(num.numerator); 
		return ad.compareTo(bc);
	}
}
/* @author rich
 * Created on 11-Mar-2004
 */
package org.lsmp.djep.groupJep.values;
import org.nfunk.jep.type.*;

/**
 * Group elements which have a natural conversion to complex numbers.
 * 
 * @author Rich Morris
 * Created on 11-Mar-2004
 */
public interface HasComplexValueI {
	public Complex getComplexValue();
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;
import org.lsmp.djep.groupJep.*;
import org.lsmp.djep.groupJep.interfaces.*;

import java.util.*;
import org.nfunk.jep.*;
/**
 * Multiplication operator for a group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class GMultiply extends PostfixMathCommand {
	private RingI group = null;
	/**
	 * 
	 */
	private GMultiply() {	}
	public GMultiply(GroupI group)
	{
		numberOfParameters = -1;
		if(group instanceof RingI)
		this.group = (RingI) group;
	}

	/**
	 * Calculates the result of applying the "*" operator to the arguments from
	 * the stack and pushes it back on the stack.
	 */
	public void run(Stack stack) throws ParseException {
		if(group==null) throw new ParseException("Multiply not implemented for this group.");
		checkStack(stack);// check the stack
		
		Object sum = stack.pop();
		Object param;
		int i = 1;
        
		// repeat summation for each one of the current parameters
		while (i < curNumberOfParameters) {
			// get the parameter from the stack
			param = stack.pop();
			// add it to the sum (order is important for String arguments)
			sum = mul(param, sum);
			i++;
		}
		stack.push(sum);
		return;
	}

	public Object mul(Object param1, Object param2) throws ParseException {
		if (param1 instanceof Number) {
			if (param2 instanceof Number) {
				return group.mul((Number)param1, (Number)param2);
			}
		}
		
		throw new ParseException("Invalid parameter type");
	}
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;
import org.lsmp.djep.groupJep.*;

import java.util.*;
import org.nfunk.jep.*;

/**
 * Add function for use with arbitary groups.
 * Actual behaviour defined by the Group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class GAdd extends PostfixMathCommand {
	private GroupI group;
	/**
	 * 
	 */
	private GAdd() {	}
	public GAdd(GroupI group)
	{
		numberOfParameters = -1;
		this.group = group;
	}

	/**
	 * Calculates the result of applying the "+" operator to the arguments from
	 * the stack and pushes it back on the stack.
	 */
	public void run(Stack stack) throws ParseException {
		checkStack(stack);// check the stack
		
		Object sum = stack.pop();
		Object param;
		int i = 1;
        
		// repeat summation for each one of the current parameters
		while (i < curNumberOfParameters) {
			// get the parameter from the stack
			param = stack.pop();
			// add it to the sum (order is important for String arguments)
			sum = add(param, sum);
			i++;
		}
		stack.push(sum);
		return;
	}

	public Object add(Object param1, Object param2) throws ParseException {
		if (param1 instanceof Number) {
			if (param2 instanceof Number) {
				return group.add((Number)param1, (Number)param2);
			}
		}
		
		throw new ParseException("Invalid parameter type");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;

import java.util.*;
import org.nfunk.jep.*;

/**
 * Implements logical operators for a group.
 * 
 * @author Rich Morris
 * Created on 13-Dec-2004
 */
public class GLogical extends PostfixMathCommand
{
	int id;
	
	/**
	 * Constructs
	 * @param id should be Logical.AND or Logical.OR
	 * @see org.nfunk.jep.function.Logical
	 **/
	public GLogical(int id)
	{
		this.id = id;
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();

		if ((param1 instanceof Boolean) && (param2 instanceof Boolean))
		{
			boolean a = ((Boolean)param1).booleanValue();
			boolean b = ((Boolean)param2).booleanValue();
			boolean flag=false;
			
			switch (id)
			{
				case Logical.AND:
					flag = a && b;
					break;
				case Logical.OR:
					flag = a || b;
					break;
				default:
					throw new ParseException("Illegal logical operator");
			}
			inStack.push(flag ? Boolean.TRUE : Boolean.FALSE);//push the result on the inStack
		}
		else
		{
			throw new ParseException("Invalid parameter type");
		}
		return;
	}
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;
import org.lsmp.djep.groupJep.*;

import java.util.*;
import org.nfunk.jep.*;
/**
 * Subtract operator for a group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class GSubtract extends PostfixMathCommand {
	private GroupI group;
	/**
	 * 
	 */
	private GSubtract() {	}
	public GSubtract(GroupI group)
	{
		numberOfParameters = 2;
		this.group = group;
	}

	/**
	 * Calculates the result of applying the "+" operator to the arguments from
	 * the stack and pushes it back on the stack.
	 */
	public void run(Stack stack) throws ParseException {
		checkStack(stack);// check the stack
		Object sum = stack.pop();
		Object param;
		param = stack.pop();
		sum = sub(param, sum);
		stack.push(sum);
		return;
	}

	public Object sub(Object param1, Object param2) throws ParseException {
		if (param1 instanceof Number) {
			if (param2 instanceof Number) {
				return group.sub((Number)param1, (Number)param2);
			}
		}
		
		throw new ParseException("Invalid parameter type");
	}
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;
import org.lsmp.djep.groupJep.*;
import org.lsmp.djep.groupJep.interfaces.*;

import java.util.*;
import org.nfunk.jep.*;
/**
 * List function for use with arbitary groups.
 * Converts elements on stack and returns a list
 * actual behaviour defined by the Group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class GList extends PostfixMathCommand {
	private GroupI group;
	/**
	 * 
	 */
	private GList() {	}
	public GList(GroupI group)
	{
		numberOfParameters = -1;
		this.group = group;
	}

	public void run(Stack stack) throws ParseException {
		checkStack(stack);// check the stack
		if(!(group instanceof HasListI))
			throw new ParseException("List not defined for this group");
		Number res[] = new Number[curNumberOfParameters]; 
		// repeat summation for each one of the current parameters
		for(int i=curNumberOfParameters-1;i>=0;--i) {
			res[i] = (Number) stack.pop();
		}
		stack.push(((HasListI) group).list(res));
		return;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;

import java.util.*;
import org.nfunk.jep.*;

 /**
  * Not function for use with arbitary groups.
  * Expects Boolean arguments.
  * 
  * @author Rich Morris
  * Created on 13-Dec-2004
  */
public class GNot extends PostfixMathCommand
{
	public GNot()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		
		Object param = inStack.pop();

		if (param instanceof Boolean)
		{
			boolean a = ((Boolean)param).booleanValue();
			inStack.push(a ? Boolean.FALSE : Boolean.TRUE);//push the result on the inStack
		}
		else
		{
			throw new ParseException("Invalid parameter type");
		}
		return;
	}
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;
import org.lsmp.djep.groupJep.*;
import java.util.*;
import org.nfunk.jep.*;
/**
 * Unitary division for a group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class GUMinus extends PostfixMathCommand {
	private GroupI group;
	/**
	 * 
	 */
	private GUMinus() {	}
	public GUMinus(GroupI group)
	{
		numberOfParameters = 1;
		this.group = group;
	}

	/**
	 * Calculates the result of applying the "+" operator to the arguments from
	 * the stack and pushes it back on the stack.
	 */
	public void run(Stack stack) throws ParseException {
		checkStack(stack);// check the stack
		
		Object sum = stack.pop();
		stack.push(uminus(sum));
		return;
	}

	public Object uminus(Object param1) throws ParseException {
		if (param1 instanceof Number) {
				return group.getInverse((Number)param1);
		}
		throw new ParseException("Invalid parameter type");
	}
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;
import org.lsmp.djep.groupJep.*;
import org.lsmp.djep.groupJep.interfaces.*;

import java.util.*;
import org.nfunk.jep.*;
/**
 * Divide function for use with arbitary groups.
 * Actual behaviour defined by the Group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class GDivide extends PostfixMathCommand {
	private HasDivI group=null;
	/**
	 * 
	 */
	private GDivide() {	}
	public GDivide(GroupI group)
	{
		numberOfParameters = 2;
		if(group instanceof HasDivI)
			this.group = (HasDivI) group;
	}

	/**
	 * Calculates the result of applying the "/" operator to the arguments from
	 * the stack and pushes it back on the stack.
	 */
	public void run(Stack stack) throws ParseException {
		checkStack(stack);// check the stack
		Object sum = stack.pop();
		Object param;
		param = stack.pop();
		sum = div(param, sum);
		stack.push(sum);
		return;
	}

	public Object div(Object param1, Object param2) throws ParseException {
		if(group==null) throw new ParseException("Divide not implemented for this group.");
		if (param1 instanceof Number) {
			if (param2 instanceof Number) {
				return group.div((Number)param1, (Number)param2);
			}
		}
		
		throw new ParseException("Invalid parameter type");
	}
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;
import org.lsmp.djep.groupJep.*;
import org.lsmp.djep.groupJep.interfaces.*;

import java.util.*;
import org.nfunk.jep.*;
/**
 * Modulus operator for group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class GMod extends PostfixMathCommand {
	private HasModI group=null;
	/**
	 * 
	 */
	private GMod() {	}
	public GMod(GroupI group)
	{
		numberOfParameters = 2;
		if(group instanceof HasModI)
			this.group = (HasModI) group;
	}

	/**
	 * Calculates the result of applying the "+" operator to the arguments from
	 * the stack and pushes it back on the stack.
	 */
	public void run(Stack stack) throws ParseException {
		checkStack(stack);// check the stack
		Object sum = stack.pop();
		Object param;
		param = stack.pop();
		sum = mod(param, sum);
		stack.push(sum);
		return;
	}

	public Object mod(Object param1, Object param2) throws ParseException {
		if(group==null) throw new ParseException("Modulus not implemented for this group.");
		if (param1 instanceof Number) {
			if (param2 instanceof Number) {
				return group.mod((Number)param1, (Number)param2);
			}
		}
		
		throw new ParseException("Invalid parameter type");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.lsmp.djep.groupJep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import org.lsmp.djep.groupJep.*;
import org.lsmp.djep.groupJep.interfaces.*;

/** 
 * Implements logical operations on a group.
 * Will always return Boolean results.
 * 
 * @author Rich Morris
 * Created on 06-Mar-2004
 */
public class GComparative extends PostfixMathCommand
{
	int id;
	GroupI group;
	
	/**
	 * Constructor.	For inequalities the group should implement OrderedSetI.
	 * 
	 * @param id should be Comparative.LT or GT, LE, GE, NE EQ
	 * @see org.nfunk.jep.function.Comparative
	 */	
	public GComparative(GroupI group,int id)
	{
		this.id = id;
		numberOfParameters = 2;
		this.group = group;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			Number num1 = (Number)param1;
			Number num2 = (Number)param2;
			boolean flag;
			if(group instanceof OrderedSetI)
			{
				int comp = ((OrderedSetI) group).compare(num1,num2);
				switch (id)
				{
					case Comparative.LT:
						flag = comp < 0;
						break;
					case Comparative.GT:
						flag = comp > 0;
						break;
					case Comparative.LE:
						flag = comp <= 0;
						break;
					case Comparative.GE:
						flag = comp >= 0;
						break;
					case Comparative.NE:
						flag = comp != 0;
						break;
					case Comparative.EQ:
						flag = comp == 0;
						break;
					default:
						throw new ParseException("Unknown relational operator");
				}
			}
			else
			{
				switch (id)
				{
				case Comparative.NE:
					flag = !group.equals(num1,num2);
					break;
				case Comparative.EQ:
					flag = group.equals(num1,num2);
					break;
				default:
					throw new ParseException("Unknown relational operator");
				}
			}
			inStack.push(flag ? Boolean.TRUE : Boolean.FALSE);//push the result on the inStack
		}
		else if ((param1 instanceof Boolean) && (param2 instanceof Boolean))
		{
			boolean num1 = ((Boolean)param1).booleanValue();
			boolean num2 = ((Boolean)param2).booleanValue();
			boolean flag;
			switch (id)
			{
			case Comparative.NE:
				flag = num1 != num2;
				break;
			case Comparative.EQ:
				flag = num1 == num2;
				break;
			default:
				throw new ParseException("Unknown relational operator");
			}
			inStack.push(flag ? Boolean.TRUE : Boolean.FALSE);//push the result on the inStack
		}
		else throw new ParseException("Invalid parameters for comparitive op");
			
	}
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.function;
import org.nfunk.jep.function.*;
import org.lsmp.djep.groupJep.*;
import org.lsmp.djep.groupJep.interfaces.*;

import java.util.*;
import org.nfunk.jep.*;
/**
 * Power operator for a group.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class GPower extends PostfixMathCommand {
	/** null if power not implemented */
	private HasPowerI group=null;
	/**
	 * 
	 */
	private GPower() {	}
	public GPower(GroupI group)
	{
		numberOfParameters = 2;
		if(group instanceof HasPowerI)
			this.group = (HasPowerI) group;
	}

	/**
	 * Calculates the result of applying the "+" operator to the arguments from
	 * the stack and pushes it back on the stack.
	 */
	public void run(Stack stack) throws ParseException {
		checkStack(stack);// check the stack
		Object exponant = stack.pop();
		Object param = stack.pop();
		Object res = pow(param, exponant);
		stack.push(res);
		return;
	}

	public Object pow(Object param1, Object param2) throws ParseException {
		if(group==null) throw new ParseException("Power not implemented for this group.");
		if (param1 instanceof Number) {
			if (param2 instanceof Number) {
				return group.pow((Number)param1, (Number)param2);
			}
		}
		
		throw new ParseException("Invalid parameter type");
	}
}
/* @author rich
 * Created on 07-Dec-2004
 */
package org.lsmp.djep.groupJep.groups;

import org.lsmp.djep.groupJep.interfaces.*;
import org.lsmp.djep.groupJep.values.*;
import org.nfunk.jep.type.*;
/**
 * An extended version of a Free Group, limited support for powers and division.
 * Positive integer powers are allowed and division by constants.
 * TODO implement polynomial division and remainder (mod).
 * 
 * @author Rich Morris
 * Created on 07-Dec-2004
 */
public class ExtendedFreeGroup
	extends FreeGroup
	implements HasPowerI, HasDivI {

	public ExtendedFreeGroup(RingI K, String symbol) {
		super(K, symbol);
	}

	/** Limited implementation of power, only works with integer powers.
	 * Second argument should be an Integer.
	 */
	public Number pow(Number a, Number b) {
		FreeGroupElement exp = (FreeGroupElement) b; 
		if(!isConstantPoly(exp))
			throw new IllegalArgumentException("Powers only supported for integer exponent. Current exponent is "+exp.toString());

		Complex c = exp.getComplexValue();
		if(c.im() != 0.0)
			throw new IllegalArgumentException("Powers only supported for integer exponent. Current exponent is "+exp.toString());
		double re = c.re();
		if(Math.floor(re) != re)
			throw new IllegalArgumentException("Powers only supported for integer exponent. Current exponent is "+exp.toString());

		return ((FreeGroupElement) a).pow((int) re);
	}

	/** Currently just division by constants. Polynomial division to come.
	 * 
	 */
	public Number div(Number a, Number b) {
		return ((FreeGroupElement) a).div((FreeGroupElement) b);
	}

	/** Division of Polynomials, discards remainder.
	 * Not yet implemented.
	 */
//	public Number mod(Number a, Number b) {
//		return null;
//		//return ((FreeGroupElement) a).mod((FreeGroupElement) b);
//	}

}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.groups;
import org.lsmp.djep.groupJep.interfaces.*;

/**
 * A representation of the Reals where elements are represented as Doubles.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class Reals extends Group implements FieldI,OrderedSetI,HasPowerI {

	private Double ZERO = new Double(0.0);
	private Double ONE = new Double(1.0);

	/**
	 * Operations on the reals (Implemented as Doubles).  
	 */
	public Reals() {
	}

	public Number getZERO() {
		return ZERO;
	}

	public Number getONE() {
		return ONE;
	}

	public Number getInverse(Number num) {
		return new Double(1.0/num.doubleValue());
	}

	public Number getMulInverse(Number num) {
		return new Double(1.0 / num.doubleValue());
	}

	public Number add(Number a, Number b) {
		return new Double(a.doubleValue()+b.doubleValue());
	}

	public Number sub(Number a, Number b) {
		return new Double(a.doubleValue()-b.doubleValue());
	}

	public Number mul(Number a, Number b) {
		return new Double(a.doubleValue()*b.doubleValue());
	}

	public Number div(Number a, Number b) {
		return new Double(a.doubleValue()/b.doubleValue());
	}

	public Number pow(Number a, Number b) {
		return new Double(Math.pow(a.doubleValue(),b.doubleValue()));
	}

	public Number valueOf(String str) {
		return new Double(str);
	}

	public boolean equals(Number a,Number b)	{
		return ((Double) a).compareTo((Double) b) == 0;
	}
	
	public int compare(Number a,Number b)	{
		return ((Double) a).compareTo((Double) b);
	}
	
	public String toString() {
		return "Reals (represented as Doubles)";
	}

}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.groups;
import java.math.*;

import org.lsmp.djep.groupJep.interfaces.*;

/**
 * The field of Reals represented by BigDecimals.
 * TODO Sorry power is not implemented.
 * @see BigDecimal
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class BigReals extends Group implements FieldI,OrderedSetI {

	private BigDecimal ZERO = BigDecimal.valueOf(0);
	private BigDecimal ONE = BigDecimal.valueOf(1);
	private int roundMode;
	private int scale;
	
	/** private constructor as a scale must be specified.	 */
	private BigReals() {}
	/** Create a field of BigIntegers.
	 * The round mode and scale are used during the div
	 * method which calls {@link java.math.BigDecimal#divide(BigDecimal,int,int)}.
	 * if scale is negative then the
	 * {@link java.math.BigDecimal#divide(BigDecimal,int)}. is called instead. 
	 */
	public BigReals(int scale,int roundMode) {
		this.roundMode = roundMode;
		this.scale = scale;
	}

	/** Create a BigReals group with round mode set to
	 * BigDecimal.ROUND_HALF_DOWN.
	 * 
	 * @param scale
	 */
	public BigReals(int scale) {
		this.roundMode = BigDecimal.ROUND_HALF_DOWN;
		this.scale = scale;
	}
	public Number getZERO() {
		return ZERO;
	}

	public Number getONE() {
		return ONE;
	}

	public Number getInverse(Number num) {
		BigDecimal a = (BigDecimal) num;
		return a.negate();
	}

	public Number getMulInverse(Number num) {
		return div(ONE,num);
	}

	public Number add(Number num1, Number num2) {
		BigDecimal a = (BigDecimal) num1;
		BigDecimal b = (BigDecimal) num2;
		return a.add(b);
	}

	public Number sub(Number num1, Number num2) {
		BigDecimal a = (BigDecimal) num1;
		BigDecimal b = (BigDecimal) num2;
		return a.subtract(b);
	}

	public Number mul(Number num1, Number num2) {
		BigDecimal a = (BigDecimal) num1;
		BigDecimal b = (BigDecimal) num2;
		return a.multiply(b);
	}

	public Number div(Number num1, Number num2) {
		BigDecimal a = (BigDecimal) num1;
		BigDecimal b = (BigDecimal) num2;
		if(scale>0)
			return a.divide(b,scale,roundMode);
		return a.divide(b,roundMode);
	}

	public boolean equals(Number a,Number b)	{
		return ((BigDecimal) a).compareTo((BigDecimal) b) == 0;
	}
	
	public int compare(Number a,Number b)	{
		return ((BigDecimal) a).compareTo((BigDecimal) b);
	}
	
	public Number valueOf(String str) {
		return new BigDecimal(str);
	}
}
/* @author rich
 * Created on 16-May-2004
 */
package org.lsmp.djep.groupJep.groups;

import org.nfunk.jep.JEP;
import org.lsmp.djep.groupJep.interfaces.*;
/**
 * Possibly the Quaternions, completely untested.
 * 
 * @author Rich Morris
 * Created on 16-May-2004
 */
public class Quaternions extends Group implements RingI {

	public static class Quaternion extends Number {
		double x,y,z,w;
		public Quaternion(double x,double y,double z,double w){
			this.w = x; this.y = y; this.z=z; this.w=w;
		}
		public double doubleValue() {return x;}
		public float floatValue() {return (float) x;}
		public int intValue() {return (int) x;}
		public long longValue() {return (long) x;}
		// TODO pretty print so 0 + 0 i + 0 j + 1 k printed as k
		public String toString() {//return ""+x+"+"+y+" i +"+z+" j +"+w+" k";
			StringBuffer sb = new StringBuffer();
			boolean flag=false;
			if(x!=0.0) { sb.append(x); flag = true; }
			if(y!=0.0) { 
				if(flag && y>0.0) sb.append("+");
				if(y==1.0) {}
				else if(y==-1.0) { sb.append("-"); }
				else sb.append(y); 
				sb.append("i");
				flag=true;
			}
			
			if(z!=0.0) { 
				if(flag && z>0.0) sb.append("+");
				if(z==1.0) {}
				else if(z==-1.0) { sb.append("-"); }
				else sb.append(z); 
				sb.append("j");
				flag=true;
			}
			if(w!=0.0) { 
				if(flag && w>0.0) sb.append("+");
				if(w==1.0) {}
				else if(w==-1.0) { sb.append("-"); }
				else sb.append(w); 
				sb.append("k");
				flag=true;
			}
			if(!flag)
				sb.append("0");
			return sb.toString();
		}
	}
	private Quaternion ZERO = new Quaternion(0,0,0,0);
	private Quaternion ONE = new Quaternion(1,0,0,0);
	private Quaternion I = new Quaternion(0,1,0,0);
	private Quaternion J = new Quaternion(0,0,1,0);
	private Quaternion K = new Quaternion(0,0,0,1);

	public Number getZERO() {return ZERO;}
	public Number getONE() {return ONE;	}

	public Number getInverse(Number num) {
		Quaternion q = (Quaternion) num;
		return new Quaternion(-q.x,-q.y,-q.z,-q.w);
	}

	public Number add(Number a, Number b) {
		Quaternion p = (Quaternion) a;
		Quaternion q = (Quaternion) b;
		return new Quaternion(p.x+q.x,p.y+q.y,p.z+q.z,p.w+q.w);
	}

	public Number sub(Number a, Number b) {
		Quaternion p = (Quaternion) a;
		Quaternion q = (Quaternion) b;
		return new Quaternion(p.x-q.x,p.y-q.y,p.z-q.z,p.w-q.w);
	}


	public Number mul(Number a, Number b) {
		Quaternion p = (Quaternion) a;
		Quaternion q = (Quaternion) b;
		return new Quaternion(
			p.x*q.x - p.y*q.y - p.z*q.z - p.w*q.w,
			p.x*q.y - p.y*q.x + p.z*q.w - p.w*q.z,
			p.x*q.z - p.y*q.w + p.z*q.x + p.w*q.y,
			p.x*q.w - p.y*q.z - p.z*q.y + p.w*q.x
			);
	}

	public boolean equals(Number a, Number b) {
		Quaternion p = (Quaternion) a;
		Quaternion q = (Quaternion) b;
		return (p.x==q.x)&&(p.y==q.y)&&(p.z==q.z)&&(p.w==q.w);
	}

	public Number valueOf(String s) {
		return new Quaternion(Double.parseDouble(s),0,0,0);
	}

	public void addStandardConstants(JEP j) {
		super.addStandardConstants(j);
		j.addConstant("i",I);
		j.addConstant("j",J);
		j.addConstant("k",K);
	}
	public String toString() {return "Quaternions";}

}
/* @author rich
 * Created on 15-Mar-2004
 */
package org.lsmp.djep.groupJep.groups;

import org.lsmp.djep.groupJep.GroupI;
import org.lsmp.djep.groupJep.values.*;
import org.lsmp.djep.groupJep.interfaces.*;

/**
 * The group of permutations.
 * 
 * TODO not sure if this works, not really tested.
 * 
 * @author Rich Morris
 * @see org.lsmp.djep.groupJep.values.Permutation
 * Created on 15-Mar-2004
 */
public class PermutationGroup extends Group implements GroupI , HasListI {

	protected Permutation zeroPerm;
	
	public PermutationGroup(int n)
	{
		Integer perm[] = new Integer[n];
		for(int i=0;i<n;++i)
			perm[i]=new Integer(i+1);
		zeroPerm = new Permutation(this,perm);
	}

	public Number getZERO() {
		return zeroPerm;
	}

	public Number getInverse(Number a) {
		return ((Permutation) a).getInverse();
	}

	public Number add(Number a, Number b) {
		return ((Permutation) a).add((Permutation) b);
	}

	public Number sub(Number a, Number b) {
		return ((Permutation) a).sub((Permutation) b);
	}

	public boolean equals(Number a, Number b) {
		return ((Permutation) a).equals((Permutation) b);
	}

	public Number valueOf(String s) {
		return Integer.valueOf(s);
	}

	public Number valueOf(Number[] eles) {
		
		Integer perm[] = new Integer[eles.length];
		for(int i=0;i<eles.length;++i)
			perm[i]=new Integer(eles[i].intValue());
		Permutation res = new Permutation(this,perm);
		return res;
	}

	public Number list(Number[] eles) {
		return this.valueOf(eles);
	}

}
/* @author rich
 * Created on 09-Mar-2004
 */
package org.lsmp.djep.groupJep.groups;
import org.lsmp.djep.groupJep.interfaces.*;
import org.lsmp.djep.groupJep.values.*;
import org.nfunk.jep.type.*;

/**
 * An Algebraic Extension of a Ring.
 * The ring generated by {1,t,...,t^n-1} where t is an algebraic number
 * i.e t is be a root of a monic polynomial equation.
 * 
 * @see AlgebraicExtensionElement
 * @author Rich Morris
 * Created on 09-Mar-2004
 */
public class AlgebraicExtension extends ExtendedFreeGroup implements RingI {

	private Polynomial poly;
	private Polynomial poly2;

	/**
	 * Create the ring K(t) where t is a solution of the monic polynomial p.
	 * 
	 * @param K the Ring this is an extension of.
	 * @param poly A monic polynomial whose solution gives an algebraic number which is used to generate this group.
	 * @throws IllegalArgumentException if the base ring of the poly is not the same.
	 * @throws IllegalArgumentException if the polynomial is not monic.
	 */
	public AlgebraicExtension(RingI K, Polynomial poly) {
		super(K,poly.getSymbol());
		this.poly = poly;
		if(baseRing != poly.getBaseRing())
			throw new IllegalArgumentException("The polynomial should be specified over the same base ring");
		// test for monic
		if(!baseRing.equals(
			poly.getCoeffs()[poly.getDegree()],
			baseRing.getONE()))
			throw new IllegalArgumentException("poly "+poly.toString()+" should be monic");
		
		// construct q = t^n - poly (deg n-1)	
		Number coeffs[] = new Number[poly.getDegree()];
		for(int i=0;i<poly.getDegree();++i)
			coeffs[i]= baseRing.getInverse(poly.getCoeffs()[i]);
		poly2 = new Polynomial(baseRing,poly.getSymbol(),coeffs);
		
		if(poly.getDegree()==2)
		{
			double b = poly.getCoeffs()[1].doubleValue();
			double c = poly.getCoeffs()[0].doubleValue();
			double det = b*b-4*c;
			if(det<0)
				rootVal = new Complex(-b/2,Math.sqrt(-det)/2);
			else
				rootVal = new Complex(-b/2+Math.sqrt(det)/2);
		}
		else
		{
			boolean flag = true;
			for(int i=1;i<poly.getDegree();++i)
				if(!baseRing.equals(poly.getCoeffs()[i],baseRing.getZERO()))
				{	flag = false; break;	}
			if(flag)
			{
				double a0 = poly.getCoeffs()[0].doubleValue();
				Complex z = new Complex(-a0);
				rootVal = z.power(1.0/poly.getDegree());
			}
		}

		// construct the zero poly
		zeroPoly = new AlgebraicExtensionElement(this,new Number[]{
					baseRing.getZERO()});
		// construct the unit poly
		unitPoly = new AlgebraicExtensionElement(this,new Number[]{
					baseRing.getONE()});
		// construct the polynomial t
		tPoly = new AlgebraicExtensionElement(this,new Number[]{
					baseRing.getZERO(),
					baseRing.getONE()});
	}
	
	public Number valueOf(Number coeffs[])	{
		return new AlgebraicExtensionElement(this, coeffs);
	}
	
	public String toString()
	{
		return baseRing.toString() + '[' + poly.toString() + ']';
	}
	
	/** Returns the polynomial defining the algebraic number. */
	public Polynomial getPoly() {
		return poly;
	}

	/** Returns the polynomial -a_(n-1) t^(n-1) + ... + a_0.
	 * This polynomial is used in reducing the equation t^n
	 */
	public Polynomial getSubsPoly() {
		return poly2;
	}
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.groups;
import java.math.*;

import org.lsmp.djep.groupJep.interfaces.*;
import org.lsmp.djep.groupJep.values.*;

/**
 * The Field of rational numbers.
 * 
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class Rationals extends Group implements FieldI,OrderedSetI,HasPowerI {

	private Rational ZERO = new Rational(BigInteger.valueOf(0));
	private Rational ONE = new Rational(BigInteger.valueOf(1));

	public Rationals() {}

	public Number getZERO() {
		return ZERO;
	}

	public Number getONE() {
		return ONE;
	}

	public Number getInverse(Number num) {
		return ((Rational) num).negate();
	}

	public Number getMulInverse(Number num) {
		return ((Rational) num).inverse();
	}

	public Number add(Number a, Number b) {
		return ((Rational) a).add((Rational) b);
	}

	public Number sub(Number a, Number b) {
		return ((Rational) a).sub((Rational) b);
	}

	public Number mul(Number a, Number b) {
		return ((Rational) a).mul((Rational) b);
	}

	public Number div(Number a, Number b) {
		return ((Rational) a).div((Rational) b);
	}

	public Number pow(Number a, Number b) {
		return ((Rational) a).pow((Rational) b);
	}

	public boolean equals(Number a,Number b)
	{
		return ((Rational) a).compareTo(b) == 0;
	}
	
	public int compare(Number a,Number b)
	{
		return ((Rational) a).compareTo(b);
	}
	
	public Number valueOf(String s) {
		return Rational.valueOf(s); 
	}
	
	public String toString() { return "Q"; }
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.groups;
import org.lsmp.djep.groupJep.interfaces.*;
import java.math.*;

/**
 * The group of integers mod n.
 * For prime values of n this is a field, with some
 * nice division tables. i.e. for Z5
 * <pre>* | 1 2 3 4
 * ------------
 * 1 | 1 2 3 4
 * 2 | 2 4 1 3
 * 3 | 3 1 4 2
 * 4 | 4 3 2 1
 * </pre>
 * <pre>/ | 1 2 3 4
 * ------------
 * 1 | 1 2 3 4
 * 2 | 3 1 4 2
 * 3 | 2 4 1 3
 * 4 | 4 3 2 1
 * </pre>
 *
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class Zn extends Group implements FieldI,
	OrderedSetI,HasModI,HasPowerI {
	BigInteger modulus;
	/**
	 * Operations on the reals (Implemented as BigInteger).
	 */
	private Zn() {}
	
	public Zn(BigInteger modulus) {
		this.modulus = modulus;
	}

	public Number getZERO() {
		return BigInteger.ZERO;
	}

	public Number getONE() {
		return BigInteger.ONE;
	}

	public Number getInverse(Number num) {
		BigInteger a = (BigInteger) num;
		return a.negate().mod(modulus);
	}

	public Number getMulInverse(Number num) {
		BigInteger a = (BigInteger) num;
		return a.modInverse(modulus);
	}

	public Number add(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.add(b).mod(modulus);
	}

	public Number sub(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.subtract(b).mod(modulus);
	}

	public Number mul(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.multiply(b).mod(modulus);
	}

	public Number div(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.multiply(b.modInverse(modulus)).mod(modulus);
	}
	
	public Number mod(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.mod(b).mod(modulus);
	}
	
	public Number pow(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.modPow(b,modulus);
	}
	public boolean equals(Number a,Number b)	{
		return ((Integer) a).compareTo((Integer) b) == 0;
	}
	
	public int compare(Number a,Number b)	{
		return ((Integer) a).compareTo((Integer) b);
	}


	public Number valueOf(String str) {
		BigInteger in = new BigInteger(str);
		return in.mod(modulus);
	}
	
	public String toString() { return "Integers mod "+this.modulus; }
}
/* @author rich
 * Created on 05-Mar-2004
 */
package org.lsmp.djep.groupJep.groups;
import java.math.*;

import org.lsmp.djep.groupJep.interfaces.*;

/**
 * The group of integers, implemented as a BigInteger.
 * @see java.math.BigInteger
 * @author Rich Morris
 * Created on 05-Mar-2004
 */
public class Integers extends Group implements IntegralDomainI,HasDivI,
	OrderedSetI,HasModI,HasPowerI {
	
	/**
	 * Operations on the reals (Implemented as BigInteger).
	 */
	public Integers() {
	}

	public Number getZERO() {
		return BigInteger.ZERO;
	}

	public Number getONE() {
		return BigInteger.ONE;
	}

	public Number getInverse(Number num) {
		BigInteger a = (BigInteger) num;
		return a.negate();
	}

	public Number add(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.add(b);
	}

	public Number sub(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.subtract(b);
	}

	public Number mul(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.multiply(b);
	}

	public Number div(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.divide(b);
	}
	/* note -3 mod 2 is 1 rather than -1 as for % in java language specifications. */ 
	public Number mod(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.remainder(b);
	}
	
	public Number pow(Number num1, Number num2) {
		BigInteger a = (BigInteger) num1;
		BigInteger b = (BigInteger) num2;
		return a.pow(b.intValue());
	}
	public boolean equals(Number a,Number b)	{
		return ((BigInteger) a).compareTo((BigInteger) b) == 0;
	}
	
	public int compare(Number a,Number b)	{
		return ((BigInteger) a).compareTo((BigInteger) b);
	}

	public Number valueOf(String str) {
		return new BigInteger(str);
	}
	
	public String toString() { return "Z: integers"; }
}
/* @author rich
 * Created on 09-Mar-2004
 */
package org.lsmp.djep.groupJep.groups;
import org.lsmp.djep.groupJep.interfaces.*;
import org.lsmp.djep.groupJep.values.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
import java.util.*;
/**
 * A free group generated by a symbol t.
 * 
 * @author Rich Morris
 * Created on 09-Mar-2004
 */
public class FreeGroup extends Group implements RingI {

	protected RingI baseRing;
	protected FreeGroupElement zeroPoly;
	protected FreeGroupElement unitPoly;
	protected FreeGroupElement tPoly;    // t
	protected String symbol;
	protected Complex rootVal=new Complex(Double.NaN);

	/**
	 * Create the ring K(t) where t is a free variable.
	 * 
	 * @param K the Ring this is an extension of.
	 * @param symbol the name of the free variable.
	 */
	public FreeGroup(RingI K,String symbol) {
		super();
		this.symbol = symbol;
		this.baseRing=K;
		
		// construct the zero poly
		zeroPoly = new FreeGroupElement(this,new Number[]{
				baseRing.getZERO()});
		// construct the unit poly
		unitPoly = new FreeGroupElement(this,new Number[]{
					baseRing.getONE()});
		// construct the polynomial t
		tPoly = new FreeGroupElement(this,new Number[]{
				baseRing.getZERO(),
				baseRing.getONE()});
	}
	
	public Number add(Number a,Number b)
	{
		return ((FreeGroupElement) a).add((FreeGroupElement) b);
	}
	public Number sub(Number a,Number b)
	{
		return ((FreeGroupElement) a).sub((FreeGroupElement) b);
	}
	public Number mul(Number a,Number b)
	{
		return ((FreeGroupElement) a).mul((FreeGroupElement) b);
	}
	public boolean equals(Number a,Number b)
	{
		return ((FreeGroupElement) a).equals((FreeGroupElement) b);
	}

	public Number valueOf(String s)	{
		Number coeffs[] = new Number[]{baseRing.valueOf(s)};
		return valueOf(coeffs);
	}

	public Number valueOf(Number coeffs[])	{
		return new FreeGroupElement(this, coeffs);
	}

	public Number getZERO() { return zeroPoly; }
	public Number getONE() { return unitPoly; }
	public Number getTPoly() { return tPoly; }
	public Number getInverse(Number a)	{
		return sub(zeroPoly,a);
	}

	public void addStandardConstants(JEP j)
	{
		baseRing.addStandardConstants(j);
		SymbolTable st = j.getSymbolTable();
		for(Enumeration en=st.elements();en.hasMoreElements();)
		{
			Variable val = (Variable) en.nextElement();
			st.remove(val.getName());
			Number num = (Number) val.getValue();
			Number p = this.valueOf(new Number[]{
					num});
			j.addConstant(val.getName(),p);
		}
		j.addConstant(symbol,tPoly);
	}
	
	public String toString()
	{
		return baseRing.toString() +"["+symbol+"]";
	}
	
	/** Returns the base ring of this extension. */
	public RingI getBaseRing() {
		return baseRing;
	}


	/** Sets the value used to approximate the root as a complex number. */
	public void setRootVal(Complex complex) {
		rootVal = complex;
	}

	/** Sets the root value for given symbol.
	 * 
	 * @param sym the symbol to set
	 * @param val the complex value
	 * @return true is sym is a symbol for either this group or its baseRing or the basrRing's baseRing etc.
	 */
	public boolean setRootVal(String sym,Complex val) {
		if(symbol.equals(sym))
		{
			rootVal = val;
			return true;
		}
		else if(baseRing instanceof FreeGroup)
			return ((FreeGroup) baseRing).setRootVal(sym,val);
		return false;
	}

	/** Returns an approximation to the value of the root as a complex number. */
	public Complex getRootVal() {
		return rootVal;
	}

	/** Returns the symbol used to denote the generator. */
	public String getSymbol() {
		return symbol;
	}

	/** Whether the given polynomial is constant. */
	public boolean isConstantPoly(Number poly) {
		return ((FreeGroupElement) poly).isConstantPoly();
	}

}
/* @author rich
 * Created on 06-Mar-2004
 */
package org.lsmp.djep.groupJep.groups;
import org.lsmp.djep.groupJep.*;
import org.nfunk.jep.type.*;
import org.nfunk.jep.*;
/**
 * Base abstract class for all groups.
 * 
 * @author Rich Morris
 * Created on 06-Mar-2004
 */
public abstract class Group implements GroupI {
	/**
	* Creates a default NumberFactory which calls
	* the {@link org.lsmp.djep.groupJep.GroupI#valueOf} method of the subclass
	* to create strings from numbers.
	*/
	private NumberFactory NumFac = new NumberFactory()	{
		public Object createNumber(String s) {
			return valueOf(s);
		}
		/** Return an object representing ZERO the additive identity. */
		public Object getZero() { return getZERO() ; }
        public Object createNumber(double value) throws ParseException {
            // TODO Auto-generated method stub
            return null;
        }
        public Object createNumber(int value) throws ParseException {
            // TODO Auto-generated method stub
            return null;
        }
        public Object createNumber(short value) throws ParseException {
            // TODO Auto-generated method stub
            return null;
        }
        public Object createNumber(float value) throws ParseException {
            // TODO Auto-generated method stub
            return null;
        }
        public Object createNumber(boolean value) throws ParseException {
            // TODO Auto-generated method stub
            return null;
        }
        public Object createNumber(Number value) throws ParseException {
            // TODO Auto-generated method stub
            return null;
        }
        public Object createNumber(Complex value) throws ParseException {
            // TODO Auto-generated method stub
            return null;
        }
        public Object getOne() {
            // TODO Auto-generated method stub
            return null;
        }
        public Object getMinusOne() {
            // TODO Auto-generated method stub
            return null;
        }
        public Object getTwo() {
            // TODO Auto-generated method stub
            return null;
        }
	};

	/** returns a number factory for creating group elements from strings */
	public NumberFactory getNumberFactory() { return NumFac; }

	/** adds the standard constants for this group.
	 * By default does nothing. */
	public void addStandardConstants(JEP j) {}
	
	/** adds the standard function for this group 
	* By default does nothing. */
	public void addStandardFunctions(JEP j) {}
	
	public String toString()
	{
		return "general group";
	}
	
	
	/** Default implementation.
	 * Returns true.
	 */
	public boolean isConstantPoly(Number a) {
		return true;
	}

}
/* @author rich
 * Created on 16-Dec-2004
 */
package org.lsmp.djep.sjep;
import org.lsmp.djep.xjep.*;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommandI;

/**
 * Represents an operator.
 * 
 * @author Rich Morris
 * Created on 16-Dec-2004
 */
public class POperator extends AbstractPNode {
	XOperator op;
	PNodeI args[];
	public POperator(PolynomialCreator pc,XOperator op,PNodeI[] args) {
		super(pc);
		this.op = op;
		this.args = args;
	}
	
	public boolean equals(PNodeI node)
	{
		if(!(node instanceof POperator)) return false;
		POperator nodeOp = (POperator) node;
		if(!this.op.equals(nodeOp)) return false;
		if(args.length != nodeOp.args.length)
			return false;
		for(int i=0;i<args.length;++i)
			if(!args[i].equals(nodeOp.args[i])) return false;
		return true;
	}

	/**
	this < arg ---> -1
	this > arg ---> 1
	*/
	public int compareTo(POperator fun)
	{
		int res = op.getName().compareTo(op.getName());
		if(res != 0) return res;
		
		if(args.length < fun.args.length) return -1;
		if(args.length > fun.args.length) return 1;
		
		for(int i=0;i<args.length;++i)
		{
			res = args[i].compareTo(fun.args[i]);
			if(res != 0) return res;
		}
		return 0;
	}


	public String toString()
	{
		if(args.length == 1)
		{
			if(op.isPrefix())
			return  "("+op.getSymbol() + args[0].toString()+")"; 
		}
		if(args.length == 2)
		{
			return "(("+args[0].toString()+")"+op.getSymbol()+"("+args[1].toString()+"))";
		}
		//TODO
		return super.toString();
	}
	
	public Node toNode() throws ParseException
	{
		Node funargs[] = new Node[args.length];
		for(int i=0;i<args.length;++i)
			funargs[i] = args[i].toNode();
		Node fun = pc.nf.buildOperatorNode(op,funargs);
		return fun;
	}

	public PNodeI expand() throws ParseException	{ 
		PNodeI newTerms[] = new PNodeI[args.length];
		for(int i=0;i<args.length;++i)
			newTerms[i] = args[i].expand();
		return new POperator(pc,op,newTerms);		
	}
	
	/**
	 * @return Returns the name of the operator.
	 */
	public String getName() {
		return op.getName();
	}

	/**
	 * @return Returns the PostfixMathCommandI for the operator.
	 */
	public PostfixMathCommandI getPfmc() {
		return op.getPFMC();
	}
	/**
	 * @return the number of arguments
	 */
	public int getNArgs() { return args.length; }
	/**
	 * @param i
	 * @return returns the i-th argument
	 */
	public PNodeI getArg(int i) { return args[i]; }

	/**
	 * @return Returns the operator.
	 */
	public XOperator getOp() {
		return op;
	}

}
/* @author rich
 * Created on 17-Dec-2004
 */
package org.lsmp.djep.sjep;
import org.nfunk.jep.*;
/**
 * An element in a polynomial representation of an expression.
 * Provides the main routines for creating, comparing and manipulating polynomials.
 * 
 * @author Rich Morris
 * Created on 17-Dec-2004
 */
public interface PNodeI {
	/** Adds a node to this one. **/
	public PNodeI add(PNodeI node)  throws ParseException;
	/** Subtracts the argument from this. **/
	public PNodeI sub(PNodeI node)  throws ParseException;
	/** negates node i.e. -x */
	public PNodeI negate() throws ParseException;
	/** Multiplies this by the argument. **/
	public PNodeI mul(PNodeI node) throws ParseException;
	/** Divides this by the argument. **/
	public PNodeI div(PNodeI node) throws ParseException;
	/** Raise this to the argument. **/
	public PNodeI pow(PNodeI node)  throws ParseException;
	/** inverts node i.e. 1/x */
	public PNodeI invert() throws ParseException;
	/** True is nodes represent the same parse trees */
	public boolean equals(PNodeI node);
	/** True is nodes represent the same parse trees */
	public boolean equals(Object o);
	/** Compares this expression to argument. Uses a total ordering of expressions. Returns positive if this node comes after the argument. */
	public int compareTo(PNodeI fun);
	/** Converts the node to standard JEP format. */
	public Node toNode() throws ParseException;
	/** Produces a string representation of the argument. */
	public String toString();
	/** True if node represents zero */
	public boolean isZero();
	/** True if node represents one */
	public boolean isOne();
	/** complete expansion. (1+x)^2 --> 1+2*x+x^2 */
	public PNodeI expand() throws ParseException; 
}
/* @author rich
 * Created on 14-Dec-2004
 */
package org.lsmp.djep.sjep;

import org.lsmp.djep.xjep.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
import org.nfunk.jep.function.*;
/**
 * Main entry point for simplification routines.
 *
 *<p>
Uses a complete reworking of the ways equations are represented.
A tree structure is built from Polynomials, Monomials, PVariable etc.
An equation like 
<pre>1+2 x^2+3 x y+4 x sin(y)</pre>
is represented as
<pre>
Polynomial([
  Monomial(2.0,[PVariable(x)],[2])]),
  Monomial(3.0,[x,y],[1,1]),
  Monomial(4.0,[x,Function(sin,arg)],[1,1])
])
</pre>
</p>

<p>
A total ordering of all expressions is used. 
As the representation is constructed the total ordering of terms is maintained. 
This helps ensure that polynomials are always in their simplest form
and also allows comparison of equations.
</p>
<p>   
The following sequence illustrates current ordering. 
This ordering may change without warning.
<ul>
<li>-1 numbers sorted by values
<li>0
<li>1 numbers before monomials
<li>a^-2 powers in increasing order
<li>a^-1
<li>a
<li>a^2
<li>a^3
<li>a^x numeric powers before symbolic powers
<li>a b single variable monomials before multiple variables
<li>a^2 b
<li>b variables sorted alphabetically
<li>cos(a) monomials before functions
<li>sin(a) function names sorted alphabetically
<li>a+b functions before polynomials
<li>a+b+c
<li>
</ul>
 * @author Rich Morris
 * Created on 14-Dec-2004
 */
public class PolynomialCreator extends DoNothingVisitor {
	private XJep jep;
	Object zero,one,minusOne,infinity,nan,two;
	PConstant zeroConstant,oneConstant,minusOneConstant,infConstant,nanConstant,twoConstant;
	Monomial zeroMonomial,unitMonomial,infMonomial,nanMonomial;
	Polynomial zeroPolynomial,unitPolynomial,infPolynomial,nanPolynomial;
	NumberFactory numf;
	OperatorSet os;
	NodeFactory nf;
	//boolean expand=false;
	private PolynomialCreator() {}
	public PolynomialCreator(XJep j)
	{
		jep = j;
		numf = j.getNumberFactory();
		os = j.getOperatorSet();
		nf = j.getNodeFactory();
		
		zero = j.getNumberFactory().getZero();
		one = j.getNumberFactory().getOne();
		minusOne = j.getNumberFactory().getMinusOne();
		two = j.getNumberFactory().getTwo();
		try {
			infinity = div(one,zero);
			nan = div(zero,zero);
		} catch(ParseException e) {
			infinity = new Double(Double.POSITIVE_INFINITY);
			nan = new Double(Double.NaN);
		}
			
		zeroConstant = new PConstant(this,zero);
		oneConstant = new PConstant(this,one);
		twoConstant = new PConstant(this,two);
		minusOneConstant = new PConstant(this,minusOne);
		infConstant = new PConstant(this,infinity);
		nanConstant = new PConstant(this,nan);
	}

	/**
	 * Converts an expression into the polynomial representation. 
	 * @param node top node of expression
	 * @return top node of polynomial form of expression
	 * @throws ParseException if expression cannot be converted.
	 */
	public PNodeI createPoly(Node node) throws ParseException
	{
		return (PNodeI) node.jjtAccept(this,null);
	}

	/**
	 * Simplifies an expression.
	 * 
	 * @param node top node to expression to be simplified.
	 * @return a simplified expression
	 * @throws ParseException
	 */
	public Node simplify(Node node) throws ParseException
	{
		PNodeI poly = createPoly(node);
		return poly.toNode();
	}
	/**
	 * Expands an expression.
	 * Will always expand brackets for multiplication and simple powers.  
	 * For instance
	 * <code>(1+x)^3 -> 1+3x+3x^2+x^3</code>
	 * 
	 * @param node top node to expression to be simplified.
	 * @return a simplified expression
	 * @throws ParseException
	 */

	public Node expand(Node node) throws ParseException
	{
		PNodeI poly = createPoly(node);
		PNodeI expand = poly.expand();
		return expand.toNode();
	}

	/**
	 * Compares two nodes.
	 * Uses a total ordering of expressions.
	 * Expands equations before comparison.
	 * 
	 * @param node1
	 * @param node2
	 * @return -1 if node1<node2, 0 if node1==node2, +1 if node1>node2
	 * @throws ParseException
	 */
	public int compare(Node node1,Node node2) throws ParseException
	{
		PNodeI poly1 = createPoly(node1);
		PNodeI exp1 = poly1.expand();
		PNodeI poly2 = createPoly(node2);
		PNodeI exp2 = poly2.expand();
		return exp1.compareTo(exp2);
	}

	/**
	 * Compares two nodes.
	 * Uses a total ordering of expressions.
	 * May give some false negatives is simplification cannot reduce
	 * two equal expressions to the same canonical form.
	 * Expands equations before comparison.
	 * 
	 * @param node1
	 * @param node2
	 * @return true if two nodes represents same expression.
	 * @throws ParseException
	 */
	public boolean equals(Node node1,Node node2) throws ParseException
	{
		PNodeI poly1 = createPoly(node1);
		PNodeI exp1 = poly1.expand();
		PNodeI poly2 = createPoly(node2);
		PNodeI exp2 = poly2.expand();
		return exp1.equals(exp2);
	}

	public Object visit(ASTConstant node, Object data) throws ParseException {

		return new PConstant(this,node.getValue());
	}

	public Object visit(ASTVarNode node, Object data) throws ParseException {
		return new PVariable(this,(XVariable) node.getVar());
	}

	public Object visit(ASTFunNode node, Object data) throws ParseException {
		int nChild = node.jjtGetNumChildren();
		PNodeI args[] = new PNodeI[nChild];
		for(int i=0;i<nChild;++i) {
			args[i] = (PNodeI) node.jjtGetChild(i).jjtAccept(this,data);
		}

/*		jep.println(node);
		for(int i=0;i<nChild;++i)
			System.out.println("\t"+args[i].toString());
*/		
		XOperator op = (XOperator) node.getOperator();
		if(op == os.getAdd())
		{
			PNodeI res = args[0];
			for(int i=1;i<nChild;++i)
				res = res.add(args[i]);
			return res;
		}
		else if(op == os.getSubtract())
		{
			if(args.length!=2) throw new ParseException("Subtract must have two args it has "+args.length);
			return args[0].sub(args[1]);
		}
		else if(op == os.getUMinus())
		{
			PNodeI res = args[0];
			return res.negate();
		}
		else if(op == os.getMultiply())
		{
			PNodeI res = args[0];
			for(int i=1;i<nChild;++i)
				res = res.mul(args[i]);
			return res;
		}
		else if(op == os.getDivide())
		{
			if(args.length!=2) throw new ParseException("Divide must have two args it has "+args.length);
			return args[0].div(args[1]);
		}
		else if(op == os.getPower())
		{
			if(args.length!=2) throw new ParseException("Power must have two args it has "+args.length);
			return args[0].pow(args[1]);
		}
		
		boolean allConst = true;
		for(int i=0;i<args.length;++i)
			if(!(args[i] instanceof PConstant)) { allConst = false; break; }

		if(allConst)
		{
			Node newNodes[] = new Node[args.length];
			for(int i=0;i<args.length;++i)
				newNodes[i] = args[i].toNode();
			Node topNode;
			if(op != null)
				topNode = nf.buildOperatorNode(op,newNodes);
			else
				topNode = nf.buildFunctionNode(node.getName(),node.getPFMC(),newNodes);
			
			Object val;
			try	{
				val = jep.evaluate(topNode);
			} catch(Exception e) {
				throw new ParseException(e.getMessage());
			}
			return new PConstant(this,val);
		}
		
		if(op != null)
			return new POperator(this,op,args);
		return new PFunction(this,node.getName(),node.getPFMC(),args);
		
		//throw new ParseException("Polynomial: Sorry don't know how to convert "+node.getName());
	}

	Object add(Object a,Object b) throws ParseException {
		return ((Add) os.getAdd().getPFMC()).add(a,b);
	}
	
	Object sub(Object a,Object b) throws ParseException {
		return ((Subtract) os.getSubtract().getPFMC()).sub(a,b);
	}


	Object mul(Object a,Object b) throws ParseException {
		return ((Multiply) os.getMultiply().getPFMC()).mul(a,b);
	}
	
	Object div(Object a,Object b) throws ParseException {
		return ((Divide) os.getDivide().getPFMC()).div(a,b);
	}

	Object intToValue(int i)
	{
		return new Double(i);	
	}
	Object raise(Object a,Object b) throws ParseException 
	{
		return 
		((Power) os.getPower().getPFMC()).power(a,b);
	}

	Object neg(Object val) throws ParseException {	
		return ((UMinus) os.getUMinus().getPFMC()).umin(val);
	}

	int cmp(Object a,Object b) throws ParseException {
		if(a.equals(b)) return 0;
		
		if(a instanceof Complex)
		{
			Complex ca = (Complex) a;
			double ax = ca.re(), ay = ca.im();
			if(b instanceof Complex)
			{
				Complex cb = (Complex) b;
				double bx = cb.re(), by = cb.im();
				if(ax == bx)
				{
					if(ay==by) return 0;
					else if(ay<by) return -1;
					else return 0;
				}
				else if(ax < bx) return -1;
				else return 1;
			}
			else if(b instanceof Number)
			{
				double bx = ((Number) b).doubleValue(), by = 0.0;
				if(ax == bx)
				{
					if(ay==by) return 0;
					else if(ay<by) return -1;
					else return 0;
				}
				else if(ax < bx) return -1;
				else return 1;
			}
			throw new ParseException("Don't know how to compare a Complex with "+b+" ("+b.getClass().getName()+")");
		}
		else if(a instanceof Number)
		{
			if(b instanceof Complex)
			{
				double ax = ((Number) a).doubleValue(), ay = 0.0;
				Complex cb = (Complex) b;
				double bx = cb.re(), by = cb.im();
				if(ax == bx)
				{
					if(ay==by) return 0;
					else if(ay<by) return -1;
					else return 0;
				}
				else if(ax < bx) return -1;
				else return 1;
			}
		}
		if(a instanceof Comparable && a.getClass().equals(b.getClass()))
			return ((Comparable) a).compareTo(b);
			
		if((a instanceof Number) && (b instanceof Number))
		{
			double ax = ((Number) a).doubleValue();
			double bx = ((Number) b).doubleValue();

			if(ax == bx) return 0;
			else if(ax < bx) return -1;
			else return 1;
		}
		
		if(a instanceof Comparable)
			return ((Comparable) a).compareTo(b);
		
		throw new IllegalArgumentException("Sorry don't know how to compare "+a+" ("+a.getClass().getName()+") and "+b+" ("+b.getClass().getName()+")");	
	}
}
/* @author rich
 * Created on 23-Dec-2004
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.sjep;
import org.nfunk.jep.*;
/**
 * A mutable polynomial representing a + b + c.
 * There are no requirements that this is in a reduced form
 * so some powers can be zero.
 * 
 * @author Rich Morris
 * Created on 23-Dec-2004
 */
public class MutiablePolynomial
{
	PolynomialCreator pc;
	PNodeI terms[];
	/**
	 * Note arrays parsed may be modified.
	 */
	public MutiablePolynomial(PolynomialCreator pc,PNodeI nodes[])
	{
		this.pc = pc;
		terms = nodes;
	}

	public void add(PNodeI term) throws ParseException
	{
		if(term instanceof PConstant)
			for(int i=0;i<terms.length;++i)
				if(terms[i] instanceof PConstant) {
					terms[i] = terms[i].add(term);
					return;
				}				

		if(term instanceof Polynomial)
		{
			Polynomial p = (Polynomial) term;
			for(int i=0;i<p.terms.length;++i)
				add(p.terms[i]);
			return;
		}
		for(int i=0;i<terms.length;++i) {
			if(terms[i] instanceof Monomial) {
				if(((Monomial) terms[i]).equalsIgnoreConstant(term)){
					terms[i] = terms[i].add(term);
					return;		
				}
			}
			else if(terms[i].equals(term)) {
				terms[i] = terms[i].add(term);
				return;
			}
		}
		// insert in correct posn
		PNodeI newTerms[] = new PNodeI[terms.length+1]; 
		int pos=0; boolean done = false;
		for(int i=0;i<terms.length;++i) {
			if(!done && terms[i].compareTo(term) > 0) {
		 		newTerms[pos] = term;
		 		++pos;
		 		done = true;
			}
			newTerms[pos] = terms[i];
			++pos;
		}
		if(!done)
		{
			newTerms[pos] = term;
			++pos;
		}
		terms = newTerms;
	}

	/**
	 * Multiplies this by a polynomial and expands the results.
	 * (1+x)*(1+x) --> 1+2*x+x^2
	 * @param p the polynomial to multiply by
	 * @throws ParseException
	 */
	void expandMul(Polynomial p) throws ParseException
	{
		PNodeI newTerms[][] = new PNodeI[terms.length][p.terms.length];
		for(int i=0;i<terms.length;++i)
			for(int j=0;j<p.terms.length;++j)
				newTerms[i][j] = terms[i].mul(p.terms[j]);
		int oldLen = terms.length;
		terms = new PNodeI[0];
		for(int i=0;i<oldLen;++i)
			for(int j=0;j<p.terms.length;++j)
				add(newTerms[i][j]);		
	}
	/**
	 * Multiplies this by a node and expands the results.
	 * (1+x)*(1+x) --> 1+2*x+x^2
	 * @param node
	 * @throws ParseException
	 */
	void expandMul(PNodeI node) throws ParseException
	{	
		if(node instanceof Polynomial)	{
			expandMul((Polynomial) node);
			return;
		}
		PNodeI newTerms[] = new PNodeI[terms.length];
		for(int i=0;i<terms.length;++i)
			newTerms[i] = terms[i].mul(node);
		terms = new PNodeI[0];
		for(int i=0;i<newTerms.length;++i)
			add(newTerms[i]);
	}
	/** removes terms like x^0, 1^x, 2^3 */
	private void reduce() throws ParseException
	{
		int numZeros=0;
		int numConst=0;
		PConstant c = pc.zeroConstant;
		for(int i=0;i<terms.length;++i)
		{
			if(terms[i].isZero()) ++numZeros;
			else if(terms[i] instanceof PConstant)
			{
				++numConst;
				c = (PConstant) c.add(terms[i]);
			}
		}
		if(numZeros == 0 && numConst == 0 )
			return;
		int newLen = terms.length-numZeros-numConst;
		if(!c.isZero()) ++newLen;
		PNodeI newTerms[] = new PNodeI[newLen];
		int pos=0;
		if(!c.isZero())
			newTerms[pos++] = c;
		
		for(int i=0;i<terms.length;++i)
		{
			if(terms[i].isZero()) {} // 1^x --> 1
			else if(terms[i] instanceof PConstant) {}
			else {
				newTerms[pos] = terms[i];
				++pos;
			}
		}
		terms = newTerms;
	}
	
	PNodeI toPNode() throws ParseException
	{
		reduce();
		if(terms.length ==0) return pc.zeroConstant;
		if(terms.length == 1) return terms[0];
		return new Polynomial(pc,terms);
	}
	
	public String toString() {
		StringBuffer sb = new StringBuffer();
		for(int i=0;i<terms.length;++i){
			if(i>0) sb.append('+');
			sb.append(terms[i].toString());
		}
		return sb.toString();
	}
}
/* @author rich
 * Created on 14-Dec-2004
 */
package org.lsmp.djep.sjep;
import org.nfunk.jep.*;
/**
 * Represents a polynomial.
 * i.e. a sum of terms which are typically 
 * {@link Monomial}s, but can be any {@link AbstractPNode}. The order of the terms is specified by the total ordering.
 * 
 * @author Rich Morris
 * Created on 14-Dec-2004
 */
public class Polynomial extends AbstractPNode {

	PNodeI terms[];

	/**
	 * 
	 */
	Polynomial(PolynomialCreator pc,PNodeI terms[]) {
		super(pc);
		this.terms = terms;
	}

	MutiablePolynomial toMutiablePolynomial()
	{
		PNodeI newTerms[] = new PNodeI[terms.length];
		for(int i=0;i<terms.length;++i)
			newTerms[i] = terms[i];
		return new MutiablePolynomial(pc,newTerms);
	}
	
	public PNodeI add(PNodeI node) throws ParseException
	{
		if(node instanceof Polynomial)
			return this.add((Polynomial) node);
			
		MutiablePolynomial mp = this.toMutiablePolynomial();
		mp.add(node);
		return mp.toPNode();
	}
	
	public PNodeI sub(PNodeI node) throws ParseException
	{
		if(node instanceof Polynomial)
			return this.sub((Polynomial) node);
			
		MutiablePolynomial mp = this.toMutiablePolynomial();
		mp.add(node.negate());
		return mp.toPNode();
	}

	public PNodeI add(Polynomial p) throws ParseException
	{
		MutiablePolynomial mp = this.toMutiablePolynomial();
		for(int i=0;i<p.terms.length;++i)
			mp.add(p.terms[i]);
		return mp.toPNode();
	}

	public PNodeI sub(Polynomial p) throws ParseException
	{
		MutiablePolynomial mp = this.toMutiablePolynomial();
		for(int i=0;i<p.terms.length;++i)
			mp.add(p.terms[i].negate());
		return mp.toPNode();
	}

	public PNodeI negate() throws ParseException
	{
		PNodeI newTerms[] = new PNodeI[terms.length];
		for(int i=0;i<terms.length;++i)
			newTerms[i] = terms[i].negate();
		return new Polynomial(pc,newTerms);				
	}
	
	public PNodeI mul(PNodeI node)  throws ParseException
	{
		if(node instanceof PConstant)
		{
			PConstant c = (PConstant) node;
			if(c.isZero()) return pc.zeroConstant;
			if(c.isOne()) return this;
			//if(c.isInfinity()) return pc.infConstant;
			
//			PNodeI newTerms[] = new PNodeI[terms.length];
//			for(int i=0;i<terms.length;++i)
//				newTerms[i] = terms[i].mul(c);
//			return new Polynomial(pc,newTerms);				
		}
		return super.mul(node);
	}
	
	public PNodeI div(PNodeI node)  throws ParseException
	{
		if(node instanceof PConstant)
		{
			PConstant c = (PConstant) node;
			if(c.isZero()) return pc.infConstant;
			if(c.isOne()) return this;
			PNodeI newTerms[] = new PNodeI[terms.length];
			for(int i=0;i<terms.length;++i)
				newTerms[i] = terms[i].div(c);
			return new Polynomial(pc,newTerms);				
		}
		return super.div(node);
	}
	
	public boolean equals(PNodeI node)
	{
		if(!(node instanceof Polynomial)) return false;
		Polynomial p = (Polynomial) node;
		if(terms.length != (p.terms.length)) return false;
		for(int i=0;i<terms.length;++i)
			if(!terms[i].equals(p.terms[i])) return false;
		return true; 
	}
	/**
	this < arg ---> -1
	this > arg ---> 1
	*/

	public int compareTo(PNodeI node)
	{
		if(node instanceof Polynomial)
			return this.compareTo((Polynomial) node);
		int res = terms[0].compareTo(node);
		if(res != 0) return res;
		if(terms.length == 1) return 0;
		return 1;
	}

	public int compareTo(Polynomial p)
	{
		for(int i=0;i<terms.length;++i)
		{
			if(i >= p.terms.length) return 1;
			int res = terms[i].compareTo(p.terms[i]);
			if(res != 0) return res;
		}
		if(terms.length < p.terms.length) return -1;
		return 0;
	}
	
	private boolean isNegative(PNodeI node)
	{
		if(node instanceof PConstant)
			return ((PConstant) node).isNegative();
		if(node instanceof Monomial)
			return ((Monomial) node).negativeCoefficient();
		return false;
	}
	public String toString() {
		if(terms.length==0)
			return "0";
		StringBuffer sb = new StringBuffer();
		for(int i=0;i<terms.length;++i)
		{
			if(i>0 && !isNegative(terms[i])) 
				sb.append('+');
			sb.append(terms[i].toString());
		}
		return sb.toString();
	}
	
	public Node toNode() throws ParseException {
		if(terms.length==0)
			return pc.nf.buildConstantNode(pc.zero);
		Node args[] = new Node[terms.length];
		for(int i=0;i<terms.length;++i)
			args[i] = terms[i].toNode();
		if(terms.length ==1) return args[0];
		return pc.nf.buildOperatorNode(pc.os.getAdd(),args);	
	}
	
	public PNodeI expand() throws ParseException {
		MutiablePolynomial mp = new MutiablePolynomial(pc,new PNodeI[]{pc.zeroConstant});
		for(int i=0;i<terms.length;++i)
		{
			PNodeI exp = terms[i].expand();
			mp.add(exp);
		}
		 return mp.toPNode();
	}
	
	/**
	 * The number of terms which make up the polynomial.
	 * @return the number of terms
	 */
	public int getNTerms() { return terms.length; }
	/**
	 * Get the n-th term
	 * @param i index of terms
	 * @return PNodeI for that term.
	 */
	public PNodeI getTerm(int i) { return terms[i]; }
}
/* @author rich
 * Created on 14-Dec-2004
 */
package org.lsmp.djep.sjep;
import org.lsmp.djep.xjep.*;
import org.nfunk.jep.*;
/**
 * Represents a variable.
 * 
 * @author Rich Morris
 * Created on 14-Dec-2004
 */
public class PVariable extends AbstractPNode {

	XVariable variable;
	/**
	 * 
	 */
	public PVariable(PolynomialCreator pc,XVariable var) {
		super(pc);
		this.variable = var;
	}

	public boolean equals(PNodeI node)
	{
		if(node instanceof PVariable)
			if(variable.equals(((PVariable)node).variable))
				return true;	

		return false;
	}

	/**
	this < arg ---> -1
	this > arg ---> 1
	*/
	public int compareTo(PVariable vf)
	{
			return variable.getName().compareTo(vf.variable.getName());
	}
	
	public String toString()
	{
		return variable.getName();
	}
	
	public Node toNode() throws ParseException
	{
		return pc.nf.buildVariableNode(variable);
	}
	
	public PNodeI expand()	{ return this;	}

	/**
	 * @return Returns the variable.
	 */
	public XVariable getVariable() {
		return variable;
	}
	/**
	 * @return Returns the name of the variable
	 */
	public String getName()
	{
		return variable.getName();
	}

}
/* @author rich
 * Created on 14-Dec-2004
 */
package org.lsmp.djep.sjep;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
/**
 * Represents a constant.
 * 
 * @author Rich Morris
 * Created on 14-Dec-2004
 */
public class PConstant extends AbstractPNode {

	Object value;
	
	/**
	 * 
	 */
	public PConstant(PolynomialCreator pc,Object o) {
		super(pc);
		value = o;
	}

	public PNodeI negate() throws ParseException
	{
		return new PConstant(pc,pc.neg(value));
	}
	public PNodeI add(PNodeI c) throws ParseException {
		if(this.isZero()) return c;
		if(c instanceof PConstant)
			return new PConstant(pc,pc.add(value,((PConstant) c).value));
		
		return super.add(c);
	}
	
	public PNodeI sub(PNodeI c) throws ParseException {
		if(this.isZero()) return c.negate();
		if(c instanceof PConstant)
			return new PConstant(pc,pc.sub(value,((PConstant) c).value));
		return super.sub(c);
	}

	public PNodeI mul(PNodeI c) throws ParseException {
		if(this.isZero()) return pc.zeroConstant;
		if(this.isOne()) return c;
		if(c.isZero()) return pc.zeroConstant;
		if(c.isOne()) return this;
		
		if(c instanceof PConstant)
			return new PConstant(pc,pc.mul(value,((PConstant) c).value));

		return super.mul(c);
	}

	public PNodeI div(PNodeI c) throws ParseException {
		if(this.isZero()) {
			if(c.isZero())
				return pc.nanConstant;
			return pc.zeroConstant; 
		}
		if(c.isZero()) return pc.infConstant;
		if(c.isOne()) return this;
		
		if(c instanceof PConstant)
			return new PConstant(pc,pc.div(value,((PConstant) c).value));
		
		return super.div(c);
	}

	public PNodeI invert() throws ParseException
	{
		return new PConstant(pc,pc.div(pc.one,value));
	}

	public PNodeI pow(PNodeI c) throws ParseException {
		if(this.isZero()){
			if(c.isZero()) return pc.nanConstant;
			return pc.zeroConstant;
		}
		if(this.isOne()) return pc.oneConstant;
		if(c.isZero()) return pc.oneConstant;
		 
		if(c instanceof PConstant)
			return new PConstant(pc,pc.raise(value,((PConstant) c).value));
	
		return super.pow(c);
	}
	
	public String toString()
	{
		if(isZero()) return "0";
		if(isOne()) return "1";
		if(isInfinity()) return "inf";
		if(isNan()) return "NaN";
		
		if(isInteger())
				return String.valueOf(intValue()); 
		return value.toString(); 
	}
	
	public boolean isZero() {return value.equals(pc.zero);}
	public boolean isOne() {return value.equals(pc.one);}
	public boolean isMinusOne() {return value.equals(pc.minusOne);}
	public boolean isInfinity() {
		if(value.equals(pc.infinity)) return true;
		if(value instanceof Double)
			return ((Double) value).isInfinite();
		if(value instanceof Complex)
			return ((Complex) value).isInfinite();
		return false;
	}
	public boolean isNan() {
		if(value.equals(pc.nan)) return true;
		if(value instanceof Double)
			return ((Double) value).isNaN();
		if(value instanceof Complex)
			return ((Complex) value).isNaN();
		return false;
	}
	public boolean isPositive() {
		try	{
			return ((Double) value).compareTo((Double) pc.zero) > 0;
		} catch(Exception e) { return false; }
	}
	public boolean isNegative() {
		try	{
			return ((Double) value).compareTo((Double) pc.zero) < 0;
		} catch(Exception e) { return false; }
	}
	public boolean isInteger() {
		try	{
			double val = ((Double) value).doubleValue();
			return val == Math.floor(val);
		} catch(Exception e) { return false; }
	}
	public int intValue() {
		return ((Number) value).intValue();
	}
	
	public Node toNode() throws ParseException
	{
		return pc.nf.buildConstantNode(value);
	}

	public int compareTo(PConstant c)
	{
			return ((Comparable) value).compareTo(c.value);
	}


	public boolean equals(PNodeI node)
	{
		if(node instanceof PConstant)
			return value.equals(((PConstant)node).value);
		return false;
	}

	public PNodeI expand()	{ return this;	}

	/**
	 * @return Returns the value.
	 */
	public Object getValue() {
		return value;
	}
}
/* @author rich
 * Created on 15-Dec-2004
 */
package org.lsmp.djep.sjep;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import org.lsmp.djep.xjep.*;
/**
 * Represents a function.
 * 
 * @author Rich Morris
 * Created on 15-Dec-2004
 */
public class PFunction extends AbstractPNode {
	
	String name;
	PostfixMathCommandI pfmc;
	//XOperator op=null;
	PNodeI args[];
	/**
	 * 
	 */
	public PFunction(PolynomialCreator pc,String name,PostfixMathCommandI pfmc,PNodeI args[]) {
		super(pc);
		this.name = name;
		this.pfmc = pfmc;
		this.args = args;
	}

	public boolean equals(PNodeI node)
	{
		if(!(node instanceof PFunction)) return false;
		PFunction fun = (PFunction) node;
		if(!name.equals(fun.name)) return false;
		if(args.length != fun.args.length)
			return false;
		for(int i=0;i<args.length;++i)
			if(!args[i].equals(fun.args[i])) return false;
		return true;
	}
	/**
	this < arg ---> -1
	this > arg ---> 1
	*/
	public int compareTo(PFunction fun)
	{
		int res = name.compareTo(fun.name);
		if(res != 0) return res;
		
		if(args.length < fun.args.length) return -1;
		if(args.length > fun.args.length) return 1;
		
		for(int i=0;i<args.length;++i)
		{
			res = args[i].compareTo(fun.args[i]);
			if(res != 0) return res;
		}
		return 0;
	}

	public String toString()
	{
		StringBuffer sb = new StringBuffer();
		sb.append(name);
		sb.append('(');
		for(int i=0;i<args.length;++i)
		{
			if(i>0) sb.append(',');
			sb.append(args[i].toString());
		}
		sb.append(')');
		return sb.toString();
	}
	
	public Node toNode() throws ParseException
	{
		Node funargs[] = new Node[args.length];
		for(int i=0;i<args.length;++i)
			funargs[i] = args[i].toNode();
		Node fun = pc.nf.buildFunctionNode(name,pfmc,funargs);
		return fun;
	}
	
	public PNodeI expand() throws ParseException	{ 
		PNodeI newTerms[] = new PNodeI[args.length];
		for(int i=0;i<args.length;++i)
			newTerms[i] = args[i].expand();
		return new PFunction(pc,name,pfmc,newTerms);		
	}

	/**
	 * @return Returns the name of the function.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Returns the PostfixMathCommandI for the function.
	 */
	public PostfixMathCommandI getPfmc() {
		return pfmc;
	}
	/**
	 * @return the number of arguments
	 */
	public int getNArgs() { return args.length; }
	/**
	 * @param i
	 * @return returns the i-th argument
	 */
	public PNodeI getArg(int i) { return args[i]; }
}
/* @author rich
 * Created on 23-Dec-2004
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.sjep;
import org.nfunk.jep.*;
/**
 * A mutable monomial representing a * x^i * y^j * ... * z^k.
 * There are no requirements that this is in a reduced form
 * so some powers can be zero.
 * 
 * @author Rich Morris
 * Created on 23-Dec-2004
 */
public class MutiableMonomial
{
	PolynomialCreator pc;
	PConstant coeff;
	int length;
	PNodeI terms[];
	PNodeI powers[];
	/**
	 * Note arrays parsed may be modified.
	 */
	public MutiableMonomial(PolynomialCreator pc,PConstant coeff,PNodeI nodes[],PNodeI pows[])
	{
		this.pc = pc;
		this.coeff = coeff;
		length = nodes.length;
		terms = nodes;
		powers = pows;
	}

	public void mul(PConstant c) throws ParseException
	{
		coeff = (PConstant) coeff.mul(c);
	}
	
	public void div(PConstant c) throws ParseException
	{
		coeff = (PConstant) coeff.div(c);
	}

	public void mul(PNodeI term,PNodeI power) throws ParseException
	{
		for(int i=0;i<length;++i) {
			if(terms[i].equals(term)) {
				powers[i] = powers[i].add(power);
				return;
			}
		}
		// insert in correct posn
		PNodeI newTerms[] = new PNodeI[length+1]; 
		PNodeI newPowers[] = new PNodeI[length+1];
		int pos=0; boolean done = false;
		for(int i=0;i<length;++i) {
			if(!done && terms[i].compareTo(term) > 0) {
		 		newTerms[pos] = term;
		 		newPowers[pos] = power;
		 		++pos;
		 		done = true;
			}
			newTerms[pos] = terms[i];
			newPowers[pos] = powers[i];
			++pos;
		}
		if(!done)
		{
			newTerms[pos] = term;
			newPowers[pos] = power;
			++pos;
		}
		length = length+1;
		terms = newTerms;
		powers = newPowers;
	}
	
	void power(PConstant c) throws ParseException
	{
		coeff = (PConstant) coeff.pow(c);
		for(int i=0;i<length;++i)
			powers[i] = powers[i].mul(c);
	}
	/** removes terms like x^0, 1^x, 2^3 */
	private void reduce() throws ParseException
	{
		int numZeros=0;
		int numOnes=0;
		int numConst=0;
		for(int i=0;i<length;++i)
		{
			if(powers[i].isZero()) ++numZeros;
			else if(terms[i].isOne()) ++numOnes;
			else if(terms[i] instanceof PConstant && powers[i] instanceof PConstant)
				++numConst;
		}
		if(numZeros == 0 && numOnes ==0 && numConst == 0)
			return;
		int newLen = length-numZeros-numOnes-numConst;

		PNodeI newTerms[] = new PNodeI[newLen];
		PNodeI newPowers[] = new PNodeI[newLen];
		int pos=0;
		for(int i=0;i<length;++i)
		{
			if(powers[i].isZero()) {} // x^0 --> 1
			else if(terms[i].isOne()) {} // 1^x --> 1
			else if(terms[i] instanceof PConstant && powers[i] instanceof PConstant)
			{
				coeff = (PConstant) coeff.mul(terms[i].pow(powers[i]));
			}
			else {
				newTerms[pos] = terms[i];
				newPowers[pos] = powers[i];
				++pos;
			}
		}
		length = newLen;
		terms = newTerms;
		powers = newPowers;
	}
	
	PNodeI toPNode() throws ParseException
	{
		reduce();
		if(length ==0) return coeff;
		if(coeff.isZero()) return pc.zeroConstant;

		return new Monomial(pc,coeff,terms,powers);
	}

	public String toString()
	{	
		StringBuffer sb = new StringBuffer();
		sb.append(coeff.toString());
		for(int i=0;i<length;++i)
		{
			sb.append(terms[i]);
			sb.append('^');
			sb.append(powers[i]);
		}
		return sb.toString();
	}

}
/* @author rich
 * Created on 14-Dec-2004
 */
package org.lsmp.djep.sjep;
import org.nfunk.jep.*;
/**
 * Represents an imutable monomial a x^i * y^j * ... * z^k, a constant.
 * 
 * @author Rich Morris
 * Created on 14-Dec-2004
 */
public class Monomial extends AbstractPNode {

	PConstant coeff;
	PNodeI   vars[];
	PNodeI	 powers[];
	/**
	 * 
	 */
	Monomial(PolynomialCreator pc,PConstant coeff,PNodeI vars[],PNodeI powers[]) {
		super(pc);
		if(vars.length != powers.length)
			throw new IllegalArgumentException("Monomial.valueOf length of variables and powers must be equal. they are "+vars.length+" "+powers.length);
		this.coeff = coeff;
		this.vars = vars;
		this.powers = powers;
	}

	Monomial(PolynomialCreator pc,PConstant coeff,PNodeI var) {
		super(pc);
		this.coeff = coeff;
		this.vars = new PNodeI[]{var};
		this.powers = new PNodeI[]{pc.oneConstant};
	}

	Monomial(PolynomialCreator pc,PConstant coeff,PNodeI var,PNodeI power) {
		super(pc);
		this.coeff = coeff;
		this.vars = new PNodeI[]{var};
		this.powers = new PNodeI[]{power};
	}

	PNodeI valueOf(PConstant coefficient,PNodeI terms[],PNodeI pows[])
	{
		if(coefficient.isZero()) return pc.zeroConstant;
		if(terms.length ==0) return coefficient;
		return new Monomial(pc,coefficient,terms,pows);
	}

	MutiableMonomial toMutiableMonomial()
	{
		PNodeI newTerms[] = new PNodeI[vars.length];
		PNodeI newPows[] = new PNodeI[vars.length];
		for(int i=0;i<vars.length;++i){
			newTerms[i] = vars[i];
			newPows[i] = powers[i];
		}
		return new MutiableMonomial(pc,coeff,newTerms,newPows);
	}
	
	public PNodeI mul(PNodeI node) throws ParseException
	{
		if(node instanceof PConstant)
			return this.valueOf((PConstant) coeff.mul(node),vars,powers);

		if(node instanceof Monomial)
			return mul((Monomial) node);
		
		MutiableMonomial mm = this.toMutiableMonomial();
		mm.mul(node,pc.oneConstant);
		return mm.toPNode();				
	}

	public PNodeI div(PNodeI node) throws ParseException
	{
		if(node instanceof PConstant)
			return this.valueOf((PConstant) coeff.div(node),vars,powers);

		if(node instanceof Monomial)
			return div((Monomial) node);
		
		MutiableMonomial mm = this.toMutiableMonomial();
		mm.mul(node,pc.minusOneConstant);
		return mm.toPNode();				
	}

	PNodeI mul(Monomial m) throws ParseException
	{
		MutiableMonomial mm = this.toMutiableMonomial();
		mm.mul(m.coeff);
		for(int i=0;i<m.vars.length;++i)
			mm.mul(m.vars[i],m.powers[i]);
		return mm.toPNode();
	}
	
	PNodeI div(Monomial m) throws ParseException
	{
		MutiableMonomial mm = this.toMutiableMonomial();
		mm.div(m.coeff);
		for(int i=0;i<vars.length;++i)
			mm.mul(m.vars[i],m.powers[i].negate());
		return mm.toPNode();
	}
	
	public PNodeI pow(PNodeI pow) throws ParseException
	{
		if(pow instanceof PConstant)
		{
			MutiableMonomial mm = this.toMutiableMonomial();
			mm.power((PConstant) pow);
			return mm.toPNode();			
		}
		return super.pow(pow);
	}

	public PNodeI negate() throws ParseException
	{
		return new Monomial(pc,(PConstant) coeff.negate(),vars,powers);
	}
	
	public PNodeI invert() throws ParseException
	{
		PNodeI newPows[] = new PNodeI[vars.length];
		for(int i=0;i<vars.length;++i)
			newPows[i] = powers[i].negate();
		return new Monomial(pc,(PConstant) coeff.invert(),vars,newPows);
	}
	
	public PNodeI add(PNodeI node) throws ParseException
	{
		if(node instanceof PVariable)
		{
			if(this.equalsIgnoreConstant(node))
			{
				return valueOf((PConstant)coeff.add(pc.oneConstant),
						vars,powers);		
			}
		}
		if(node instanceof Monomial)
		{
			Monomial mon = (Monomial) node;
			if(this.equalsIgnoreConstant(mon))
			{
				return valueOf((PConstant)coeff.add(mon.coeff),
					vars,powers);
			}
		}
		return super.add(node);
	}

	public PNodeI sub(PNodeI node) throws ParseException
	{
		if(node instanceof PVariable)
		{
			if(this.equalsIgnoreConstant(node))
			{
				return valueOf((PConstant)coeff.sub(pc.oneConstant),
						vars,powers);		
			}
		}
		if(node instanceof Monomial)
		{
			Monomial mon = (Monomial) node;
			if(this.equalsIgnoreConstant(mon))
			{
				return valueOf((PConstant)coeff.sub(mon.coeff),
					vars,powers);
			}
		}
		return super.sub(node);
	}
	
	PNodeI addConstant(PConstant c) throws ParseException
	{
		return valueOf((PConstant) coeff.add(c),vars,powers);
	}
	//////////////////// Comparison functions
	
	public boolean equals(PNodeI node)
	{
		if(!(node instanceof Monomial)) return false;
		if(!coeff.equals(((Monomial) node).coeff)) return false;
		return equalsIgnoreConstant((Monomial) node);
	}
	
	boolean equalsIgnoreConstant(Monomial mon)
	{
		if(vars.length != mon.vars.length) return false;
		for(int i=0;i<vars.length;++i)
		{
			if(!vars[i].equals(mon.vars[i])) return false;
			if(!powers[i].equals(mon.powers[i])) return false;
		}
		return true;
	}

	boolean equalsIgnoreConstant(PNodeI node)
	{
		if(node instanceof Monomial)
			return equalsIgnoreConstant((Monomial) node);
			
		if(vars.length != 1) return false;
		if(!vars[0].equals(node)) return false;
		if(!powers[0].isOne()) return false;
		return true;
	}
	/** Compare this to argument.
	 * x < y
	 * 2 x < 3 x
	 * x < x^2
	 * x^2 < x^3
	 * x < x y
	 * TODO x y < x^2
	 * 
	 * @return this < arg ---> -1,	this > arg ---> 1
	 */

	public int compareTo(PNodeI node)
	{
		if(node instanceof PConstant) return 1;
		if(node instanceof Monomial)
		{
			Monomial mon = (Monomial) node;
			for(int i=0;i<vars.length;++i)
			{
				if(i>=mon.vars.length) return 1;
				int res = vars[i].compareTo(mon.vars[i]);
				if(res!=0) return res;
				res = powers[i].compareTo(mon.powers[i]);
				if(res!=0) return res;
			}
			if(vars.length > mon.vars.length) return 1;
			if(vars.length < mon.vars.length) return -1;
			return coeff.compareTo(mon.coeff);
		}
		// compare with first term
		int res = vars[0].compareTo(node);
		if(res==0)
			res = powers[0].compareTo(pc.oneConstant);
		return res;
	}
	
	private boolean negativePower(PNodeI pow) {
		return( pow instanceof PConstant
		 && ((PConstant) pow).isNegative()); 

	}
	private void printPower(StringBuffer sb,PNodeI pow)
	{
		if(pow.isOne()) return;
		if(pow instanceof PConstant 
			|| pow instanceof PVariable 
			|| pow instanceof PFunction)
		{	
			sb.append('^');
			sb.append(pow.toString());	
		}
		else
		{
			sb.append("^(");
			sb.append(pow.toString());	
			sb.append(")");
		}
	}
	public String toString()
	{
		StringBuffer sb = new StringBuffer();

		boolean flag = false;
		if( coeff.isMinusOne())
			sb.append('-');
		else if( coeff.isOne()) {	}
		else {
			sb.append(coeff.toString());
			flag = true;
		}
		// first print positive and complicated powers
		int numNeg = 0;
		for(int i=0;i<vars.length;++i)
		{
			if( negativePower(powers[i])) { ++numNeg; continue;} 

			if(flag)
				sb.append('*');
			if(vars[i] instanceof Polynomial)
			{
				sb.append('(');
				sb.append(vars[i].toString());
				sb.append(')');
			}
			else
				sb.append(vars[i].toString());
			printPower(sb,powers[i]);
			flag = true; 
		}
		// now negative powers
		if(numNeg >0)
		{
			if(!flag) sb.append('1');
			if(numNeg > 1) sb.append("/(");
			else		sb.append("/");
			flag = false;
			for(int i=0;i<vars.length;++i)
			{
				if( negativePower(powers[i]) )
				{
					if(flag)
						sb.append('*');
					if(vars[i] instanceof Polynomial)
					{
						sb.append('(');
						sb.append(vars[i].toString());
						sb.append(')');
					}
					else
						sb.append(vars[i].toString());
					try {
						printPower(sb,powers[i].negate());
					} catch(ParseException e) {
						throw new IllegalStateException(e.getMessage());
					}
					flag = true; 
				}
			}
			if(numNeg > 1) sb.append(")");
		}
		
		return sb.toString();
	}
	
	public Node toNode() throws ParseException
	{
		int nCoeff = coeff.isOne() ? 0 : 1;

		int numDivisors = 0;
		for(int i=0;i<vars.length;++i)
			if(negativePower(powers[i]))
				++numDivisors;

		Node args[] = new Node[nCoeff+vars.length-numDivisors];
		int pos=0;
		if(nCoeff>0)
			args[pos++]=coeff.toNode();

		for(int i=0;i<vars.length;++i)
		{
			if(negativePower(powers[i])) continue;
			if(powers[i].isOne())
				args[pos++]=vars[i].toNode();
			else
				args[pos++] = pc.nf.buildOperatorNode(pc.os.getPower(),
					vars[i].toNode(),powers[i].toNode());
		}
		Node top;
		if(args.length==0) top = coeff.toNode();
		else if(args.length==1) top = args[0];
		else top = pc.nf.buildOperatorNode(
			pc.os.getMultiply(),args);
		
		if(numDivisors == 0) return top;
		
		Node divisors[] = new Node[numDivisors];
		pos = 0;
		for(int i=0;i<vars.length;++i)
		{
			if(negativePower(powers[i]))
			{
				PNodeI pow = powers[i].negate();
				if(powers[i] instanceof PConstant && ((PConstant) powers[i]).isMinusOne())
					divisors[pos++]=vars[i].toNode();
				else
					divisors[pos++] = pc.nf.buildOperatorNode(pc.os.getPower(),
						vars[i].toNode(),pow.toNode());
			}
		}
		Node bottom; 
		if(divisors.length==1) bottom = divisors[0];
		else bottom = pc.nf.buildOperatorNode(
			pc.os.getMultiply(),divisors);
		return pc.nf.buildOperatorNode(pc.os.getDivide(),top,bottom);
	}
	
	boolean negativeCoefficient()
	{
		return coeff.isNegative();
	}
	
	public PNodeI expand() throws ParseException
	{ 
		MutiablePolynomial mp = new MutiablePolynomial(pc,new PNodeI[]{this.coeff});
		for(int i=0;i<vars.length;++i)
		{
			if(powers[i] instanceof PConstant)
			{
				PConstant pow = (PConstant) powers[i];
				if(pow.isZero()) {}
				else if(pow.isOne())
					mp.expandMul(vars[i].expand());
				else if(pow.isInteger())
				{
					int intpow = pow.intValue();
					if(intpow >0)
					{
						PNodeI res = vars[i].expand();
						for(int j=1;j<=intpow;++j)
							mp.expandMul(res);	
					}
					else
						mp.expandMul(new Monomial(pc,pc.oneConstant,vars[i].expand(),powers[i]));
				}
			}
			else
				mp.expandMul(new Monomial(pc,pc.oneConstant,vars[i].expand(),powers[i]));
		}
		return mp.toPNode();		
	}

	/**
	 * @return Returns the coefficient.
	 */
	public PConstant getCoeff() {
		return coeff;
	}
	/**
	 * @return return the number of variables.
	 */
	public int getNVars() { return vars.length; }
	/**
	 * Returns the i-th variable
	 * @param i
	 * @return PNodeI for the i-th variable in product
	 */
	public PNodeI getVar(int i) { return vars[i]; }
	/**
	 * Returns the i-th power
	 * @param i
	 * @return PNodeI for the power of the i-th variable in product
	 */
	public PNodeI getPower(int i) { return powers[i]; }
}
/* @author rich
 * Created on 22-Dec-2004
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.sjep;

import org.nfunk.jep.ParseException;

/**
 * Default methods, when more specific methods do not work. 
 * 
 * @author Rich Morris
 * Created on 22-Dec-2004
 */
public abstract class AbstractPNode implements PNodeI
{
	/** A reference to the PolynomialCreator instance. */
	protected PolynomialCreator pc;
	
	private AbstractPNode() {}
	public AbstractPNode(PolynomialCreator pc)	{
		this.pc = pc;
	}
	/**
	 * 
	 */

	public PNodeI add(PNodeI node) throws ParseException
	{
		if(node.isZero()) return this;
		if(this.isZero()) return node;
		
		if(this.equals(node))
			return new Monomial(pc,pc.twoConstant,this);
			
		if(node instanceof Polynomial)
			return node.add(this);

		if(this.compareTo(node) < 0)
			return new Polynomial(pc,new PNodeI[]{this,node}); // x+y
		return new Polynomial(pc,new PNodeI[]{node,this}); // x+y
	}

	public PNodeI sub(PNodeI node) throws ParseException
	{
		if(node.isZero()) return this;
		if(this.isZero()) return node.negate();

		if(this.equals(node))
			return pc.zeroConstant;
		
		if(node instanceof Polynomial)
			return node.negate().add(this);
		
		if(node instanceof PConstant)
			return this.add(node.negate());
			
		return new Polynomial(pc,new PNodeI[]{this,
				new Monomial(pc,pc.minusOneConstant,node)}); // x-y
	}

	public PNodeI negate() throws ParseException
	{
		return new Monomial(pc,pc.minusOneConstant,this);
	}

	public PNodeI mul(PNodeI node) throws ParseException
	{
		if(node.isZero()) return pc.zeroConstant;
		if(node.isOne())
			return this;

		if(this.equals(node))
			return new Monomial(pc,pc.oneConstant,this,pc.twoConstant);

		if(node instanceof PConstant)
			return new Monomial(pc,(PConstant) node,this);
		
		if(node instanceof Monomial)
			return ((Monomial) node).mul(this);
		

		if(this instanceof PConstant)
		{
//			if(node instanceof Polynomial)
//				return ((Polynomial) node).mul((Constant) this);
			return new Monomial(pc,(PConstant) this,node);
		}
			
		if(this.compareTo(node) < 0)
			return new Monomial(pc,
				pc.oneConstant,
				new PNodeI[]{this,node},
				new PNodeI[]{pc.oneConstant,pc.oneConstant});
		
		return new Monomial(pc,
			pc.oneConstant,
			new PNodeI[]{node,this},
			new PNodeI[]{pc.oneConstant,pc.oneConstant});
	}

	public PNodeI div(PNodeI node) throws ParseException
	{
		if(this.equals(node))
			return pc.oneConstant;
		if(node.isZero())
			return pc.infConstant;
		if(node.isOne())
			return this;
	
		if(node instanceof Monomial)
			return ((Monomial) node).invert().mul(this);

		if(this instanceof PConstant)
			return new Monomial(pc,(PConstant) this,node,pc.minusOneConstant);
		
		if(node instanceof PConstant)
			return new Monomial(pc,(PConstant) node.invert(),this);
			
		return new Monomial(pc,
			pc.oneConstant,
			new PNodeI[]{this,node},
			new PNodeI[]{pc.oneConstant,pc.minusOneConstant});
	}

	public PNodeI invert() throws ParseException
	{
		return pow(pc.minusOneConstant); // x^-1
	}

	public PNodeI pow(PNodeI node) throws ParseException
	{
		if(node.isZero()) return pc.oneConstant;
		if(node.isOne()) return this;
		return new Monomial(pc,
			pc.oneConstant,this,node);
	}

	public boolean equals(PNodeI node)	{return false;	}
	public boolean isZero()	{return false;	}
	public boolean isOne()	{return false;	}
	/**
	this < arg ---> -1
	this > arg ---> 1
	*/
	public int compareTo(PNodeI node)	{
		if(this instanceof PConstant)
		{
			if(node instanceof PConstant)
				return ((PConstant) this).compareTo((PConstant) node);
			return -1;
		}
		if(this instanceof PVariable)
		{
			if(node instanceof PConstant) return 1;
			if(node instanceof PVariable)
				return ((PVariable) this).compareTo((PVariable) node);
			if( node instanceof PFunction 
			 || node instanceof POperator)
				return -1;
		}
		if(this instanceof POperator)
		{
			if( node instanceof PConstant
			 || node instanceof PVariable) return 1;
			if( node instanceof POperator)
				return ((POperator) this).compareTo((POperator) node);
			if( node instanceof PFunction)
				return -1;
		}
		if(this instanceof PFunction)
		{
			if( node instanceof PConstant
			 || node instanceof PVariable
			 || node instanceof PFunction) return 1;
			if( node instanceof PFunction)
				return ((PFunction) this).compareTo((PFunction) node);
		}
		if( this instanceof Monomial
		 || this instanceof Polynomial)
			throw new IllegalStateException("Comparison failed "+this.getClass().getName()+" "+node.getClass().getName());
			
		if(node instanceof Monomial)
			return -((Monomial) node).compareTo(this);
		if(node instanceof Polynomial)
			return -((Polynomial) node).compareTo(this);
			
		throw new IllegalArgumentException("Comparison failed "+this.getClass().getName()+" "+node.getClass().getName());
	}

}
/* @author rich
 * Created on 01-Oct-2004
 */
package org.lsmp.djep.rewrite;

import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;

/**
 * Basic implementation for a RewriteRule.
 * Subclasses can have access to NodeFactory,OperatorSet,TreeUtilsand XJep objects.
 * @author Rich Morris
 * Created on 01-Oct-2004
 */
public abstract class AbstractRewrite implements RewriteRuleI {
	/** A NodeFactory used for construction nodes. */
	protected NodeFactory nf;
	/** An OperatorSet used for finding operators. */
	protected OperatorSet opSet;
	/** TreeUtils for testing types of nodes. */
	protected TreeUtils tu;
	/** A reference to main XJep opbject. */
	protected XJep xj;

	/**
	 * Constructor with reference to XJep object.
	 */
	public AbstractRewrite(XJep xj) {
		opSet = xj.getOperatorSet();
		tu = xj.getTreeUtils();
		nf = xj.getNodeFactory();
		this.xj = xj;
	}
	/** Private default constructor. */
	private AbstractRewrite() {}
}
   
package org.lsmp.djep.rewrite;
//import org.lsmp.djep.matrixParser.*;
import org.lsmp.djep.xjep.DoNothingVisitor;
import org.lsmp.djep.xjep.TreeUtils;
import org.lsmp.djep.xjep.XJep;
import org.nfunk.jep.*;

/**
 * Simplifies an expression.
 * To use
 * <pre>
 * JEP j = ...; Node in = ...;
 * SimplificationVisitor sv = new SimplificationVisitor(tu);
 * Node out = sv.simplify(in);
 * </pre>
 * 
 * <p>
 * Its intended to completely rewrite this class to that simplification
 * rules can be specified by strings in a way similar to DiffRulesI.
 * It also would be nice to change the rules depending on the type of
 * arguments, for example matrix multiplication is not commutative.
 * But some of the in built rules exploit commutativity.
 * 
 * @author Rich Morris
 * Created on 20-Jun-2003
 */

public class RewriteVisitor extends DoNothingVisitor
{
  private XJep xj;
  private RewriteRuleI rules[];
  private boolean simp=false;
  public RewriteVisitor()
  {
  }

  /** must be implemented for subclasses. **/
  public Node rewrite(Node node,XJep xjep,RewriteRuleI inrules[],boolean simplify) throws ParseException,IllegalArgumentException
  {
  	xj = xjep;
	this.rules = inrules;
	this.simp = simplify;
	if(this.rules.length==0) return node;
	
	if (node == null) 
		throw new IllegalArgumentException(
			"topNode parameter is null");
	Node res = (Node) node.jjtAccept(this,null);
	return res;
  }

	
	public Object visit(ASTFunNode node, Object data) throws ParseException
	{
		Node children[] = acceptChildrenAsArray(node,data);
		TreeUtils.copyChildrenIfNeeded(node,children);
		for(int i=0;i<rules.length;++i)
		{
			if(rules[i].test(node,children))
			{
				Node newNode = rules[i].apply(node,children);
				if(simp)
					newNode = xj.simplify(newNode);
				return newNode.jjtAccept(this,data);
			}
		}
		return node;
	}
}
/* @author rich
 * Created on 01-Oct-2004
 */
package org.lsmp.djep.rewrite;
import org.nfunk.jep.*;
/**
 * @author Rich Morris
 * Created on 01-Oct-2004
 */
public interface RewriteRuleI {
    /** Returns true if node needs to be rewritten, according to this rule. */
	public boolean test(ASTFunNode node,Node children[]);
	/** Rewrites the node */
	public Node apply(ASTFunNode node,Node children[]) throws ParseException;
}
/* @author rich
 * Created on 01-Oct-2004
 */
package org.lsmp.djep.rewrite;

//import org.lsmp.djep.xjep.RewriteRuleI;
import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;

/**
 * @author Rich Morris
 * Created on 01-Oct-2004
 */
public class ExpandBrackets extends AbstractRewrite {

	/**
	 * TODO cope with a * uminus(x+x)
	 */
	public ExpandBrackets(XJep xj) {
		super(xj);
	}
	/* (non-Javadoc)
	 * @see org.lsmp.djep.xjep.RewriteRuleI#test(org.nfunk.jep.Node, org.nfunk.jep.Node[])
	 */
	public boolean test(ASTFunNode node, Node[] children) {
		if(!node.isOperator())	return false;
		XOperator op= (XOperator) node.getOperator();

		if(opSet.getMultiply() == op)
		{
			if(tu.getOperator(children[0]) == opSet.getAdd())
				return true;
			if(tu.getOperator(children[0]) == opSet.getSubtract())
				return true;
			if(tu.getOperator(children[1]) == opSet.getAdd())
				return true;
			if(tu.getOperator(children[1]) == opSet.getSubtract())
				return true;
		}
		return false;
	}

	/* (non-Javadoc)
	 * @see org.lsmp.djep.xjep.RewriteRuleI#apply(org.nfunk.jep.Node, org.nfunk.jep.Node[])
	 */
	public Node apply(ASTFunNode node, Node[] children) throws ParseException {
		
		Operator lhsOp = tu.getOperator(children[0]); 
		Operator rhsOp = tu.getOperator(children[1]); 
		if(lhsOp == opSet.getAdd() || lhsOp == opSet.getSubtract())
		{ /* (a+b)*c --> (a*c)+(b*c) */
			return nf.buildOperatorNode(
				lhsOp,
				nf.buildOperatorNode(
					opSet.getMultiply(),
						children[0].jjtGetChild(0),
						xj.deepCopy(children[1])),
				nf.buildOperatorNode(
					opSet.getMultiply(),
						children[0].jjtGetChild(1),
						xj.deepCopy(children[1]))
						);
	
		}
		if(rhsOp == opSet.getAdd() || rhsOp == opSet.getSubtract())
		{	/* a*(b+c) -> (a*b)+(a*c) */
			return nf.buildOperatorNode(
				rhsOp,
				nf.buildOperatorNode(
					opSet.getMultiply(),
						xj.deepCopy(children[0]),
						children[1].jjtGetChild(0)),
				nf.buildOperatorNode(
					opSet.getMultiply(),
						xj.deepCopy(children[0]),
						children[1].jjtGetChild(1))
						);
		}
		throw new ParseException("ExpandBrackets at least one child must be + or -");
	}

}
/* @author rich
 * Created on 01-Oct-2004
 */
package org.lsmp.djep.rewrite;

import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;

/**
 * @author Rich Morris
 * Created on 01-Oct-2004
 */
public class ExpandPower implements RewriteRuleI {

	private NodeFactory nf;
	private OperatorSet opSet;
	private TreeUtils tu;
	private XJep xj;

	/**
	 * 
	 */
	public ExpandPower(XJep xj) {
		opSet = xj.getOperatorSet();
		tu = xj.getTreeUtils();
		nf = xj.getNodeFactory();
		this.xj = xj;
	}
	private ExpandPower() {}
	/* (non-Javadoc)
	 * @see org.lsmp.djep.xjep.RewriteRuleI#test(org.nfunk.jep.Node, org.nfunk.jep.Node[])
	 */
	public boolean test(ASTFunNode node, Node[] children) {
		if(!node.isOperator())	return false;
		XOperator op= (XOperator) node.getOperator();

		if(opSet.getPower() == op)
		{
			if(tu.getOperator(children[0]) == opSet.getAdd()
			 || tu.getOperator(children[0]) == opSet.getSubtract())
			{
				return tu.isInteger(children[1]) && (tu.isPositive(children[1]) || tu.isZero(children[1]));
			}
			return false;
		}
		return false;
	}

	public Node apply(ASTFunNode node, Node[] children) throws ParseException {
		Operator lhsOp = tu.getOperator(children[0]); 
		int n = tu.intValue(children[1]);
		Node sub1 = children[0].jjtGetChild(0);
		Node sub2 = children[0].jjtGetChild(1);
		
		if(lhsOp == opSet.getAdd() || lhsOp == opSet.getSubtract())
		{ /* (a+b)^n --> (a^n+nC1 a^(n-1) b + ....) */
			if(n == 0) return nf.buildConstantNode(new Double(1));
			if(n == 1) return children[0];
			
			Node vals[] = new Node[n+1];
			/* a^n */
			vals[0] = nf.buildOperatorNode(
				opSet.getPower(),
				xj.deepCopy(sub1),
				nf.buildConstantNode(new Double(n))
				);
			if(n==2)
			{
				vals[1]=nf.buildOperatorNode(
					opSet.getMultiply(),
					nf.buildConstantNode(new Double(2)),
					nf.buildOperatorNode(
						opSet.getMultiply(),
						xj.deepCopy(sub1),
						xj.deepCopy(sub2)));
			}
			else
			{
				/* n * a^(n-1) * b */
				vals[1]=nf.buildOperatorNode(
					opSet.getMultiply(),
					nf.buildConstantNode(new Double(n)),
					nf.buildOperatorNode(
						opSet.getMultiply(),
						nf.buildOperatorNode(
							opSet.getPower(),
							xj.deepCopy(sub1),
							nf.buildConstantNode(new Double(n-1))),
						xj.deepCopy(sub2)));
			}
			/* n * a * b^(n-1) */
			if(n>=3)
			{
				vals[n-1] = nf.buildOperatorNode(
				opSet.getMultiply(),
				nf.buildConstantNode(new Double(n)),
				nf.buildOperatorNode(
					opSet.getMultiply(),
					xj.deepCopy(sub1),
					nf.buildOperatorNode(
						opSet.getPower(),
						xj.deepCopy(sub2),
						nf.buildConstantNode(new Double(n-1)))));
			}
			/* a^n */
			vals[n] = nf.buildOperatorNode(
				opSet.getPower(),
				xj.deepCopy(sub2),
				nf.buildConstantNode(new Double(n))
				);
			for(int i=2;i<n-1;++i)
			{
				/* (n,i) * a^(n-i) * b^i */ 
				vals[i]=nf.buildOperatorNode(
					opSet.getMultiply(),
					nf.buildConstantNode(new Double(XMath.binomial(n,i))),
					nf.buildOperatorNode(
						opSet.getMultiply(),
						nf.buildOperatorNode(
							opSet.getPower(),
							xj.deepCopy(sub1),
							nf.buildConstantNode(new Double(n-i))),
						nf.buildOperatorNode(
							opSet.getPower(),
							xj.deepCopy(sub2),
							nf.buildConstantNode(new Double(i)))));
			}

			Node sums[] = new Node[n+1];
			sums[n]=vals[n];
			for(int i=n-1;i>=0;--i)
			{
				sums[i] = nf.buildOperatorNode(
					lhsOp,
					vals[i],
					sums[i+1]);
			}
			return sums[0];
		}
		throw new ParseException("ExpandBrackets at least one child must be + or -");
	}

}
/* @author rich
 * Created on 06-Oct-2004
 */
package org.lsmp.djep.rewrite;

import org.lsmp.djep.xjep.*;
import org.nfunk.jep.ASTFunNode;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;

/**
 * Collect powers together so that x*x -> x^2 and x^n*x -> x^(n+1).
 * @author Rich Morris
 * Created on 06-Oct-2004
 */
public class CollectPowers extends AbstractRewrite {

	/**
	 * 
	 */
	public CollectPowers(XJep xj) {
		super(xj);
	}

	/* (non-Javadoc)
	 * @see org.lsmp.djep.xjep.RewriteRuleI#test(org.nfunk.jep.ASTFunNode, org.nfunk.jep.Node[])
	 */
	public boolean test(ASTFunNode node, Node[] children) {
		if(node.getOperator()==opSet.getMultiply())
		{
			// x * x -> true
			if(tu.isVariable(children[0]) && tu.isVariable(children[1]))
			{
				if(tu.getName(children[0]).equals(tu.getName(children[1])))
					return true;
				return false;
			}

			// x^n * x
			if(tu.getOperator(children[0]) == opSet.getPower() 
				&& tu.isVariable(children[0].jjtGetChild(0))
				&& tu.isVariable(children[1]))
			{
				if(tu.getName(children[0].jjtGetChild(0)).equals(tu.getName(children[1])))
					return true;
				return false;			
			}
			if(tu.isVariable(children[0])
				&& tu.getOperator(children[1]) == opSet.getPower() 
				&& tu.isVariable(children[1].jjtGetChild(0)))
			{
				if(tu.getName(children[0]).equals(tu.getName(children[1].jjtGetChild(0))))
					return true;
				return false;			
			}

		}
		return false;
	}

	/* (non-Javadoc)
	 * @see org.lsmp.djep.xjep.RewriteRuleI#apply(org.nfunk.jep.ASTFunNode, org.nfunk.jep.Node[])
	 */
	public Node apply(ASTFunNode node, Node[] children) throws ParseException {

		if(node.getOperator()==opSet.getMultiply())
		{
			if(tu.isVariable(children[0]) && tu.isVariable(children[1]))
			{
				if(tu.getName(children[0]).equals(tu.getName(children[1])))
				{
					return nf.buildOperatorNode(
						opSet.getPower(),
						children[0],
						nf.buildConstantNode(new Double(2.0))
						);
				}
			}
			if(tu.getOperator(children[0]) == opSet.getPower() 
				&& tu.isVariable(children[0].jjtGetChild(0))
				&& tu.isVariable(children[1]))
			{
				if(tu.getName(children[0].jjtGetChild(0)).equals(tu.getName(children[1])))
				{
					return nf.buildOperatorNode(
						opSet.getPower(),
						children[1],
						nf.buildOperatorNode(
							opSet.getAdd(),
							children[0].jjtGetChild(1),
							nf.buildConstantNode(tu.getONE())
							));
				}
			}
			if(tu.isVariable(children[0])
				&& tu.getOperator(children[1]) == opSet.getPower() 
				&& tu.isVariable(children[1].jjtGetChild(0)))
			{
				if(tu.getName(children[0]).equals(tu.getName(children[1].jjtGetChild(0))))
				{
					return nf.buildOperatorNode(
						opSet.getPower(),
						children[0],
						nf.buildOperatorNode(
							opSet.getAdd(),
							children[1].jjtGetChild(1),
							nf.buildConstantNode(tu.getONE())
							));
				}
			}
		}
		return null;
	}

}
/* @author rich
 * Created on 26-Oct-2003
 */
package org.lsmp.djep.djep;
import java.util.*;
import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;

/**
 * Holds all info about a variable.
 * Has a name, an equation, a dimension (or sent of dimensions if matrix or tensor)
 * and also a set of {@link PartialDerivative PartialDerivative}.
 * The derivatives are stored in a hashtable index by
 * the sorted names of derivatives.
 * i.e. d^2f/dxdy, and d^2f/dydx will both be indexed by {"x","y"}.
 * df/dx is indexed by {"x"}, d^2f/dx^2 is index by {"x","x"}.
 * Partial derivatives are calculated as required by the
 * findDerivative method.
 * @author Rich Morris
 * Created on 26-Oct-2003
 */
public class DVariable extends XVariable 
{
	protected Hashtable derivatives = new Hashtable();
	
	protected PartialDerivative createDerivative(String derivnames[],Node eqn)
	{
		return new PartialDerivative(this,derivnames,eqn);
	}
	/**
	 * The constructor is package private. Variables should be created
	 * using the VariableTable.find(Sting name) method.
	 */
	protected DVariable(String name) 
	{ 
		super(name);
	}

	protected DVariable(String name,Object value) 
	{ 
		super(name,value);
	}

	/** sets the equation */
	public void setEquation(Node eqn)
	{
		super.setEquation(eqn);
		derivatives.clear(); 
	}

	/** makes value and values of all derivatives invalid. **/
	public void invalidateAll()
	{
		if(isConstant()) return;
		setValidValue(false);
		for(Enumeration e = derivatives.elements(); e.hasMoreElements(); ) 
		{
			PartialDerivative deriv = (PartialDerivative) e.nextElement();
			deriv.setValidValue(false);
		}
	}
	/** Produces a string to represent the derivative.
	 * The string will be of the form "dx^2/dxdy".
	 * This string is used to index the derivatives of a variable.
	 * @param rootname name of the variable we are calculating the derivative of.
	 * @param dnames An array of the names of each of the partial derivatives.
	 * @return the string representation
	 */	
	public static String makeDerivString(String rootname,String dnames[])
	{
		StringBuffer sb = new StringBuffer();
		sb.append('d');
		if( dnames.length!= 1) sb.append("^" + dnames.length);
		sb.append(rootname);
		sb.append('/');
		// TODO print d^2f/dxdx as d^2f/dx^2
		for(int i=0;i<dnames.length;++i)
		{
			sb.append('d');
			sb.append(dnames[i]);
		}
		return sb.toString();

	}
	/** returns a sorted copy of the input array of strings */		
	private String[] sortedNames(String names[])
	{
		String newnames[] = new String[names.length]; 
		System.arraycopy(names,0,newnames,0,names.length);
		Arrays.sort(newnames);
		return newnames;
	}
	/** Sets the derivative wrt the variables specified in 
	 * 	deriv names. Note the names are sorted so that
	 *  d^2z/dxdy = d^2z/dydx.
	 */
	void setDerivative(String derivnames[],PartialDerivative eqn)
	{
		String newnames[] = sortedNames(derivnames); 
		derivatives.put(makeDerivString(name,newnames),eqn);
	}

	void setDerivativeSorted(String derivnames[],PartialDerivative eqn)
	{
		derivatives.put(makeDerivString(name,derivnames),eqn);
	}

	PartialDerivative getDerivative(String derivnames[])
	{
		String newnames[] = sortedNames(derivnames);
		return (PartialDerivative) derivatives.get(makeDerivString(name,newnames));
	}

	PartialDerivative getDerivativeSorted(String derivnames[])
	{
		return (PartialDerivative) derivatives.get(makeDerivString(name,derivnames));
	}


/**
 * Finds the derivative of this variable wrt the names.
 * If the derivative already exists just return that.
 * Otherwise use the visitor to calculate the derivative.
 * If the derivative cannot be calculated (say if the equation is null)
 * then return null.
 * 
 * @param derivnames
 * @return The derivative or null if it cannot be calculated.
 * @throws ParseException
 */
	PartialDerivative findDerivativeSorted(String derivnames[],DJep jep)
		throws ParseException
	{
		if(getEquation()==null) return null;
		
		if(derivnames == null) throw new ParseException("findDerivativeSorted: Null array of names");
		PartialDerivative res = getDerivativeSorted(derivnames);
		if(res!=null) return res;
		
		// Deriv not found. Calculate from lower derivative
		int origlen = derivnames.length;
		Node lowereqn; // equation for lower derivative (or root equation)
		if(origlen < 1)
			throw new ParseException("findDerivativeSorted: Empty Array of names");
		else if(origlen == 1)
			lowereqn = getEquation();
		else
		{
			String newnames[] = new String[origlen-1];
			for(int i=0;i<origlen-1;++i)
				newnames[i]=derivnames[i];
			lowereqn = findDerivativeSorted(newnames,jep).getEquation();
		}
		if(lowereqn==null)
		{
			return null;
		}
		Node deriv = jep.differentiate(lowereqn,derivnames[origlen-1]);
		Node simp = jep.simplify(deriv);
		res = createDerivative(derivnames,simp); 
		setDerivative(derivnames,res);
		return res;	
	}

	PartialDerivative findDerivative(String derivnames[],DJep jep)
		throws ParseException
	{
		String newnames[] = sortedNames(derivnames); 
		return findDerivativeSorted(newnames,jep);
	}

	PartialDerivative findDerivative(String derivname,DJep jep)
		throws ParseException
	{
		String newnames[] = new String[1];
		newnames[0]=derivname;
		return findDerivativeSorted(newnames,jep);
	}

	PartialDerivative findDerivative(PartialDerivative deriv,String dname,DJep jep)
		throws ParseException
	{
		int len = deriv.getDnames().length;
		String newnames[] = new String[len+1];
		System.arraycopy(deriv.getDnames(),0,newnames,0,len);
		newnames[len]=dname;
		return findDerivative(newnames,jep);
	}
	
	public String toString(PrintVisitor bpv)
	{
		boolean mode = bpv.getMode(DPrintVisitor.PRINT_VARIABLE_EQNS);
		bpv.setMode(DPrintVisitor.PRINT_VARIABLE_EQNS,false);
		StringBuffer sb = new StringBuffer(name);
		sb.append(":\t");
		if(hasValidValue()) sb.append(getValue() );
		else	sb.append("NA");
		sb.append("\t");
		if(this.isConstant()) sb.append("constant");
		else if(getEquation()!=null) sb.append("eqn "+bpv.toString(getEquation()));
		else sb.append("no equation");
		for(Enumeration e = derivatives.elements(); e.hasMoreElements(); ) 
		{
			sb.append("\n");
			PartialDerivative var = (PartialDerivative) e.nextElement();
			sb.append("\t"+var.toString()+": ");
			if(var.hasValidValue()) sb.append(var.getValue() );
			else	sb.append("NA");
			sb.append("\t");
			sb.append(bpv.toString(var.getEquation()));
		}
		bpv.setMode(DPrintVisitor.PRINT_VARIABLE_EQNS,mode);
		return sb.toString();
	}

	/** Enumerate all the derivatives of this variable.
	 * 
	 * @return an Enumeration running through all the derivatives. 
	 */
	public Enumeration allDerivatives() {
		return derivatives.elements();
	}
}
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep;

import org.nfunk.jep.ASTFunNode;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;


/****** Classes to implement the differentation rules **********/

/**
 * Holds a set of rules describing how to differentiate a function.
 * Each function to be differentiated should have a object which implements 
 * this interface. 
 * @author R Morris
 * Created on 18-Jun-2003
 */
public interface DiffRulesI {

	/**
	 * Returns the top node of of the derivative of this function 
	 * wrt to variable var.
	 * @param var The name of variable to differentiate wrt to.
	 * @param children the arguments of the function
	 * @param dchildren the derivatives of each argument of the function.
	 * @return top node of and expression tree for the derivative.
	 * @throws ParseException if there is some problem in compiling the derivative.
	 */
	public Node differentiate(ASTFunNode node,String var,Node [] children,Node [] dchildren,DJep djep) throws ParseException;

	/**
	 * Returns a string representation of the rule.
	 */
	public String toString();

	/**
	 * Returns the name of the function.
	 * Used as index in hashtable and as way of linking with standard JEP functions.
	 * You probably want to specify the in the constructors. 
	 */
	public String getName();

}
/* @author rich
 * Created on 26-Feb-2004
 */
package org.lsmp.djep.djep;
import org.nfunk.jep.*;
import org.lsmp.djep.xjep.PrintVisitor;

/**
 * An extension of PrintVisitor which will print the equations of a variable if required.
 * The behaviours of this class is determined by two modes
 * PRINT_PARTIAL_EQNS and PRINT_VARIABLE_EQNS.
 * When a variable or partial derivative is encountered then
 * its equation may be printed.
 * By default equations for PartialDerivatives are printed
 * but equations for normal derivatives are not.
 * TODO might want to print eqn for y=sin(x) but not x=3
 *  
 * @author Rich Morris
 * Created on 26-Feb-2004
 */
public class DPrintVisitor extends PrintVisitor {
	public static final int PRINT_PARTIAL_EQNS = 16;
	public static final int PRINT_VARIABLE_EQNS = 32;
	
	/**
	 * 
	 */
	public DPrintVisitor() {
		super();
		setMode(PRINT_PARTIAL_EQNS,true);
	}

	/** Prints the variable or its equation.
	 * Depends on the state of the flags and whether the variable has an equation.
	 */
	public Object visit(ASTVarNode node, Object data) throws ParseException
	{
		Variable var = node.getVar();
		if(var instanceof PartialDerivative)
		{
			PartialDerivative deriv = (PartialDerivative) var;
			if(((mode & PRINT_PARTIAL_EQNS)!=0) && deriv.hasEquation())
				deriv.getEquation().jjtAccept(this,null);
			else
				sb.append(node.getName());
		}
		else if(var instanceof DVariable)
		{
			DVariable dvar = (DVariable) var;
			if(((mode & PRINT_VARIABLE_EQNS)!=0) && dvar.hasEquation())
				dvar.getEquation().jjtAccept(this,null);
			else
				sb.append(node.getName());
		}
		else
			sb.append(node.getName());

	  return data;
	}
}
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep;

import java.util.Stack;

import org.lsmp.djep.xjep.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;


/**
   * The diff(f,x) operator.
   */
  public class Diff extends PostfixMathCommand implements CommandVisitorI
  {
	  public Diff() {
		  super();
		  super.numberOfParameters = 2;
	  }
	
  /**
   * Should never be evaluated!
   * @throws ParseException if called by evaluator.
   */
	public void run(Stack inStack)	throws ParseException 
	{
		throw new ParseException("Cannot evaluate the diff function. ");
	}

 /**
   * Process the differentiation specified by node.
   * Defines process in
   * @see CommandVisitorI 
   */
  public Node process(Node node,Node children[],XJep xjep) throws ParseException
  {
	  Node lhs = children[0];
	  Node rhs = children[1];
	  if(!xjep.getTreeUtils().isVariable(rhs) )
	  {
	  	throw new ParseException("Format should be diff(f,x) where x is a variables and 1,2 are constants");	
	  }
	  ASTVarNode var;
	  try
	  {
//			  lhs = (Node) node.jjtGetChild(0);
		  var = (ASTVarNode) rhs;
	  }
	  catch(ClassCastException e)
	  {	throw new ParseException("Format should be diff(f,x) where x is a variables and 1,2 are constants"); }
			
	  return ((DJep) xjep).differentiate(lhs,var.getName());
  }
} /* end class Diff */
/* @author rich
 * Created on 18-Jun-2003
 */
   
package org.lsmp.djep.djep;
import org.lsmp.djep.djep.diffRules.*;
import org.lsmp.djep.xjep.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import java.util.Hashtable;
import java.util.Enumeration;
import java.io.PrintStream;

/**
 * A class for performing differentiation of an expression.
 * To use do
 * <pre>
 * JEP j = ...; Node in = ...;
 * DifferentiationVisitor dv = new DifferentiationVisitor(jep);
 * dv.addStandardDiffRules();
 * Node out = dv.differentiate(in,"x");
 * </pre>
 * The class follows the visitor pattern described in
 * {@link org.nfunk.jep.ParserVisitor ParserVisitor}.
 * The rules for differentiating specific functions are contained in
 * object which implement
 * {@link DiffRulesI DiffRulesI}
 * A number of inner classes which use this interface are defined for specific
 * function types.
 * In particular
 * {@link MacroDiffRules MacroDiffRules}
 * allow the rule for differentiation to be specified by strings.
 * New rules can be added using
 * {@link DJep#addDiffRule} method.
 * @author R Morris
 * Created on 19-Jun-2003
 */
public class DifferentiationVisitor extends DeepCopyVisitor
{
	private static final boolean DEBUG = false; 
	private DJep localDJep;
	private DJep globalDJep;
	private NodeFactory nf;
	private TreeUtils tu;
//	private OperatorSet opSet;
  /**
   * Construction with a given set of tree utilities 
   */
  public DifferentiationVisitor(DJep jep)
  {
	this.globalDJep = jep;
	

  }
      
  /** The set of all differentiation rules indexed by name of function. */ 
  Hashtable diffRules = new Hashtable();
  /** Adds the rules for a given function. */
  void addDiffRule(DiffRulesI rule)
  {
	diffRules.put(rule.getName(),rule);
	if(DEBUG) System.out.println("Adding rule for "+rule.getName());
  }
  /** finds the rule for function with given name. */
  DiffRulesI getDiffRule(String name)
  {
	return (DiffRulesI) diffRules.get(name);
  }
  
  /**
   * Prints all the differentiation rules for all functions on System.out.
   */
  public void printDiffRules() { printDiffRules(System.out); }
  
  /**
   * Prints all the differentiation rules for all functions on specified stream.
   */
  public void printDiffRules(PrintStream out)
  {
	out.println("Standard Functions and their derivatives");
	for(Enumeration en = globalDJep.getFunctionTable().keys(); en.hasMoreElements();)
	{
		String key = (String) en.nextElement();
		PostfixMathCommandI value = globalDJep.getFunctionTable().get(key);
		DiffRulesI rule = (DiffRulesI) diffRules.get(key);
		if(rule==null)
			out.print(key+" No diff rules specified ("+value.getNumberOfParameters()+" arguments).");
		else
			out.print(rule.toString());
		out.println();
	}
	for(Enumeration en = diffRules.keys(); en.hasMoreElements();)
		{
			String key = (String) en.nextElement();
			DiffRulesI rule = (DiffRulesI) diffRules.get(key);
			if(!globalDJep.getFunctionTable().containsKey(key))
			{
				out.print(rule.toString());
				out.println("\tnot in JEP function list");
			}
		}
	}

	/**
	 * Differentiates an expression tree wrt a variable var.
	 * @param node the top node of the expression tree
	 * @param var the variable to differentiate wrt
	 * @return the top node of the differentiated expression 
	 * @throws ParseException if some error occurred while trying to differentiate, for instance of no rule supplied for given function.
	 * @throws IllegalArgumentException
	 */
	public Node differentiate(Node node,String var,DJep djep) throws ParseException,IllegalArgumentException
	{
	  this.localDJep = djep;
	  this.nf=djep.getNodeFactory();
	  this.tu=djep.getTreeUtils();
	  //this.opSet=djep.getOperatorSet();
	  
	  if (node == null)
		  throw new IllegalArgumentException("node parameter is null");
	  if (var == null)
		  throw new IllegalArgumentException("var parameter is null");

	  Node res = (Node) node.jjtAccept(this,var);
	  return res;
	}

	/********** Now the recursive calls to differentiate the tree ************/

	/**
	 * Applies differentiation to a function.
	 * Used the rules specified by objects of type {@link DiffRulesI}.
	 * @param node The node of the function.
	 * @param data The variable to differentiate wrt.
	 **/

	public Object visit(ASTFunNode node, Object data) throws ParseException
	{
		String name = node.getName();

	   //System.out.println("FUN: "+ node + " nchild "+nchild);
		Node children[] = TreeUtils.getChildrenAsArray(node);
		Node dchildren[] = acceptChildrenAsArray(node,data);

		if(node.getPFMC() instanceof DiffRulesI)
		{
			 return ((DiffRulesI) node.getPFMC()).differentiate(node,(String) data,children,dchildren,localDJep);
		}
		DiffRulesI rules = (DiffRulesI) diffRules.get(name);
		if(rules != null)
		return rules.differentiate(node,(String) data,children,dchildren,localDJep);

		throw new ParseException("Sorry I don't know how to differentiate "+node+"\n");
	}

	public boolean isConstantVar(XVariable var) {
		if(!var.hasEquation()) return true;
		Node eqn = var.getEquation();
		if(eqn instanceof ASTConstant) return true;
		/* So why would we want a=x to be treated as a constant? */
//		if(eqn instanceof ASTVarNode) {
//			return isConstantVar((XVariable)((ASTVarNode) eqn).getVar());
//		}
		return false;
	}
	 /**
	  * Differentiates a variable. 
	  * May want to alter behaviour when using multi equation as diff(f,x)
	  * might not be zero.
	  * @return a constant node with value 1 if the variable has the same name as data, 0 if the variable has a different name.
	  */
	 public Object visit(ASTVarNode node, Object data) throws ParseException {
	   String varName = (String) data;
	   XVariable var = (XVariable) node.getVar();
	   PartialDerivative deriv=null;
	   if(var instanceof DVariable)
	   {
	   		DVariable difvar = (DVariable) var;
	   		if(varName.equals(var.getName()))
	   			return nf.buildConstantNode(tu.getONE());
		
	   		else if(isConstantVar(var))
	   			return nf.buildConstantNode(tu.getZERO());
			
	   		deriv = difvar.findDerivative(varName,localDJep);
	   }
	   else if(var instanceof PartialDerivative)
	   {
   			if(isConstantVar(var))
   				return nf.buildConstantNode(tu.getZERO());
		
			PartialDerivative pvar = (PartialDerivative) var;
			DVariable dvar = pvar.getRoot();
			deriv = dvar.findDerivative(pvar,varName,localDJep);
				
	   }
	   else
		   throw new ParseException("Encountered non differentiable variable");
	   	
	   Node eqn = deriv.getEquation();
	   if(eqn instanceof ASTVarNode)
	   		return nf.buildVariableNode(((ASTVarNode) eqn).getVar());
	   if(eqn instanceof ASTConstant)
			return nf.buildConstantNode(((ASTConstant)eqn).getValue());

	   return nf.buildVariableNode(deriv);
	 }

	 /**
	  * Differentiates a constant.
	  * @return 0 derivatives of constants are always zero.
	  */
	 public Object visit(ASTConstant node, Object data) throws ParseException {
		return nf.buildConstantNode(tu.getZERO());
	 }
}

/*end*/
/* @author rich
 * Created on 23-Nov-2003
 */
package org.lsmp.djep.djep;

import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;
import java.util.*;
/**
 * A SymbolTable which works with partial derivatives of variables.
 * Closely linked with 
 * {@link DVariableFactory DVariableFactory}
 *   
 * @author Rich Morris
 * Created on 23-Nov-2003
 */
public class DSymbolTable extends XSymbolTable {
	private static final long serialVersionUID = 6350706295032274871L;


	public DSymbolTable(VariableFactory varFac)
	{
		super(varFac);
	}

	/** Creates a new SymbolTable with the same variable factory as this. */
	public SymbolTable newInstance()
	{
		return new DSymbolTable(this.getVariableFactory());
	}

	public PartialDerivative getPartialDeriv(String name,String dnames[])
	{
		DVariable var = (DVariable) getVar(name);
		return var.getDerivative(dnames);
	}
	

	public void clearValues()
	{
		for(Enumeration e = this.elements(); e.hasMoreElements(); ) 
		{
			DVariable var = (DVariable) e.nextElement();
			var.invalidateAll();
		}
	}	
}
/* @author rich
 * Created on 16-Nov-2003
 */
package org.lsmp.djep.djep;
import org.lsmp.djep.djep.diffRules.DivideDiffRule;
import org.lsmp.djep.djep.diffRules.MacroDiffRules;
import org.lsmp.djep.djep.diffRules.MacroFunctionDiffRules;
import org.lsmp.djep.djep.diffRules.MultiplyDiffRule;
import org.lsmp.djep.djep.diffRules.PassThroughDiffRule;
import org.lsmp.djep.djep.diffRules.PowerDiffRule;
import org.lsmp.djep.djep.diffRules.SubtractDiffRule;
import org.lsmp.djep.xjep.*;
import org.nfunk.jep.*;
/**
 * Adds differentation facilities to JEP.
 * For example
 * <pre>
 * DJep j = new DJep();
 * j.addStandardDiffRules();
 * ....
 * Node node = j.parse("x^3");
 * Node diff = j.differentiate(node,"x");
 * Node simp = j.simplify(diff);
 * j.println(simp);
 * Node node2 = j.parse("diff(x^4,x)");
 * Node proc = j.preprocess(node2);
 * Node simp2 = j.simplify(proc);
 * j.println(simp2);
 * </pre>
 * @author Rich Morris
 * Created on 16-Nov-2003
 */
public class DJep extends XJep {
	protected DifferentiationVisitor dv = new DifferentiationVisitor(this);
	/**
	 * Standard constructor.
	 * Use this instead of JEP or XJep if differentation facilities are required.
	 */
	public DJep()
	{
		this.pv = new DPrintVisitor();
//		this.vf = ;
		this.symTab = new DSymbolTable(new DVariableFactory());

		addFunction("diff",new Diff());
		
		//addDiffRule(new AdditionDiffRule("+"));
		addDiffRule(new PassThroughDiffRule("+",this.getOperatorSet().getAdd().getPFMC()));
		addDiffRule(new SubtractDiffRule("-"));
		addDiffRule(new MultiplyDiffRule("*"));
		addDiffRule(new DivideDiffRule("/"));
		addDiffRule(new PowerDiffRule("^"));
		addDiffRule(new PassThroughDiffRule("UMinus",this.getOperatorSet().getUMinus().getPFMC()));

	}
	/**
	 * Differentiate an equation with respect to a variable.
	 * @param node top node of the expression tree to differentiate.
	 * @param name differentiate with respect to this variable.
	 * @return the top node of a new parse tree representing the derivative.
	 * @throws ParseException if for some reason equation cannot be differentiated,
	 * usually if it has not been taught how to differentiate a particular function.
	 */
	public Node differentiate(Node node,String name) throws ParseException
	{
		return dv.differentiate(node,name,this);
	}
	protected DJep(DJep j)
	{
		super(j);
		this.dv=j.dv;
		
	}

	public XJep newInstance()
	{
		DJep newJep = new DJep(this);
		return newJep;
	}
	public XJep newInstance(SymbolTable st)
	{
		DJep newJep = new DJep(this);
		newJep.symTab = st;
		return newJep;
	}

	/** 
	 * Returns the visitor used for differentiation. Allows more advanced functions.
	 */
	public DifferentiationVisitor getDifferentationVisitor() { return dv; }
	
	 /** 
	   * Adds the standard set of differentation rules. 
	   * Corresponds to all standard functions in the JEP plus a few more.
	   * <pre>
	   * sin,cos,tan,asin,acos,atan,sinh,cosh,tanh,asinh,acosh,atanh
	   * sqrt,log,ln,abs,angle
	   * sum,im,re are handled separately.
	   * rand and mod currently un-handled
	   * 
	   * Also adds rules for functions not in JEP function list:
	   * 	sec,cosec,cot,exp,pow,sgn 
	   * 
	   * TODO include if, min, max, sgn
	   * </pre>
	   * @return false on error
	   */
	  public boolean addStandardDiffRules()
	  {
	  	try
	  	{
	  		addDiffRule(new MacroDiffRules(this,"sin","cos(x)"));
			addDiffRule(new MacroDiffRules(this,"cos","-sin(x)")); 	
			addDiffRule(new MacroDiffRules(this,"tan","1/((cos(x))^2)"));

			
			addDiffRule(new MacroDiffRules(this,"sec","sec(x) * tan(x)"));
			addDiffRule(new MacroDiffRules(this,"cosec","-cosec(x) * cot(x)"));
			addDiffRule(new MacroDiffRules(this,"cot","-(cosec(x))^2"));
				
			addDiffRule(new MacroDiffRules(this,"asin","1/(sqrt(1-x^2))"));
			addDiffRule(new MacroDiffRules(this,"acos","-1/(sqrt(1-x^2))"));
			addDiffRule(new MacroDiffRules(this,"atan","1/(1+x^2)"));

			addDiffRule(new MacroDiffRules(this,"sinh","cosh(x)"));
			addDiffRule(new MacroDiffRules(this,"cosh","sinh(x)"));
			addDiffRule(new MacroDiffRules(this,"tanh","1-(tanh(x))^2"));

			addDiffRule(new MacroDiffRules(this,"asinh","1/(sqrt(1+x^2))"));
			addDiffRule(new MacroDiffRules(this,"acosh","1/(sqrt(x^2-1))"));
			addDiffRule(new MacroDiffRules(this,"atanh","1/(1-x^2)"));

			addDiffRule(new MacroDiffRules(this,"sqrt","1/(2 (sqrt(x)))"));
			
			addDiffRule(new MacroDiffRules(this,"exp","exp(x)"));
//			this.addFunction("pow",new Pow());
//			addDiffRule(new MacroDiffRules(this,"pow","y*(pow(x,y-1))","(ln(x)) (pow(x,y))"));
			addDiffRule(new MacroDiffRules(this,"ln","1/x"));
			addDiffRule(new MacroDiffRules(this,"log",	// -> (1/ln(10)) /x = log(e) / x but don't know if e exists
				this.getNodeFactory().buildOperatorNode(this.getOperatorSet().getDivide(),
					this.getNodeFactory().buildConstantNode(
						this.getTreeUtils().getNumber(1/Math.log(10.0))),
					this.getNodeFactory().buildVariableNode(this.getSymbolTable().makeVarIfNeeded("x")))));
			// TODO problems here with using a global variable (x) in an essentially local context
			addDiffRule(new MacroDiffRules(this,"abs","abs(x)/x"));
			addDiffRule(new MacroDiffRules(this,"atan2","-y/(x^2+y^2)","x/(x^2+y^2)"));
			addDiffRule(new MacroDiffRules(this,"mod","1","0"));
			addDiffRule(new PassThroughDiffRule(this,"sum"));
			addDiffRule(new PassThroughDiffRule(this,"re"));
			addDiffRule(new PassThroughDiffRule(this,"im"));
			addDiffRule(new PassThroughDiffRule(this,"rand"));
			
			MacroFunction cmplx = (MacroFunction) this.getFunctionTable().get("macrocomplex");
			if(cmplx!=null)
			    addDiffRule(new MacroFunctionDiffRules(this,cmplx));
			
	/*		addDiffRule(new PassThroughDiffRule("\"<\"",this.getOperatorSet().getLT().getPFMC()));
			addDiffRule(new PassThroughDiffRule("\">\"",new Comparative(1)));
			addDiffRule(new PassThroughDiffRule("\"<=\"",new Comparative(2)));
			addDiffRule(new PassThroughDiffRule("\">=\"",new Comparative(3)));
			addDiffRule(new PassThroughDiffRule("\"!=\"",new Comparative(4)));
			addDiffRule(new PassThroughDiffRule("\"==\"",new Comparative(5)));
	*/		
//			addDiffRule(new DiffDiffRule(this,"diff"));
			// TODO do we want to add eval here?
//			addDiffRule(new EvalDiffRule(this,"eval",eval));
			
			//addDiffRule(new PassThroughDiffRule("\"&&\""));
			//addDiffRule(new PassThroughDiffRule("\"||\""));
			//addDiffRule(new PassThroughDiffRule("\"!\""));
			
			// also consider if, min, max, sgn, dot, cross, 
			//addDiffRule(new MacroDiffRules(this,"sgn","0"));
			return true;
	  	}
	  	catch(ParseException e)
	  	{
	  		System.err.println(e.getMessage());
	  		return false;
	  	}
	  }

	/**
	 * Adds a rule with instruction on how to differentiate a function.
	 * @param rule
	 */
	public void addDiffRule(DiffRulesI rule) {
		dv.addDiffRule(rule);
	}

}
/* @author rich
 * Created on 19-Dec-2003
 */
package org.lsmp.djep.djep;

import org.nfunk.jep.Variable;
import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;
/**
 * A VariableFactory which can work with PartialDerivatives.
 * @author Rich Morris
 * Created on 19-Dec-2003
 */
public class DVariableFactory extends XVariableFactory {

	/** Creates a partial derivative of a given variable. */
	public PartialDerivative createDerivative(DVariable var, String[] dnames,Node eqn) {
		return new PartialDerivative(var,dnames,eqn);
	}

	public Variable createVariable(String name, Object value) {
		return new DVariable(name,value);
	}

	public Variable createVariable(String name) {
		if(defaultValue!=null)
			return new DVariable(name,defaultValue);
		else
			return new DVariable(name);
	}

}
/* @author rich
 * Created on 29-Oct-2003
 */
package org.lsmp.djep.djep;
import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;

import java.util.Observable;
import java.util.Observer;
/**
 * Contains infomation about a PartialDerivative of a variable.
 * Should  
 * @author Rich Morris
 * Created on 29-Oct-2003
 */
public class PartialDerivative extends XVariable  implements Observer {

	private DVariable root;
	private String dnames[] = null;
	private String printString;
	/**
	 * Protected constructor, should only be constructed
	 * through the findDerivative method in {@link DVariable DVariable}.
	**/ 
	protected PartialDerivative(DVariable var, String derivnames[])
	{
		super(var.getName());
		root = var;
		dnames = derivnames;
		printString = DVariable.makeDerivString(root.getName(),derivnames);
		root.addObserver(this);
	}
	
	protected PartialDerivative(DVariable var, String derivnames[],Node deriv)
	{
		this(var,derivnames);
		/*TODO could be a little cleverer just have a 
		 * partial derivative which is a constant dy/dx = 1
		 * don't use an equation, instead use a value.
		 * 
		if(deriv instanceof ASTConstant) {
			System.out.println("Warning constant derivative "+printString+"="+((ASTConstant) deriv).getValue());
			this.setValue(((ASTConstant) deriv).getValue());
		}
		else
		*/
			setEquation(deriv);
	}
	
	public String getName() { return printString; }
	
	/**
	 * Every partial derivative has a root variable
	 * for instance the root variable of dy/dx is y.
	 * This method returns than variable.
	 */
	public DVariable getRoot() { return root; }
	public String[] getDnames() { return dnames; }

	public String toString()
	{
		return printString;
	}
	
	public PartialDerivative findDerivative(String dname,DJep jep)
		throws ParseException
	{
		return root.findDerivative(this,dname,jep);
	}
	
	
	/**
	 * When the value of the root object is changed
	 * makes the value of this partial derivative invalid.
	 * 
	 * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
	 */
	public void update(Observable arg0, Object arg1) {
		if(root.equals(arg0))
		{
			setValidValue(false);
		}
	}

}
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep.diffRules;

import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.djep.DiffRulesI;
import org.nfunk.jep.ASTFunNode;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;


/**
	 * Diffrentiates a subtaction with respect to var.
	 * diff(y-z,x) -> diff(y,x)-diff(z,x)
	 */
  public class SubtractDiffRule implements DiffRulesI
  {
	private String name;

	private SubtractDiffRule() {}
	public SubtractDiffRule(String inName)
	{	  
	  name = inName;
	}

	public String toString()
	{	  return name + "  \t\tdiff(f-g,x) -> diff(f,x)-diff(g,x)";  }
	public String getName() { return name; }
  	
	public Node differentiate(ASTFunNode node,String var,Node [] children,Node [] dchildren,DJep djep) throws ParseException
	{
	  int nchild = node.jjtGetNumChildren();
	  if(nchild==2) 
		  return djep.getNodeFactory().buildOperatorNode(djep.getOperatorSet().getSubtract(),dchildren[0],dchildren[1]);
	  else if(nchild==1)
		  return djep.getNodeFactory().buildOperatorNode(djep.getOperatorSet().getUMinus(),dchildren[0]);
	  else
		  throw new ParseException("Too many children "+nchild+" for "+node+"\n");
	}
  } /* end SubtractDiffRule */
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep.diffRules;

import org.nfunk.jep.*;
import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.djep.DiffRulesI;
import org.lsmp.djep.xjep.*;

/**
   * Diffrentiates a product with respect to var.
   * diff(y*z,x) -> diff(y,x)*z+y*diff(z,x)
   * @since 28/1/05 now works when multiply has more than two arguments.
   */
  public class MultiplyDiffRule implements DiffRulesI
  {
	private String name;
	//private DifferentationVisitor dv;

	private MultiplyDiffRule() {}
	public MultiplyDiffRule(String inName)
	{	  
	  //dv = inDv;
	  name = inName;
	}
	Operator mulOp=null;
	public MultiplyDiffRule(String inName,Operator op)
	{	  
	  //dv = inDv;
	  name = inName;
	  mulOp = op;
	}

	public String toString()
	{	  return name + "  \t\tdiff(f*g,x) -> diff(f,x)*g+f*diff(g,x)";  }
	public String getName() { return name; }
  	
	public Node differentiate(ASTFunNode node,String var,Node [] children,Node [] dchildren,DJep djep) throws ParseException
	{
		OperatorSet opset = djep.getOperatorSet();
		NodeFactory nf = djep.getNodeFactory();
		Operator op = opset.getMultiply();
		if(mulOp!=null) op = mulOp;
		
	  int nchild = node.jjtGetNumChildren();
	  if(nchild==2) 
		  return nf.buildOperatorNode(opset.getAdd(),
			nf.buildOperatorNode(op,
			  dchildren[0],
			  djep.deepCopy(children[1])),
			nf.buildOperatorNode(op,
			  djep.deepCopy(children[0]),
			  dchildren[1]));
	  
	  	Node sums[] = new Node[nchild];
	  	for(int i=0;i<nchild;++i)
	  	{
	  		Node terms[] = new Node[nchild];
	  		for(int j=0;j<nchild;++j)
	  			terms[j] = children[j];
	  		terms[i] = dchildren[i];
			sums[i] = nf.buildOperatorNode(op,terms);
	  	}
	  	Node res = nf.buildOperatorNode(opset.getAdd(),sums);
	  	return res;
	  
	  //throw new ParseException("Too many children "+nchild+" for "+node+"\n");
	}
  } /* end MultiplyDiffRule */
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep.diffRules;

import org.nfunk.jep.ASTFunNode;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.djep.DiffRulesI;
import org.lsmp.djep.xjep.*;

/**
   * Differentiates a division with respect to var.
   * diff(y/z,x) -> (diff(y,x)*z-y*diff(z,x))/(z*z)
   */
  public class DivideDiffRule implements DiffRulesI
  {
	private String name;
	
	private DivideDiffRule() {}
	public DivideDiffRule(String inName)
	{	  
	  name = inName;
	}

	public String toString()
	{	  return name + "  \t\tdiff(f/g,x) -> (diff(f,x)*g-f*diff(g,x))/(g*g)";  }
	public String getName() { return name; }
  	
	public Node differentiate(ASTFunNode node,String var,Node [] children,Node [] dchildren,DJep djep) throws ParseException
	{
	  XOperatorSet op = (XOperatorSet) djep.getOperatorSet();
	  NodeFactory nf = djep.getNodeFactory();
	  
	  int nchild = node.jjtGetNumChildren();
	  if(nchild==2) return 
			nf.buildOperatorNode(op.getDivide(),
			  nf.buildOperatorNode(op.getSubtract(),
				nf.buildOperatorNode(op.getMultiply(),
				  dchildren[0],
				  djep.deepCopy(children[1])),
				nf.buildOperatorNode(op.getMultiply(),
				  djep.deepCopy(children[0]),
				  dchildren[1])),
			  nf.buildOperatorNode(op.getMultiply(),
				djep.deepCopy(children[1]),
				djep.deepCopy(children[1])));
	  
	  throw new ParseException("Too many children "+nchild+" for "+node+"\n");
	}
  } /* end DivideDiffRule */
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep.diffRules;

import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.xjep.*;
import org.nfunk.jep.*;

/**
   * If your really lazy, you don't even need to workout the derivatives
   * of a function defined by a macro yourself.
   * This class will automatically calculate the rules for you.
   */
  public class MacroFunctionDiffRules extends ChainRuleDiffRules
  {
	/**
	 * Calculates the rules for the given function.
	 */
	  public MacroFunctionDiffRules(DJep djep,MacroFunction fun)  throws ParseException
	  {
		  name = fun.getName();
		  pfmc = fun;
		  
		XSymbolTable localSymTab = (XSymbolTable) ((XSymbolTable) djep.getSymbolTable()).newInstance(); //new SymbolTable();
		localSymTab.copyConstants(djep.getSymbolTable());
		DJep localJep = (DJep) djep.newInstance(localSymTab);

		  int nargs = fun.getNumberOfParameters();
		  rules = new Node[nargs];
		  if(nargs == 1)
			  rules[0] = localJep.differentiate(fun.getTopNode(),"x");
		  else if(nargs == 2)
		  {
			  rules[0] = localJep.differentiate(fun.getTopNode(),"x");
			  rules[1] = localJep.differentiate(fun.getTopNode(),"y");
		  }
		  else
		  {
			  for(int i=0;i<nargs;++i)
				  rules[i] = localJep.differentiate(fun.getTopNode(),"x"+ String.valueOf(i));
		  }
		  for(int i=0;i<nargs;++i)
				rules[i] = localJep.simplify(rules[i]);
		  //fixVarNames();
	  }
  }
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep.diffRules;

import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.djep.DiffRulesI;
import org.nfunk.jep.ASTFunNode;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommandI;


/**
   * Rules like Sum where diff(sum(a,b,c),x) -> sum(da/dx,db/dx,dc/dx) are instance of this class.
   **/
  public class PassThroughDiffRule implements DiffRulesI
  {
	private String name;
	private PostfixMathCommandI pfmc;

	private PassThroughDiffRule() {}
	public PassThroughDiffRule(DJep djep,String inName)
	{	  
	  name = inName;
	  pfmc = djep.getFunctionTable().get(name);
	}
	public PassThroughDiffRule(String inName,PostfixMathCommandI inPfmc)
	{
		name = inName;
		pfmc = inPfmc; 
	}
	public String toString()
	{
		if(pfmc==null)
		{
			return "" + name +"\t\tPassthrough but no math command!"; 
		}
		switch(pfmc.getNumberOfParameters())
		{
		case 0:
			return name + "  \t\tdiff("+name+",x) -> "+name;
		case 1:
			return name + "  \tdiff("+name+"(a),x) -> "+name+"(da/dx)";
		case 2:
			return name + "  \tdiff("+name+"(a,b),x) -> "+name+"(da/dx,db/dx)";
		default:
			return name + "  \tdiff("+name+"(a,b,...),x) -> "+name+"(da/dx,db/dx,...)";
		}
	}
	public String getName() { return name; }
  	  	
	public Node differentiate(ASTFunNode node,String var,Node [] children,Node [] dchildren,DJep djep) throws ParseException
	{
		return djep.getNodeFactory().buildFunctionNode(node,dchildren);
	}
  }
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep.diffRules;

import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.djep.DiffRulesI;
import org.lsmp.djep.xjep.*;
import org.nfunk.jep.*;


/**
	* Diffrentiates a power with respect to var.
	* If m is a a number 
	* diff(y^m,x) -> m * y^(m-1)
	* otherwise
	* diff(y^z,x) -> z * y^(z-1) * diff(y,x) + y^z * ln(z) * diff(z,x) 
	*/

 public class PowerDiffRule implements DiffRulesI
 {
	private String name;
	private PowerDiffRule() {}
	public PowerDiffRule(String inName)
	{	  
	  name = inName;
	}

  public String toString()
  {	  return name + "  \t\tdiff(f*g,x) -> diff(f,x)*g+f*diff(g,x)";  }
  public String getName() { return name; }
  	
  public Node differentiate(ASTFunNode node,String var,Node [] children,Node [] dchildren,DJep djep) throws ParseException
  {
	OperatorSet op = djep.getOperatorSet();
	NodeFactory nf = djep.getNodeFactory();
	TreeUtils tu = djep.getTreeUtils();
	FunctionTable funTab = djep.getFunctionTable();
	
	int nchild = node.jjtGetNumChildren();
	if(nchild!=2) 
		throw new ParseException("Too many children "+nchild+" for "+node+"\n");
	//	x^y -> 	n*(pow(x,y-1)) x' + ln(y) pow(x,y) y'

	if(tu.isConstant(children[1]))
	{
	   ASTConstant c = (ASTConstant) children[1];
	   Object value = c.getValue();
	   if(value instanceof Double)
	   {	// x^m -> m * x^(m-1) * x'
//	   	Node  a = TreeUtils.deepCopy(children[1]);
//	   	Node b = TreeUtils.deepCopy(children[0]);
//	   	Node cc = TreeUtils.createConstant( ((Double) value).doubleValue()-1.0);
//	   	Node d = opSet.buildPowerNode(b,cc);
//	   	Node e = opSet.buildMultiplyNode(a,d);

		 return nf.buildOperatorNode(op.getMultiply(),
		   djep.deepCopy(children[1]),
		   nf.buildOperatorNode(op.getMultiply(),
			nf.buildOperatorNode(op.getPower(),
			   djep.deepCopy(children[0]),
		   nf.buildConstantNode( tu.getNumber(((Double) value).doubleValue()-1.0))),
			 dchildren[0]));
	   }
	   
		 return nf.buildOperatorNode(op.getMultiply(),
			djep.deepCopy(children[1]),
			nf.buildOperatorNode(op.getMultiply(),
				nf.buildOperatorNode(op.getPower(),
				   djep.deepCopy(children[0]),
				   nf.buildOperatorNode(op.getSubtract(),
				 	djep.deepCopy(children[1]),
				 	nf.buildConstantNode(tu.getONE()))),
			 dchildren[0]));
	   
   }
   // z * y^(z-1) * diff(y,x) + y^z * ln(z) * diff(z,x) 
   {
		return nf.buildOperatorNode(op.getAdd(),  
			nf.buildOperatorNode(op.getMultiply(), // z * y^(z-1) * diff(y,x)
				nf.buildOperatorNode(op.getMultiply(), // z * y^(z-1)
					djep.deepCopy(children[1]), // z
					nf.buildOperatorNode(op.getPower(), // y^(z-1)
						djep.deepCopy(children[0]), // y
						nf.buildOperatorNode(op.getSubtract(), // z-1
							djep.deepCopy(children[1]), // z
							djep.getNodeFactory().buildConstantNode(tu.getONE()) ))),
				dchildren[0]), // diff(y,x)
			nf.buildOperatorNode(op.getMultiply(), //  + y^z * ln(z) * diff(z,x)
				nf.buildOperatorNode(op.getMultiply(), 
					nf.buildOperatorNode(op.getPower(), // y^z
						djep.deepCopy(children[0]), 
						djep.deepCopy(children[1])),
					djep.getNodeFactory().buildFunctionNode("ln",funTab.get("ln"), // ln(z)
						new Node[]{djep.deepCopy(children[0])})),
				dchildren[1]));
				// TODO will NaturalLog always have the name "ln"
   }
 }
 }
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep.diffRules;

import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.djep.DiffRulesI;
import org.nfunk.jep.ASTFunNode;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;

/**
   * Differentiates a addition with respect to var.
   * diff(y+z,x) -> diff(y,x)+diff(z,x)
   */
public class AdditionDiffRule implements DiffRulesI
{
  private String name;

  /** private default constructor, a name must always be specified. */
  private AdditionDiffRule() { /* nothing happening */ 	}
  
  public AdditionDiffRule(String inName)
  {	  
	name = inName;
  }

  public String toString()
  {	  return name + "  \t\tdiff(f+g,x) -> diff(f,x)+diff(g,x)";  }
  public String getName() { return name; }
  	
  public Node differentiate(ASTFunNode node,String var,Node [] children,Node [] dchildren,DJep djep) throws ParseException
  {
	int nchild = node.jjtGetNumChildren();
	if(nchild!=2) 
		throw new ParseException("Too many children "+nchild+" for "+node+"\n");
	return djep.getNodeFactory().buildOperatorNode(djep.getOperatorSet().getAdd(),dchildren[0],dchildren[1]);
  }
}
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep.diffRules;

import org.nfunk.jep.*;
import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.xjep.*;
import org.nfunk.jep.function.PostfixMathCommandI;


/**
   * Rules are specfied by a set of strings or trees of nodes.
   * The standard chain rule is applied
   * <pre>diff(f(g(x),h(x)),x) -> df/dg dg/dx + df/dh dh/dx</pre> 
   * for example 
   * <pre>
   * DifferentiationVisitor dv = new DifferentiationVisitor(new TreeUtils(jep));
   * DiffRulesI rule = new MacroDiffRules(dv,"sin","cos(x)");
   * </pre>
   **/
  public class MacroDiffRules extends ChainRuleDiffRules
  {
	/**
	 * Create a differention rule for function with 1 argument
	 * @param inName	name of function
	 * @param node		a tree represention differation of function wrt "x"
	 * @throws ParseException
	 */
	
	public MacroDiffRules(DJep djep,String inName,Node node) throws ParseException
	{
		name = inName;
		pfmc = djep.getFunctionTable().get(inName);
		if(pfmc!=null)
		{
			int nParam = pfmc.getNumberOfParameters();
			if(nParam != 1)
				throw new ParseException("Number of rules must match number of parameters for "+inName+" which is "+nParam);
		}
		rules = new Node[1];
		rules[0] = node;
		//fixVarNames();
	}
  	
	/**
	 * Create a differention rule for function with 1 argument
	 * @param inName	name of function
	 * @param rule		a string represention differation of a function wrt "x"
	 * @throws ParseException
	 */
	public MacroDiffRules(DJep djep,String inName,String rule) throws ParseException
	{
		this(djep,inName,djep.getFunctionTable().get(inName),rule);
	} 	

	/**
	 * Create a differention rule for function with 1 argument
	 * @param inName	name of function
	 * @param inPfmc	PostfixMathCommandI for function
	 * @param rule		a string represention differation of function wrt "x"
	 * @throws ParseException
	 */
	public MacroDiffRules(DJep djep,String inName,PostfixMathCommandI inPfmc,String rule) throws ParseException
	{
		//super(dv);
		name = inName;
		pfmc = inPfmc;
		if(pfmc!=null)
		{
			int nParam = pfmc.getNumberOfParameters();
			if(nParam != 1)
				throw new ParseException("Number of rules must match number of parameters for "+inName+" which is "+nParam);
		}
		XSymbolTable localSymTab = (XSymbolTable) ((XSymbolTable) djep.getSymbolTable()).newInstance(); //new SymbolTable();
		localSymTab.copyConstants(djep.getSymbolTable());
		XJep localJep = djep.newInstance(localSymTab);
		Node node = localJep.parse(rule);
		rules = new Node[1];
		rules[0] = node;
		//fixVarNames();
	}

	/**
	 * Create a differention rule for function with 2 arguments.
	 * The rules must be in terms of "x" and "y"
	 * @param inName	name of function
	 * @param inPfmc	PostfixMathCommandI for function
	 * @param rule1		a string represention differation of function wrt "x"
	 * @param rule2		a string represention differation of function wrt "y"
	 * @throws ParseException
	 */
	public MacroDiffRules(DJep djep,String inName,PostfixMathCommandI inPfmc,String rule1,String rule2) throws ParseException
	{
		//super(dv);
		name = inName;
		pfmc = inPfmc;
		if(pfmc!=null)
		{
			int nParam = pfmc.getNumberOfParameters();
			if(nParam != 2)
			throw new ParseException("Number of rules must match number of parameters for "+inName+" which is "+nParam);
		}
		XSymbolTable localSymTab = (XSymbolTable) ((XSymbolTable) djep.getSymbolTable()).newInstance(); //new SymbolTable();
		localSymTab.copyConstants(djep.getSymbolTable());
		XJep localJep = djep.newInstance(localSymTab);
		Node node1 = localJep.parse(rule1);
		Node node2 = localJep.parse(rule2);
		rules = new Node[2];
		rules[0] = node1;
		rules[1] = node2;
		//fixVarNames();
	}
	
	/**
	 * Create a differention rule for function with 2 arguments.
	 * The rules must be in terms of "x" and "y"
	 * @param inName	name of function
	 * @param rule1		a string represention differation of function wrt "x"
	 * @param rule2		a string represention differation of function wrt "y"
	 * @throws ParseException
	 */
	public MacroDiffRules(DJep djep,String inName,String rule1,String rule2) throws ParseException
	{
		this(djep,inName,djep.getFunctionTable().get(inName),rule1,rule2);
	}

	/**
	 * Create a differention rule for function with 2 arguments.
	 * The rules must be in terms of "x" and "y"
	 * @param inName	name of function
	 * @param inPfmc	PostfixMathCommandI for function
	 * @param node1		a expression tree represention differation of function wrt "x"
	 * @param node2		a expression tree represention differation of function wrt "y"
	 * @throws ParseException
	 */
/*	public MacroDiffRules(DJep djep,String inName,PostfixMathCommandI inPfmc,Node node1,Node node2) throws ParseException
	{
	  //super(dv);
		name = inName;
		pfmc = inPfmc;
		if(pfmc!=null)
		{
			int nParam = pfmc.getNumberOfParameters();
			if(nParam != 2)
			throw new ParseException("Number of rules must match number of parameters for "+inName+" which is "+nParam);
		}
		rules = new Node[2];
		rules[0] = node1;
		rules[1] = node2;
		//fixVarNames();
	}
*/	
	/**
	 * Create a differention rule for function with 2 arguments.
	 * The rules must be in terms of "x" and "y"
	 * @param inName	name of function
	 * @param node1		a expression tree represention differation of function wrt "x"
	 * @param node2		a expression tree represention differation of function wrt "y"
	 * @throws ParseException
	 */
/*	public MacroDiffRules(DJep djep,String inName,Node node1,Node node2) throws ParseException
	{
		this(djep,inName,djep.getFunctionTable().get(inName),node1,node2);
	}
*/	/**
	 * Create a differentation rule for function with n arguments.
	 * The rules must be in terms of "x1", "x2", ... "xn"
	 * @param inName	name of function
	 * @param inPfmc	PostfixMathCommandI for function
	 * @throws ParseException
	 */
	public MacroDiffRules(DJep djep,String inName,PostfixMathCommandI inPfmc,String[] inRules) throws ParseException
	{
		name = inName;
		pfmc = inPfmc;
		if(pfmc!=null)
		{
			int nParam = pfmc.getNumberOfParameters();
			if(nParam != inRules.length)
			throw new ParseException("Number of rules must match number of parameters for "+inName+" which is "+nParam);
		}
		
		XSymbolTable localSymTab = (XSymbolTable) ((XSymbolTable) djep.getSymbolTable()).newInstance(); //new SymbolTable();
		localSymTab.copyConstants(djep.getSymbolTable());
		XJep localJep = djep.newInstance(localSymTab);

		rules = new Node[inRules.length];
		for(int i=0;i<inRules.length;++i)
		{
			rules[i] = localJep.parse(inRules[i]);
		}
		//fixVarNames();
	}

	/**
	 * Create a differentation rule for function with n arguments.
	 * The rules must be in terms of "x1", "x2", ... "xn"
	 * @param inName	name of function
	 * @param inRules	an array of strings representation differentation of function wrt "x1",...
	 * @throws ParseException
	 */
	public MacroDiffRules(DJep djep,String inName,String[] inRules) throws ParseException
	{
		this(djep,inName,djep.getFunctionTable().get(inName),inRules);
	}
	/**
	 * Create a differentation rule for function with n arguments.
	 * The rules must be in terms of "x1", "x2", ... "xn"
	 * @param inName	name of function
	 * @param inPfmc	PostfixMathCommandI for function
	 * @param inRule	an array of expression trees representation differentation of function wrt "x1",...
	 * @throws ParseException
	 */
/*	public MacroDiffRules(DJep djep,String inName,PostfixMathCommandI inPfmc,Node[] inRules) throws ParseException
	{
		//super(dv);
		name = inName;
		pfmc = inPfmc;
		if(pfmc!=null)
		{
			int nParam = pfmc.getNumberOfParameters();
			if(nParam != inRules.length)
				throw new ParseException("Number of rules must match number of parameters for "+inName+" which is "+nParam);
		}
		rules = inRules;
		//fixVarNames();
	}
*/	
	/**
	 * Create a differentation rule for function with n arguments.
	 * The rules must be in terms of "x1", "x2", ... "xn"
	 * @param inName	name of function
	 * @param inRules	an array of expression trees representation differentation of function wrt "x1",...
	 * @throws ParseException
	 */
/*	public MacroDiffRules(DJep djep,String inName,Node[] inRules) throws ParseException
	{
		this(djep,inName,djep.getFunctionTable().get(inName),inRules);
	}
*/	
  } /* end MacroDiffRules */
/* @author rich
 * Created on 04-Jul-2003
 */
package org.lsmp.djep.djep.diffRules;

import org.lsmp.djep.djep.DJep;
import org.lsmp.djep.djep.DiffRulesI;
import org.lsmp.djep.xjep.*;
import org.nfunk.jep.ASTFunNode;
import org.nfunk.jep.*;
import org.nfunk.jep.function.PostfixMathCommandI;


/**
 * Common methods used when the rules are specified by node trees or strings.
 *  All subclasses use the chain rule to differentiate.
 *  df(g(x),h(x))/dx -> df/dg * dg/dx + df/dh * dh/dx
 *  Variable names MUST be x,y for 1 to 2 variables or
 *  x1,x2,x3 for 3 for more variables.
 */
public abstract class ChainRuleDiffRules implements DiffRulesI
{
	protected String name;
	protected PostfixMathCommandI pfmc;
	protected Node rules[]=null;
//	protected DifferentationVisitor dv;
//	protected OperatorSet opSet;
//	protected NodeFactory nf;
	/** Cannot construct outside the context of a differentation visitor. */
	public ChainRuleDiffRules() {}
	
	/** returns the name of the function */
	public String getName() { return name; }
	/** returns the PostfixMathCommandI for the function. */
	public PostfixMathCommandI getPfmc() { return pfmc; }
	/** Returns the number of rules which should be number of arguments of function */
	public int getNumRules() { return rules.length; }
	/** returns the i-th rule as an expression tree. */
	public Node getRule(int i) { return rules[i]; }
	
	/**
	 *  Use the chain rule to differentiate.
	 *  df(g(x),h(x))/dx -> df/dg * dg/dx + df/dh * dh/dx
	 */
	public Node differentiate(ASTFunNode node,String var,Node [] children,Node [] dchildren,DJep djep) throws ParseException
	{
		XOperatorSet opSet= (XOperatorSet) djep.getOperatorSet();
		NodeFactory nf=djep.getNodeFactory();
		FunctionTable funTab = djep.getFunctionTable();
		
		int nRules = rules.length;
		if(nRules != children.length)
			throw new ParseException("Error differentiating "+name+" number of rules "+nRules+" != number of arguments "+children.length);
		
		if(nRules ==1)
		{
			// df(g(x))/dx -> f'(g(x)) * g'(x)
			Node fprime = djep.deepCopy(rules[0]);
			Node g = children[0];
			Node fprimesub = djep.substitute(fprime,"x",g);
			Node gprime = dchildren[0];
			return nf.buildOperatorNode(opSet.getMultiply(),fprimesub,gprime);
		}
		else if(nRules == 2)
		{
			//	df(g(x),h(x))/dx -> df/dg * dg/dx + df/dh * dh/dx
			Node df_dg = djep.deepCopy(rules[0]);
			Node df_dh = djep.deepCopy(rules[1]);
			//Node replacements[] = new Node[]{children[0],children[1]};
			Node gprime = dchildren[0];
			Node hprime = dchildren[1];
			df_dg = djep.substitute(df_dg,new String[]{"x","y"},children);
			df_dh = djep.substitute(df_dh,new String[]{"x","y"},children);
	//		df_dg = dv.djep.substitute(df_dg,"@2",h);
	//		df_dh = dv.djep.substitute(df_dh,"@1",g);
	//		df_dh = dv.djep.substitute(df_dh,"@2",h);

			return nf.buildOperatorNode(opSet.getAdd(),
				nf.buildOperatorNode(opSet.getMultiply(),df_dg,gprime),
				nf.buildOperatorNode(opSet.getMultiply(),df_dh,hprime));
		}
		else if(nRules < 1)
		{
			throw new ParseException("Error differentiating "+name+" zero differention rules!");
		}
		else
		{
			String names[]=new String[nRules];
			Node[] df_dg = new Node[nRules];
			Node[] products = new Node[nRules];
			for(int i=0;i<nRules;++i)
			{
				df_dg[i]=djep.deepCopy(rules[i]);
				names[i]="x"+i;
			}
			for(int i=0;i<nRules;++i)
			{
				df_dg[i] = djep.substitute(df_dg[i],names,children);
				products[i] = nf.buildOperatorNode(opSet.getMultiply(),df_dg[i],dchildren[i]); 
			}
			return nf.buildFunctionNode("sum",funTab.get("sum"),products);
		}
	}

	public String toString()
	{
		StringBuffer sb = new StringBuffer();
		sb.append(name + "  \t");
		if(rules==null)
			sb.append("no diff rules possible parse error?");
		else
			for(int i=0;i<getNumRules();++i)
			{
				sb.append("\t");
				//sb.append(dv.djep.toString(getRule(i)));
				//TODO print the rule.
			}
		return sb.toString();
	}
	/**
	 * Changes the names of variables in the rules to make the chain rule easier.
	 * Substitutes the variable x,y with @1,@2 and x1,x2,x3,... with @1,@2,@3,...
	 * @throws ParseException
	 */
/*	protected void fixVarNames() throws ParseException
	{
		NameChangeVisitor nc = new NameChangeVisitor(dv.djep);
		int nrules = this.getNumRules();
		if(nrules==0) return;
		else if(nrules == 1)
			rules[0] = nc.changeNames(rules[0],new String[]{"x"},new String[]{"@1"});
		else if(nrules == 2)
		{
			rules[0] = nc.changeNames(rules[0],new String []{"x","y"},new String []{"@1","@2"});
			rules[1] = nc.changeNames(rules[1],new String []{"x","y"},new String []{"@1","@2"});
		}
		else
		{
			String[] oldvars = new String[nrules];
			String[] newvars = new String[nrules];
			for(int i=0;i<nrules;++i)
			{
				oldvars[i] = "x" + String.valueOf(i);
				newvars[i] = "@" + String.valueOf(i);
			}
			rules[0] = nc.changeNames(rules[0],oldvars,newvars);
		}
	 }*/
} /* end ChainRuleDiffRules */
/* @author rich
 * Created on 14-Apr-2004
 */
package org.lsmp.djep.rpe;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import java.util.*;
/**
 * A fast evaluation algorithm for equations over Doubles, does not work with vectors or matricies.
 * This is based around reverse polish notation
 * and is optimized for speed at every opportunity.
 * <p>
 * To use do
 * <pre>
 * JEP j = ...;
 * Node node = ...; 
 * RpEval rpe = new RpEval(j);
 * RpCommandList list = rpe.compile(node);
 * double val = rpe.evaluate(list);
 * System.out.println(val);
 * rpe.cleanUp();
 * </pre>
 * <p>
 * Variable values in the evaluator are stored in a array. The array index of a variable can be found using
 * <pre>
 * Varaible v = j.getVar("x");
 * int ref = rpe.getVarRef(v);
 * </pre>
 * and the value of the variable set using
 * <pre>
 * rpe.setVarValue(ref,0.1234);
 * </pre>
 * Variable values can also be set using the standard <tt>Variable.setValue()</tt> or (slower) <tt>JEP.setVarVal(name,vlaue)</tt> methods.
 * Setting the value of a jep variable will automatically update the corresponding rpe value but there will be a performance hit. 
 * Setting the value of the rpe variable does not change the corresponding jep value.
 * <p> 
 * The compile methods converts the expression represented by node
 * into a string of commands. For example the expression "1+2*3" will
 * be converted into the sequence of commands
 * <pre>
 * Constant no 1 (pushes constant onto stack)
 * Constant no 2
 * Constant no 3
 * Multiply scalers (multiplies last two entries on stack)
 * Add scalers (adds last two entries on stack)
 * </pre>
 * The evaluate method executes these methods sequentially
 * using a stack 
 * and returns the last object on the stack. 
 * <p>
 * A few cautionary notes:
 * Its very unlikely to be thread safe. It only works over doubles
 * expressions with complex numbers or strings will cause problems.
 * It only works for expressions involving scalers.
 * <p>
 * <b>Implementation notes</b>
 * A lot of things have been done to make it as fast as possible:
 * <ul>
 * <li>Everything is final which maximizes the possibility for in-lining.</li>
 * <li>All object creation happens during compile.</li>
 * <li>All calculations done using double values.</li>
 * <li>Each operator/function is hand coded. To extend functionality you will have to modify the source.</li>
 * </ul>
 *  
 * @author Rich Morris
 * Created on 14-Apr-2004
 */
public final class RpEval implements ParserVisitor {

	private OperatorSet opSet;
	private ScalerStore scalerStore = new ScalerStore();
	/** Contains the constant values **/
	double constVals[] = new double[0];

	/** Temporary holder for command list used during compilation */
	private RpCommandList curCommandList;

	public RpEval(JEP jep) {
		this.opSet = jep.getOperatorSet();
	}

	private RpEval() {}
	
	/** Index for each command */
	public static final short CONST = 0;
	public static final short VAR = 1;

	public static final short ADD = 2;
	public static final short SUB = 3;
	public static final short MUL = 4;
	
	public static final short DIV = 5;
	public static final short MOD = 6;
	public static final short POW = 7;

	public static final short AND = 8;
	public static final short OR  = 9;
	public static final short NOT = 10;

	public static final short LT = 11;
	public static final short LE = 12;
	public static final short GT = 13;
	public static final short GE = 14;
	public static final short NE = 15;
	public static final short EQ = 16;
	
	public static final short LIST = 17;
	public static final short DOT = 18;
	public static final short CROSS = 19;

	public static final short ASSIGN = 20;
	public static final short VLIST = 21;
	public static final short MLIST = 22;
	public static final short FUN = 23;
	public static final short UMINUS = 24;
	public static final short FUN2 = 25;
	public static final short FUN3 = 26;
	public static final short FUN4 = 27;
	public static final short POWN = 28;
	public static final short RECIP = 29;
	/** Standard functions **/
	
	private static final short SIN = 1;
	private static final short COS = 2;
	private static final short TAN = 3;
	private static final short ASIN = 4;
	private static final short ACOS = 5;
	private static final short ATAN = 6;
	private static final short SINH = 7;
	private static final short COSH = 8;
	private static final short TANH = 9;
	private static final short ASINH = 10;
	private static final short ACOSH = 11;
	private static final short ATANH = 12;
	
	private static final short ABS = 13;
	private static final short EXP = 14;
	private static final short LOG = 15;
	private static final short LN = 16;
	private static final short SQRT = 17;
	
	private static final short SEC = 18;
	private static final short COSEC = 19;
	private static final short COT = 20;
	
	// 2 argument functions
	private static final short ATAN2 = 21;

	// 3 argument functions
	private static final short IF = 22;

	/** Hashtable for function name lookup **/
	
	private static final Hashtable functionHash = new Hashtable();
	{
		functionHash.put("sin",new Short(SIN));
		functionHash.put("cos",new Short(COS));
		functionHash.put("tan",new Short(TAN));
		functionHash.put("asin",new Short(ASIN));
		functionHash.put("acos",new Short(ACOS));
		functionHash.put("atan",new Short(ATAN));
		functionHash.put("sinh",new Short(SINH));
		functionHash.put("cosh",new Short(COSH));
		functionHash.put("tanh",new Short(TANH));
		functionHash.put("asinh",new Short(ASINH));
		functionHash.put("acosh",new Short(ACOSH));
		functionHash.put("atanh",new Short(ATANH));

		functionHash.put("abs",new Short(ABS));
		functionHash.put("exp",new Short(EXP));
		functionHash.put("log",new Short(LOG));
		functionHash.put("ln",new Short(LN));
		functionHash.put("sqrt",new Short(SQRT));

		functionHash.put("sec",new Short(SEC));
		functionHash.put("cosec",new Short(COSEC));
		functionHash.put("cot",new Short(COT));
		
		functionHash.put("atan2",new Short(ATAN2));
		functionHash.put("if",new Short(IF));
	}

	

	/**
	 * Base class for storage for each type of data.
	 * Each subclass should define
	 * <pre>
	 * private double stack[];
	 * private double vars[]= new double[0];
	 * </pre>
	 * and the stack is the current data used for calculations.
	 * Data for Variables is stored in vars and references to the Variables
	 * in varRefs. 
	 */
	private abstract static class ObjStore implements Observer {
		/** Contains references to Variables of this type */
		Hashtable varRefs = new Hashtable();
		/** The stack pointer */
		int sp=0;
		/** Maximum size of stack */
		int stackMax=0;
		final void incStack()	{sp++; if(sp > stackMax) stackMax = sp;	}
		final void decStack()	throws ParseException {--sp; if(sp <0 ) throw new ParseException("RPEval: stack error");}
		/** call this to reset pointers as first step in evaluation */
		final void reset() { sp = 0; }
		/** Add a reference to this variable. 
		 * @return the index of variable in table
		 */
		final int addVar(Variable var){
			Object index = varRefs.get(var);
			if(index==null)
			{
				int size = varRefs.size();
				expandVarArray(size+1);
				varRefs.put(var,new Integer(size));
				copyFromVar(var,size);
				var.addObserver(this);
				return size;
			}
			return ((Integer) index).intValue();
		}
		final public void update(Observable obs, Object arg1) 
		{
			Variable var = (Variable) obs;
			Object index = varRefs.get(var);
			copyFromVar(var,((Integer) index).intValue());
		}
		/** allocates space needed */
		abstract void alloc();
		
		final void cleanUp()
		{
			for(Enumeration e=varRefs.keys();e.hasMoreElements();)
			{
				Variable var = (Variable) e.nextElement();
				var.deleteObserver(this);
			}
			varRefs.clear();
		}
		/** Copy variable values into into private storage. 
		 * 
		 * @param var The variable
		 * @param i index of element in array
		 */
		abstract void copyFromVar(Variable var,int i);
		/** expand size of array used to hold variable values. */
		abstract void expandVarArray(int i);
		/** add two objects of same type */
		abstract void add();
		/** subtract two objects of same type */
		abstract void sub();
		/** multiply by a scaler either of left or right */
		abstract void mulS();
		/** assign a variable to stack value
		 * @param i index of variable */
		abstract void assign(int i);
		Variable getVariable(int ref)
		{
			for(Enumeration en=varRefs.keys();en.hasMoreElements();)
			{
				Variable var = (Variable) en.nextElement();
				Integer index = (Integer) varRefs.get(var);
				if(index.intValue()==ref) return var;
			}
			return null;
		}
	}

	private final class ScalerStore extends ObjStore {
		double stack[]=new double[0];
		double vars[]= new double[0];
		final void alloc() { 
			stack = new double[stackMax];
			}
		final void expandVarArray(int size)
		{
			double newvars[] = new double[size];
			System.arraycopy(vars,0,newvars,0,vars.length);
			vars = newvars;
		}
			
		final void copyFromVar(Variable var,int i){
			if(var.hasValidValue())
			{
				Double val = (Double) var.getValue();
				vars[i]=val.doubleValue();
			}
		}
		final void add(){
			double r = stack[--sp];
			stack[sp-1] += r;
		}
		final void sub(){
			double r = stack[--sp];
			stack[sp-1] -= r;
		}
		final void uminus(){
			double r = stack[--sp];
				stack[sp++] = -r;
		}
		final void recroprical(){
			double r = stack[--sp];
				stack[sp++] = 1/r;
		}
		final void mulS(){
			double r = stack[--sp];
			stack[sp-1] *= r;
		} 
		final void div(){
			double r = stack[--sp];
			stack[sp-1] /= r;
		} 
		final void mod(){
			double r = stack[--sp];
			stack[sp-1] %= r;
		} 
		final void pow(){
			double r = stack[--sp];
			short s = (short) r;
			if(r==s) {
				if(r>=0) { powN(s); return; }
				else { powN((short) -s); recroprical(); return; }
			}
			double l = stack[--sp];
			stack[sp++] = Math.pow(l,r);
		} 
		
		/**
		 * Code adapted form http://mindprod.com/jgloss/power.html
		 * @author Patricia Shanahan pats@acm.org
		 * almost identical to the method Knuth gives on page 462 of The Art of Computer Programming Volume 2 Seminumerical Algorithms.
		 */
		
		final void powN(short n){
			double r = stack[--sp];
			switch(n){
				case 0: r = 1.0; break;
				case 1: break;
				case 2: r *= r; break;
				case 3: r *= r*r; break;
				case 4: r *= r*r*r; break;
				case 5: r *= r*r*r*r; break;
				case 6: r *= r*r*r*r*r; break;
				case 7: r *= r*r*r*r*r*r; break;
				case 8: r *= r*r*r*r*r*r*r; break;
				default:
				   {
					   short bitMask = n;
					   double evenPower = r;
					   double result;
					   if ( (bitMask & 1) != 0 )
					      result = r;
					   else
					      result = 1;
					   bitMask >>>= 1;
					   while ( bitMask != 0 ) {
					      evenPower *= evenPower;
					      if ( (bitMask & 1) != 0 )
					         result *= evenPower;
					      bitMask >>>= 1;
					   } // end while
					r = result;
				   }
			}
			stack[sp++] = r;
		} 
		
		final void assign(int i) {
			vars[i] = stack[--sp]; ++sp;
		} 
		final void and(){
			double r = stack[--sp];
			double l = stack[--sp];
			if((l != 0.0) && (r != 0.0))
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void or(){
			double r = stack[--sp];
			double l = stack[--sp];
			if((l != 0.0) || (r != 0.0))
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void not(){
			double r = stack[--sp];
			if(r == 0.0)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void lt(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l < r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void gt(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l > r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void le(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l <= r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void ge(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l >= r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void eq(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l == r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
		final void neq(){
			double r = stack[--sp];
			double l = stack[--sp];
			if(l != r)
				stack[sp++] = 1.0;
			else
				stack[sp++] = 0.0;
		}
	}
	
	/**
	 * Compile the expressions to produce a set of commands in reverse Polish notation.
	 */
	public final RpCommandList compile(Node node) throws ParseException
	{
		curCommandList = new RpCommandList(this);
		node.jjtAccept(this,null);
		scalerStore.alloc();
		return curCommandList;
	}
	
	public final Object visit(ASTStart node, Object data) throws ParseException {
		throw new ParseException("RpeEval: Start node encountered");
	}
	public final Object visit(SimpleNode node, Object data) throws ParseException {
		throw new ParseException("RpeEval: Simple node encountered");
	}

	public final Object visit(ASTConstant node, Object data) throws ParseException {
		Object obj = node.getValue();
		double val;
		if(obj instanceof Double)
			val = ((Double) node.getValue()).doubleValue();
		else
			throw new ParseException("RpeEval: only constants of double type allowed");
		
		scalerStore.incStack();
		for(short i=0;i<constVals.length;++i)
		{
			if(val == constVals[i])
			{
				curCommandList.addCommand(CONST,i);
				return null;
			}
		}
		// create a new const
		double newConst[] = new double[constVals.length+1];
		System.arraycopy(constVals,0,newConst,0,constVals.length);
		newConst[constVals.length] = val;
		curCommandList.addCommand(CONST,(short) constVals.length);
		constVals = newConst;
		return null;
	}

	public final Object visit(ASTVarNode node, Object data) throws ParseException 
	{
		Variable var = node.getVar();
		// find appropriate table
		short vRef = (short) scalerStore.addVar(var);
		scalerStore.incStack();
		curCommandList.addCommand(VAR,vRef);
		return null;
	}

	public final Object visit(ASTFunNode node, Object data) throws ParseException 
	{
		int nChild = node.jjtGetNumChildren();

		if(node.isOperator() && node.getOperator() == opSet.getAssign()) {}
		else if(node.isOperator() && node.getOperator() == opSet.getPower()) {}
		else
			node.childrenAccept(this,null);

		if(node.isOperator())
		{
			Operator op = node.getOperator();

			if(op == opSet.getAdd())
			{
				curCommandList.addCommand(ADD);
				scalerStore.decStack();
				return null;
			}
			else if(op == opSet.getSubtract())
			{
				curCommandList.addCommand(SUB);
				scalerStore.decStack();
				return null;
			}
			else if(op == opSet.getUMinus())
			{
				curCommandList.addCommand(UMINUS);
				return null;
			}
			else if(op == opSet.getMultiply())
			{
				scalerStore.decStack();
				curCommandList.addCommand(MUL);
				return null;
			}
			else if(op == opSet.getAssign())
			{
				Node rightnode = node.jjtGetChild(1);
				rightnode.jjtAccept(this,null);
				Variable var = ((ASTVarNode)node.jjtGetChild(0)).getVar();
				short vRef = (short) scalerStore.addVar(var);
				scalerStore.decStack();
				curCommandList.addCommand(ASSIGN,vRef);
				return null;
			}
			else if(op == opSet.getEQ())
			{
				scalerStore.decStack();
				curCommandList.addCommand(EQ); return null;
			}
			else if(op == opSet.getNE())
			{
				scalerStore.decStack();
				curCommandList.addCommand(NE); return null;
			}
			else if(op == opSet.getLT())
			{
				scalerStore.decStack();
				curCommandList.addCommand(LT); return null;
			}
			else if(op == opSet.getGT())
			{
				scalerStore.decStack();
				curCommandList.addCommand(GT); return null;
			}
			else if(op == opSet.getLE())
			{
				scalerStore.decStack();
				curCommandList.addCommand(LE); return null;
			}
			else if(op == opSet.getGE())
			{
				scalerStore.decStack();
				curCommandList.addCommand(GE); return null;
			}
			else if(op == opSet.getAnd())
			{
				scalerStore.decStack();
				curCommandList.addCommand(AND); return null;
			}
			else if(op == opSet.getOr())
			{
				scalerStore.decStack();
				curCommandList.addCommand(OR); return null;
			}
			else if(op == opSet.getNot())
			{
				//scalerStore.decStack();
				curCommandList.addCommand(NOT); return null;
			}
			else if(op == opSet.getDivide())
			{
				scalerStore.decStack();
				curCommandList.addCommand(DIV); return null;
			}
			else if(op == opSet.getMod())
			{
				scalerStore.decStack();
				curCommandList.addCommand(MOD); return null;
			}
			else if(op == opSet.getPower())
			{
				Node lhs = node.jjtGetChild(0);
				Node rhs = node.jjtGetChild(1);
				lhs.jjtAccept(this,null);	
				if(rhs instanceof ASTConstant) {
					Object val = ((ASTConstant) rhs).getValue();
					if(val instanceof Number) {
						double dval = ((Number) val).doubleValue();
						short sval = ((Number) val).shortValue();
						if(dval>= 0 && dval == sval)
						{
							curCommandList.addCommand(POWN,sval); 
							return null;
						}
						else if(dval == sval)
						{
							curCommandList.addCommand(POWN,(short) (-sval));
							curCommandList.addCommand(RECIP);
						}
					}
				}
				rhs.jjtAccept(this,null);
				scalerStore.decStack();
				curCommandList.addCommand(POW); return null;
			}
			throw new ParseException("RpeEval: Sorry unsupported operator/function: "+ node.getName());
		}
		// other functions
		
		Short val = (Short) functionHash.get(node.getName());
		if(val == null)
			throw new ParseException("RpeEval: Sorry unsupported operator/function: "+ node.getName());
		if(nChild == 1)
		{
			//scalerStore.decStack();
			curCommandList.addCommand(FUN,val.shortValue()); 
			return null;
		}
		else if(nChild == 2)
		{
			curCommandList.addCommand(FUN2,val.shortValue()); 
			return null;
		}
		else if(nChild == 3)
		{
			curCommandList.addCommand(FUN3,val.shortValue()); 
			return null;
		}
		else if(nChild == 4)
		{
			curCommandList.addCommand(FUN4,val.shortValue()); 
			return null;
		}

		throw new ParseException("RpeEval: sorry can currently only support single argument functions");
	}

	/***************************** evaluation *****************************/
	
	/** Evaluate the expression.
	 * 
	 * @return the double value of the equation
	 */
	public final double evaluate(RpCommandList comList)
	{
		scalerStore.reset();
	
		// Now actually process the commands
		int num = comList.getNumCommands();
		for(short commandNum=0;commandNum<num;++commandNum)
		{
			RpCommand command = comList.commands[commandNum];
			short aux1 = command.aux1;
			switch(command.command)
			{
			case CONST:
				scalerStore.stack[scalerStore.sp++]=constVals[aux1]; break;
			case VAR:
				scalerStore.stack[scalerStore.sp++]=scalerStore.vars[aux1]; break;
				
			case ADD: scalerStore.add(); break;
			case SUB: scalerStore.sub(); break; 
			case MUL: scalerStore.mulS(); break;
			case DIV: scalerStore.div(); break;
			case MOD: scalerStore.mod(); break;
			case POW: scalerStore.pow(); break;

			case AND: scalerStore.and(); break;
			case OR:  scalerStore.or(); break;
			case NOT: scalerStore.not(); break;

			case LT: scalerStore.lt(); break;
			case LE: scalerStore.le(); break;
			case GT: scalerStore.gt(); break;
			case GE: scalerStore.ge(); break;
			case NE: scalerStore.neq(); break;
			case EQ: scalerStore.eq(); break;
			case ASSIGN: scalerStore.assign(aux1); break;
			case FUN: unitaryFunction(aux1); break;
			case UMINUS: scalerStore.uminus(); break;
			case FUN2: binaryFunction(aux1); break;
			case FUN3: trianaryFunction(aux1); break;
			case FUN4: quarteraryFunction(aux1); break;
			case POWN: scalerStore.powN(aux1); break;
			case RECIP: scalerStore.recroprical(); break;
			}
		}

		return scalerStore.stack[--scalerStore.sp];
	}

	
	private static final double LOG10 = Math.log(10.0);

	private final void unitaryFunction(short fun)
	{
		double r = scalerStore.stack[--scalerStore.sp];
		switch(fun) {
			case SIN: r = Math.sin(r); break;
			case COS: r = Math.cos(r); break;
			case TAN: r = Math.tan(r); break;

			case ASIN: r = Math.asin(r); break;
			case ACOS: r = Math.acos(r); break;
			case ATAN: r = Math.atan(r); break;

			case SINH: r = (Math.exp(r)-Math.exp(-r))/2; break;
			case COSH: r = (Math.exp(r)+Math.exp(-r))/2; break;
			case TANH: 
				{double ex = Math.exp(r*2);
				 r = (ex-1)/(ex+1); break;
				}

			case ASINH: r = Math.log(r+Math.sqrt(1+r*r)); break;
			case ACOSH: r = Math.log(r+Math.sqrt(r*r-1)); break;
			case ATANH: r = Math.log((1+r)/(1-r))/2.0; break;

			case ABS: r = Math.abs(r); break;
			case EXP: r = Math.exp(r); break;
			case LOG: r = Math.log(r) / LOG10; break;
			case LN:  r = Math.log(r); break;
			case SQRT: r = Math.sqrt(r); break;

			case SEC: r = 1.0/Math.cos(r); break;
			case COSEC:  r = 1.0/Math.sin(r); break;
			case COT: r = 1.0/Math.tan(r); break;
		}
		scalerStore.stack[scalerStore.sp++] = r;
	}
	
	private final void binaryFunction(short fun){
		double r = scalerStore.stack[--scalerStore.sp];
		double l = scalerStore.stack[--scalerStore.sp];
		switch(fun) {
		case ATAN2: r = Math.atan2(l,r); break;
		}
		scalerStore.stack[scalerStore.sp++] = r;
	}
	private final void trianaryFunction(short fun)
	{
		double a = scalerStore.stack[--scalerStore.sp];
		double r = scalerStore.stack[--scalerStore.sp];
		double l = scalerStore.stack[--scalerStore.sp];
		switch(fun) {
		case IF: r = (l>0.0?r:a); break;
		}
		scalerStore.stack[scalerStore.sp++] = r;
		
	}
	private final void quarteraryFunction(short fun)
	{
		double b = scalerStore.stack[--scalerStore.sp];
		double a = scalerStore.stack[--scalerStore.sp];
		double r = scalerStore.stack[--scalerStore.sp];
		double l = scalerStore.stack[--scalerStore.sp];
		switch(fun) {
		case IF: r = (l>0.0?r: (l<0.0?a:b)); break;
		}
		scalerStore.stack[scalerStore.sp++] = r;
		
	}

	/**
	 * Removes observers and other cleanup needed when evaluator no longer used.
	 */
	public void cleanUp()
	{
		scalerStore.cleanUp();
	}
	
	/**
	 * Gets the JEP Variable for a give reference number
	 * @param ref reference number for the variable
	 * @return corresponding JEP variable
	 */
	public Variable getVariable(int ref)
	{
		return scalerStore.getVariable(ref);
	}
	/**
	 * Gets the reference number for a given variable
	 * @param var JEP Variable
	 * @return reference number for the variable
	 * @throws ParseException
	 */
	public int getVarRef(Variable var) throws ParseException
	{
		short vRef = (short) scalerStore.addVar(var);
		return vRef;
	}
	
	/**
	 * Sets the value of a variable
	 * @param ref reference number for the variable
	 * @param val the value to set the variable
	 */
	public void setVarValue(int ref, double val)
	{
		scalerStore.vars[ref]=val;
	}
	public String getFunction(short ref)
	{
			switch(ref) {
			case SIN: return "sin";
			case COS: return "cos";
			case TAN: return "tan";
			case ASIN: return "asin";
			case ACOS: return "acos";
			case ATAN: return "atan";
			case SINH: return "sinh";
			case COSH: return "cosh";
			case TANH: return "tanh";
			case ASINH: return "asinh";
			case ACOSH: return "acosh";
			case ATANH: return "atanh";
			case ABS: return "abs";
			case EXP: return "exp";
			case LOG: return "log";
			case LN: return "ln";
			case SQRT: return "sqrt";
			case SEC: return "sec";
			case COSEC: return "cosec";
			case COT: return "cot";
			case ATAN2: return "atan2";
			case IF: return "if";
			}
			return null;
	}
}
package org.lsmp.djep.rpe;

import org.nfunk.jep.ParseException;
import org.nfunk.jep.Variable;

/** Data type for the command string */
public final class RpCommand {
	short command;
	short aux1; 
	RpEval rpe;
	private RpCommand() {};
	RpCommand(RpEval rpe,short command){
		this.command = command; this.aux1 = -1; this.rpe = rpe;
	}
	RpCommand(RpEval rpe,short command,short aux){
		this.command = command; this.aux1 = aux; this.rpe = rpe;
	}
	public String toString() {
		switch(command)
		{
			case RpEval.CONST: return "Constant\tno "+aux1;
			case RpEval.VAR: return "Variable\tnum "+aux1;
			case RpEval.ADD: return "ADD";
			case RpEval.SUB: return "SUB";
			case RpEval.MUL: return "MUL";
			case RpEval.DIV: return "DIV";
			case RpEval.MOD: return "MOD";
			case RpEval.POW: return "POW";
			case RpEval.AND: return "AND";
			case RpEval.OR: return "OR";
			case RpEval.NOT: return "NOT";
			case RpEval.LT: return "LT";
			case RpEval.LE: return "LE";
			case RpEval.GT: return "GT";
			case RpEval.GE: return "GE";
			case RpEval.EQ: return "EQ";
			case RpEval.NE: return "NE";
			case RpEval.ASSIGN: return "Assign\tnum "+aux1;
			case RpEval.FUN: return "Function\tnum "+aux1;
		}
		return "WARNING unknown command: "+command+" "+aux1;
	}
	/**
	 * Returns the type of an individual command. The return value will be one of the constants defined in RpEval. 
	 * These include RpEval.CONST - constants, RpEval.VAR - variables, RpEval.ASSIGN assinments x=..., RpEval.FUN functions. 
	 * Other indicies correspond to unary and binary operators,  RpEval.ADD.
	 * @return an integer representing the type
	 */
	public int getType() { return command; }
	public int getRef() { return aux1; }
	public double getConstantValue() throws ParseException
	{
		if(command!=RpEval.CONST) throw new ParseException("This element is not a constant.");
		return rpe.constVals[aux1];
	}
	
	public Variable getVariable() throws ParseException
	{
		if(command!=RpEval.VAR) throw new ParseException("This element is not a variable.");
		return rpe.getVariable(aux1);
	}
	
	public String getFunction() throws ParseException
	{
		if(command!=RpEval.FUN) throw new ParseException("This element is not a function.");
		return rpe.getFunction(aux1);
	}
}
/* @author rich
 * Created on 04-May-2004
 */
package org.lsmp.djep.rpe;

/** A list of commands */
public final class RpCommandList {
	
	/** Incremental size for list of commands **/
	private static final int STACK_INC=10;
	/** List of commands **/
	RpCommand commands[] = new RpCommand[STACK_INC];
	/** Current position in the command Stack. **/
	private short commandPos;
	private RpEval rpe;
	/** Package private constructor */
	private RpCommandList() {}
	RpCommandList(RpEval rpe) {this.rpe = rpe;}
	/** Adds a command to the list */
	final void addCommand(short command,short aux)
	{
		if(commandPos == commands.length)
		{
			RpCommand newCommands[] = new RpCommand[commands.length+STACK_INC];
			System.arraycopy(commands,0,newCommands,0,commands.length);
			commands = newCommands;
		}
		commands[commandPos]=new RpCommand(rpe,command,aux);
		++commandPos;
//		++maxCommands;
	}
	final void addCommand(short command)
	{
		if(commandPos == commands.length)
		{
			RpCommand newCommands[] = new RpCommand[commands.length+STACK_INC];
			System.arraycopy(commands,0,newCommands,0,commands.length);
			commands = newCommands;
		}
		commands[commandPos]=new RpCommand(rpe,command);
		++commandPos;
//		++maxCommands;
	}

	public int getNumCommands() { return commandPos;}
	public RpCommand getCommand(int i) { return commands[i]; }
	public String toString() {
		StringBuffer sb = new StringBuffer();
		for(int i=0;i<commandPos;++i) {
			sb.append(commands[i].toString());
			sb.append("\n");
		}
		return sb.toString();
	}
}
/* @author rich
 * Created on 02-May-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.xjep;

import java.text.FieldPosition;
import java.text.NumberFormat;
import java.text.ParsePosition;

import org.lsmp.djep.xjep.function.FromBase;
import org.lsmp.djep.xjep.function.ToBase;

/**
 * A Number format object which prints results in a specified base.
 * TODO Do something with the FieldPosition arguments.
 *  
 * @author Rich Morris
 * Created on 02-May-2005
 */
public class BaseFormat extends NumberFormat {
    /**
	 * 
	 */
	private static final long serialVersionUID = 1805136353312272410L;
	int base;
    ToBase tb=null;
    FromBase fb=null;
    /**
     * 
     */
    private BaseFormat() {
        super();
        tb = new ToBase();
        fb = new FromBase();
    }

    /**
     * Create a new base format object 
     * @param base the base of number to use
     * @throws IllegalArgumentException if base is < 2 or > 36
     */
    public BaseFormat(int base) {
        super();
        this.base = base;
        tb = new ToBase(base);
        fb = new FromBase(base);
    }
    /**
     * Create a new base format object 
     * @param base the base of number to use
     * @param prefix prefix to appear before number
     * @throws IllegalArgumentException if base is < 2 or > 36
     */
    public BaseFormat(int base,String prefix) {
        super();
        this.base = base;
        tb = new ToBase(base,prefix);
        fb = new FromBase(base,prefix);
    }
    /**
     * Format a double value in specific base.
     * @param val the number to format
     * @param sb  the buffer to append to
     * @param fp  not used
     * @return the string buffer
     */
    public StringBuffer format(double val, StringBuffer sb,
            FieldPosition fp) {
        sb.append(tb.toBase(val,base,this.getMaximumFractionDigits()));
        return sb;
    }

    /**
     * Format a double value in specific base.
     * @param val the number to format
     * @param sb  the buffer to append to
     * @param fp  not used
     * @return the string buffer
     */
 
    public StringBuffer format(long val, StringBuffer sb, FieldPosition fp) {
        sb.append(tb.toBase(val,base));
        return sb;
    }

    /**
     * Not implemented
     */

    public Number parse(String arg0, ParsePosition arg1) {
        // TODO Auto-generated method stub
        return null;
    }

}
/* @author rich
 * Created on 16-Nov-2003
 */
package org.lsmp.djep.xjep;

import org.nfunk.jep.*;
import org.nfunk.jep.function.Exp;
import org.nfunk.jep.function.PostfixMathCommandI;
import org.lsmp.djep.xjep.PrintVisitor.PrintRulesI;
import org.lsmp.djep.xjep.function.*;
import java.util.*;
import java.io.PrintStream;
import java.io.Reader;
/**
 * An extended version of JEP adds various routines for working with trees.
 * Has a NodeFactory, and OperatorSet, TreeUtils
 * and Visitors DoNothingVisitor,
 * @author Rich Morris
 * Created on 16-Nov-2003
 */
public class XJep extends JEP {
	/** Creates new nodes */
	protected NodeFactory nf = null;
	/** A few utility functions. */
	protected TreeUtils tu = null;
	protected DeepCopyVisitor copier = null;
	protected SubstitutionVisitor subv = null;
	protected SimplificationVisitor simpv = null;
	protected CommandVisitor commandv = null;
	protected PrintVisitor pv = null;
	private VariableFactory vf = new XVariableFactory();

	/**
	 * Create a new XJep will all the function of JEP plus printing and other features.
	 */
	public XJep()
	{
		this.symTab = new XSymbolTable(vf); 

		/* Creates new nodes */
		nf = new NodeFactory(this);
		/* Collects operators **/
		opSet = new XOperatorSet();
		/* A few utility functions. */
		tu = new TreeUtils();
		
		copier = new DeepCopyVisitor();
		subv = new SubstitutionVisitor();
		ev = new XEvaluatorVisitor(this.getSymbolTable());
		simpv = new SimplificationVisitor();
		commandv = new CommandVisitor();
		pv = new PrintVisitor();
		pv.addSpecialRule(opSet.getElement(),new PrintRulesI() {
			public void append(Node node, PrintVisitor pv) throws ParseException {
				node.jjtGetChild(0).jjtAccept(pv, null);
				node.jjtGetChild(1).jjtAccept(pv, null);
			}});
	}

	/** Copy constructions, reuses all the components of argument. */
	protected XJep(XJep j)
	{
		super(j);
		this.commandv=j.commandv;
		this.copier=j.copier;
		this.ev=j.ev;
		this.nf=j.nf;
		this.opSet=j.opSet;
		this.pv=j.pv;
		this.simpv=j.simpv;
		this.subv=j.subv;
		this.tu=j.tu;
	}

	private JEP ingrediant = null;
	/** Conversion constructor.
	 * Turns a JEP object into an XJep object.
	 * @param j 
	 */
	public XJep(JEP j)
	{
		ingrediant=j;
		/* Creates new nodes */
		nf = new NodeFactory(this);
		this.symTab = new XSymbolTable(vf); 
		this.funTab = j.getFunctionTable();
		/* Collects operators **/
		opSet = new XOperatorSet(j.getOperatorSet());
		/* A few utility functions. */
		tu = new TreeUtils();
		copier = new DeepCopyVisitor();
		subv = new SubstitutionVisitor();
		ev = new XEvaluatorVisitor(this.getSymbolTable());
		simpv = new SimplificationVisitor();
		commandv = new CommandVisitor();
		pv = new PrintVisitor();
	}
	/**
	 * Creates a new instance of XJep with the same components as this one.
	 * Sub classes should overwrite this method to create objects of the correct type.
	 */
	public XJep newInstance()
	{
		XJep newJep = new XJep(this);
		return newJep;
	}
	/**
	 * Creates a new instance of XJep with the same components as this one and the specified symbol table.
	 * Sub classes should overwrite this method to create objects of the correct type.
	 */
	public XJep newInstance(SymbolTable st)
	{
		XJep newJep = new XJep(this);
		newJep.symTab = st;
		return newJep;
	}

	public void addStandardFunctions()
	{
		if(ingrediant!=null)
		{
			ingrediant.addStandardFunctions();
		} 
		else super.addStandardFunctions();
		addFunction("eval",new Eval());
		addFunction("Sum",new Sum(this));
		addFunction("Product",new Product());
		addFunction("Min",new Min());
		addFunction("Max",new Max());
		addFunction("MinArg",new MinArg());
		addFunction("MaxArg",new MaxArg());
		addFunction("Simpson",new Simpson());
		addFunction("Trapezium",new Trapezium());
		addFunction("toBase",new ToBase());
		addFunction("toHex",new ToBase(16,"0x"));
		addFunction("fromBase",new FromBase());
		addFunction("fromHex",new FromBase(16,"0x"));
		
		addFunction("exp",new Exp());
		addFunction("Define",new Define(this));
		try {
		MacroFunction sec = new MacroFunction("sec",1,"1/cos(x)",this);
		addFunction("sec",sec);
		MacroFunction cosec = new MacroFunction("cosec",1,"1/sin(x)",this);
		addFunction("cosec",cosec);
		MacroFunction cot = new MacroFunction("cot",1,"1/tan(x)",this);
		addFunction("cot",cot);
		} catch (ParseException e) {System.err.println(e.getMessage());}
	}

	public void addStandardConstants()
	{
		if(ingrediant!=null)
		{
			ingrediant.addStandardConstants();
			for(Enumeration en=ingrediant.getSymbolTable().elements();en.hasMoreElements();)
			{
				Variable var = (Variable) en.nextElement();
				if(var.isConstant())
					this.symTab.addConstant(var.getName(),var.getValue());
				//else
				//	this.symTab.addVariable(var.getName(),var.getValue());
			}
		} 
		else super.addStandardConstants();
	}

	public void addComplex()
	{
		if(ingrediant!=null)
		{
			ingrediant.addComplex();
		} 
		else super.addComplex();
		try {
		MacroFunction complex = new MacroFunction("macrocomplex",2,"x+i*y",this);
		addFunction("macrocomplex",complex);
		} catch (ParseException e) {System.err.println(e.getMessage());}
	}
		

	/** Returns a deep copy of an expression tree. */
	public Node deepCopy(Node node) throws ParseException
	{
		return copier.deepCopy(node,this);
	}
	/** Returns a simplification of an expression tree. */
	public Node simplify(Node node) throws ParseException
	{
		return simpv.simplify(node,this);
	}
	/** Pre-processes an equation to allow the diff and eval operators to be used. */
	public Node preprocess(Node node) throws ParseException
	{
		return commandv.process(node,this);
	}
	/** Substitute all occurrences of a named variable with an expression tree. */ 
	public Node substitute(Node orig,String name,Node replacement) throws ParseException
	{
		return subv.substitute(orig,name,replacement,this);
	}
	/** Substitute all occurrences of a set of named variable with a set of expression tree. */ 
	public Node substitute(Node orig,String names[],Node replacements[]) throws ParseException
	{
		return subv.substitute(orig,names,replacements,this);
	}
	/** Prints the expression tree on standard output. */
	public void print(Node node) { pv.print(node); }
	/** Prints the expression tree on given stream. */
	public void print(Node node,PrintStream out) { pv.print(node,out); }
	/** Prints the expression tree on standard output with newline at end. */
	public void println(Node node) { pv.println(node); }
	/** Prints the expression tree on given stream with newline at end. */
	public void println(Node node,PrintStream out) { pv.println(node,out); }
	/** Returns a string representation of a expression tree. */
	public String toString(Node node) { return pv.toString(node); }
	/** Returns the node factory, used for constructing trees of Nodes. */ 
	public NodeFactory getNodeFactory() {return nf;}
	/** Returns the TreeUtilitities, used for examining properties of nodes. */ 
	public TreeUtils getTreeUtils() { return tu; }
//	public SimplificationVisitor getSimpV() { return simpv; }
	/** Returns the PrintVisitor, used for printing equations. */ 
	public PrintVisitor getPrintVisitor() {	return pv;	}

	/**
	 * Calculates the value for the variables equation and returns that value.  
	 * If the variable does not have an equation just return its value.
	 */
	public Object calcVarValue(String name) throws Exception
	{
		XVariable xvar = (XVariable) getVar(name);
		return xvar.calcValue(this);
	}

	/**
	 * Continue parsing without re-initilising the stream.
	 * Allows re-entrance of parser so that strings like
	 * "x=1; y=2; z=3;" can be parsed.
	 * When a semi colon is encountered parsing finishes leaving the rest of the string unparsed.
	 * Parsing can be resumed from the current position by using this method.
	 * For example
	 * <pre>
	 * XJep j = new XJep();
	 * j.restartParser("x=1;y=2; z=3;");
	 * Node node;
	 * try {
	 * while((node = j.continueParsing())!=null) {
	 *    j.println(node);
	 * } }catch(ParseException e) {}
	 * </pre>
	 * @return top node of equation parsed to date or null if empty equation
	 * @throws ParseException
	 * @see #restartParser(String)
	 */
	public Node continueParsing() throws ParseException {
		return parser.continueParse();
	}

	/**
	 * Restarts the parser with the given string.
	 * @param str String containing a sequence of equations separated by semi-colons.
	 * @see #continueParsing
	 */
	public void restartParser(String str) {
		parser.restart(new java.io.StringReader(str), this);
	}

	/**
	 * Restarts the parser with the given Reader.
	 * @param reader Reader from which equations separated by semi-colons will be read.
	 * @see #continueParsing
	 */
	public void restartParser(Reader reader) {
		parser.restart(reader, this);
	}

	/**
	 * Finds all the variables in an equation.
	 * 
	 * @param n the top node of the expression
	 * @param v a vector to store the list of variables (new variables will be added on end) 
	 * @return v
	 */
	public Vector getVarsInEquation(Node n,Vector v) {
		if(n instanceof ASTVarNode) {
			Variable var = ((ASTVarNode) n).getVar();
			if(!v.contains(var)) v.add(var);
		}
		else if(n instanceof ASTFunNode) {
			for(int i=0;i<n.jjtGetNumChildren();++i)
				getVarsInEquation(n.jjtGetChild(i),v);
		}
		return v;
	}
	
	/**
	 * Finds all the variables in an equation and if any of those 
	 * variables are defined by equations find the variables 
	 * in those equations as well.
	 * The result is an ordered sequence, evaluating each
	 * variable in turn will correctly allow the final equation to be evaluated.
	 * <p>
	 * For example if the equation is <code>a+b</code> and 
	 * <code>a=c+d</code>, <code>b=c+e</code> then the
	 * result will be the sequence <code>(c,d,a,e,b)</code>
	 * 
	 * @param n top node
	 * @param v vector for storing results, new variables will be added on the end.
	 * @return v, the ordered sequence of variables
	 * @throws ParseException if equation is recursive i.e. <code>x=y; y=x+1;</code>
	 */
	public Vector recursiveGetVarsInEquation(Node n,Vector v) throws ParseException {
		if(n instanceof ASTVarNode) {
			XVariable var = (XVariable) (((ASTVarNode) n).getVar());
			if(!v.contains(var))
			{
				if(var.hasEquation())
					recursiveGetVarsInEquation(var.getEquation(),v);
				if(v.contains(var))
					throw new ParseException("Recursive definition for "+var.getName());
				v.add(var);
			}
		}
		else if(n instanceof ASTFunNode) {
			for(int i=0;i<n.jjtGetNumChildren();++i)
				recursiveGetVarsInEquation(n.jjtGetChild(i),v);
		}
		return v;
	}
	
    /**
     *
     */

    public Object evaluate(PostfixMathCommandI pfmc,Node node) throws ParseException {
        // TODO Auto-generated method stub
        return super.evaluate(node);
    }
}
/* @author Rich Morris
 * Created on 19-Jun-2003
 */
package org.lsmp.djep.xjep;
//import org.lsmp.djep.matrixParser.*;
import org.nfunk.jep.*;

/**
 * An abstract ParserVisitor
 * which adds some useful error handling facilities.
 * Visitors which require these facilities should extend this class.
 * General format should be
 * <pre>  
 * 	clearErrors();
 *	Object res = (Node) node.jjtAccept(this,data);
 *	if(hasErrors())
 *		throw new ParseException(getErrors());
 *</pre>
 * @author Rich Morris
 * Created on 19-Jun-2003
 */
abstract public class ErrorCatchingVisitor extends DoNothingVisitor
{
	/** The current error list. */
	private Exception error=null;

	/** calls jjtAccept inside a try catch block, adding the error if necessary */
	public Object acceptCatchingErrors(Node node,Object data)
	{
		Object res=null;
		clearErrors();
		try
		{
			res = node.jjtAccept(this,data);
		}
		catch (ParseException e) { addError(e); }
		return res;
	}
	/** Reset the list of errors. */
	public void clearErrors() {	error = null;	}

	/** Are their any errors? */	
	public boolean hasErrors() { return error != null; }
	
	/** Adds an error message to the list of errors. */
	public void addError(Exception e) 	{error = e;	}

	/** Returns the error messages.	 */
	public String getErrorsMessage() {
		if(error==null) return null;
		return error.getMessage();
	}
	/** Returns the Exception or null if no error. */
	public Exception getError() { return error; }
}
/*
 * Created on 16-Jun-2003 by Rich webmaster@pfaf.org
 * www.singsurf.org
 */

package org.lsmp.djep.xjep;

import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * A set of Utility functions for working with JEP expression trees.
 * Main methods are
 * <ul>
 * <li> {@link #isConstant isConstant} test if its a constant. Many other is... methods.
 * <li> {@link #getValue getValue} extracts the value from a node without needing to cast and check types.
 * </ul>
 * @author rich
 */
public class TreeUtils {
	/** Real zero. Note that this is a Double, if a different number
	 * format is needed then this class should be sub-classed.
	 */
	protected static Double ZERO = new Double(0.0);
	/** Real One */
	protected static Double ONE = new Double(1.0);
	/** Real Minus One */
	protected static Double MINUSONE = new Double(-1.0);
	/** Complex Zero **/
	protected static Complex CZERO = new Complex(0.0,0.0);
	/** Complex One **/
	protected static Complex CONE = new Complex(1.0,0.0);
	/** Complex i **/
	protected static Complex CI = new Complex(0.0,1.0);
	/** Complex Minus One **/
	protected static Complex CMINUSONE = new Complex(-1.0,0.0);
	/** Complex Minus i **/
	protected static Complex CMINUSI = new Complex(0.0,-1.0);
	/** Real NaN */
	protected static Double NAN = new Double(Double.NaN);
	/** Real positive infinity */
	protected static Double PosInf = new Double(Double.POSITIVE_INFINITY);
	/** Real NaN */
	protected static Double NegInf = new Double(Double.NEGATIVE_INFINITY);
	
	/**
	 * Default constructor.
	 * TODO Should use the NumberFactory to create numbers!
	 */
	public TreeUtils() {}
	//public static TreeUtils getInstance() { return INSTANCE; }
	
	/**
	 * Returns the value represented by node
	 * @throws IllegalArgumentException if given something which is not an ASTConstant
	 */
	public String getName(Node node) throws IllegalArgumentException
	{
		if(isVariable(node))
			return ((ASTVarNode) node).getName();
		if(isFunction(node))
			return ((ASTFunNode) node).getName();
		
		throw new IllegalArgumentException("Tried to find the name of constant node");
	}

	/** gets the PostfixMathCommand with a given name. */
	/*
	public PostfixMathCommandI getPfmc(String name)
	{
		return (PostfixMathCommandI) myFunTab.get(name);
	}
	*/
	
	/**
	 * Returns the value represented by node
	 * @throws IllegalArgumentException if given something which is not an ASTConstant
	 */
	public Object getValue(Node node) throws IllegalArgumentException
	{
		if(!isConstant(node)) throw new IllegalArgumentException("Tried to find the value of a non constant node");
		return ((ASTConstant) node).getValue();
	}
	
	/**
	 * Returns the double value represented by node
	 * @throws IllegalArgumentException if given something which is not an ASTConstant with a Double value
	 */
	public double doubleValue(Node node) throws IllegalArgumentException
	{
		return ((Double) getValue(node)).doubleValue();
	}
	/**
	 * Returns the long value represented by node
	 * @throws IllegalArgumentException if given something which is not an ASTConstant with a Double value
	 */
	public long longValue(Node node) throws IllegalArgumentException
	{
		return ((Number) getValue(node)).longValue();
	}
	/**
	 * Returns the int value represented by node
	 * @throws IllegalArgumentException if given something which is not an ASTConstant with a Double value
	 */
	public int intValue(Node node) throws IllegalArgumentException
	{
		return ((Number) getValue(node)).intValue();
	}

	/**
	 * Returns the Complex value represented by node
	 * @throws IllegalArgumentException if given something which is not an ASTConstant with a Complex value
	 */
	public Complex complexValue(Node node) throws IllegalArgumentException
	{
		return ((Complex) getValue(node));
	}

	/**
	 * returns true if node is a ASTConstant 
	 */
	public boolean isConstant(Node node)
	{
		return (node instanceof ASTConstant);
	}
	 
	/**
	 * returns true if node is a ASTConstant with Double value 
	 */
	public boolean isReal(Node node)
	{
			return (node instanceof ASTConstant)
			 && ( ((ASTConstant) node).getValue() instanceof Double );
	}
	
	/**
	 * returns true if node is a ASTConstant with Double value representing an integer.
	 */
	public boolean isInteger(Node node)
	{
			if(isReal(node))
			{
				Number val = (Number) ((ASTConstant) node).getValue();
				double x = val.doubleValue();
				double xInt = Math.rint(x);
				return x == xInt;
			}
			return false;
	}

	/**
	 * returns true if node is a ASTConstant with value Double(0) or Complex(0,0) 
	 */
	public boolean isZero(Node node)
	{
		   return ( isReal(node)
					&& ( ((ASTConstant) node).getValue().equals(ZERO)) )
				||( isComplex(node)
					&& ( ((Complex) ((ASTConstant) node).getValue()).equals(CZERO,0.0) ) );
	}

	/**
	 * returns true if node is a ASTConstant with value Double(0) or Complex(0,0)
	 * @param tol	tolerance for testing for zero
	 */
	
	public boolean isZero(Node node,double tol)
	{
		   return ( isReal(node)
					&&
					(  (((ASTConstant) node).getValue().equals(ZERO)) )
					 || Math.abs(doubleValue(node)) < tol )
				||( isComplex(node)
					&& ( ((Complex) ((ASTConstant) node).getValue()).equals(CZERO,tol) ) );
	}

	/**
	 * returns true if node is a ASTConstant with value Double(1) or Complex(1,0) 
	 */
	public boolean isOne(Node node)
	{
		return ( isReal(node)
				 && ( ((ASTConstant) node).getValue().equals(ONE)) )
			 ||( isComplex(node)
				 && ( ((Complex) ((ASTConstant) node).getValue()).equals(CONE,0.0) ) );
	}

	/**
	 * returns true if node is a ASTConstant with value Double(-1) or Complex(-1,0) 
	 */
	public boolean isMinusOne(Node node)
	{
		return ( isReal(node)
				 && ( ((ASTConstant) node).getValue().equals(MINUSONE)) )
			 ||( isComplex(node)
				 && ( ((Complex) ((ASTConstant) node).getValue()).equals(CMINUSONE,0.0) ) );
	}
	/** 
	 * returns true if node is a ASTConstant with a Infinite component
	 * TODO do proper treatment of signed infinity 
	 */

	public boolean isInfinity(Node node)
	{
		if(isReal(node))
		{
			Double dub = (Double) ((ASTConstant) node).getValue();
			return dub.isInfinite();
		}
		if(isComplex(node))
		{
			Complex z = (Complex) ((ASTConstant) node).getValue();
			return Double.isInfinite(z.re()) 
				|| Double.isInfinite(z.im());
		}
		return false;
	}

	/**
	 * returns true if node is a ASTConstant with a NaN component 
	 */
	public boolean isNaN(Node node)
	{
		if(isReal(node))
		{
			Double dub = (Double) ((ASTConstant) node).getValue();
			return dub.isNaN();
		}
		if(isComplex(node))
		{
			Complex z = (Complex) ((ASTConstant) node).getValue();
			return Double.isNaN(z.re()) 
				|| Double.isNaN(z.im());
		}
		return false;
	}

	/**
	 * returns true if node is an ASTConstant with a negative Double value 
	 */
	public boolean isNegative(Node node)
	{
			return isReal(node)
					 && ( ((Double) ((ASTConstant) node).getValue()).doubleValue() < 0.0 );
	}

	/**
	 * returns true if node is an ASTConstant with a positive Double value 
	 */
	public boolean isPositive(Node node)
	{
			return isReal(node)
					 && ( ((Double) ((ASTConstant) node).getValue()).doubleValue() > 0.0 );
	}

	/**
	 * returns true if node is an ASTConstant of type Complex
	 */
	 public boolean isComplex(Node node)
	 {
			return isConstant(node)
				 && ( ((ASTConstant) node).getValue() instanceof Complex );
	 }

	/**
	 * returns true if node is an ASTVarNode
	 */
	public boolean isVariable(Node node)
	{
	   return (node instanceof ASTVarNode);
	}
	
	/**
	 * returns true if node is an ASTOpNode
	 */
	public boolean isOperator(Node node)
	{
	   return (node instanceof ASTFunNode) && ((ASTFunNode) node).isOperator();
	}

	public boolean isBinaryOperator(Node node)
	{
	   if(isOperator(node))
	   {
	   		return ((XOperator) ((ASTFunNode) node).getOperator()).isBinary();
	   }
	   return false;
	}

	public boolean isUnaryOperator(Node node)
	{
	   if(isOperator(node))
	   {
			return ((XOperator) ((ASTFunNode) node).getOperator()).isUnary();
	   }
	   return false;
	}

	/**
	 * returns the operator for a node or null if it is not an operator node.
	 */
	public Operator getOperator(Node node)
	{
	   if(isOperator(node))
	   	return ((ASTFunNode) node).getOperator();
	   return null;
	}

	/**
	 * returns true if node is an ASTFunNode
	 */
	public boolean isFunction(Node node)
	{
	   return (node instanceof ASTFunNode);
	}
	
	/**
	 * Sets the children of a node if they have changed for it current children.
	 */
	public static Node copyChildrenIfNeeded(Node node,Node children[]) throws ParseException
	{
		int n=node.jjtGetNumChildren();
		if(n!=children.length)
			throw new ParseException("copyChildrenIfNeeded: umber of children of node not the same as supplied children");
		for(int i=0;i<n;++i)
			if(node.jjtGetChild(i) != children[i])
			{
				node.jjtAddChild(children[i],i);
				children[i].jjtSetParent(node);
			}
		return node;
	}

	/** returns the children of a node as an array of nodes. */
	static public Node[] getChildrenAsArray(Node node)
	{
		int n = node.jjtGetNumChildren();
		Node[] children = new Node[n];
		for(int i=0;i<n;++i)
			children[i]=node.jjtGetChild(i);
		return children;
	}

	public Object getCI() {	return CI;	}
	public Object getCMINUSI() {return CMINUSI;	}
	public Object getCMINUSONE() {return CMINUSONE;	}
	public Object getCONE() {return CONE;	}
	public Object getCZERO() {return CZERO;	}
	public Object getMINUSONE() {return MINUSONE;	}
	public Object getONE() {return ONE;	}
	public Object getZERO() {return ZERO;	}
	public Object getNAN() { return NAN; }
	public Object getPositiveInfinity() { return PosInf; }
	public Object getNegativeInfinity() { return NegInf; }
	public Object getNumber(double val) { return new Double(val); }
}
/* @author rich
 * Created on 19-Jun-2003
 */
package org.lsmp.djep.xjep;
import org.nfunk.jep.*;

/**
 * Interface defining the special actions performed during the preprocess 
 * stage. This interface should be implemented by PostFixMath Commands
 * which wish to perform a special action during the XJep.preprocess() method. 
 */
public interface CommandVisitorI {

	/**
	 * Performs the specified action on an expression tree.
	 * @param node top node of the tree
	 * @param children the children of the node after they have been preprocessed.
	 * @param xjep a reference to the current XJep interface.
	 * @return top node of the results.
	 * @throws ParseException
	 */
	public Node process(Node node,Node children[],XJep xjep) throws ParseException;
}
/* @author rich
 * Created on 18-Jun-2003
 */
package org.lsmp.djep.xjep;
import org.nfunk.jep.function.PostfixMathCommand;
import org.nfunk.jep.*;
import java.util.*;

/**
 * Symbolic eval(x^3,x,2) operator.  
 * @author R Morris.
 * Created on 18-Jun-2003
 */
public class Eval extends PostfixMathCommand implements CommandVisitorI
{
	/**
	 * Create a function that evaluates the lhs with values given on rhs.
	 * e.g. eval(f,x,1,y,2) sets variable x to 1, y to 2 and evaluates f.
	 */
	public Eval()
	{
		super();
		numberOfParameters = -1;
	}
	//TODO probably broken
	public Node process(Node node,Node children[],XJep xjep) throws ParseException
	{
		Vector errorList = new Vector();
		int nchild = children.length;
		if(nchild %2 == 0)
			throw new ParseException("Number of parameters must be odd");
		XSymbolTable localSymTab = (XSymbolTable) ((XSymbolTable) xjep.getSymbolTable()).newInstance();
		XJep localJep = xjep.newInstance(localSymTab);

		for(Enumeration en = xjep.getSymbolTable().keys();en.hasMoreElements();)
		{
			String key = (String) en.nextElement();
			Object val = xjep.getSymbolTable().getValue(key);
			localSymTab.addVariable(key,val);
		}
		/** first evaluate the arguments **/
		for(int i=1;i<nchild;i+=2)
		{
			ASTVarNode var;
			Object value;
			try
			{
				var = (ASTVarNode) children[i];
				Node rhs = children[i+1];
				if( rhs instanceof ASTConstant)
					value = ((ASTConstant) rhs).getValue();
				else
				{
					value = localJep.evaluate(rhs);
					if(!errorList.isEmpty())
						throw new ParseException(errorList.toString());
				}
			}
			catch(ClassCastException e)
			{
				throw new ParseException("Format should be eval(f,x,1,y,2) where x,y are variables and 1,2 are constants");
			}
			catch(Exception e)	{ throw new ParseException(e.getMessage());	}
			localSymTab.setVarValue(var.getName(),value);
		}
		/** now evaluate the equation **/
		try
		{
			Object res = localJep.evaluate(node.jjtGetChild(0));
			if(!errorList.isEmpty())
				throw new ParseException(errorList.toString());
			return xjep.getNodeFactory().buildConstantNode(res);
		}
		catch(Exception e2) { throw new ParseException(e2.getMessage()); } 
	}
	
	/**
	 * Should not be called by evaluator
	 * @throws ParseException if run.
	 */
	public void run(Stack s) throws ParseException 
	{
		throw new ParseException("Eval should not be called by Evaluator"); 
	}
}
/* @author rich
 * Created on 18-Jun-2003
 */
package org.lsmp.djep.xjep;

import org.nfunk.jep.function.PostfixMathCommand;
import org.nfunk.jep.*;
import java.util.*;
/**
 * A function specified by a string.
 * For example
 * <pre>
 * XJepI jep = new XJep();
 * j.addFunction("zap",new MacroFunction("zap",1,"x*(x-1)/2",j));
 * Node node = j.parse("zap(10)");
 * System.out.println(j.evaluate(node)); // print 45
 * </pre>
 * The names of the variables used inside the function depends on the number of arguments:
 * <ul>
 * <li>One argument variable must be x: <tt>new MacroFunction("sec",1,"1/cos(x)",j)</tt></li>
 * <li>Two arguments variables must be x or y: <tt>new MacroFunction("myPower",2,"x^y",j)</tt></li>
 * <li>Three or more arguments variables must be x1, x2, x3,...: <tt>new MacroFunction("add3",3,"x1+x2+x3",j)</tt></li>
 * </ul>
 * @author R Morris.
 * Created on 18-Jun-2003
 */
public class MacroFunction extends PostfixMathCommand
{
	private String name;
	private Node topNode;
	private EvaluatorI ev;
//	private XJep localJep;
	private XSymbolTable mySymTab;
	private Variable vars[];
	
	public String getName() { return name; }
	public Node getTopNode() { return topNode; }
	
	/**
	 * Create a function specified by a string.
	 * For example <tt>new MacroFunction("sec",1,"1/cos(x)",tu)</tt> creates the function for sec.
	 * Variable names must be x,y for 1 or 2 variables or x1,x2,x3,.. for 3 or more variables.
	 * @param inName name of function
	 * @param nargs number of arguments
	 * @param expression a string representing the expression.
	 * @param jep a reference to main XJep object.
	 */
	public MacroFunction(String inName,int nargs,String expression,XJep jep) throws IllegalArgumentException,ParseException
	{
		super();
		name = inName;

		XSymbolTable jepSymTab = (XSymbolTable) jep.getSymbolTable();
		mySymTab = (XSymbolTable) jepSymTab.newInstance(); 
		mySymTab.copyConstants(jepSymTab);
		XJep localJep = jep.newInstance(mySymTab);
		numberOfParameters = nargs;

		if(numberOfParameters == 0) {}
		else if(numberOfParameters == 1)
			vars = new Variable[]{mySymTab.addVariable("x",null)};
		else if(numberOfParameters == 2)
		{
			vars = new Variable[]{
					mySymTab.addVariable("x",null),
					mySymTab.addVariable("y",null)};
		}
		else
		{
			vars = new Variable[numberOfParameters];
			for(int i=numberOfParameters;i>0;--i)
				vars[i-1] = mySymTab.addVariable("x"+String.valueOf(i),null);
		}

		topNode = localJep.parse(expression);
		ev = new EvaluatorVisitor(mySymTab);
	}
	
	/**
	 * Calculates the value of the expression.
	 * @throws ParseException if run.
	 */
	public void run(Stack stack) throws ParseException 
	{

		if(numberOfParameters == 0) {}
		else if(numberOfParameters == 1)
			vars[0].setValue(stack.pop());
		else if(numberOfParameters == 2)
		{
			vars[1].setValue(stack.pop());
			vars[0].setValue(stack.pop());
		}
		else
		{
			for(int i=numberOfParameters;i>0;--i)
				vars[i-1].setValue(stack.pop());
		}
		try
		{
			Object res = ev.eval(topNode);
			stack.push(res);
		}
		catch(Exception e1) { throw new ParseException("MacroFunction eval: "+e1.getMessage()); }
	}
}
/* @author rich
 * Created on 16-Nov-2003
 */
package org.lsmp.djep.xjep;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
/**
 * This class is used to create nodes of specified types.
 * It can be sub-classed to change the nature of how nodes
 * are constructed. Generally there are two methods for creating
 * nodes, methods which take an existing node and methods which
 * take the components.
 * 
 * @author Rich Morris
 * Created on 16-Nov-2003
 */
public class NodeFactory {
    protected XJep xj;
	public NodeFactory(XJep xj) {this.xj=xj;}
	private NodeFactory() {}
	/**
	 * Sets the children of node to be those specified in array.
	 * @param node the node whose children will be set.
	 * @param children an array of nodes which will be the children of the node.
	 */
	public void copyChildren(Node node,Node children[])
	{	
		int nchild = children.length; 
		node.jjtOpen();
		for(int i=0;i<nchild;++i)
		{
			children[i].jjtSetParent(node);
			node.jjtAddChild(children[i],i);
		}
		node.jjtClose();
	}
	
	/** Creates an ASTConstant node with specified value. 
	 * This method should be overwritten by subclasses.
	 * @throws ParseException
	 **/
	public ASTConstant buildConstantNode(Object value) throws ParseException
	{
		ASTConstant node  = new ASTConstant(ParserTreeConstants.JJTCONSTANT);
		node.setValue(value);
		return node;
	}

	/** Create an ASTConstant with same value as argument. *
	 * @throws ParseException*/
	public ASTConstant buildConstantNode(ASTConstant node) throws ParseException
	{
		return buildConstantNode(node.getValue());
	}	

	/** Creates a constant node whose result is the given function applied to the children.
	 * @param pfmc the function to apply
     * @param children the arguments to the function, each argument should be a constant node.
     * @return a new constant node
	*/
	public ASTConstant buildConstantNode(PostfixMathCommandI pfmc, Node[] children) throws IllegalArgumentException, ParseException {
		Node node2 = buildFunctionNode("tmpfun",pfmc,children);
	    Object val = xj.getEvaluatorVisitor().eval(node2);
		return buildConstantNode(val);
	}

	/** Creates a ASTConstant whose value of applying the operator to its arguments. */
	public ASTConstant buildConstantNode(Operator op,Node children[]) throws IllegalArgumentException,ParseException
	{
		return buildConstantNode(op.getPFMC(),children);
	}

	/** Creates a ASTConstant whose value of applying binary operator to its arguments. */
	public ASTConstant buildConstantNode(Operator op,Node child1,Node child2) throws IllegalArgumentException,ParseException
	{
		return buildConstantNode(op.getPFMC(),new Node[]{child1,child2});
	}

	/** Creates a ASTConstant whose value of applying a unary operator to its arguments. */
	public ASTConstant buildConstantNode(Operator op,Node child1) throws IllegalArgumentException,ParseException
	{
		return buildConstantNode(op.getPFMC(),new Node[]{child1});
	}

	/** creates a new ASTVarNode with the same name as argument. 
	 * @throws ParseException*/ 
	public ASTVarNode buildVariableNode(ASTVarNode node) throws ParseException
	{
		   return buildVariableNode(node.getVar());
	}
	
	/** creates a new ASTVarNode with a given variable. 
	 * This method should be sub-classed
	 * @throws ParseException
	 */ 
	public ASTVarNode buildVariableNode(Variable var) throws ParseException
	{
		ASTVarNode node  = new ASTVarNode(ParserTreeConstants.JJTVARNODE);
		node.setVar(var);
		return node;
	}

	public ASTVarNode buildVariableNode(String name,Object value) throws ParseException
	{
	    return buildVariableNode(xj.getSymbolTable().addVariable(name,value));
	}
	/**
	 * Builds a operator node with n arguments
	 * This method should be sub-classed
	 * @param op the operator to use
	 * @param arguments the arguments to the function.
	 * @return top Node of expression 
	 * @throws ParseException
	 */
	
	public ASTFunNode buildOperatorNode(Operator op,Node[] arguments) throws ParseException
	{
		ASTFunNode res = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
		res.setOperator(op);
		copyChildren(res,arguments);
		return res;		
	}
	
	/**
	 * Builds a function with n arguments
	 * This method should be sub-classed
	 * @param name of function.
	 * @param pfmc PostfixMathCommand for function.
	 * @param arguments the arguments to the function.
	 * @return top Node of expression 
	 * @throws ParseException
	 */

	public ASTFunNode buildFunctionNode(String name,PostfixMathCommandI pfmc,Node[] arguments) throws ParseException
	{
		ASTFunNode res = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
		res.setFunction(name,pfmc);
		copyChildren(res,arguments);
		return res;		
	}


	/** An unfinished node. Caller has responsibility for
	 * filling in the children. */
	public ASTFunNode buildUnfinishedOperatorNode(Operator op)
	{
		ASTFunNode res = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
		res.setOperator(op);
		return res;		
	}
	
	/** creates a unary function. 
	 * @throws ParseException*/
	
	public ASTFunNode buildOperatorNode(Operator op,Node child) throws ParseException
	{
		return buildOperatorNode(op,new Node[]{child});		
	}
	
	/** creates a binary function. 
	 * @throws ParseException*/
	
	public ASTFunNode buildOperatorNode(Operator op,Node lhs,Node rhs) throws ParseException
	{
		return buildOperatorNode(op,new Node[]{lhs,rhs});		
	}
	
	/**
	 * Builds a function with n arguments and same fun as specified in arguments.
	 * @param node the properties (name and pfmc) of this node will be copied.
	 * @param arguments the arguments to the function.
	 * @return top Node of expression 
	 * @throws ParseException
	 */
	public ASTFunNode buildFunctionNode(ASTFunNode node,Node[] arguments) throws ParseException
	{
		if(node.getOperator()!=null)
			return buildOperatorNode(node.getOperator(),arguments); 
		return buildFunctionNode(node.getName(),node.getPFMC(),arguments);
	}

}
/* @author rich
 * Created on 03-Aug-2003
 */
package org.lsmp.djep.xjep;

import org.nfunk.jep.function.PostfixMathCommandI;
import org.nfunk.jep.*;

/**
 * An Operator with additional information about its commutativity etc.
 * <p>
 * Operators have a number of properties:
 * <ul>
 * <li>A symbol or name of the operator "+".
 * <li>The number of arguments NO_ARGS 0, UNARY 1 (eg UMINUS -x), 
 * BINARY 2 (eq x+y), and NARY either 3 ( a>b ? a : b) or
 * unspecified like a list [x,y,z,w].
 * <li>The binging of the operator, LEFT 1+2+3 -> (1+2)+3 or RIGHT 1=2=3 -> 1=(2=3).
 * <li>Whether the operator is ASSOCIATIVE or COMMUTATIVE.
 * <li>The precedence of the operators + has a higher precedence than *.
 * <li>For unary opperators they can either be PREFIX like -x or SUFIX like x%.
 * <li>Comparative operators can be REFLEXIVE, SYMMETRIC, TRANSITIVE or EQUIVILENCE which has all three properties.
 * <li>A reference to a PostfixtMathCommandI object which is used to evaluate an equation containing the operator.
 * </ul>
 * various is... and get... methods are provided to query the properties of the opperator.
 * 
 * @author Rich Morris
 * Created on 19-Oct-2003
 */
public class XOperator extends Operator {
	/** No arguments to operator */
	public static final int NO_ARGS=0;
	/** Unary operators, such as -x !x ~x */
	public static final int UNARY=1;
	/** Binary operators, such as x+y, x>y */
	public static final int BINARY=2;
	/** Trinary ops such as ?: and or higher like [x,y,z,w] */
	public static final int NARY=3;
	/** Left binding like +: 1+2+3 -> (1+2)+3 */
	public static final int LEFT=4;
	/** Right binding like =: 1=2=3 -> 1=(2=3) */
	public static final int RIGHT=8;
	/** Associative operators x*(y*z) == (x*y)*z . */
	public static final int ASSOCIATIVE=16;
	/** Commutative operators x*y = y*x. */
	public static final int COMMUTATIVE=32;
	/** Reflecive relations x=x for all x. */
	public static final int REFLEXIVE=64;
	/** Symmetric relation x=y implies y=x. */
	public static final int SYMMETRIC=128;
	/** Transative relations x=y and y=z implies x=z */
	public static final int TRANSITIVE=256;
	/** Equivilence relations = reflexive, transative and symetric. */
	public static final int EQUIVILENCE=TRANSITIVE+REFLEXIVE+SYMMETRIC;
	/** prefix operators -x **/
	public static final int PREFIX=512;
	/** postfix operators  x%, if neiter prefix and postif then infix, if both trifix like x?y:z **/
	public static final int SUFIX=1024;
	/** self inverse operators like -(-x) !(!x) **/
	public static final int SELF_INVERSE=2048;
	/** composite operators, like a-b which is a+(-b) **/
	public static final int COMPOSITE=4096;
	/** For non commutative operators printing can be determined by the left or right binding. 
	 *  For example (a-b)-c is printed as a-b-c. 
	 *  But a/b/c could be ambiguous so (a/b)/c is printed with brackets.
	 */	
	public static final int USE_BINDING_FOR_PRINT=8192;
	/** flags for type of operator */
	private int flags;

	/** construct a new operator.
	 * 
	 * @param name	printable name of operator
	 * @param pfmc  postfix math command for opperator
	 * @param flags set of flags defining the porperties of the operator.
	 */
	public XOperator(String name,PostfixMathCommandI pfmc,int flags)
	{
		super(name,pfmc);
		this.flags = flags; 
	}
	/**
	 * Allows a given precedent to be set.
	 * @param name
	 * @param pfmc
	 * @param flags
	 * @param precedence
	 */
	public XOperator(String name,PostfixMathCommandI pfmc,int flags,int precedence)
	{
		this(name,pfmc,flags);
		this.precedence=precedence;
	}
	/** construct a new operator, with a different name and symbol
	 * 
	 * @param name	name of operator, must be unique, used when describing operator
	 * @param symbol printable name of operator, used for printing equations
	 * @param pfmc  postfix math command for opperator
	 * @param flags set of flags defining the porperties of the operator.
	 */
	public XOperator(String name,String symbol,PostfixMathCommandI pfmc,int flags)
	{
		super(name,symbol,pfmc);
		this.flags = flags; 
	}
	/**
	 * Allows a given precedent to be set.
	 * @param name
	 * @param pfmc
	 * @param flags
	 * @param precedence
	 */
	public XOperator(String name,String symbol,PostfixMathCommandI pfmc,int flags,int precedence)
	{
		super(name,symbol,pfmc);
		this.precedence=precedence;
		this.flags=flags;
	}

	public XOperator(Operator op,int flags,int precedence)
	{
		this(op.getName(),op.getSymbol(),op.getPFMC(),flags,precedence);
	}

	public XOperator(Operator op,int flags)
	{
		this(op.getName(),op.getSymbol(),op.getPFMC(),flags);
	}
	/** Creates a new XOperators with same flags and precedance as argument. */
//	public XOperator(XOperator op,PostfixMathCommandI pfmc)
//	{
//		this(op.getName(),op.getSymbol(),op.getPFMC(),op.flags,op.precedence);
//	}

	/** precedence of operator, 0 is most tightly bound, so prec("*") < prec("+"). */
	private int precedence = -1;
	public final int getPrecedence() {return precedence;}
	protected final void setPrecedence(int i) {precedence = i;}

	/** Operators this is distributative over **/
	private Operator distribOver[] = new Operator[0];

	protected final void setDistributiveOver(Operator op)
	{
		int len = distribOver.length;
		Operator temp[] = new Operator[len+1];
		for(int i=0;i<len;++i)	temp[i] = distribOver[i];
		temp[len]=op;
		distribOver=temp; 
	}
	public boolean isDistributiveOver(Operator op)
	{
		for(int i=0;i<distribOver.length;++i)
			if(op == distribOver[i])
				return true;
		return false;	
	}
	
	/** For composite operators like a-b which is really a+(-b) there is a root operator and an inverse operator **/
	private Operator rootOperator=null;
	private Operator inverseOperator=null;
	private Operator binaryInverseOperator=null;
	protected void setRootOp(Operator root)	{rootOperator=root;}
	protected void setInverseOp(Operator inv){inverseOperator = inv;}
	protected void setBinaryInverseOp(Operator inv){binaryInverseOperator = inv;}
	public Operator getRootOp() { return rootOperator; }
	public Operator getInverseOp() { return inverseOperator; }
	public Operator getBinaryInverseOp() { return binaryInverseOperator; }

	/** 
	 * When parsing how is x+y+z interpreted.
	 * Can be Operator.LEFT x+y+z -> (x+y)+z or
	 * Operator.RIGHT x=y=z -> x=(y=z). 
	 */  
	public final int getBinding() { return (flags & (LEFT | RIGHT)); }
	public final boolean isAssociative() {return ((flags & ASSOCIATIVE) == ASSOCIATIVE);}
	public final boolean isCommutative() { return ((flags & COMMUTATIVE) == COMMUTATIVE);}
	public final boolean isBinary() {	return ((flags & 3) == BINARY);	}
	public final boolean isUnary() {	return ((flags & 3) == UNARY);	}
	public final boolean isNary() {	return ((flags & 3) == NARY);	}
	public final int numArgs() { return (flags & 3);	}
	public final boolean isTransitive() {	return ((flags & TRANSITIVE) == TRANSITIVE);	}
	public final boolean isSymmetric() {	return ((flags & SYMMETRIC) == SYMMETRIC);	}
	public final boolean isReflexive() {	return ((flags & REFLEXIVE) == REFLEXIVE);	}
	public final boolean isEquivilence() {return ((flags & EQUIVILENCE) == EQUIVILENCE);	}
	public final boolean isPrefix() {return ((flags & PREFIX) == PREFIX);	}
	public final boolean isSufix() {return ((flags & SUFIX) == SUFIX);	}
	public final boolean isComposite() {return ((flags & COMPOSITE) == COMPOSITE);	}
	public final boolean isSelfInverse() {return ((flags & SELF_INVERSE) == SELF_INVERSE);	}
	public final boolean useBindingForPrint() {return ((flags & USE_BINDING_FOR_PRINT) == USE_BINDING_FOR_PRINT);	}

	/** returns a verbose representation of the operator and all its properties. **/
	
	public String toFullString()
	{
		StringBuffer sb = new StringBuffer();
		sb.append("Operator: \""+getSymbol()+"\"");
		if(!getName().equals(getSymbol())) sb.append(" "+getName());
		switch(numArgs()){
		case 0: sb.append(" no arguments,"); break;
		case 1: sb.append(" unary,"); break;
		case 2: sb.append(" binary,"); break;
		case 3: sb.append(" variable number of arguments,"); break;
		}
		if(isPrefix() && isSufix()) sb.append(" trifix,");
		else if(isPrefix()) sb.append(" prefix,");
		else if(isSufix()) sb.append(" sufix,");
		else sb.append(" infix,");
		if(getBinding()==LEFT) sb.append(" left binding,");
		else if(getBinding()==RIGHT) sb.append(" right binding,");
		if(isAssociative()) sb.append(" associative,");
		if(isCommutative()) sb.append(" commutative,");
		sb.append(" precedence "+getPrecedence()+",");
		if(isEquivilence())
			sb.append(" equivilence relation,");
		else
		{
			if(isReflexive()) sb.append(" reflexive,");
			if(isSymmetric()) sb.append(" symmetric,");
			if(isTransitive()) sb.append(" transitive,");
		}
		sb.setCharAt(sb.length()-1,'.');
		return sb.toString();
	}
}
/* @author rich
 * Created on 18-Jun-2003
 */

package org.lsmp.djep.xjep;
//import org.lsmp.djep.matrixParser.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.PostfixMathCommandI;

/**
 * Executes commands like diff and eval embedded in expression trees.
 * For example you could do 
 * <pre>eval(diff(x^3,x),x,2)</pre>
 * to differentiate x^3 and then substitute x=2 to get the value 12. 
 * To use do
 * <pre>
 * JEP j = ...; Node in = ...;
 * TreeUtils tu = new TreeUtils(j);
 * CommandVisitor cv = new CommandVisitor(tu);
 * Node out = cv.process(in);
 * </pre>
 * Commands to be executed must implement
 * {@link org.lsmp.djep.xjep.CommandVisitorI CommandVisitorI} and {@link  org.nfunk.jep.function.PostfixMathCommandI PostfixMathCommandI}.
 * See {@link org.lsmp.djep.xjep.Eval Eval} for an example of this. 
 * See {@link org.nfunk.jep.ParserVisitor ParserVisitor} for details on the VisitorPattern.
 * @author R Morris
 * Created on 19-Jun-2003
 */
public class CommandVisitor extends DoNothingVisitor
{
  private XJep xjep;
  /** private default constructor to prevent init without a tree utils
   */
    public CommandVisitor()
  {
  }
  
  /** 
   * Descends the tree processing all diff, eval and simplify options
   */

  public Node process(Node node,XJep xj) throws ParseException
  {
  	this.xjep=xj;
	Node res = (Node) node.jjtAccept(this,null);
	return res;
  }

  public Object visit(ASTFunNode node, Object data) throws ParseException
  {
	Node children[] = acceptChildrenAsArray(node,data);

	PostfixMathCommandI pfmc = node.getPFMC();
	if(pfmc instanceof CommandVisitorI )
	{
		CommandVisitorI com = (CommandVisitorI) pfmc;
		return com.process(node,children,xjep);
	}
	TreeUtils.copyChildrenIfNeeded(node,children);
	return node;
  }
}
/* @author rich
 * Created on 26-Jul-2003
 */
package org.lsmp.djep.xjep;
import org.lsmp.djep.xjep.function.*;
import org.nfunk.jep.*;

/**
 * An OperatorSet where the operators have information about their commutativity etc.
 * 
 * @see XOperator
 * @author Rich Morris
 * Created on 26-Jul-2003
 */
public class XOperatorSet extends OperatorSet {
	
	private void annotateOperators(OperatorSet o) {
	OP_GT     =  new XOperator(o.getGT(),XOperator.BINARY+XOperator.LEFT+XOperator.TRANSITIVE);
	OP_LT     =  new XOperator(o.getLT(),XOperator.BINARY+XOperator.LEFT+XOperator.TRANSITIVE);
	OP_EQ     =  new XOperator(o.getEQ(),XOperator.BINARY+XOperator.LEFT+XOperator.EQUIVILENCE);
	OP_LE     =  new XOperator(o.getLE(),XOperator.BINARY+XOperator.LEFT+XOperator.REFLEXIVE+XOperator.TRANSITIVE);
	OP_GE     =  new XOperator(o.getGE(),XOperator.BINARY+XOperator.LEFT+XOperator.REFLEXIVE+XOperator.TRANSITIVE);
	OP_NE     =  new XOperator(o.getNE(),XOperator.BINARY+XOperator.LEFT+XOperator.SYMMETRIC);

	OP_AND    =  new XOperator(o.getAnd(),XOperator.BINARY+XOperator.LEFT+XOperator.COMMUTATIVE+XOperator.ASSOCIATIVE+XOperator.USE_BINDING_FOR_PRINT);
	OP_OR     =  new XOperator(o.getOr(),XOperator.BINARY+XOperator.LEFT+XOperator.COMMUTATIVE+XOperator.ASSOCIATIVE);
	OP_NOT    = new XOperator(o.getNot(),XOperator.UNARY+XOperator.RIGHT+XOperator.PREFIX+XOperator.SELF_INVERSE);

	OP_ADD   =  new XOperator(o.getAdd(),XOperator.BINARY+XOperator.LEFT+XOperator.COMMUTATIVE+XOperator.ASSOCIATIVE);
	OP_SUBTRACT  =  new XOperator(o.getSubtract(),XOperator.BINARY+XOperator.LEFT+XOperator.COMPOSITE+XOperator.USE_BINDING_FOR_PRINT);
	OP_UMINUS =  new XOperator(o.getUMinus(),XOperator.UNARY+XOperator.RIGHT+XOperator.PREFIX+XOperator.SELF_INVERSE);

	OP_MULTIPLY    =  new XOperator(o.getMultiply(),XOperator.BINARY+XOperator.LEFT+XOperator.COMMUTATIVE+XOperator.ASSOCIATIVE);
	OP_DIVIDE = new XOperator(o.getDivide(),XOperator.BINARY+XOperator.LEFT+XOperator.COMPOSITE);
	OP_MOD    = new XOperator(o.getMod(),XOperator.BINARY+XOperator.LEFT);
	/** unary division i.e. 1/x or x^(-1) **/ 
	OP_UDIVIDE =  new XOperator("UDivide","^-1",null,XOperator.UNARY+XOperator.RIGHT+XOperator.PREFIX+XOperator.SELF_INVERSE);

	OP_POWER  = new XOperator(o.getPower(),XOperator.BINARY+XOperator.LEFT);

	OP_ASSIGN = new XOperator("=",new XAssign(),XOperator.BINARY+XOperator.RIGHT); // 

	OP_DOT = new XOperator(o.getDot(),XOperator.BINARY+XOperator.LEFT); // 
	OP_CROSS = new XOperator(o.getCross(),XOperator.BINARY+XOperator.LEFT); // 
	OP_LIST = new XOperator(o.getList(),XOperator.NARY+XOperator.RIGHT); // 
	OP_ELEMENT = new XOperator(o.getElement(),XOperator.NARY+XOperator.RIGHT); // 
//	OP_RANGE = new XOperator(o.getRange(),XOperator.NARY+XOperator.RIGHT); //
	setPrecedenceTable(new Operator[][] 
		{	{OP_UMINUS},
			{OP_NOT},
			{OP_POWER},
			{OP_MULTIPLY,OP_DIVIDE,OP_MOD,OP_DOT,OP_CROSS},
			{OP_ADD,OP_SUBTRACT},
			{OP_LT,OP_LE},
			{OP_GT,OP_GE},
			{OP_EQ},
			{OP_NE},
			{OP_AND},
			{OP_OR},
			{OP_ASSIGN},
			});
	//printOperators();

	// 		
	((XOperator) OP_ADD).setInverseOp(OP_UMINUS);
	((XOperator) OP_ADD).setBinaryInverseOp(OP_SUBTRACT);
	((XOperator) OP_SUBTRACT).setRootOp(OP_ADD);
	((XOperator) OP_SUBTRACT).setInverseOp(OP_UMINUS);
	((XOperator) OP_UMINUS).setRootOp(OP_ADD);
	((XOperator) OP_UMINUS).setBinaryInverseOp(OP_SUBTRACT);
		
	((XOperator) OP_MULTIPLY).setInverseOp(OP_UDIVIDE);
	((XOperator) OP_MULTIPLY).setBinaryInverseOp(OP_DIVIDE);
	((XOperator) OP_DIVIDE).setRootOp(OP_MULTIPLY);
	((XOperator) OP_DIVIDE).setInverseOp(OP_UDIVIDE);
	((XOperator) OP_UDIVIDE).setRootOp(OP_MULTIPLY);
	((XOperator) OP_UDIVIDE).setBinaryInverseOp(OP_DIVIDE);
		
	// Set distributive over
	((XOperator) OP_UMINUS).setDistributiveOver(OP_ADD); // -(a+b) -> (-a) + (-b)
	((XOperator) OP_UMINUS).setDistributiveOver(OP_SUBTRACT); // -(a-b) -> (-a) - (-b)

	((XOperator) OP_MULTIPLY).setDistributiveOver(OP_ADD); // a*(b+c) -> a*b + a*c
	((XOperator) OP_MULTIPLY).setDistributiveOver(OP_SUBTRACT); // a*(b-c) -> a*b - a*c
	((XOperator) OP_MULTIPLY).setDistributiveOver(OP_UMINUS); // a*(-b) -> -(a*b)
	}

	/** Creates the operator set from a given set. Will
	 * use the names and pfmc's but adds info about the operators properties.
	 * Note changes pfmc for = from Assign to XAssign 	*/
	public XOperatorSet(OperatorSet opSet)
	{
		annotateOperators(opSet);
	}

	/** Create the standard set of operators. */
	public XOperatorSet()
	{
		annotateOperators(this);
	}
	
	/** 
	 * Sets the precedences of the operators according to order in the supplied array.
	 * For example
	 * <pre>
	 * 		setPrecedenceTable(new Operator[][] 
	 *		{	{OP_UMINUS},
	 *			{OP_NOT},
	 *			{OP_MUL,OP_DIV,OP_MOD},
	 *			{OP_PLUS,OP_MINUS},
	 *			{OP_LT,OP_LE},
	 *			{OP_GT,OP_GE},
	 *			{OP_EQ},
	 *			{OP_NE},
	 *			{OP_AND},
	 *			{OP_OR},
	 *			});
	 * </pre>
	 */

	public static final void setPrecedenceTable(Operator[][] precArray)
	{
		for(int i=0;i<precArray.length;++i)
			for(int j=0;j<precArray[i].length;++j)
				((XOperator) precArray[i][j]).setPrecedence(i);
	}
	
	/** Prints all the operators, with verbose representations of each operators properties. 
	 * 
	 */
	public void printOperators()
	{
		Operator ops[] = getOperators();
		int maxPrec = -1;
		for(int i=0;i<ops.length;++i)
			if(((XOperator) ops[i]).getPrecedence()>maxPrec) maxPrec=((XOperator) ops[i]).getPrecedence();
		for(int j=-1;j<=maxPrec;++j)
			for(int i=0;i<ops.length;++i)
				if(((XOperator) ops[i]).getPrecedence()==j)
					System.out.println(((XOperator) ops[i]).toFullString());
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.lsmp.djep.xjep;
import java.util.*;
import org.nfunk.jep.*;

/**
 * An extension of the symbol table with a few new features.
 * 
 * @author Rich Morris
 * Created on 18-Mar-2004
 */
public class XSymbolTable extends SymbolTable
{
	/**
	 * 
	 */
	private static final long serialVersionUID = 741560154912130566L;

	/**
	 * Create a new XSymbolTable with the given variable factory.
	 */
	public XSymbolTable(VariableFactory varFac)
	{
		super(varFac);
	}
	
	/** Creates a new SymbolTable with the same variable factory as this. */
	public SymbolTable newInstance()
	{
		return new XSymbolTable(this.getVariableFactory());
	}

	/** Prints the contents of the symbol table displaying its equations and value. */	
	public void print(PrintVisitor pv)
	{
		for(Enumeration e = this.elements(); e.hasMoreElements(); ) 
		{
			XVariable var = (XVariable) e.nextElement();
			pv.append(var.toString(pv)+"\n");
			// TODO watch out for possible conflict with overriding pv's string buffer
		}
	}	
	
	/** Copy the values of all constants into this from the supplied symbol table. */
	public void copyConstants(SymbolTable symTab)
	{
		for(Enumeration e = symTab.elements(); e.hasMoreElements(); ) 
		{
			Variable var = (Variable) e.nextElement();
			if(var.isConstant())
				this.addConstant(var.getName(),var.getValue());
		}
	}
}
package org.lsmp.djep.xjep;

import org.nfunk.jep.*;

/**
 * This class is used for the evaluation of an expression. It uses the Visitor
 * design pattern to traverse the function tree and evaluate the expression
 * using a stack.
 * <p>
 * Function nodes are evaluated by first evaluating all the children nodes,
 * then applying the function class associated with the node. Variable and
 * constant nodes are evaluated by pushing their value onto the stack.

 * <p>
 * Some changes implemented by rjm. Nov 03.
 * Added hook to SpecialEvaluationI.
 * Clears stack before evaluation.
 * Simplifies error handling by making visit methods throw ParseException.
 * Changed visit(ASTVarNode node) so messages not calculated every time. 
 */
public class XEvaluatorVisitor extends EvaluatorVisitor {

	public XEvaluatorVisitor(SymbolTable st) {
		super(st);
	}

	/**
	 * Visit a variable node. The value of the variable is obtained from the
	 * symbol table (symTab) and pushed onto the stack.
	 */
	public Object visit(ASTVarNode node, Object data) throws ParseException {

		Variable var = node.getVar();
		if (var == null) {
			String message = "Could not evaluate " + node.getName() + ": ";
			throw new ParseException(message + " variable not set");
		}
		Object val = null;
		if(var.hasValidValue()) {
			val = var.getValue();
			if (trapNullValues && val == null) {
				String message = "Could not evaluate " + node.getName() + ": null value";
				throw new ParseException(message);
			}
			stack.push(val);
		} 
		else if(var instanceof XVariable)
		{
			Node equation = ((XVariable) var).getEquation();
			if(equation==null)
				throw new ParseException("Cannot find value of "+var.getName()+" no equation.");
			// TODO causes stack overflow if recursive eqn with undefined value is used: recurse = recurse+1
			equation.jjtAccept(this,data);
			val = stack.peek();
			if (trapNullValues && val == null) {
				String message = "Could not evaluate " + node.getName() + ": null value";
				throw new ParseException(message);
			}
		}
		else
		{
			throw new ParseException("Could not evaluate " + node.getName() + ": value not set");
		}

		return data;
	}
}
   
package org.lsmp.djep.xjep;
//import org.lsmp.djep.matrixParser.*;
import org.nfunk.jep.*;

/**
 * Simplifies an expression.
 * To use
 * <pre>
 * JEP j = ...; Node in = ...;
 * SimplificationVisitor sv = new SimplificationVisitor(tu);
 * Node out = sv.simplify(in);
 * </pre>
 * 
 * <p>
 * Its intended to completly rewrite this class to that simplification
 * rules can be specified by strings in a way similar to DiffRulesI.
 * It also would be nice to change the rules depending on the type of
 * arguments, for example matrix multiplication is not commutative.
 * But some of the in built rules exploit commutativity.
 * 
 * @author Rich Morris
 * Created on 20-Jun-2003
 * TODO cope with 'a - (-1) * b'
 * TODO cope with '0 - uminus(b)' 
 * TODO cope with simplifying complex numbers
 */

public class SimplificationVisitor extends DoNothingVisitor
{
  private NodeFactory nf;
  private OperatorSet opSet;
  private TreeUtils tu;
  
  public SimplificationVisitor()
  {
  }

  /** must be implemented for subclasses. **/
  public Node simplify(Node node,XJep xjep) throws ParseException,IllegalArgumentException
  {
	nf = xjep.getNodeFactory();
	opSet = xjep.getOperatorSet();
	tu = xjep.getTreeUtils();
	
	if (node == null) return null;
//		throw new IllegalArgumentException(
//			"topNode parameter is null");
	Node res = (Node) node.jjtAccept(this,null);
	return res;
  }
	/** First create a new node and then simplify it. */
	public Node simplifyBuiltOperatorNode(Operator op,Node lhs,Node rhs) throws ParseException
	{
		ASTFunNode res = nf.buildOperatorNode(op,lhs,rhs);
		Node res2 = simplifyOp(res,new Node[]{lhs,rhs});
		return res2;
	}
 	/**
 	 * Simplifies expressions like 2+(3+x) or (2+x)+3
 	 * 
 	 * @param op the root operator
 	 * @param lhs the left hand side node
 	 * @param rhs the right hand side node
 	 * @return null if no rewrite happens or top node or top node of new tree.
 	 * @throws ParseException
 	 */
	public Node simplifyTripple(XOperator op,Node lhs,Node rhs) throws ParseException
	{
		
		XOperator rootOp;
		if(op.isComposite()) rootOp = (XOperator) op.getRootOp();
		else				 rootOp = op;

		if(op.isCommutative() && tu.isConstant(rhs))
		{
			return simplifyBuiltOperatorNode(op,rhs,lhs);
		}			
		if(tu.isConstant(lhs) && tu.isBinaryOperator(rhs))
		{
			Node rhsChild1 = rhs.jjtGetChild(0);
			Node rhsChild2 = rhs.jjtGetChild(1);
			XOperator rhsOp = (XOperator) ((ASTFunNode) rhs).getOperator();
			XOperator rhsRoot;
			if(rhsOp.isComposite())	rhsRoot = (XOperator) rhsOp.getRootOp();
			else					rhsRoot = rhsOp;
	
			if(tu.isConstant(rhsChild1))	
			{
				XOperator op2 = rootOp;
				if(op == rhsOp) op2 = rootOp;
				else			op2 = (XOperator) rootOp.getBinaryInverseOp();

				//	2 + ~( 3 + ~x ) -> (2+~3) + ~~x
				if(rootOp == rhsRoot && rootOp.isAssociative()) 
				{
					Node newnode = simplifyBuiltOperatorNode(op2,
						nf.buildConstantNode(op,lhs,rhsChild1),rhsChild2);
					return newnode;
				}
			
				if(op.isDistributiveOver(rhsRoot))	// 2 * (3 + ~x) -> (2 * 3) + ~(2 @ x)
				{
					Node newnode = simplifyBuiltOperatorNode(rhsOp,
						nf.buildConstantNode(op,lhs,rhsChild1),
						simplifyBuiltOperatorNode(op,lhs,rhsChild2));
					return newnode;
				}
			}


			if(tu.isConstant(rhsChild2))	
			{
				// 2 + ~( x + ~3 ) -> (2 + ~~3) + ~x

				Operator op2 = rootOp;
				if(op == rhsOp) op2 = rootOp;
				else			op2 = rootOp.getBinaryInverseOp();

				if(rootOp == rhsRoot && rootOp.isCommutative() && rootOp.isAssociative())
				{
					Node newnode = simplifyBuiltOperatorNode(op,
						nf.buildConstantNode(op2,lhs,rhsChild2),rhsChild1);
					return newnode;
				}
			
				if(op.isDistributiveOver(rhsRoot))	// 2 * (x + ~3) -> (2 * x) + ~(2 * 3)
				{
					Node newnode = simplifyBuiltOperatorNode(rhsOp,
						simplifyBuiltOperatorNode(op,lhs,rhsChild1),
						nf.buildConstantNode(op,lhs,rhsChild2));
					return newnode;
				}
			}
		}

		if(tu.isBinaryOperator(lhs) && tu.isConstant(rhs))
		{
			Node lhsChild1 = lhs.jjtGetChild(0);
			Node lhsChild2 = lhs.jjtGetChild(1);
			XOperator lhsOp = (XOperator) ((ASTFunNode) lhs).getOperator();
			XOperator lhsRoot;
			if(lhsOp.isComposite())	lhsRoot = (XOperator) lhsOp.getRootOp();
			else					lhsRoot = lhsOp;
	
			if(tu.isConstant(lhsChild1))	
			{
				// (2 + ~x) + ~3    ->   (2 + ~3) + ~x
				if(rootOp == lhsRoot && rootOp.isAssociative() && rootOp.isCommutative())
				{
					Node newnode = simplifyBuiltOperatorNode(lhsOp,
						nf.buildConstantNode(op,lhsChild1,rhs),
						lhsChild2);
					return newnode;
				}
			
				// (2 + ~x) * 3    -->  (2*3) +~ (x*3)
				if(op.isDistributiveOver(lhsRoot)) 
				{
					Node newnode = simplifyBuiltOperatorNode(lhsOp,
						nf.buildConstantNode(op,lhsChild1,rhs),
						simplifyBuiltOperatorNode(op,lhsChild2,rhs));
					return newnode;
				}
			}


			if(tu.isConstant(lhsChild2))	
			{
				// (x + ~2) + !3 -> x + (~2 + !3) -> x + ~(2+~!3)
				// (x*2)*3 -> x*(2*3), (x/2)*3 -> x/(2/3)
				// (x*2)/3 -> x*(2/3), (x/2)/3 -> x/(2*3) 
				if(rootOp == lhsRoot && rootOp.isAssociative())
				{
					Operator op2 = rootOp;
					if(op == lhsOp) op2 = rootOp;
					else			op2 = rootOp.getBinaryInverseOp();
					
					Node newnode = simplifyBuiltOperatorNode(lhsOp,
						lhsChild1,
						nf.buildConstantNode(op2,lhsChild2,rhs));
					return newnode;
				}
			
				// (x + ~2) * 3 -> (x*3) + ~(2*3)
				if(op.isDistributiveOver(lhsRoot))
				{
					Node newnode = simplifyBuiltOperatorNode(lhsOp,
						simplifyBuiltOperatorNode(op,lhsChild1,rhs),
						nf.buildConstantNode(op,lhsChild2,rhs));
					return newnode;
				}
			}
		}
		return null;
	}

  /**
   * Simplifies an addition. Performs the following rules
   * <pre>
   * 0+x -> x
   * x+0 -> x
   * m+n -> (m+n) where m,n are numbers
   * x - (-2) -> x + 2 for any negative number -2
   * x + (-2) -> x - 2 for any negative number -2
   * 2 +/- ( 3 +/- x ) ->  (2 +/- 3 ) +/- x and similar
   * </pre>
   */
  
  public Node simplifyAdd(Node lhs,Node rhs) throws ParseException
  {
	if(tu.isInfinity(lhs))
	{	// Inf + Inf -> NaN TODO not correct for signed infinity 
		if(tu.isInfinity(rhs))
			return nf.buildConstantNode(tu.getNAN());
		// Inf + x -> Inf
		return nf.buildConstantNode(tu.getPositiveInfinity());
	}
	if(tu.isInfinity(rhs)) // x + Inf -> Inf
		return nf.buildConstantNode(tu.getPositiveInfinity());
	  
	if(tu.isZero(lhs))	// 0+x -> x
		return rhs;
	if(tu.isZero(rhs))	// x + 0 -> x
		return lhs;

	if(tu.isNegative(lhs)) // -3 + x -> x - 3
	{
		Node newnode = nf.buildOperatorNode(opSet.getSubtract(),
			rhs,
			nf.buildConstantNode(opSet.getUMinus(),lhs));
		return newnode;
	}
	if(tu.isNegative(rhs)) // x + -3 -> x - 3
	{
		Node newnode = nf.buildOperatorNode(opSet.getSubtract(),
			lhs,
			nf.buildConstantNode(opSet.getUMinus(),rhs));
		return newnode;
	}
	return null;
//	return nf.buildOperatorNode(node.getOperator(),lhs,dimKids[1]);
//	return opSet.buildAddNode(lhs,dimKids[1]);
  }

  /**
   * Simplifies a subtraction. Performs the following rules
   * <pre>
   * 0-x -> 0-x
   * x-0 -> x
   * m-n -> (m-n) where m,n are numbers
   * x - (-2) -> x + 2 for any negative number -2
   * x + (-2) -> x - 2 for any negative number -2
   * 2 +/- ( 3 +/- x ) ->  (2 +/- 3 ) +/- x and similar
   * </pre>
   * @param lhs the left hand side
   * @param rhs the right hand side
   */
  
  public Node simplifySubtract(Node lhs,Node rhs) throws ParseException
  {
	if(tu.isInfinity(lhs))
	{	// Inf + Inf -> NaN TODO not correct for signed infinity 
		if(tu.isInfinity(rhs))
			return nf.buildConstantNode(tu.getNAN());
		// Inf + x -> Inf
		return nf.buildConstantNode(tu.getPositiveInfinity());
	}
	if(tu.isInfinity(rhs)) // x + Inf -> Inf
		return nf.buildConstantNode(tu.getPositiveInfinity());

	if(tu.isZero(rhs))	// x - 0 -> x
		return lhs;
	// TODO implement 0 - x -> -(x)
	
	if(tu.isNegative(rhs)) // x - (-2) -> x + 2
	{
		Node newnode = simplifyBuiltOperatorNode(opSet.getAdd(),
			lhs,
			nf.buildConstantNode(opSet.getUMinus(),rhs));
		return newnode;
	}
	
	if(tu.getOperator(rhs)==opSet.getUMinus())
	{
		Node newnode = simplifyBuiltOperatorNode(opSet.getAdd(),
			lhs,
			rhs.jjtGetChild(0));
		return newnode;
	}
/*	if(tu.getOperator(rhs)==opSet.getMultiply())
	{
		if(tu.isNegative(rhs.jjtGetChild(0))) // a - (-2) * b -> a + 2 * b
		{
			Node newnode = simplifyBuiltOperatorNode(
				opSet.getAdd(),
				lhs,
				nf.buildOperatorNode(
					opSet.getMultiply(),
					nf.buildConstantNode(
						opSet.getUMinus(),rhs.jjtGetChild(0)),
					rhs.jjtGetChild(1)));
			return newnode;
		}
	}
*/
	return null;
//	return nf.buildOperatorNode(((ASTOpNode) node).getOperator(),lhs,rhs);
//	return tu.buildSubtract(lhs,rhs);
  }
  
  /**
   * Simplifies a multiplication.
   * <pre>
   * 0 * Inf -> NaN
   * 0 * x -> 0
   * x * 0 -> 0
   * 1 * x -> x
   * x * 1 -> x
   * Inf * x -> Inf
   * x * Inf -> Inf
   * 2 * ( 3 * x) -> (2*3) * x
   * and similar.
   * </pre>
   */
  
  public Node simplifyMultiply(Node child1,Node child2) throws ParseException
  {
	if(tu.isZero(child1))
	{	// 0*Inf -> NaN 
		if(tu.isInfinity(child2))
			return nf.buildConstantNode(tu.getNAN());
		// 0*x -> 0
		return nf.buildConstantNode(tu.getZERO());
	}
	if(tu.isZero(child2))
	{ // Inf*0 -> NaN
		if(tu.isInfinity(child1))
			return nf.buildConstantNode(tu.getNAN());
		// 0 * x -> 0
		return nf.buildConstantNode(tu.getZERO());
	}
	if(tu.isInfinity(child1)) // Inf * x -> Inf
			return nf.buildConstantNode(tu.getPositiveInfinity());
	if(tu.isInfinity(child2)) // x * Inf -> Inf
			return nf.buildConstantNode(tu.getPositiveInfinity());
	  			  
	if(tu.isOne(child1))	// 1*x -> x
			  return child2;
	if(tu.isOne(child2))	// x*1 -> x
			  return child1;
	
	if(tu.isMinusOne(child1))	// -1*x -> -x
	{
		Node newnode = nf.buildOperatorNode(opSet.getUMinus(),child2);
		return newnode;
	}

	if(tu.isMinusOne(child2))	// x*-1 -> -x
	{
		Node newnode = nf.buildOperatorNode(opSet.getUMinus(),child1);
		return newnode;
	}
	return null;
//	return nf.buildOperatorNode(((ASTOpNode) node).getOperator(),child1,child2);
//  return tu.buildMultiply(child1,child2);
	}
	/**
	 * Simplifies a division.
	 * <pre>
	 * 0/0 -> NaN
	 * 0/Inf -> Inf
	 * 0/x -> Inf
	 * x/0 -> Inf
	 * x/1 -> x
	 * Inf / x -> Inf
	 * x / Inf -> 0
	 * 2 / ( 3 * x) -> (2/3) / x
	 * 2 / ( x * 3) -> (2/3) / x
	 * 2 / ( 3 / x) -> (2/3) * x
	 * 2 / ( x / 3) -> (2*3) / x
	 * (2 * x) / 3 -> (2/3) * x
	 * (x * 2) / 3 -> x * (2/3)
	 * (2 / x) / 3 -> (2/3) / x
	 * (x / 2) / 3 -> x / (2*3)
	 * </pre>
	 */
	public Node simplifyDivide(Node child1,Node child2) throws ParseException
	{
	  if(tu.isZero(child2))
	  {
		if(tu.isZero(child1))	// 0/0 -> NaN
			return nf.buildConstantNode(tu.getNAN());
		// x/0 -> Inf
		return nf.buildConstantNode(tu.getPositiveInfinity());
	  }
		  
	  if(tu.isZero(child1))
	  {		// 0/x -> 0
		return child1;
	  }
	  //if(tu.isOne(child1))	// 1/x -> 1/x
	  //		  return child2;
	  if(tu.isOne(child2))	// x/1 -> x
			  return child1;
			
	  if(tu.isInfinity(child1)) // Inf / x -> Inf
			  return nf.buildConstantNode(tu.getPositiveInfinity());
	  if(tu.isInfinity(child2)) // x / Inf -> 0
			  return nf.buildConstantNode(tu.getZERO());
  	  return null;
//	  return nf.buildOperatorNode(((ASTOpNode) node).getOperator(),child1,child2);
//	  return opSet.buildDivideNode(child1,child2);
	}

	/** Simplify a power.
	 * <pre>
	 * x^0 -> 1
	 * x^1 -> x
	 * 0^0 -> NaN
	 * 0^x -> 0
	 * 1^x -> 1
	 * </pre>
	 */
	public Node simplifyPower(Node child1,Node child2) throws ParseException
	{
		if(tu.isZero(child1))
		{
			if(tu.isZero(child2))	// 0^0 -> NaN
				return nf.buildConstantNode(tu.getNAN());
			// 0^x -> 0
			return nf.buildConstantNode(tu.getZERO());
		}
		if(tu.isZero(child2))	// x^0 -> 1
			return nf.buildConstantNode(tu.getONE());
		if(tu.isOne(child1))	// 1^x -> 1
			return nf.buildConstantNode(tu.getONE());
		if(tu.isOne(child2))	// x^1 -> x
			return child1;
			
		if(tu.isConstant(child2) && tu.getOperator(child1) == opSet.getPower())
		{
			if(tu.isConstant(child1.jjtGetChild(1)))
			{
				/* (x^3)^4 -> x^(3*4) */
				return nf.buildOperatorNode(
					opSet.getPower(),
					child1.jjtGetChild(0),
					nf.buildConstantNode(
						opSet.getMultiply(),
						child1.jjtGetChild(1),
						child2));
			}
		}
		return null;	
//		return nf.buildOperatorNode(((ASTOpNode) node).getOperator(),child1,child2);
//		return tu.buildPower(child1,child2);
	}

	/** simplifies operators, does not descend into children */

	public Node simplifyOp(ASTFunNode node,Node children[]) throws ParseException
	{
		boolean allConst=true;
		XOperator op= (XOperator) node.getOperator();
		// TODO a bit of a hack to prevent lists of constants being converted
		// what happens is that for [[1,2],[3,4]] the dimension is not passed
		// into buildConstantNode so list is treated as [1,2,3,4]
		// Ideally there would be a special simplification rule for List 
		if(op.getPFMC() instanceof org.nfunk.jep.function.List) return node;
		int nchild=children.length;
		for(int i=0;i<nchild;++i)
		{
			if(!tu.isConstant(children[i]))
				allConst=false;
			if(tu.isNaN(children[i]))
				return nf.buildConstantNode(tu.getNAN());
		}	
		if(allConst)
			return nf.buildConstantNode(op,children);
		
		if(nchild==1)
		{
			if(tu.isUnaryOperator(children[0]) && op == tu.getOperator(children[0]))
			{
				if(op.isSelfInverse()) return children[0].jjtGetChild(0);
			}
		}
		if(nchild==2)
		{
			Node res=null;
			if(opSet.getAdd() == op) res = simplifyAdd(children[0],children[1]);
			if(opSet.getSubtract() == op) res = simplifySubtract(children[0],children[1]);
			if(opSet.getMultiply() == op) res = simplifyMultiply(children[0],children[1]);
			if(opSet.getDivide() == op) res = simplifyDivide(children[0],children[1]);
			if(opSet.getPower() == op) res = simplifyPower(children[0],children[1]);
			if(res!=null)
			{
				if(tu.isConstant(res)) return res;
				if(tu.isOperator(res))
				{
					Node res2 = simplifyOp((ASTFunNode) res,TreeUtils.getChildrenAsArray(res));
					return res2;
				} 
				return res;
			}
			res = this.simplifyTripple(op,children[0],children[1]);
			if(res!=null)
			{
				if(tu.isConstant(res)) return res;
				if(tu.isOperator(res))
				{
					Node res2 = simplifyOp((ASTFunNode) res,TreeUtils.getChildrenAsArray(res));
					return res2;
				} 
				return res;
			}
		}
		return node;
	}
	
	public Object visit(ASTFunNode node, Object data) throws ParseException
	{
		int nchild = node.jjtGetNumChildren();

		if(node.isOperator())
		{
			XOperator op= (XOperator) node.getOperator();
			if( (op.isBinary() && nchild !=2)
			 || (op.isUnary() && nchild !=1))
			 throw new ParseException("Wrong number of children for "+nchild+" for operator "+op.getName());
	
			Node children[] = acceptChildrenAsArray(node,data);
			TreeUtils.copyChildrenIfNeeded(node,children);
	
			Node res = simplifyOp(node,children);
			if(res == null)
				throw new ParseException("null res from simp op");
			return res;
		}		
		
		Node children[] = acceptChildrenAsArray(node,data);

		boolean allConst=true;
		for(int i=0;i<nchild;++i)
		{
			if(!tu.isConstant(children[i]))
				allConst=false;
			if(tu.isNaN(children[i]))
				return nf.buildConstantNode(tu.getNAN());
		}	
		if(allConst)
			return nf.buildConstantNode(node.getPFMC(),children);
	
		return TreeUtils.copyChildrenIfNeeded(node,children);
		
	}
}
/* @author rich
 * Created on 01-Oct-2004
 */
package org.lsmp.djep.xjep;
import java.util.*;
/**
 * @author Rich Morris
 * Created on 01-Oct-2004
 */
public class XMath {

	static class LongPair { 
		long a,b;
		public LongPair(long x,long y) { a=x; b=y;}
		long x() { return a; }
		long y() { return b; }
		public boolean equals(Object o) {
			if(!( o instanceof LongPair)) return false;
			LongPair p = (LongPair) o;
			return (a == p.a) && (b == p.b); 
		}

		public int hashCode() {
			int result = 17;
			int xi = (int)(a^(a>>32));
			int yi = (int)(b^(b>>32));
			result = 37*result+xi;
			result = 37*result+yi;
			return result;
		}
		public String toString() { return "("+a+","+b+")"; }
		
	}	
	static Hashtable pascal = new Hashtable();

	public static long binomial(long n,long i)
	{
		if(i==0 || n==i) return 1;
		if(i==1 || n==i-1 ) return n;
		return binomial(new LongPair(n,i));
	}
	
	public static long binomial(LongPair pair)
	{
		Object find = pascal.get(pair);
		if(find == null)
		{
			long l = binomial(pair.x()-1,pair.y()-1);
			long r = binomial(pair.x()-1,pair.y());
			pascal.put(pair,new Long(l+r));
			return l+r; 
		}
		return ((Long) find).longValue();
	}
}
/* @author rich
 * Created on 16-Nov-2003
 */
package org.lsmp.djep.xjep;

import org.nfunk.jep.*;

/**
 * A Visitor which returns an exact copy of the tree.
 * This class should be extended by visitors which
 * modify trees and creates a new tree.
 * 
 * @author Rich Morris
 * Created on 16-Nov-2003
 */
public class DeepCopyVisitor extends DoNothingVisitor implements ParserVisitor {

	private XJep xjep;
	/** Creates a deepCopy of a Node **/	
	public Node deepCopy(Node node,XJep xj) throws ParseException
	{
		this.xjep = xj;
		Node res = (Node) node.jjtAccept(this,null);
		return res;
	}

	public Object visit(ASTConstant node, Object data)  throws ParseException
	{
		return xjep.getNodeFactory().buildConstantNode(node);
	}

	public Object visit(ASTVarNode node, Object data)  throws ParseException
	{
		return xjep.getNodeFactory().buildVariableNode(node);
	}

	public Object visit(ASTFunNode node, Object data)  throws ParseException
	{
		Node children[]=acceptChildrenAsArray(node,data);
		return xjep.getNodeFactory().buildFunctionNode(node,children);
	}
}
/* @author rich
 * Created on 18-Jun-2003
 */

package org.lsmp.djep.xjep;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
import java.io.PrintStream;
import java.util.Hashtable;
import java.text.NumberFormat;
import java.text.FieldPosition;
/**
 * Prints an expression.
 * Prints the expression with lots of brackets.
 * <tt>((-1.0)/sqrt((1.0-(x^2.0))))</tt>.
 * To use
 * <pre>
 * XJep j = ...; Node in = ...;
 * j.print(in,"x");
 * </pre>
 * @author Rich Morris
 * Created on 20-Jun-2003
 * @since Dec 04 and NumberFormat object can be supplied to modify printing of numbers.
 * @since 21 Dec 04 PrintVisitor can now cope with 3 or more arguments to + and *. 
 * @see XJep#print(Node)
 * @see XJep#print(Node, PrintStream)
 * @see XJep#println(Node)
 * @see XJep#println(Node, PrintStream)
 * @see XJep#toString(Node)
 */
public class PrintVisitor extends ErrorCatchingVisitor
{
  /** All brackets are printed. Removes all ambiguity. */
  public static final int FULL_BRACKET = 1;
  /** Print Complex as 3+2 i */
  public static final int COMPLEX_I = 2;
  private int maxLen = -1;
  protected StringBuffer sb;
  /** The current mode for printing. */
//  protected boolean fullBrackets=false;
  protected int mode=0;
  private Hashtable specialRules = new Hashtable();
  
  /** Creates a visitor to create and print string representations of an expression tree. **/

  public PrintVisitor()
  {
  }

  
  /** Prints the tree descending from node with lots of brackets 
   * or specified stream. 
   * @see XJep#println(Node, PrintStream)
   **/

  public void print(Node node,PrintStream out)
  {
	sb = new StringBuffer();
	acceptCatchingErrors(node,null);
	if(maxLen == -1)
		out.print(sb);
	else
	{
		while(true)	{
			if(sb.length() < maxLen) {
				out.print(sb);
				return;
			}
			int pos = maxLen-2;
			for(int i=maxLen-2;i>=0;--i) {
				char c = sb.charAt(i);
				if(c == '+' || c == '-' || c == '*' || c == '/'){
					pos = i; break;
				}
			}
			//out.println("<"+sb.substring(0,pos+10)+">");
			out.println(sb.substring(0,pos+1));
			sb.delete(0,pos+1);
		}
	}
  }

  /** Prints on System.out. */
  public void print(Node node) { print(node,System.out); }
    
  /** Prints the tree descending from node with a newline at end. **/

  public void println(Node node,PrintStream out)
  {
	print(node,out);
	out.println("");
  }

  /** Prints on System.out. */
  public void println(Node node) { println(node,System.out); }

  /** returns a String representation of the equation. */
  
  public String toString(Node node)
  {
	sb = new StringBuffer();
	acceptCatchingErrors(node,null);
	return sb.toString();
  }
  
	/**
	 * This interface specifies the method needed to implement a special print rule.
	 * A special rule must implement the append method, which should
	 * call pv.append to add data to the output. For example
	 * <pre>
	 * 	pv.addSpecialRule(Operator.OP_LIST,new PrintVisitor.PrintRulesI()
	 *	{
	 *  	public void append(Node node,PrintVisitor pv) throws ParseException
	 *		{
	 *			pv.append("[");
	 *			for(int i=0;i<node.jjtGetNumChildren();++i)
	 *			{
	 *				if(i>0) pv.append(",");
	 *				node.jjtGetChild(i).jjtAccept(pv, null);
	 *			}
	 *			pv.append("]");
	 *		}});
 	 * </pre>
	 * @author Rich Morris
	 * Created on 21-Feb-2004
	 */
  public interface PrintRulesI
  {
  	/** The method called to append data for the rule. **/
  	public void append(Node node,PrintVisitor pv) throws ParseException;
  }

  /** Add a string to buffer. Classes implementing PrintRulesI 
   * should call this add the */
  public void append(String s) { sb.append(s); }

  /** Adds a special print rule to be added for a given operator. 
   * TODO Allow special rules for other functions, i.e. not operators. */
  public void addSpecialRule(Operator op,PrintRulesI rules)
  {
  	specialRules.put(op,rules);
  }

/***************** visitor methods ********************************/

	/** print the node with no brackets. */
	private void printNoBrackets(Node node) throws ParseException
	{
		node.jjtAccept(this,null);
	}
	
	/** print a node surrounded by brackets. */
	private void printBrackets(Node node) throws ParseException
	{
		sb.append("(");
		printNoBrackets(node);
		sb.append(")");
	}
	
	/** print a unary operator. */
	private Object visitUnary(ASTFunNode node, Object data) throws ParseException
	{
		Node rhs = node.jjtGetChild(0);
	
		// now print the node
		sb.append(node.getOperator().getSymbol());
		// now the rhs
		if(rhs instanceof ASTFunNode && ((ASTFunNode) rhs).isOperator())
			printBrackets(rhs);	// -(-3) -(1+2) or !(-3)
		else
			printNoBrackets(rhs);
		
		return data;
	}
	
	private boolean testLeft(XOperator top,Node lhs)
	{
		if((mode & FULL_BRACKET)!= 0)
		{
			return true;
		}
		else if(lhs instanceof ASTFunNode && ((ASTFunNode) lhs).isOperator())
		{
			XOperator lhsop = (XOperator) ((ASTFunNode) lhs).getOperator();
			if(top == lhsop)
			{
				if(top.getBinding() == XOperator.LEFT	// (1-2)-3 -> 1-2-3
					&& top.isAssociative() )
						return false;
				else if(top.useBindingForPrint())
						return false;
				else
						return true;				// (1=2)=3 -> (1=2)=3
			}
			else if(top.getPrecedence() == lhsop.getPrecedence())
			{
				if(lhsop.getBinding() == XOperator.LEFT && lhsop.isAssociative())
						return false;
				else if(lhsop.useBindingForPrint())
						return false;
				else	return true;
			} 				// (1=2)=3 -> (1=2)=3
				
			else if(top.getPrecedence() > lhsop.getPrecedence()) // (1*2)+3
						return false;
			else
						return true;
		}
		else
			return false;
	
	}
	
	private boolean testMid(XOperator top,Node rhs)
	{
		if((mode & FULL_BRACKET)!= 0)
		{
			return true;
		}
		else if(rhs instanceof ASTFunNode && ((ASTFunNode) rhs).isOperator())
		{
			XOperator rhsop = (XOperator) ((ASTFunNode) rhs).getOperator();
			if(top == rhsop)
			{
				return false;
			}
			else if(top.getPrecedence() == rhsop.getPrecedence())
			{
				return false;	// a+(b-c) -> a+b-c
			}
			else if(top.getPrecedence() > rhsop.getPrecedence()) // 1+(2*3) -> 1+2*3
						return false;
			else
						return true;
		}
		else
			return false;
	}
	
	private boolean testRight(XOperator top,Node rhs)
	{
		if((mode & FULL_BRACKET)!= 0)
		{
			return true;
		}
		else if(rhs instanceof ASTFunNode && ((ASTFunNode) rhs).isOperator())
		{
			XOperator rhsop = (XOperator) ((ASTFunNode) rhs).getOperator();
			if(top == rhsop)
			{
				if(top.getBinding() == XOperator.RIGHT	// 1=(2=3) -> 1=2=3
					|| top.isAssociative() )			// 1+(2-3) -> 1+2-3
						return false;
				return true;				// 1-(2+3) -> 1-(2-3)
			}
			else if(top.getPrecedence() == rhsop.getPrecedence())
			{
				if(top.getBinding() == XOperator.LEFT && top.isAssociative() )			// 1+(2-3) -> 1+2-3)
					return false;	// a+(b-c) -> a+b-c
				return true;		// a-(b+c) -> a-(b+c)
			}
			else if(top.getPrecedence() > rhsop.getPrecedence()) // 1+(2*3) -> 1+2*3
						return false;
			else
						return true;
		}
		else
			return false;
	}
	
	private Object visitNaryBinary(ASTFunNode node,XOperator op) throws ParseException
	{
		int n = node.jjtGetNumChildren();
		for(int i=0;i<n;++i)
		{
			if(i>0) sb.append(op.getSymbol());
			
			Node arg = node.jjtGetChild(i);
			if(testMid(op,arg))
				printBrackets(arg);
			else
				printNoBrackets(arg);
		}
		return null;
	}
	public Object visit(ASTFunNode node, Object data) throws ParseException
	{
		if(!node.isOperator()) return visitFun(node);
		if(node instanceof PrintRulesI)
		{
			((PrintRulesI) node).append(node,this);
			return null;
		}
		if(node.getOperator()==null)
		{
			throw new ParseException("Null operator in print for "+node);
		}
		if(specialRules.containsKey(node.getOperator()))
		{
			((PrintRulesI) specialRules.get(node.getOperator())).append(node,this);
			return null;
		}
		if(node.getPFMC() instanceof org.nfunk.jep.function.List)
		{	
			append("[");
				for(int i=0;i<node.jjtGetNumChildren();++i)
				{
					if(i>0) append(",");
					node.jjtGetChild(i).jjtAccept(this, null);
				}
				append("]");
			return null;
		}
			
		if(((XOperator) node.getOperator()).isUnary())
			return visitUnary(node,data);
	
		if(((XOperator) node.getOperator()).isBinary())
		{
			XOperator top = (XOperator) node.getOperator();
			if(node.jjtGetNumChildren()!=2)
				return visitNaryBinary(node,top);
			Node lhs = node.jjtGetChild(0);
			Node rhs = node.jjtGetChild(1);
		
			if(testLeft(top,lhs))
				printBrackets(lhs);
			else
				printNoBrackets(lhs);
			
			// now print the node
			sb.append(node.getOperator().getSymbol());
			// now the rhs
	
			if(testRight(top,rhs))
				printBrackets(rhs);
			else
				printNoBrackets(rhs);
	
		}
		return null;
	}

	/** prints a standard function: fun(arg,arg) */
	private Object visitFun(ASTFunNode node) throws ParseException
	{
		sb.append(node.getName()+"(");
		for(int i=0;i<node.jjtGetNumChildren();++i)
		{
			if(i>0) sb.append(",");
			node.jjtGetChild(i).jjtAccept(this, null);
		}
		sb.append(")");
	
		return null;
	}

	public Object visit(ASTVarNode node, Object data) throws ParseException  {
		sb.append(node.getName());
		return data;
	}

	public Object visit(ASTConstant node, Object data) {
		Object val = node.getValue();
		formatValue(val,sb);
		return data;
	}

	private FieldPosition fp = new FieldPosition(NumberFormat.FRACTION_FIELD);

	/** Appends a formatted versions of val to the string buffer.
	 * 
	 * @param val The value to format
	 * @param sb1  The StingBuffer to append to
	 */
	public void formatValue(Object val,StringBuffer sb1)
	{
		if(format != null)
		{
			if(val instanceof Number)
				format.format(val,sb1,fp);
			else if(val instanceof Complex)
			{
				if((mode | COMPLEX_I) == COMPLEX_I)
					sb1.append(((Complex) val).toString(format,true));
				else
					sb1.append(((Complex) val).toString(format));
			}
			else
				sb1.append(val);
		}
		else
			sb1.append(val);
	}
	
	/** Returns a formated version of the value. */
	public String formatValue(Object val)
	{
	  	StringBuffer sb2 = new StringBuffer();
	  	formatValue(val,sb2);
	  	return sb2.toString();
	}
	/**
	 * Return the current print mode.
	 */
	public int getMode() {
		return mode;
	}
	public boolean getMode(int testmode) {
		return( (this.mode | testmode ) == testmode); 
	}
	/**
	 * Set printing mode.
	 * In full bracket mode the brackets each element in the tree will be surrounded
	 * by brackets to indicate the tree structure. 
	 * In the default mode, (full bracket off) the number of brackets is
	 * minimized so (x+y)+z will be printed as x+y+z.
	 * @param mode which flags to change, typically FULL_BRACKET
	 * @param flag whether to switch this mode on or off
	 */
	public void setMode(int mode,boolean flag) {
		if(flag)
			this.mode |= mode;
		else
			this.mode ^= mode;
	}
	/** The NumberFormat object used to print numbers. */
	protected NumberFormat format;
	public void setNumberFormat(NumberFormat format)
	{
		this.format = format;
	}
	
	/**
	 * Sets the maximum length printed per line.
	 * If the value is not -1 then the string will be broken into chunks
	 * each of which is less than the max length.
	 * @param i the maximum length
	 */
	public void setMaxLen(int i) {
		maxLen = i;
	}
	/**
	 * @return the maximum length printed per line
	 */
	public int getMaxLen() {
		return maxLen;
	}

}

/*end*/
/* @author rich
 * Created on 16-Nov-2003
 */
package org.lsmp.djep.xjep;

import org.nfunk.jep.*;

/**
 * A Visitor which visits each node of a expression tree.
 * It returns the top node.
 * This visitor should be extended by Visitors which modify trees in place.
 * 
 * @author Rich Morris
 * Created on 16-Nov-2003
 */
public abstract class DoNothingVisitor implements ParserVisitor {

	/*
	 * The following methods was used to facilitate 
	 * using visitors which implemented a interface
	 * which subclassed ParserVisitor.
	 *  
	 * If subclassed to extend to implement a different visitor
	 * this method should be overwritten to ensure the correct 
	 * accept method is called.
	 * This method simply calls the jjtAccept(ParserVisitor this,Object data) of node.
	 *
	 * We no longer need this as we use ParseVisitor everywhere,
	 * but kept for future reference.
	 * 
	private Object nodeAccept(Node node, Object data) throws ParseException
	{
		return node.jjtAccept(this,data);
	}
	*/
	
	/**
	 * Gets the result of visiting children of a array of nodes.
	 */
	
	protected Node[] acceptChildrenAsArray(Node node,Object data)  throws ParseException
	{
		int n = node.jjtGetNumChildren();
		Node children[] = new Node[n];
		for(int i=0;i<n;++i)
			children[i]= (Node) node.jjtGetChild(i).jjtAccept(this,data);
		return children;
	}
	


	public Object visit(SimpleNode node, Object data) throws ParseException
	{
		throw new ParseException(this.toString()+": encountered a simple node, problem with visitor.");
	}

	public Object visit(ASTStart node, Object data) throws ParseException
	{
		throw new ParseException(this.toString()+": encountered a start node, problem with visitor.");
	}


	public Object visit(ASTConstant node, Object data)  throws ParseException
	{
		return node;
	}

	public Object visit(ASTVarNode node, Object data)  throws ParseException
	{
		return node;
	}

	public Object visit(ASTFunNode node, Object data)  throws ParseException
	{
		Node children[] = acceptChildrenAsArray(node,data);
		TreeUtils.copyChildrenIfNeeded(node,children);
		return node;
	}
}
/* @author rich
 * Created on 28-Feb-2004
 */
package org.lsmp.djep.xjep;

import org.nfunk.jep.*;

/**
 * Variables which have their equations stored.
 * 
 * @author Rich Morris
 * Created on 28-Feb-2004
 */
public class XVariable extends Variable {
	private Node equation=null;

	public XVariable(String name) {
		super(name);
	}

	public XVariable(String name, Object value) {
		super(name, value);
	}

	/** Does this variable has an associated equation? **/
	public boolean hasEquation() { return equation != null; }
	/** sets the equation */
	public void setEquation(Node eqn)
	{
		equation = eqn; 
		this.setValidValue(false);
		this.setChanged();
		this.notifyObservers(eqn);
	}
	/** get the equation */
	public Node getEquation() { return equation; }
	
	/**
	 * Calculates the value for the variables equation and returns that value.  
	 * 
	 */
	public Object calcValue(XJep jep) throws Exception
	{
		if(equation == null ) return getValue();
		Object val = jep.evaluate(equation);
		setValue(val);
		return val;
	}

	/** Returns a string rep of variable with its equation and value. */ 
	public String toString(PrintVisitor pv)
	{
		StringBuffer sb = new StringBuffer(name);
		sb.append(": val "+getValue() );
		if(!hasValidValue()) sb.append("NA");
		sb.append("\t");
		if(this.isConstant()) sb.append("constant");
		else if(getEquation()!=null) sb.append(pv.toString(getEquation()));
		else sb.append("no equation");
		return sb.toString();
	}
}
/* @author rich
 * Created on 16-Nov-2003
 */
package org.lsmp.djep.xjep;
import org.nfunk.jep.*;
/**
 * Allows substitution of a given variable with an expression tree.
 * Substitution is best done using the 
 * {@link XJep#substitute(Node,String,Node) XJep.substitute} method. 
 * For example
 * <pre>
 * XJepI xjep = ...;
 * Node node = xjep.parse("x^2+x");
 * Node sub = xjep.parse("sin(y)");
 * Node res = xjep.substitute(node,"x",sub,xjep);
 * </pre>
 * Will give the expression "(sin(y))^2+sin(y)".
 * 
 * @author Rich Morris
 * Created on 16-Nov-2003
 */
public class SubstitutionVisitor extends DoNothingVisitor {

	private String names[];
	private Node replacements[];
	private XJep xjep;
	public SubstitutionVisitor() {}

	/**
	 * Substitutes all occurrences of variable var with replacement.
	 * Does not do a DeepCopy.
	 * @param orig	the expression we wish to perform the substitution on
	 * @param name	the name of the variable
	 * @param replacement	the expression var is substituted for
	 * @return the tree with variable replace (does not do a DeepCopy)
	 * @throws ParseException
	 */
	public Node substitute(Node orig,String name,Node replacement,XJep xj) throws ParseException
	{
		this.names = new String[]{name};
		this.replacements = new Node[]{replacement};
		this.xjep=xj;
		Node res = (Node) orig.jjtAccept(this,null);
		return res;
	}

	/**
	 * Substitutes all occurrences of a set of variable var with a set of replacements.
	 * Does not do a DeepCopy.
	 * @param orig	the expression we wish to perform the substitution on
	 * @param names	the names of the variable
	 * @param replacements	the expression var is substituted for
	 * @return the tree with variable replace (does not do a DeepCopy)
	 * @throws ParseException
	 */
	public Node substitute(Node orig,String names[],Node replacements[],XJep xj) throws ParseException
	{
		this.names = names;
		this.replacements = replacements;
		this.xjep=xj;
		Node res = (Node) orig.jjtAccept(this,null);
		return res;
	}

	public Object visit(ASTVarNode node, Object data) throws ParseException
	{
		for(int i=0;i<names.length;++i)
		{
			if(names[i].equals(node.getName()))
				return xjep.deepCopy(replacements[i]);
		}
		if(node.getVar().isConstant())
			return xjep.getNodeFactory().buildVariableNode(xjep.getSymbolTable().getVar(node.getName()));
			
		throw new ParseException("No substitution specified for variable "+node.getName());
	}
}
/* @author rich
 * Created on 28-Feb-2004
 */
package org.lsmp.djep.xjep;
import org.nfunk.jep.*;

/**
 * A VariableFactory which creates XVariables (which have equations).
 * 
 * @author Rich Morris
 * Created on 28-Feb-2004
 */
public class XVariableFactory extends VariableFactory {

	public Variable createVariable(String name, Object value) {
		return new XVariable(name,value);
	}

	public Variable createVariable(String name) {
		if(defaultValue!=null)
			return new XVariable(name,defaultValue);
		else
			return new XVariable(name);
	}
}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.lsmp.djep.xjep.function;

import org.lsmp.djep.xjep.CommandVisitorI;
import org.lsmp.djep.xjep.TreeUtils;
import org.lsmp.djep.xjep.XJep;
import org.lsmp.djep.xjep.XVariable;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * An assignment operator so we can do
 * x=3+4.
 * This function implements the SpecialEvaluationI interface
 * so that it handles seting the value of a variable. 
 * @author Rich Morris
 * Created on 18-Nov-2003
 */
public class XAssign extends Assign implements CommandVisitorI {

	public XAssign() {}
	{
		numberOfParameters = 2;
	}

	/**
	 * In the pre-process stage, set the equation of the lhs variable to the rhs equation.
	 */
	public Node process(Node node,Node children[],XJep xjep) throws ParseException
	{
		if(node.jjtGetNumChildren()!=2)
			throw new ParseException("Assignment opperator must have 2 operators.");

		// evaluate the value of the righthand side. Left on top of stack

		// Set the value of the variable on the lhs. 
		Node lhsNode = children[0];
		if(lhsNode instanceof ASTVarNode)
		{
			ASTVarNode vn = (ASTVarNode) lhsNode;
			XVariable var = (XVariable) vn.getVar();
			var.setEquation(xjep.deepCopy(children[1]));
			TreeUtils.copyChildrenIfNeeded(node,children);
			return node;
		}
		else if(lhsNode instanceof ASTFunNode && ((ASTFunNode) lhsNode).getPFMC() instanceof LValueI)
		{
			//TODO 
			TreeUtils.copyChildrenIfNeeded(node,children);
			return node;
		}
		throw new ParseException("Assignment should have a variable for the lhs.");
	}
}
/* @author rich
 * Created on 02-May-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.xjep.function;

import java.util.Stack;

import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * Convert a number to a string in a given base.
 * toBase(val,12) converts to base 12 numbers.
 * toBase(val,16,3) converts to base 12 with 3 hex digits after decimal place.
 * toHex(val) converts to base 16
 * toHex(val,3) converts to base 16 with 3 hex digits after decimal place.
 * A prefix can be specified in the constructor. If set
 * this will be appended to the number (after minus sign for negative values).
 * 
 * @author Rich Morris
 * Created on 02-May-2005
 * @see java.lang.Long#toString(long, int) 
 */
public class ToBase extends PostfixMathCommand {
    int globalBase=-1;
    String prefix="";
    /**
     * Constructor where base is specified as a function argument.
     */
    public ToBase() {
        super();
        this.numberOfParameters = -1;
    }
    /**
     * Constructor with specified base.
     * @param base the base to use
     * @throws IllegalArgumentException if base is < 2 or > 36
     */
    public ToBase(int base) {
        if(base < Character.MIN_RADIX || base > Character.MAX_RADIX)
            throw new IllegalArgumentException("base must be between "+Character.MIN_RADIX+" and "+Character.MIN_RADIX);
 
        globalBase = base;
        numberOfParameters = -1;
    }
    /**
     * Constructor with specified base and a given prefix.
     * For example 0x to proceed hexadecimal numbers.
     * @param base the base to use
     * @param prefix the string to prefix numbers with.
     * @throws IllegalArgumentException if base is < 2 or > 36
     */
    public ToBase(int base,String prefix) {
        if(base < Character.MIN_RADIX || base > Character.MAX_RADIX)
            throw new IllegalArgumentException("base must be between "+Character.MIN_RADIX+" and "+Character.MIN_RADIX);
 
        globalBase = base;
        numberOfParameters = -1;
        this.prefix = prefix;
    }
    
    public boolean checkNumberOfParameters(int n) {
        if(globalBase == -1) { return (n==2||n==3); }
        else				 {return (n==1||n==2); }
	}
	public void run(Stack s) throws ParseException {
        int narg = curNumberOfParameters;
        int digits=0;
        int base = 0;
        
        if(!checkNumberOfParameters(narg))
            throw new ParseException("toBase: can only have 1,2 or 3 arguments");

        if(narg==3 || (globalBase != -1 && narg==2)) {
            try {
            digits = ((Number) s.pop()).intValue();
            } catch(ClassCastException e) {
                throw new ParseException("toBase: last argument should be an integer");
            }
        }

        if(globalBase == -1) {
	        Object rhs = s.pop();
	        if(rhs instanceof Number)
	            base = ((Number) rhs).intValue();
	        else
	            throw new ParseException("toBase: second argument should be an integer");
        } else {
            base = globalBase;
        }
        if(base < Character.MIN_RADIX || base > Character.MAX_RADIX)
            throw new ParseException("base must be between "+Character.MIN_RADIX+" and "+Character.MIN_RADIX);

        Object lhs = s.pop();
        String res=null;
        if(lhs instanceof Integer || lhs instanceof Short || lhs instanceof Long)
            res = toBase(((Number) lhs).longValue(),base);
        else if(lhs instanceof Float || lhs instanceof Double || lhs instanceof Number)
            res = toBase(((Number) lhs).doubleValue(),base,digits);
        else
            throw new ParseException("toBase: Cannot convert object of type "+lhs.getClass().getName());
    	s.push(res);
	}
    
    /**
     * Converts a number to a give base.
     * @param num number to convert
     * @param base base to use
     * @return String representation
     * @throws IllegalArgumentException if base is < 2 or > 36
     */
    public String toBase(long num,int base) {
        if(base < Character.MIN_RADIX || base > Character.MAX_RADIX)
            throw new IllegalArgumentException("base must be between "+Character.MIN_RADIX+" and "+Character.MIN_RADIX);
        if(num<0)
            return '-' + prefix + Long.toString(num,base);
        return prefix + Long.toString(num,base);
    }
    
    /**
     * Converts a number to a give base.
     * @param val number to convert
     * @param base base to use
     * @param digits number of digits after decimal place
     * @return String representation
     * @throws IllegalArgumentException if base is < 2 or > 36
     */
    public String toBase(double val,int base,int digits) {
        if(base < Character.MIN_RADIX || base > Character.MAX_RADIX)
            throw new IllegalArgumentException("base must be between "+Character.MIN_RADIX+" and "+Character.MIN_RADIX);

        StringBuffer sb = new StringBuffer();
        if(val<0.0) { 
            val = -val; 
            sb.append('-');
        }
        sb.append(prefix);
        val = val * Math.pow(base,digits);
        long round = Math.round(val);
        String s = Long.toString(round,base);
        if(s.length()<=digits) {
            sb.append("0.");
            for(int i=0;i<digits-s.length();++i)
                sb.append('0');
            sb.append(s);
        }
        else if(digits>0) {
            sb.append(s);
            sb.insert(sb.length()-digits,'.');
        }
        else
            sb.append(s);
        return sb.toString();
    }
}
/* @author rich
 * Created on 10-Sep-2004
 */
package org.lsmp.djep.xjep.function;


import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * @author Rich Morris
 * Created on 10-Sep-2004
 */
public class MinArg extends SumType {

	static Comparative comp = new Comparative(Comparative.LE);

	public MinArg() {
		super("MinArg");
	}

	public Object evaluate(Object[] elements) throws ParseException {
		throw new ParseException("MinArg: call to evaluate(Object[] elements) should not have happened.");
	}

	public Object evaluate(
		Node node,
		Variable var,
		double min,
		double max,
		double inc,
		EvaluatorI pv)
		throws ParseException {

			int i=0;
			double val;
			Object minVal=null;
			Object minArg=null;
			for(i=0,val=min;val<=max;++i,val=min+i*inc)
			{
				Object curArg = new Double(val); 
				var.setValue(curArg);
				
				Object res = pv.eval(node);
				if(i==0)
				{
					minVal = res;
					minArg = curArg;
				}
				else if(comp.lt(res,minVal))
				{
					minVal = res;
					minArg = curArg;
				}
			}
			return minArg;

	}

}
/* @author rich
 * Created on 02-May-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.xjep.function;

import java.util.Stack;

import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * @author Rich Morris
 * Created on 02-May-2005
 */
public class FromBase extends PostfixMathCommand {
    int globalBase=-1;
    String prefix=null;
    /**
     * 
     */
    public FromBase() {
        super();
        this.numberOfParameters = 2;
    }

    public FromBase(int base) {
        super();
        this.numberOfParameters = 1;
        globalBase = base;
    }

    public FromBase(int base,String prefix) {
        super();
        this.numberOfParameters = 1;
        globalBase = base;
        this.prefix = prefix;
    }

    public void run(Stack s) throws ParseException {
        int nargs = this.curNumberOfParameters;
        if(globalBase == -1 && nargs != 2)
            throw new ParseException("fromBase: number of arguments should be 2");
        if(globalBase != -1 && nargs != 1)
            throw new ParseException("fromBase: number of arguments should be 1");
        // find the base
        int base=globalBase;
        if(globalBase == -1) {
	        Object rhs = s.pop();
	        if(rhs instanceof Number)
	            base = ((Number) rhs).intValue();
	        else
	            throw new ParseException("toBase: second argument should be an integer");
        }
        Object lhs = s.pop();
        if(lhs instanceof String) {
            try {
                Object res = fromBase((String) lhs,base);
                s.push(res);
                return;
            } catch(NumberFormatException e) {
                throw new ParseException(e.getMessage());
            }
        }
        throw new ParseException("fromBase: first arg should be a string");
    }
    
    public Object fromBase(String str,int base) throws NumberFormatException {
        boolean sign = str.startsWith("-");
        if(sign) str = str.substring(1);
        
        // remove prefix
        if(prefix!=null) {
            if(str.startsWith(prefix)) {
                str = str.substring(prefix.length());
            } else 
                throw new NumberFormatException("fromBase: string must start with prefix "+prefix);
        }
        
        // work with decimal part
        int ind = str.indexOf('.');
        if(ind==-1) {
            double val = Long.parseLong(str,base);
            if(sign) val = -val;
            return new Double(val);
        }
        String intpart = str.substring(0,ind);
        String fractpart = str.substring(ind+1);
        long intlong = Long.parseLong(intpart,base);
        double fractlong = Long.parseLong(fractpart,base);
        double val = intlong + fractlong / Math.pow(base,fractpart.length());
        if(sign) val = -val;
        return new Double(val);
    }
}
/* @author rich
 * Created on 10-Sep-2004
 */
package org.lsmp.djep.xjep.function;


import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * @author Rich Morris
 * Created on 10-Sep-2004
 */
public class MaxArg extends SumType {

	static Comparative comp = new Comparative(Comparative.LE);

	public MaxArg() {
		super("MaxArg");
	}

	public Object evaluate(Object[] elements) throws ParseException {
		throw new ParseException("MaxArg: call to evaluate(Object[] elements) should not have happened.");
	}

	public Object evaluate(
		Node node,
		Variable var,
		double min,
		double max,
		double inc,
		EvaluatorI pv)
		throws ParseException {

			int i=0;
			double val;
			Object maxVal=null;
			Object maxArg=null;
			for(i=0,val=min;val<=max;++i,val=min+i*inc)
			{
				Object curArg = new Double(val); 
				var.setValue(curArg);
				
				Object res = pv.eval(node);
				if(i==0)
				{
					maxVal = res;
					maxArg = curArg;
				}
				else if(comp.gt(res,maxVal))
				{
					maxVal = res;
					maxArg = curArg;
				}
			}
			return maxArg;
	}

}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.lsmp.djep.xjep.function;

import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * A product function product(x^2,x,1,10) finds the product of x^2 with x running from 1 to 10.
 *
 * @author Rich Morris
 * Created on 10-Sept-2004
 */
public class Product extends SumType {

	static Multiply mul = new Multiply();

	public Product()
	{
		super("Product");
	}

		
	public Object evaluate(Object elements[]) throws ParseException
	{
		Object ret;
		ret = elements[0];
		for(int i=1;i<elements.length;++i)
		{
			ret = mul.mul(ret,elements[i]);
		}
		return ret;
	}
}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.lsmp.djep.xjep.function;

import java.util.Stack;

import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * Base class for functions like Sum(x^2,x,1,10) which finds the sum of x^2 with x running from 1 to 10.
 * The first argument should be an equation, the second argument is a variable name,
 * the third argument is the min value, the forth is the max value and the 
 * fifth argument (if present, default 1) is the increment to use.
 * Sub classes should implement the 
 * <pre>public abstract Object evaluate(Object elements[]) throws ParseException;</pre>
 * method, which is passed an array of the value 

 * @author Rich Morris
 * Created on 10-Sept-2004
 */
public abstract class SumType extends PostfixMathCommand implements CallbackEvaluationI {
	/** The name of the function, use in error reporting. */
	protected String name;

	public SumType(String funName)
	{
		numberOfParameters = -1;
		name = funName;
	}

	public SumType()
	{
		numberOfParameters = -1;
	}

	public boolean checkNumberOfParameters(int n) {
		return (n==4||n==5);
	}

	/**
	 * Evaluates the operator in given context. 
	 * Typically does not need to be sub-classed as the other evaluate methods are more useful. This method just checks the arguments.
	 */
	public Object evaluate(Node node,EvaluatorI pv) throws ParseException {

		int numParams =  node.jjtGetNumChildren();
		if(!checkNumberOfParameters(numParams))
			throw new ParseException(name+": called with invalid number of parameters: "+numParams+" it should be either 4 or 5.");
			
		Node varNode = node.jjtGetChild(1);
		Variable var=null;
		if(varNode instanceof ASTVarNode)
			var = ((ASTVarNode) varNode).getVar();
		else
			throw new ParseException(name+": second argument should be a variable");
			
		Object minObj = pv.eval(node.jjtGetChild(2));
		double min;
		if(minObj instanceof Number)
			min = ((Number ) minObj).doubleValue();
		else throw new ParseException(name+": third argument (min) should evaluate to a number it is "+minObj.toString());
			
		Object maxObj = pv.eval(node.jjtGetChild(3));
		double max;
		if(maxObj instanceof Number)
			max = ((Number ) maxObj).doubleValue();
		else throw new ParseException(name+": forth argument (max) should evaluate to a number it is "+minObj.toString());

		if(min>max) throw new ParseException(name+": min value should be smaller than max value they are "+min+" and "+max+".");
		
		if(numParams == 5)
		{
			//node.jjtGetChild(3).jjtAccept(pv,data);	
			//checkStack(stack); // check the stack
			//Object incObj = stack.pop();
			Object incObj = pv.eval(node.jjtGetChild(4));
			double inc;
			if(incObj instanceof Number)
				inc = ((Number ) incObj).doubleValue();
			else throw new ParseException(name+": fifth argument (steps) should evaluate to a number it is "+minObj.toString());
			
			return evaluate(node.jjtGetChild(0),var,min,max,inc,pv);
		}
		return evaluate(node.jjtGetChild(0),var,min,max,1.0,pv);
	}

	/** Evaluates the node by repeatibly setting the value of the variable from min to max, and calculating the value of the first argument.
	 * Sub classes generally do not need to implement this method as
	 * {@link #evaluate(Object[])}
	 * is more useful. If they do they should follow the pattern used here. 
	 * 
	 * @param node
	 * @param var
	 * @param min
	 * @param max
	 * @param inc
	 * @param pv
	 * @return the result of evaluation
	 * @throws ParseException
	 */ 

	public Object evaluate(
		Node node,
		Variable var,
		double min, double max, double inc,
		EvaluatorI pv)
		throws ParseException {
			
			int i=0;
			double val;
			Object[] res=new Object[(int) ((max-min)/inc)+1];	
			for(i=0,val=min;val<=max;++i,val=min+i*inc)
			{
				var.setValue(new Double(val));
				
				res[i] = pv.eval(node);
			}
			Object ret = evaluate(res);
			return ret;
	}
		
	/** Evaluates the function given the set of y values.
	 * For example for Sum(x^2,x,1,5) the function will be passed the array [1,4,9,16,25].
	 * 
	 * @param elements the y values
	 * @return the result of the function
	 * @throws ParseException
	 */
	public abstract Object evaluate(Object elements[]) throws ParseException;
	
	/**
	 * run method. Should not be called.
	 */
	public void run(Stack s) throws ParseException {
		throw new ParseException(name+": run method called should not normally happen.");
	}

}
/* @author rich
 * Created on 21-Jul-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.xjep.function;


import org.lsmp.djep.xjep.CommandVisitorI;
import org.lsmp.djep.xjep.MacroFunction;
import org.lsmp.djep.xjep.XJep;
import org.nfunk.jep.ASTConstant;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * Allows functions to be defined in equations.
 * <pre>
 * XJep > Define("half",1,"x/2")
 * XJep > half(5)
 * </pre>
 * <p>
 * Currently the Define function is handled in the preprocessing step
 * <pre>
 * Node n = xj.parse("Define(\"sumToX\",1,\"x*(x+1)/2\")");
 * Node preproc = xj.preprocess(n);
 * </pre>
 * and preproc will be null if a Define statement is encountered.
 * This is probably a bug.
 * 
 * TODO improve syntax. So can have Define("half(x)",x/2)
 * TODO work out how to simplify and evaluate Define statements which don't really have a value. 
 * TODO fix parser so can do half(x) = x/2
 *  
 * @author Rich Morris
 * Created on 21-Jul-2005
 */
public class Define extends PostfixMathCommand implements CommandVisitorI {
    private XJep xj;
    public Define(XJep xj) {
        this.numberOfParameters = -1;
        this.xj = xj;
    }

    /**
     *
     */

    public Node process(Node node, Node[] children, XJep xjep)
            throws ParseException {
       String funName = null;
        int nArgs=-1;
        String def = null;
        if(children[0] instanceof ASTConstant)
        {
            Object val = ((ASTConstant) children[0]).getValue();
            if(val instanceof String) {
                funName = (String) val;
            }
            else throw new ParseException("First argument to Define must be a string");
        }
        if(children[1] instanceof ASTConstant)
        {
            Object val = ((ASTConstant) children[1]).getValue();
            if(val instanceof Number) {
                nArgs = ((Number) val).intValue();
            }
            else throw new ParseException("Second argument to Define must be a integer");
        }
        if(children[2] instanceof ASTConstant)
        {
            Object val = ((ASTConstant) children[2]).getValue();
            if(val instanceof String) {
                def = (String) val;
            }
            else throw new ParseException("Third argument to Define must be a string");
        }

        MacroFunction mf = new MacroFunction(funName,nArgs,def,xj);
        xj.addFunction(funName,mf);
        return null;
    }
}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.lsmp.djep.xjep.function;

import org.nfunk.jep.*;

/**
 * The Simpson rule for approximation to a definite integral.
 * h * (y0 + yn + 4(y1+y3+...+y_(n-1)) + 2(y2+y4+...+y_(n-2)) ) /3
 * where h = (xn-x0)/n, yi = f(xi)
 * Simpson(x^2,x,0,10,0.5) 
 * finds an approximation for int(x^2) where x runs from 0 to 10 in steps of 
 * h=0.5. 
 *
 * @author Rich Morris
 * Created on 10-Sept-2004
 */
public class Simpson extends Trapezium {

	public Simpson()
	{
		super("Simpson");
	}

		
	public Object evaluate(Object elements[]) throws ParseException
	{
		if(elements.length % 2 != 1 || elements.length <2)
			throw new ParseException("Simpson: there should be an odd number of ordinates, its"+elements.length);

		Object ret = add.add(elements[0],elements[elements.length-1]);
		for(int i=1;i<elements.length-1;++i) { 
			//TODO could be quicker
			if(i %2 == 0)
				ret = add.add(ret,
						mul.mul(TWO,elements[i]));
			else
				ret = add.add(ret,
					mul.mul(FOUR,elements[i]));
		}
		return mul.mul(ret,THIRD);
	}
}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.lsmp.djep.xjep.function;

import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * A sum function Sum(x^2,x,1,10) finds the sum of x^2 with x running from 1 to 10.
 * Sum(x^2,x,1,10,2) calculates the 1^2+3^2+5^2+7^2+9^2 i.e. in steps of 2.
 * @author Rich Morris
 * Created on 10-Sept-2004
 */
public class Sum extends SumType {

	static Add add;

	private Sum() {}
	public Sum(JEP j)
	{
		super("Sum");
		add = (Add) j.getOperatorSet().getAdd().getPFMC();
	}

		
	public Object evaluate(Object elements[]) throws ParseException
	{
		Object ret;
		ret = elements[0];
		for(int i=1;i<elements.length;++i)
		{
			ret = add.add(ret,elements[i]);
		}
		return ret;
	}
}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.lsmp.djep.xjep.function;

import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * The trapezium rule for approximation to a definite integral.
 * h * (y0 + yn + 2(y1+y2+...+y_(n-1)) /2
 * where h = (xn-x0)/n, yi = f(xi)
 * Trapezium(x^2,x,0,10,0.5) 
 * finds an approximation for int(x^2) where x runs from 0 to 10 in steps of 
 * h=0.5. 
 * 
 * @author Rich Morris
 * Created on 10-Sept-2004
 */
public class Trapezium extends SumType {

	static Add add = new Add();
	static Multiply mul = new Multiply();
	static Double HALF = new Double(1.0/2);
	static Double THIRD = new Double(1.0/3);
	static Double TWO = new Double(2);
	static Double FOUR = new Double(4);
	
	public Trapezium()
	{
		super("Trapezium");
	}
	public Trapezium(String name) { super(name); }
		
	public Object evaluate(Object elements[]) throws ParseException
	{
		if(elements.length <2)
			throw new ParseException("Trapezium: there should two or more ordinates, its"+elements.length);

		Object ret = mul.mul(HALF,
				add.add(elements[0],
						elements[elements.length-1]));
		for(int i=1;i<elements.length-1;++i)
		{
			ret = add.add(ret,elements[i]);
		}
		return ret;
	}
	
	public Object evaluate(
			Node node,
			Variable var,
			double min, double max, double inc,
			EvaluatorI pv)
			throws ParseException {
				
				int i=0;
				double val;
				Object[] res=new Object[(int) ((max-min)/inc)+1];	
				for(i=0,val=min;val<=max;++i,val=min+i*inc)
				{
					var.setValue(new Double(val));
					
					res[i] = pv.eval(node);
				}
				Object ret = evaluate(res);
				return mul.mul(ret,new Double(inc));
		}

}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.lsmp.djep.xjep.function;

import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * A max function Max(x^2,x,1,10) finds the max of x^2 with x running from 1 to 10.
 *
 * @author Rich Morris
 * Created on 10-Sept-2004
 */
public class Max extends SumType {

	static Comparative comp = new Comparative(Comparative.LE);

	public Max()
	{
		super("Max");
	}

		
	public Object evaluate(Object elements[]) throws ParseException
	{
		Object ret;
		ret = elements[0];
		for(int i=1;i<elements.length;++i)
		{
			if(comp.gt(elements[i],ret))
			ret = elements[i];
		}
		return ret;
	}
}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.lsmp.djep.xjep.function;

import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * A min function Min(x^2,x,1,10) finds the min of x^2 with x running from 1 to 10.
 *
 * @author Rich Morris
 * Created on 10-Sept-2004
 */
public class Min extends SumType {

	static Comparative comp = new Comparative(Comparative.LE);

	public Min()
	{
		super("Min");
	}

		
	public Object evaluate(Object elements[]) throws ParseException
	{
		Object ret;
		ret = elements[0];
		for(int i=1;i<elements.length;++i)
		{
			if(comp.lt(elements[i],ret))
			ret = elements[i];
		}
		return ret;
	}
}
/* @author rich
 * Created on 29-Oct-2003
 */
package org.lsmp.djep.matrixJep;
import org.nfunk.jep.*;
import org.lsmp.djep.djep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
/**
 * Contains information about a PartialDerivative of a variable.
 * 
 * @author Rich Morris
 * Created on 29-Oct-2003
 * TODO Should setValue be overwritten?
 */
public class MatrixPartialDerivative extends PartialDerivative implements MatrixVariableI {

	private MatrixValueI mvalue = null;

	/**
	 * Protected constructor, should only be constructed
	 * through the findDerivative method in {@link MatrixVariable}.
	**/ 
	protected MatrixPartialDerivative(MatrixVariable var, String derivnames[],Node deriv)
	{
		super(var,derivnames);
		/*TODO could be a little cleverer just have a 
		 * partial derivative which is a constant dy/dx = 1
		 * don't use an equation, instead use a value.
		 * 
		if(deriv instanceof ASTMConstant) {
			MatrixValueI val = ((ASTMConstant) deriv).getMValue();
			System.out.println("Warning constant derivative "+getName()+"="+val);
			mvalue = (Scaler) Scaler.getInstance(val);
		}
		else {
		*/
			setEquation(deriv);
			setValidValue(false);
			mvalue=Tensor.getInstance(var.getDimensions());
	}
	
	public Dimensions getDimensions()
	{
		MatrixVariableI root = (MatrixVariableI) getRoot();
		return root.getDimensions();
	}
	public void setDimensions(Dimensions dims)	{}
	public MatrixValueI getMValue() { return mvalue; }

	public void setMValue(MatrixValueI val) {
		if(this.isConstant()) return;
		mvalue.setEles(val);
		setValidValue(true);
		setChanged();
		notifyObservers();
	}
//	public void setMValue(VectorMatrixTensorI value) 
//	{ this.mvalue = value; setValidValue(true); }
}
/* @author rich
 * Created on 19-Dec-2003
 */
package org.lsmp.djep.matrixJep;

import org.lsmp.djep.djep.*;
import org.lsmp.djep.djep.diffRules.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.Power;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.vectorJep.function.*;
import org.lsmp.djep.xjep.*;
import org.lsmp.djep.matrixJep.function.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
/**
 * An extension of JEP which allows advanced vector and matrix handling and differentation.
 *
 * @author Rich Morris
 * Created on 19-Dec-2003
 */
public class MatrixJep extends DJep {

	protected MatrixPreprocessor dec = new MatrixPreprocessor();
	protected MatrixVariableFactory mvf = new MatrixVariableFactory();
	protected MatrixEvaluator mev = new MatrixEvaluator();
	
	public MatrixJep() {
		super();
		nf = new MatrixNodeFactory(this);
		symTab = new DSymbolTable(mvf);
		opSet = new MatrixOperatorSet();
		this.parser.setInitialTokenManagerState(ParserConstants.NO_DOT_IN_IDENTIFIERS);

		Operator tens = ((MatrixOperatorSet) opSet).getMList();
		pv.addSpecialRule(tens,(PrintVisitor.PrintRulesI) tens.getPFMC());
		Operator eleAccess = ((MatrixOperatorSet) opSet).getElement();
		pv.addSpecialRule(eleAccess,(PrintVisitor.PrintRulesI) eleAccess.getPFMC());

		addDiffRule(new PassThroughDiffRule(tens.getName(),tens.getPFMC()));
		Operator cross = ((MatrixOperatorSet) opSet).getCross();
		addDiffRule(new MultiplyDiffRule(cross.getName(),cross));
		Operator dot = ((MatrixOperatorSet) opSet).getDot();
		addDiffRule(new MultiplyDiffRule(dot.getName(),dot));
	}

	public void addStandardFunctions()
	{
		super.addStandardFunctions();
		addFunction("pow",new Power());
		this.getFunctionTable().remove("if");
		addFunction("if",new MIf());
		addFunction("ele",new VEle());
		this.getFunctionTable().remove("diff");
		addFunction("diff",new MDiff());
		addFunction("len",new Length());
		addFunction("size",new Size());
		addFunction("diag",new Diagonal());
		addFunction("getdiag",new GetDiagonal());
		addFunction("trans",new Transpose());
		addFunction("det",new Determinant());
		addFunction("trace",new Trace());
		addFunction("vsum",new VSum());
		addFunction("Map",new MMap());
		this.getFunctionTable().remove("Sum");
		addFunction("Sum",new MSum(this));
	}

	/** Evaluate a node. If the result is a scaler it
	 * will be unwrapped, i.e. it will return a Double and not a Scaler.
	 */
	public Object evaluate(Node node) throws ParseException
	{
		Object res = mev.evaluate((MatrixNodeI) node,this);
		if(res instanceof Scaler)
			return ((Scaler) res).getEle(0);
		return res;
	}

	/** Evaluate a node. Does not unwrap scalers. */
	public Object evaluateRaw(Node node) throws ParseException
	{
		Object res = mev.evaluate((MatrixNodeI) node,this);
		return res;
	}

	/** Pre-processes an equation to allow the diff and eval operators to be used. */
	public Node preprocess(Node node) throws ParseException
	{
		return dec.preprocess(node,this);
	}

	/* (non-Javadoc)
	 * @see org.nfunk.jep.JEP#getValueAsObject()
	 */
	public Object getValueAsObject() {
		try
		{
			Object res = mev.evaluate((MatrixNodeI) getTopNode(),this);
			if(res instanceof Scaler)
				return ((Scaler) res).getEle(0);
			return res;
		}
		catch(Exception e)
		{
			this.errorList.addElement("Error during evaluation:");
			this.errorList.addElement(e.getMessage());
			return null;
		}
	}

	public EvaluatorI getEvaluatorVisitor() {
		return mev;
	}
	
	
}
/* @author rich
 * Created on 14-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.matrixJep;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.nfunk.jep.*;
/**
 * Applies a special preprocessing step for a function or operator.
 * 
 * @author Rich Morris
 * Created on 14-Feb-2005
 */
public interface SpecialPreProcessorI
{
	/**
	 * Subverts the preprocessing stage.
	 * Preprocessing performs a number of operations:
	 * <ol>
	 * <li>Converts each node into one of the subtypes of MatrixNodeI</li>
	 * <li>Calculate the dimensions for the results</li>
	 * <li>Performs any special symbolic operations such as differentation</li> 
	 * </ol>
	 * In general the first step in preprocessing is to run the preprocessor on the children of the node.
	 * This can be done using 
	 * <pre>
	 * MatrixNodeI children[] = visitor.visitChildrenAsArray(node,null);
	 * </pre>
	 * The final step is to construct a node of the correct type. The MatrixNodeFactory
	 * argument has a number of methods to do this. For example
	 * <pre>
	 * return (ASTMFunNode) nf.buildOperatorNode(node.getOperator(),children,rhsDim);
	 * </pre>
	 * Note how the dimension is specified.
	 * 
	 * @param node the top node of the tree representing the function and its arguments.
	 * @param visitor A reference to the preprocessing visitor.
	 * @param jep A reference of the MatrixJep instance.
	 * @param nf  A reference to the node factory object.
	 * @return A new MatrixNodeI representing the converted function.
	 * @throws ParseException if some error occurs.
	 */
	public MatrixNodeI preprocess(
		ASTFunNode node,
		MatrixPreprocessor visitor,
		MatrixJep jep,
		MatrixNodeFactory nf) throws ParseException;

}
/* @author rich
 * Created on 19-Dec-2003
 */
package org.lsmp.djep.matrixJep;

import org.lsmp.djep.djep.*;
import org.lsmp.djep.xjep.XVariable;
import org.nfunk.jep.Node;
import org.nfunk.jep.Variable;

/**
 * Allows creation of matrix aware variables.
 * 
 * @author Rich Morris
 * Created on 19-Dec-2003
 */
public class MatrixVariableFactory extends DVariableFactory {

	/** create a derivative */
	public PartialDerivative createDerivative(DVariable var,String[] dnames,Node eqn) {
		return null;
	}

	/** Create a variable with a given value. */
	public Variable createVariable(String name, Object value) {
		if(defaultValue!=null)
			return new MatrixVariable(name,defaultValue);
		else
			return new MatrixVariable(name,value);
	}

	/** Create a variable with a given value. */
	public Variable createVariable(String name) {
		return new MatrixVariable(name);
	}

}
/* @author rich
 * Created on 30-Oct-2003
 */
package org.lsmp.djep.matrixJep;
import org.nfunk.jep.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.vectorJep.function.*;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.vectorJep.Dimensions;
import org.nfunk.jep.function.*;
import java.util.Stack;

/**
 * This visitor evaluates a the tree representing the equation.
 * 
 * @author Rich Morris
 * Created on 30-Oct-2003
 * @since 2.3.2 Hack so comparative operations work with vectors and matrices. 
 */
public class MatrixEvaluator implements ParserVisitor,EvaluatorI
{
//	private DimensionCalculator dimCalc;
	private Stack stack = new Stack();
	private MatrixJep mjep;
	public MatrixValueI evaluate(MatrixNodeI node,MatrixJep mj) throws ParseException
	{
		this.mjep=mj;
		return (MatrixValueI) node.jjtAccept(this,null);
	}

	public Object eval(Node node) throws ParseException {
		MatrixValueI val = (MatrixValueI) node.jjtAccept(this,null);
		return val.copy();
	}

	public Object visit(SimpleNode node, Object data)	{ return null;	}
	public Object visit(ASTStart node, Object data)	{ return null;	}

	/** constants **/
	public Object visit(ASTConstant node, Object data)
	{
		return ((ASTMConstant) node).getMValue();
	}
	/** multi dimensional differentiable variables */
	public Object visit(ASTVarNode node, Object data) throws ParseException
	{
		MatrixVariableI var = (MatrixVariableI) node.getVar();
		if(var.hasValidValue())
			return var.getMValue();
		if(!var.hasEquation())
			throw new ParseException("Tried to evaluate a variable with an invalid value but no equation");
		MatrixValueI res = (MatrixValueI) var.getEquation().jjtAccept(this,data);
		var.setMValue(res);
		return res;
	}
	
	/** other functions **/
	public Object visit(ASTFunNode node, Object data) throws ParseException
	{
		MatrixNodeI mnode = (MatrixNodeI) node;
		PostfixMathCommandI pfmc = node.getPFMC(); 
		if(pfmc instanceof MatrixSpecialEvaluationI)
		{
			MatrixSpecialEvaluationI se = (MatrixSpecialEvaluationI) pfmc;
			return se.evaluate(mnode,this,mjep);
		}
		else if (pfmc instanceof CallbackEvaluationI) {
			Object val = ((CallbackEvaluationI) pfmc).evaluate(node,this);
			if(val instanceof MatrixValueI)
				mnode.getMValue().setEles((MatrixValueI) val);
			else
				mnode.getMValue().setEle(0,val);
			return mnode.getMValue();
		}
		else if (pfmc instanceof SpecialEvaluationI) {
			
			throw new ParseException("Encountered an instance of SpecialEvaluationI");
		}
		else if(pfmc instanceof BinaryOperatorI)
		{
			BinaryOperatorI bin = (BinaryOperatorI) pfmc;
			MatrixValueI lhsval = (MatrixValueI) node.jjtGetChild(0).jjtAccept(this,data);
			MatrixValueI rhsval = (MatrixValueI) node.jjtGetChild(1).jjtAccept(this,data);
			return bin.calcValue(mnode.getMValue(),lhsval,rhsval);
		}
		else if(pfmc instanceof UnaryOperatorI)
		{
			UnaryOperatorI uni = (UnaryOperatorI) pfmc;
			MatrixValueI val = (MatrixValueI) node.jjtGetChild(0).jjtAccept(this,data);
			return uni.calcValue(mnode.getMValue(),val);
		}
		else if(pfmc instanceof NaryOperatorI)
		{
			NaryOperatorI uni = (NaryOperatorI) pfmc;
			MatrixValueI results[] = new MatrixValueI[node.jjtGetNumChildren()];
			for(int i=0;i<results.length;++i)
				results[i] = (MatrixValueI) node.jjtGetChild(i).jjtAccept(this,data);
			return uni.calcValue(mnode.getMValue(),results);
		}
		else if(pfmc instanceof Comparative) {
			Object lhsval = (MatrixValueI) node.jjtGetChild(0).jjtAccept(this,data);
			Object rhsval = (MatrixValueI) node.jjtGetChild(1).jjtAccept(this,data);
			stack.push(lhsval);
			stack.push(rhsval);
			pfmc.setCurNumberOfParameters(2);
			pfmc.run(stack);
			mnode.getMValue().setEle(0,stack.pop());
			return mnode.getMValue();
		}

		// not a clever op use old style call
		// assumes 
		int num = node.jjtGetNumChildren();
		for(int i=0;i<num;++i)
		{
			MatrixValueI vec = (MatrixValueI) node.jjtGetChild(i).jjtAccept(this,data);
			if(!vec.getDim().equals(Dimensions.ONE))
				throw new ParseException("Arguments of "+node.getName()+" must be scalers");			
			stack.push(vec.getEle(0));
		}
		pfmc.setCurNumberOfParameters(num);
		pfmc.run(stack);
		mnode.getMValue().setEle(0,stack.pop());
		return mnode.getMValue();
	}
}
/* @author rich
 * Created on 26-Oct-2003
 */
package org.lsmp.djep.matrixJep;
import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.xjep.*;
import org.lsmp.djep.djep.*;
/**
 * Holds all info about a variable.
 * Has a name, an equation, a dimension (or sent of dimensions if matrix or tensor)
 * and also a set of {@link MatrixPartialDerivative MatrixPartialDerivative}.
 * The derivatives are stored in a hashtable index by
 * the sorted names of derivatives.
 * i.e. d^2f/dxdy, and d^2f/dydx will both be indexed by {"x","y"}.
 * df/dx is indexed by {"x"}, d^2f/dx^2 is index by {"x","x"}.
 * Partial derivatives are calculated as required by the
 * findDerivative method.
 * @author Rich Morris
 * Created on 26-Oct-2003
 * @since 2.3.2 Added a setValue method overriding 
 */
public class MatrixVariable extends DVariable implements MatrixVariableI {

	private Dimensions dims;
	private MatrixValueI mvalue = null;

	protected PartialDerivative createDerivative(String derivnames[],Node eqn)
	{
		return new MatrixPartialDerivative(this,derivnames,eqn);
	}

	/**
	 * The constructor is package private. Variables should be created
	 * using the VariableTable.find(Sting name) method.
	 */
	MatrixVariable(String name) 
	{ 
		super(name);
		this.dims = Dimensions.ONE;
		this.mvalue = Scaler.getInstance(new Double(0.0));
		setValidValue(false);
	}

	MatrixVariable(String name,Object value) 
	{ 
		super(name);
		if(value == null)
			this.mvalue = Scaler.getInstance(new Double(0.0));
		else if(value instanceof MatrixValueI)
			this.mvalue = (MatrixValueI) value;
		else
			this.mvalue = Scaler.getInstance(value);
		
		this.dims = mvalue.getDim();
		setValidValue(true);
	}

	public Dimensions getDimensions() { return dims; }
	public void setDimensions(Dimensions dims) {
		this.dims = dims;
		this.mvalue=Tensor.getInstance(dims);
		this.invalidateAll();
	}

	/** returns the value, uses the Scaler type. */
	public MatrixValueI getMValue() { return mvalue; }	

	/** returns the value, unpacks Scalers so they just return its elements. */
	public Object getValue() { 
		if(mvalue instanceof Scaler)
			return mvalue.getEle(0);
		return mvalue;
	}	

	/**
	 * Sets the value of this variable.
	 * Needed when using macro functions in matrix calculations.
	 * TODO might be better to change macro function behaviour.
	 */
	protected boolean setValueRaw(Object val) {
		if(val instanceof MatrixValueI)
		{
			mvalue = (MatrixValueI) val;
			this.dims = mvalue.getDim();
		}
		else 
			mvalue.setEle(0,val);
		this.setValidValue(true);
		return true;
	}
	 
	public void setMValue(MatrixValueI val) {
		if(this.isConstant()) return;
		mvalue.setEles(val);
		setValidValue(true);
		setChanged();
		notifyObservers(val);
	}
	
//	public void setMValue(VectorMatrixTensorI value) 
//	{ this.mvalue = value; this.invalidateAll(); }
	
	public void print(PrintVisitor bpv)
	{
		StringBuffer sb = new StringBuffer(name);
		sb.append(": ");
		if(dims!=null) sb.append("dim "+dims.toString());
		if(hasValidValue() && mvalue != null) sb.append(" val "+getMValue() );
		else	sb.append(" null value");
		sb.append(" ");
		if(this.getEquation()!=null)
			sb.append("eqn "+bpv.toString(this.getEquation()));
		else
			sb.append("no equation");
		sb.append("\n");
		for(java.util.Enumeration e = this.derivatives.elements(); e.hasMoreElements(); ) 
		{
			MatrixPartialDerivative var = (MatrixPartialDerivative) e.nextElement();
			sb.append("\t"+var.toString()+": ");
			if(var.hasValidValue()) sb.append(" val "+var.getMValue() );
			else	sb.append(" null value");
			sb.append(" ");
			sb.append(bpv.toString(var.getEquation()));
			sb.append("\n");
		}
		System.out.print(sb.toString());
	}
	

}
/* @author rich
 * Created on 27-Jul-2003
 */
package org.lsmp.djep.matrixJep;
import org.lsmp.djep.matrixJep.function.*;
import org.lsmp.djep.vectorJep.function.*;
import org.nfunk.jep.*;
import org.lsmp.djep.xjep.*;
/**
 * The set of operators used in matricies.
 * 
 * @author Rich Morris
 * Created on 27-Jul-2003
 */
public class MatrixOperatorSet extends XOperatorSet {
	protected Operator TENSOR = new XOperator("TENSOR",new MList(),XOperator.NARY);
	public Operator getMList() { return TENSOR; }

	public MatrixOperatorSet() {
		super();
		OP_ADD.setPFMC(new MAdd());
		OP_SUBTRACT.setPFMC(new MSubtract());
		// TODO fix commutatitivity for matrix mult. How?
		OP_MULTIPLY.setPFMC(new MMultiply());
		OP_DIVIDE.setPFMC(new MDivide());
		OP_POWER.setPFMC(new MPower());
		OP_UMINUS.setPFMC(new MUMinus());
		OP_DOT.setPFMC(new MDot());
		OP_CROSS= new XOperator("^^","^",new ExteriorProduct(),XOperator.BINARY+XOperator.RIGHT,((XOperator) OP_CROSS).getPrecedence());
		OP_ASSIGN.setPFMC(new MAssign());
		OP_LIST.setPFMC(new MList());
		OP_ELEMENT.setPFMC(new MArrayAccess());
//		OP_RANGE.setPFMC(new VRange());
	}
	
	public Operator[] getOperators()
	{
		Operator ops1[] = super.getOperators();
		Operator ops2[] = new Operator[ops1.length+1];
		System.arraycopy(ops1,0,ops2,0,ops1.length);
		ops2[ops1.length]= TENSOR;
		return ops2;
	}
}
/* @author rich
 * Created on 19-Dec-2003
 */
package org.lsmp.djep.matrixJep;
import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.MatrixValueI;

/**
 * Matrix aware variables should implement this interface. 
 * @author Rich Morris
 * Created on 19-Dec-2003
 */
public interface MatrixVariableI {
	/** The dimension of the variable. */
	public abstract Dimensions getDimensions();
	/** Sets the dimension of the variable. 
	 * Will also allocate appropriate space for value container. 
	 */
	public abstract void setDimensions(Dimensions dims);
	/** Returns the value container of this variable.
	 * There is no setMValue as the value can be changed by
	 * setting the individual elements of value container.
	 */
	public abstract MatrixValueI getMValue();
	/** Sets the value of the variable (matrix aware). */
	public abstract void setMValue(MatrixValueI val);
	/** Is the value of this variable meaningful? */
	public abstract boolean hasValidValue();
	/** makes the vaule valid. */
	public abstract void setValidValue(boolean b);
	/** The equation represented by this variable. */
	public abstract Node getEquation();
	/** Whether this variable has an equation. */
	public abstract boolean hasEquation();
	/** The name of variable */
	public abstract String getName();
	/** Is it constant? */
	public abstract boolean isConstant();
}
/* @author rich
 * Created on 26-Nov-2003
 */
package org.lsmp.djep.matrixJep;
import org.nfunk.jep.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.vectorJep.values.*;

/**
 * If a function requires a special form of evaluation it should
 * implement this interface.
 * 
 * @author Rich Morris
 * Created on 26-Nov-2003
 */
public interface MatrixSpecialEvaluationI {
	/** 
	 * Returns the result of evaluating this node and the tree below.
	 * This method has the responsibility for evaluating the children of the node
	 * and it should generally call
	 * <pre>
	 * MatrixValueI val = (MatrixValueI) node.jjtGetChild(i).jjtAccept(visitor,null);	
	 * </pre>
	 * for each child.
	 * 
	 * <p>
	 * The final results should be copied into the mvalue field of the node using
	 * <pre>
	 * MatrixValueI mvalue = node.getMValue();
	 * mvalue.setEles(res);
	 * return mvalue;
	 * </pre>
	 * 
	 * @param node The top node.
	 * @param visitor The parser visitor
	 * @param jep The current MatrixJep instance.
	 * @return Value after evaluation.
	 * @throws ParseException
	 */
	public MatrixValueI evaluate(MatrixNodeI node,MatrixEvaluator visitor,MatrixJep jep) throws ParseException;
}
/* @author rich
 * Created on 16-Nov-2003
 */
package org.lsmp.djep.matrixJep;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.function.*;
import org.lsmp.djep.vectorJep.values.Scaler;
import org.lsmp.djep.xjep.*;

/**
 * This class is used to create nodes of specified types.
 * It can be sub-classed to change the nature of how nodes
 * are constructed. Generally there are two methods for creating
 * nodes, methods which take an existing node and methods which
 * take the components.
 * 
 * @author Rich Morris
 * Created on 16-Nov-2003
 */
public class MatrixNodeFactory extends NodeFactory {

	public MatrixNodeFactory(XJep xj)
	{
	    super(xj);
	}
	
	/** Creates an ASTConstant node with specified value. **/
	public ASTConstant buildConstantNode(Object value) throws ParseException
	{
		ASTMConstant node  = new ASTMConstant(ParserTreeConstants.JJTCONSTANT);
		if(value instanceof Scaler)
			node.setValue(((Scaler)value).getEle(0));
		else
			node.setValue(value);
		return node;
	}

	/** Creates a ASTVariable node with specified value. **/
	public ASTVarNode buildVariableNode(Variable var) throws ParseException
	{
		ASTMVarNode node  = new ASTMVarNode(ParserTreeConstants.JJTVARNODE);
		node.setVar(var);
		return node;
	}
	

	/**
	 * Builds a function with n arguments
	 * @param name of function.
	 * @param pfmc PostfixMathCommand for function.
	 * @param arguments the arguments to the function.
	 * @return top Node of expression 
	 */

	public ASTFunNode buildFunctionNode(String name,PostfixMathCommandI pfmc,Node[] arguments) throws ParseException
	{
		ASTMFunNode res = new ASTMFunNode(ParserTreeConstants.JJTFUNNODE);
		res.setFunction(name,pfmc);
		copyChildren(res,arguments);
		res.setDim(calcDim(name,pfmc,arguments));
		return res;		
	}

	/** Calculates the dimension of node using the dimensions
	 * of the children. Does not recurse down the tree.
	 */
	public Dimensions calcDim(String name,PostfixMathCommandI pfmc,Node arguments[])
		throws ParseException
	{
		MatrixNodeI children[] = new MatrixNodeI[arguments.length];
		for(int i=0;i<arguments.length;++i)
			children[i] = (MatrixNodeI) arguments[i];

		if(pfmc instanceof BinaryOperatorI)
		{
			if(children.length!=2) throw new ParseException("Operator "+name+" must have two elements, it has "+children.length);
			BinaryOperatorI bin = (BinaryOperatorI) pfmc;
			Dimensions dim = bin.calcDim(children[0].getDim(),children[1].getDim());
			return dim;
		}
		else if(pfmc instanceof UnaryOperatorI)
		{
			if(children.length!=1) throw new ParseException("Operator "+name+" must have one elements, it has "+children.length);
			UnaryOperatorI uni = (UnaryOperatorI) pfmc;
			Dimensions dim = uni.calcDim(children[0].getDim());
			return dim;
		}
		else if(pfmc instanceof NaryOperatorI)
		{
			Dimensions dims[] = new Dimensions[children.length];
			for(int i=0;i<children.length;++i)
				dims[i]=children[i].getDim();
			//if(arguments.length!=1) throw new ParseException("Operator "+op.getName()+" must have one elements, it has "+arguments.length);
			NaryOperatorI uni = (NaryOperatorI) pfmc;
			Dimensions dim = uni.calcDim(dims);
			return dim;
		}
		else
		{
			return Dimensions.ONE;
	//		System.out.println("Warning: assuming 1 for dimensions of "+node.getName());
		}
	}

	/** Calculates the dimension of node using the dimensions
	 * of the children.
	 */
	public Dimensions calcDim(Operator op,Node arguments[])	throws ParseException
	{
		return calcDim(op.getName(),op.getPFMC(),arguments);
	}
	
	/**
	 * Builds a function with n arguments
	 * @param node the properties (name and pfmc) of this node will be copied.
	 * @param children the arguments to the function.
	 * @return top Node of expression 
	 * 
	 * @since 2.3.3 if possible use dimension of existing node. (Needed when deep copying MList functions)
	 */
	public ASTFunNode buildFunctionNode(ASTFunNode node,Node[] children) throws ParseException
	{
		if(node instanceof ASTMFunNode)
		{
			if(node.isOperator())
				return buildOperatorNode(node.getOperator(),children,
				((ASTMFunNode) node).getDim()); 
			ASTMFunNode res = new ASTMFunNode(ParserTreeConstants.JJTFUNNODE);
			res.setFunction(node.getName(),node.getPFMC());
			copyChildren(res,children);
			res.setDim(((ASTMFunNode) node).getDim()); 
			return res;
		}
		//MatrixNodeI children[] = (MatrixNodeI []) arguments;
		if(node.isOperator())
			return buildOperatorNode(node.getOperator(),children); 
		ASTMFunNode res = new ASTMFunNode(ParserTreeConstants.JJTFUNNODE);
		res.setFunction(node.getName(),node.getPFMC());
		copyChildren(res,children);
		res.setDim(calcDim(node.getName(),node.getPFMC(),children));
		return res;		
	}
	
	/** create a function node with a known dimension */
	public ASTFunNode buildFunctionNode(ASTFunNode node,Node[] arguments,Dimensions dim)
	{
		ASTMFunNode res = new ASTMFunNode(ParserTreeConstants.JJTFUNNODE);
		res.setFunction(node.getName(),node.getPFMC());
		res.setDim(dim);
		copyChildren(res,arguments);
		return res;		
	}

	
	/**
	 * Builds a operator node with n arguments
	 * @param op the operator for this node
	 * @param arguments the arguments to the function.
	 * @return top Node of expression 
	 */

	public ASTFunNode buildOperatorNode(Operator op,Node[] arguments) throws ParseException
	{
			
		ASTMFunNode res = new ASTMFunNode(ParserTreeConstants.JJTFUNNODE);
		res.setOperator(op);
		copyChildren(res,arguments);
		res.setDim(calcDim(op,arguments));
		return res;
	}

	/** create a function node with a known dimension */
	public ASTFunNode buildOperatorNode(Operator op,Node[] arguments,Dimensions dim)
	{
		ASTMFunNode res = new ASTMFunNode(ParserTreeConstants.JJTFUNNODE);
		res.setOperator(op);
		res.setDim(dim);
		copyChildren(res,arguments);
		return res;		
	}

	/**
	 * Creates an operator node, but don't fill in the children or calculate
	 * its dimension.
	 */
	public ASTFunNode buildUnfinishedOperatorNode(Operator op)
	{
		ASTMFunNode res = new ASTMFunNode(ParserTreeConstants.JJTFUNNODE);
		res.setOperator(op);
		return res;		
	}
}
/* @author rich
 * Created on 30-Oct-2003
 */
package org.lsmp.djep.matrixJep;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import org.lsmp.djep.djep.*;
import org.lsmp.djep.xjep.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.function.*;
/**
 * This visitor does the majority of preprocessing work.
 * Specifically it
 * <ul>
 * <li>Sets the dimension of each node.
 * <li>For assignment equations it adds an entry in the VariableTable
 * <li>For diff opperator it calculates the derivative.
 * <li>For the List opperator it finds the dimensions and
 * returns a ASTTensor.
 * <li>For the Hat opperator it finds the dimension and returns
 * a Power or Wedge opperator.
 * </ul>
 * The visitor will return a new Tree.
 * 
 * @author Rich Morris
 * Created on 30-Oct-2003
 */
public class MatrixPreprocessor implements ParserVisitor
{
	private MatrixJep mjep;
	private MatrixNodeFactory nf;
	private DSymbolTable vt;

	public MatrixPreprocessor() {}

	/**
	 * Main entry point: pre-process a node. 
	 * @param node	Top node of tree. 
	 * @param mdjep	Reference to MatrixJep instance
	 * @return	A new tree with all preprocessing carried out.
	 * @throws ParseException
	 */	
	public MatrixNodeI preprocess(Node node,MatrixJep mdjep) throws ParseException
	{
		this.mjep=mdjep;
		this.nf=(MatrixNodeFactory) mdjep.getNodeFactory();
		this.vt=(DSymbolTable) mdjep.getSymbolTable();
		return (MatrixNodeI) node.jjtAccept(this,null);
	}
	
	/**
	 * Returns an array of matrix nodes which are the results of visiting each child.
	 */
	public MatrixNodeI[] visitChildrenAsArray(Node node,Object data) throws ParseException 
	{
		int nchild = node.jjtGetNumChildren();
		MatrixNodeI children[] = new MatrixNodeI[nchild];
		for(int i=0;i<nchild;++i)
		{
		  MatrixNodeI no = (MatrixNodeI) node.jjtGetChild(i).jjtAccept(this,data);
		  children[i] = no;
		}
		return children;
	}
	
	////////////////////////////////////////////////////////////////////
	
	public Object visit(SimpleNode node, Object data)	{ return null;	}
	public Object visit(ASTStart node, Object data)	{ return null;	}

	/** constants **/
	public Object visit(ASTConstant node, Object data) throws ParseException
	{
		return nf.buildConstantNode(node.getValue());
	}
	/** multi-dimensional differentiable variables */
	public Object visit(ASTVarNode node, Object data) throws ParseException
	{
		return nf.buildVariableNode(vt.getVar(node.getName()));
	}

	/** visit functions and operators **/
	public Object visit(ASTFunNode node, Object data) throws ParseException
	{
		PostfixMathCommandI pfmc=node.getPFMC();
		if(pfmc instanceof SpecialPreProcessorI)
		{
			SpecialPreProcessorI spp = (SpecialPreProcessorI) node.getPFMC();
			return spp.preprocess(node,this,mjep,nf);
		}
		if(node.isOperator()) return visitOp(node,data);
		if(node.getPFMC() instanceof CommandVisitorI)
				throw new IllegalArgumentException("MatrixPreprocessor: encountered and instance of CommandVisitorI  for function "+node.getName());

		MatrixNodeI children[] = visitChildrenAsArray(node,data);
		ASTMFunNode res = (ASTMFunNode) nf.buildFunctionNode(node,children);
		return res;
	}

	/** operators +,-,*,/ **/
	public Object visitOp(ASTFunNode node, Object data) throws ParseException
	{
		PostfixMathCommandI pfmc=node.getPFMC();
		MatrixNodeI children[] = visitChildrenAsArray(node,data);

		if(pfmc instanceof BinaryOperatorI)
		{
			if(node.jjtGetNumChildren()!=2) throw new ParseException("Operator "+node.getOperator().getName()+" must have two elements, it has "+children.length);
			BinaryOperatorI bin = (BinaryOperatorI) pfmc;
			Dimensions dim = bin.calcDim(children[0].getDim(),children[1].getDim());
			return (ASTMFunNode) nf.buildOperatorNode(node.getOperator(),children,dim);
		}
		else if(pfmc instanceof UnaryOperatorI)
		{
			if(children.length!=1) throw new ParseException("Operator "+node.getOperator().getName()+" must have one elements, it has "+children.length);
			UnaryOperatorI uni = (UnaryOperatorI) pfmc;
			Dimensions dim = uni.calcDim(children[0].getDim());
			return (ASTMFunNode) nf.buildOperatorNode(node.getOperator(),children,dim);
		}
		else if(pfmc instanceof NaryOperatorI)
		{
			Dimensions dims[] = new Dimensions[children.length];
			for(int i=0;i<children.length;++i)
				dims[i]=children[i].getDim();
			NaryOperatorI uni = (NaryOperatorI) pfmc;
			Dimensions dim = uni.calcDim(dims);
			return (ASTMFunNode) nf.buildOperatorNode(node.getOperator(),children,dim);
		}
		else
		{
			//throw new ParseException("Operator must be unary or binary. It is "+op);
			Dimensions dim = Dimensions.ONE;
			return (ASTMFunNode) nf.buildOperatorNode(node.getOperator(),children,dim);
		}
	}
}
/* @author rich
 * Created on 01-Feb-2004
 */
package org.lsmp.djep.matrixJep.nodeTypes;
import org.nfunk.jep.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;

/**
 * @author Rich Morris
 * Created on 01-Feb-2004
 */
public class ASTMVarNode extends ASTVarNode implements MatrixNodeI 
{
	private MatrixVariableI mvar=null;

	public ASTMVarNode(int i)	{super(i);}
	public Dimensions getDim() {return mvar.getDimensions();}
	public void setVar(Variable var)
	{
		mvar = (MatrixVariableI) var;
		super.setVar(var);
	}
	public MatrixValueI getMValue() {return mvar.getMValue();}
}
/* @author rich
 * Created on 01-Feb-2004
 */
package org.lsmp.djep.matrixJep.nodeTypes;
import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
/**
 * @author Rich Morris
 * Created on 01-Feb-2004
 */
public interface MatrixNodeI extends Node {
	public Dimensions getDim();
//	public void setDim(Dimensions dim);
	public MatrixValueI getMValue();
	//public void setMValue(VectorMatrixTensorI val); 
}
/* @author rich
 * Created on 01-Feb-2004
 */
package org.lsmp.djep.matrixJep.nodeTypes;
import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;

/**
 * @author Rich Morris
 * Created on 01-Feb-2004
 */
public class ASTMFunNode extends ASTFunNode implements MatrixNodeI 
{
	private MatrixValueI mvar=null;

	public ASTMFunNode(int i) {	super(i);}

	public Dimensions getDim()	{return mvar.getDim();	}

	public void setDim(Dimensions dim) {
		mvar = Tensor.getInstance(dim);
	}

	public MatrixValueI getMValue() {return mvar;}
	
}
/* @author rich
 * Created on 01-Feb-2004
 */
package org.lsmp.djep.matrixJep.nodeTypes;
import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;

/**
 * Holds a single constant number.
 * @author Rich Morris
 * Created on 01-Feb-2004
 */
public class ASTMConstant extends ASTConstant implements MatrixNodeI 
{
	private Scaler scalerval;

	public ASTMConstant(int i)
	{
		super(i);
		scalerval = (Scaler) Scaler.getInstance(new Double(0.0));
	}
	public Dimensions getDim() {
		return Dimensions.ONE;
	}

	public MatrixValueI getMValue() {
		return scalerval;
	}

	public Object getValue() {
		return scalerval.getEle(0);
	}

	public void setValue(Object val) {
		scalerval.setEle(0,val);
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.lsmp.djep.matrixJep.function;

import org.nfunk.jep.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.vectorJep.function.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.xjep.*;
//import org.lsmp.djep.matrixJep.nodeTypes.*;

/**
 * A enhanced version of list, allows matrices and tensors.
 * 
 * @author Rich Morris
 * Created on 27-Nov-2003
 */
public class MList extends VList 
	implements PrintVisitor.PrintRulesI,NaryOperatorI,SpecialPreProcessorI
{
	public MList()
	{
		numberOfParameters = -1;
	}

	public MatrixValueI calcValue(MatrixValueI res,
		MatrixValueI inputs[]) throws ParseException
	{
		int eleSize = inputs[0].getNumEles();
		for(int i=0;i<inputs.length;++i)
		{
			for(int j=0;j<eleSize;++j)
			{
				res.setEle(i*eleSize+j,inputs[i].getEle(j));
			}
		}
		return res;
	}
	
	public MatrixNodeI preprocess(
		ASTFunNode node,
		MatrixPreprocessor visitor,
		MatrixJep jep,
		MatrixNodeFactory nf)
		throws ParseException
	{
		MatrixNodeI children[] = visitor.visitChildrenAsArray(node,null);
		Operator listOp = ((MatrixOperatorSet) jep.getOperatorSet()).getMList();
		// What if we have x=[1,2]; y = [x,x]; or z=[[1,2],x];
		// first check if all arguments are TENSORS
		boolean flag=true;
		for(int i=0;i<children.length;++i)
		{
			if(children[i] instanceof ASTMFunNode)
			{
				if(((ASTMFunNode) children[i]).getOperator() != listOp)
				{
					flag=false; break;
				}
			}
			else
				flag=false; break;
		}

		if(flag)
		{
			ASTMFunNode opNode1 = (ASTMFunNode) children[0];
			Dimensions dim = Dimensions.valueOf(children.length,opNode1.getDim());
			ASTMFunNode res = (ASTMFunNode) nf.buildUnfinishedOperatorNode(listOp);
			int k=0;
			res.setDim(dim);
			res.jjtOpen();
			for(int i=0;i<children.length;++i)
			{
				ASTMFunNode opNode = (ASTMFunNode) children[i];
				for(int j=0;j<opNode.jjtGetNumChildren();++j)
				{
					Node child = opNode.jjtGetChild(j);
					res.jjtAddChild(child,k++);
					child.jjtSetParent(res);
				}
			}
			res.jjtClose();
			return res;
		}
		MatrixNodeI node1 = children[0];
		Dimensions dim = Dimensions.valueOf(children.length,node1.getDim());
		ASTMFunNode res = (ASTMFunNode) nf.buildOperatorNode(listOp,children,dim);
		return res;
	}

	
	int curEle;
	/** recursive procedure to print the tensor with lots of brackets. **/
	protected void bufferAppend(MatrixNodeI node,PrintVisitor pv,int currank) throws ParseException
	{
		pv.append("[");
		if(currank+1 >= node.getDim().rank())
		{
			// bottom of tree
			for(int i=0;i<node.getDim().getIthDim(currank);++i)
			{
				if(i!=0) pv.append(",");
				node.jjtGetChild(curEle++).jjtAccept(pv,null);
			}
		}
		else
		{
			// not bottom of tree
			for(int i=0;i<node.getDim().getIthDim(currank);++i)
			{
				if(i!=0) pv.append(",");
				bufferAppend(node,pv,currank+1);
			}
		}
		pv.append("]");
	}

	/**
	 * Used to print the TensorNode with all its children.
	 * Method implements PrintVisitor.PrintRulesI.
	 */
	public void append(Node node,PrintVisitor pv) throws ParseException
	{
		curEle = 0;
		bufferAppend((MatrixNodeI) node,pv,0);
	}


}
/* @author rich
 * Created on 14-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.matrixJep.function;

import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.nfunk.jep.ASTFunNode;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * @author Rich Morris
 * Created on 14-Feb-2005
 */
public class MDiff extends PostfixMathCommand implements SpecialPreProcessorI
{

	public MDiff()
	{
		super();
		this.numberOfParameters = 2;
	}

	public MatrixNodeI preprocess(
		ASTFunNode node,
		MatrixPreprocessor visitor,
		MatrixJep jep,
		MatrixNodeFactory nf)
		throws ParseException
	{
		MatrixNodeI children[] = visitor.visitChildrenAsArray(node,null);
		if(children.length != 2)
			throw new ParseException("Diff opperator should have two children, it has "+children.length);
		// TODO need to handle diff(x,[x,y])
		if(!(children[1] instanceof ASTMVarNode))
			throw new ParseException("rhs of diff opperator should be a variable.");
		ASTMVarNode varNode = (ASTMVarNode) children[1];
		MatrixNodeI diff = (MatrixNodeI) jep.differentiate(children[0],varNode.getName());
		return diff;
	}

}
package org.lsmp.djep.matrixJep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.vectorJep.*;

/**
 * A matrix enabled assignment function.
 * The lhs of an assignment must be a variable.
 * 
 * @author Rich Morris
 * Created on 23-Feb-2004
 */
public class MAssign extends Assign implements MatrixSpecialEvaluationI,SpecialPreProcessorI
{
	public MAssign()
	{
		numberOfParameters = 2;
	}

	/** The run method should not be called. 
	 * Use {@link #evaluate} instead.
	 */	
	public void run(Stack s) throws ParseException 
	{
		throw new ParseException("Eval should not be called by Evaluator"); 
	}

	/**
	 * A special methods for evaluating an assignment.
	 * When an assignment is encountered, first
	 * evaluate the rhs. Then set the value 
	 * of the lhs to the result.
	 */
	public MatrixValueI evaluate(MatrixNodeI node,MatrixEvaluator visitor,MatrixJep j) throws ParseException
	{
		if(node.jjtGetNumChildren()!=2)
			throw new ParseException("Assignment operator must have 2 operators.");

		// evaluate the value of the right-hand side. Left on top of stack
		
		MatrixValueI rhsVal = (MatrixValueI) node.jjtGetChild(1).jjtAccept(visitor,null);	

		// Set the value of the variable on the lhs. 
		Node lhsNode = node.jjtGetChild(0);
		if(lhsNode instanceof ASTMVarNode)
		{
			ASTMVarNode vn = (ASTMVarNode) lhsNode;
			MatrixVariableI var = (MatrixVariableI) vn.getVar();
			var.setMValue(rhsVal);
			return rhsVal;
		}
		else if(lhsNode instanceof ASTMFunNode && ((ASTMFunNode) lhsNode).getPFMC() instanceof LValueI)
		{
			((LValueI) ((ASTMFunNode) lhsNode).getPFMC()).set(visitor,lhsNode,rhsVal);
			return rhsVal;
		}

		throw new ParseException("Assignment should have a variable for the lhs.");
	}

	public MatrixNodeI preprocess(
		ASTFunNode node,
		MatrixPreprocessor visitor,
		MatrixJep mjep,
		MatrixNodeFactory nf)
		throws ParseException
	{
		MatrixNodeI children[] = visitor.visitChildrenAsArray(node,null);

		if(node.jjtGetNumChildren()!=2) throw new ParseException("Operator "+node.getOperator().getName()+" must have two elements, it has "+children.length);
		Dimensions rhsDim = children[1].getDim();
		if(children[0] instanceof ASTVarNode)
		{
			MatrixVariable var = (MatrixVariable) ((ASTVarNode) children[0]).getVar();
			var.setDimensions(rhsDim);
			Node copy =mjep.deepCopy(children[1]);
			Node simp = mjep.simplify(copy);
			//Node preproc = (Node) simp.jjtAccept(this,data);
			var.setEquation(simp);
		}
		//TODO cope with ArrayAccess. Should really set the array access equations
		return (ASTMFunNode) nf.buildOperatorNode(node.getOperator(),children,rhsDim);
	}

}
/* @author rich
 * Created on 24-Apr-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.matrixJep.function;

import org.lsmp.djep.vectorJep.Dimensions;
import org.lsmp.djep.vectorJep.function.NaryOperatorI;
import org.lsmp.djep.vectorJep.values.MatrixValueI;
import org.lsmp.djep.xjep.function.Sum;
import org.nfunk.jep.JEP;
import org.nfunk.jep.ParseException;

/**
 * @author Rich Morris
 * Created on 24-Apr-2005
 */
public class MSum extends Sum implements NaryOperatorI {

	/**
	 * @param j
	 */
	public MSum(JEP j) {
		super(j);
	}

	public Dimensions calcDim(Dimensions[] dims) throws ParseException {
		return dims[0];
	}

	public MatrixValueI calcValue(MatrixValueI res, MatrixValueI[] inputs)
			throws ParseException {
		throw new ParseException("calcValue method for MSum called");
	}

}
/* @author rich
 * Created on 14-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.matrixJep.function;

import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.vectorJep.function.VMap;
import org.lsmp.djep.vectorJep.values.*;
import org.lsmp.djep.vectorJep.Dimensions;
import org.nfunk.jep.*;

/**
 * @author Rich Morris
 * Created on 14-Feb-2005
 */
public class MMap extends VMap implements SpecialPreProcessorI,MatrixSpecialEvaluationI
{
	public MatrixNodeI preprocess(
		ASTFunNode node,
		MatrixPreprocessor visitor,
		MatrixJep jep,
		MatrixNodeFactory nf)
		throws ParseException
	{
		Variable vars[] = getVars(node.jjtGetChild(1));
		for(int i=0;i<vars.length;++i)
		{
			((MatrixVariable) vars[i]).setDimensions(Dimensions.ONE);
		}
		MatrixNodeI children[] = visitor.visitChildrenAsArray(node,null);
		return (MatrixNodeI) nf.buildFunctionNode(node,children,children[2].getDim());
	}

	public MatrixValueI evaluate(
		MatrixNodeI node,
		MatrixEvaluator visitor,
		MatrixJep jep)
		throws ParseException
	{
		int nChild = node.jjtGetNumChildren();
		if(nChild <3)
			throw new ParseException("Map must have three or more arguments");
		
		// First find the variables
		Variable vars[] = getVars(node.jjtGetChild(1));
			
		if(nChild != vars.length + 2)
			throw new ParseException("Map: number of arguments should match number of variables + 2");

		// Now evaluate third and subsequent arguments
		MatrixValueI inputs[] = new MatrixValueI[nChild-2];
		Dimensions dim=null;
		for(int i=0;i<nChild-2;++i)
		{
			Object out = node.jjtGetChild(i+2).jjtAccept(visitor,null);	
			if(out instanceof MatrixValueI)
			{
				inputs[i] = (MatrixValueI) out;
				if(i==0) dim = inputs[0].getDim();
				else
				{
					if(!dim.equals(inputs[i].getDim()))
						throw new ParseException("Map: dimensions of third and subsequent arguments must match");
				}
			}
			else
				throw new ParseException("Map: third and following arguments should be vectos or matricies");
		}

		// Now evaluate the function for each element
		MatrixValueI res = node.getMValue();
		for(int i=0;i<dim.numEles();++i)
		{
			for(int j=0;j<vars.length;++j)
			{
				((MatrixVariableI) vars[j]).getMValue().setEle(0,inputs[j].getEle(i));
				vars[j].setValidValue(true);
			}
			Scaler val = (Scaler) node.jjtGetChild(0).jjtAccept(visitor,null);
			res.setEle(i,val.getEle(0));
		}
		return res;
	}

}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.lsmp.djep.matrixJep.function;
import org.nfunk.jep.function.*;
import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.function.NaryOperatorI;
import org.lsmp.djep.vectorJep.values.*;
import org.nfunk.jep.*;

/**
 * The if(condExpr,posExpr,negExpr) function.
 * The value of trueExpr will be returned if condExpr is >0 (true)
 * and value of negExpr will be returned if condExpr is &lt;= 0 (false).
 * <p>
 * This function performs lazy evaluation so that
 * only posExpr or negExpr will be evaluated.
 * For Complex numbers only the real part is used.
 * <p>
 * An alternate form if(condExpr,posExpr,negExpr,zeroExpr)
 * is also available. Note most computations
 * are carried out over floating point doubles so
 * testing for zero can be dangerous.
 * <p>
 * This function implements the SpecialEvaluationI interface
 * so that it handles setting the value of a variable. 
 * @author Rich Morris
 * Created on 18-Nov-2003
 */
public class MIf extends PostfixMathCommand implements NaryOperatorI, MatrixSpecialEvaluationI 
{
	public MIf() {
		super();
		numberOfParameters = -1;
	}

	/** Find the dimension of this node. */
	public Dimensions calcDim(Dimensions dims[]) throws ParseException
	{
		int num =dims.length; 
		if( num < 3 || num > 4)
			throw new ParseException("If operator must have 3 or 4 arguments.");

		Dimensions condDim = dims[0];
		if(!condDim.equals(Dimensions.ONE))
			throw new ParseException("First argument of if opperator must be 0 dimensional");
		Dimensions posDim = dims[1];
		for(int i=2;i<num;++i)
			if(!posDim.equals(dims[i]))
				throw new ParseException("Dimensions for each argument of if must be equal");		
		return posDim;
	}

	/** This method should not be called.
	 * Use {@link #evaluate} instead.
	 */
	public MatrixValueI calcValue(MatrixValueI res,
		MatrixValueI inputs[]) throws ParseException
	{
		throw new ParseException("Called calc value for If");
	}

	/**
	 * Evaluate the node, uses lazy evaluation.
	 */
	public MatrixValueI evaluate(MatrixNodeI node,MatrixEvaluator visitor,MatrixJep j) throws ParseException
	{
		int num =node.jjtGetNumChildren(); 
		if( num < 3 || num > 4)
			throw new ParseException("If operator must have 3 or 4 arguments.");

		// get value of argument
		
		Scaler cond = (Scaler) node.jjtGetChild(0).jjtAccept(visitor,null);	
//		Object condVal = cond.getEle(0);		
		// convert to double
		double val = cond.doubleValue();
		MatrixValueI res;
		if(val>0.0)
		{
			res = (MatrixValueI) node.jjtGetChild(1).jjtAccept(visitor,null);
		}
		else if(num ==3 || val <0.0)
		{
			res = (MatrixValueI) node.jjtGetChild(2).jjtAccept(visitor,null);
		}
		else
		{
			res = (MatrixValueI) node.jjtGetChild(3).jjtAccept(visitor,null);
		}
		MatrixValueI mvalue = node.getMValue();
		mvalue.setEles(res);
		return mvalue;
	}

	public boolean checkNumberOfParameters(int n) {
		return (n == 3 || n == 4);
	}
	
	
}
/*
Created 17-May-2006 - Richard Morris
*/
package org.lsmp.djep.matrixJep.function;

import org.lsmp.djep.xjep.PrintVisitor;

import org.lsmp.djep.vectorJep.function.ArrayAccess;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;

public class MArrayAccess extends ArrayAccess implements PrintVisitor.PrintRulesI{

	public void append(Node node, PrintVisitor pv) throws ParseException {
		// TODO Auto-generated method stub
		//pv.append("[");
		node.jjtGetChild(0).jjtAccept(pv, null);
		node.jjtGetChild(1).jjtAccept(pv, null);
	}

	public MArrayAccess() {
		super();
		// TODO Auto-generated constructor stub
	}

}
/* @author rich
 * Created on 14-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.lsmp.djep.matrixJep.function;

import org.lsmp.djep.matrixJep.*;
import org.lsmp.djep.matrixJep.nodeTypes.*;
import org.lsmp.djep.vectorJep.*;
import org.lsmp.djep.vectorJep.function.*;
import org.nfunk.jep.*;

/**
 * An overloaded Power function compatible with MatrixJep.
 * 
 * @author Rich Morris
 * Created on 14-Feb-2005
 */
public class MPower extends VPower implements SpecialPreProcessorI
{
	/** During preprocessing sets the function to the Cross function if necessary. */ 
	public MatrixNodeI preprocess(
		ASTFunNode node,
		MatrixPreprocessor visitor,
		MatrixJep jep,
		MatrixNodeFactory nf)
		throws ParseException
	{
		MatrixNodeI children[] = visitor.visitChildrenAsArray(node,null);

		if(node.jjtGetNumChildren()!=2) throw new ParseException("Operator "+node.getOperator().getName()+" must have two elements, it has "+children.length);
		Dimensions lhsDim = children[0].getDim();
		Dimensions rhsDim = children[1].getDim();
		if(rhsDim.equals(Dimensions.ONE))
		{
			Dimensions dim = lhsDim; 
			return (ASTMFunNode) nf.buildOperatorNode(
					node.getOperator(),children,dim);
		}
		Operator op = jep.getOperatorSet().getCross();
		BinaryOperatorI bin = (BinaryOperatorI) op.getPFMC();
		Dimensions dim = bin.calcDim(lhsDim,rhsDim);
		return (ASTMFunNode) nf.buildOperatorNode(op,children,dim);
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jepexamples;

import java.awt.*;

import org.nfunk.jep.JEP;

/**
 * This class plots a graph using the JEP API.
 */
public class GraphCanvas extends Canvas {
	private static final long serialVersionUID = -3169263228971794887L;

	/** Scaling of the graph in x and y directions */
	private int scaleX, scaleY;

	/** Dimensions of the canvas */
	private Dimension dimensions;

	/** Buffer for the graph */
	private Image buffer;

	/** Boolean flags */
	private boolean initializedBuffer, changedFunction, hasError;

	/** Math parser */
	private JEP myParser;

	/** The expression field where the functions are entered */
	private java.awt.TextField exprField;

	/**
	 * Constructor
	 */
	public GraphCanvas(String initialExpression,
						java.awt.TextField exprField_in) {
		scaleX = 1;
		scaleY = 1;
		dimensions = getSize();
		initializedBuffer = false;
		changedFunction = true;
		hasError = true;
		exprField = exprField_in;
		initParser(initialExpression);
	}

	/**
	 * Initializes the parser
	 */
	private void initParser(String initialExpression) {
		// Init Parser
		myParser = new JEP();
		
		// Allow implicit multiplication
		myParser.setImplicitMul(true);

		// Load the standard functions
		myParser.addStandardFunctions();

		// Load the standard constants, and complex variables/functions
		myParser.addStandardConstants();
		myParser.addComplex();
		
		// Add and initialize x to 0
		myParser.addVariable("x",0);

		// Set the string to the initial value
		setExpressionString(initialExpression);
	}

	/**
	 * Sets a new string to be used as function
	 */
	public void setExpressionString(String newString) {
		// Parse the new expression
		myParser.parseExpression(newString);

		// Find out whether there was an error in the expression
		hasError = myParser.hasError();
		if (hasError)
		  exprField.setForeground(Color.red);
		else
		  exprField.setForeground(Color.black);

		changedFunction = true;
	}

	/**
	 * @return The value of the function at an x value of the parameter.
	 */
	private double getYValue(double xValue) {
		// Save the new value in the symbol table
		myParser.addVariable("x", xValue);

		return myParser.getValue();
	}

	/**
	 * Fills the background with white.
	 */
	private void paintWhite(Graphics g) {
		g.setColor(Color.white);
		g.fillRect(0,0,dimensions.width,dimensions.height);
	}

	/**
	 * Paints the axes for the graph.
	 */
	private void paintAxes(Graphics g) {
		g.setColor(new Color(204,204,204));
		g.drawLine(0,dimensions.height/2,dimensions.width-1,dimensions.height/2);
		g.drawLine(dimensions.width/2,0,dimensions.width/2,dimensions.height-1);
	}

	/**
	 * Paints the graph of the function.
	 */
	private void paintCurve(Graphics2D g) {
		boolean firstpoint=true;
		int lastX=0, lastY=0;

		g.setColor(Color.black);

		for (int xAbsolute = 0; xAbsolute <= (dimensions.width-1); xAbsolute++)
		{
			double xRelative = (xAbsolute - dimensions.width/2)/scaleX;
			double yRelative = getYValue(xRelative);
			int yAbsolute = (int)(-yRelative*scaleY + dimensions.height/2);

			if (yAbsolute > dimensions.height)
				yAbsolute = dimensions.height;
			if (yAbsolute < -1)
				yAbsolute = -1;

			if (firstpoint != true)
				g.drawLine(lastX, lastY, xAbsolute, yAbsolute);
			else
				firstpoint = false;

			lastX = xAbsolute;
			lastY = yAbsolute;
		}
	}

	/**
	 * Draws the graph to the Graphics object. If the image buffer has been
	 * initialized, and the function has not changed since the last paint, 
	 * the image stored in the buffer is drawn straight to the Graphics
	 * object with drawImage().
	 * <p>
	 * If a image buffer has not yet been initialized (i.e. first time after
	 * being started) the buffer is created with createImage().
	 * <p>
	 * If the function has changed since the last paint, the graph is first 
	 * drawn on the buffer image, then that image is drawn on the Graphics
	 * object.
	 */
	public void paint(Graphics g_in) {
		boolean changedDimensions = !dimensions.equals(getSize());
		Graphics2D g = (Graphics2D) g_in;
		
		// If the buffer has not been initialized, do it now
		if (!initializedBuffer || changedDimensions)
		{
			dimensions = getSize();
			buffer = createImage(dimensions.width,dimensions.height);
			initializedBuffer = true;
		}
		
		// Get the Graphics instance of the buffer
		Graphics2D buffergc = (Graphics2D) buffer.getGraphics();
		// Turn on anti aliasing
		buffergc.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

		// Redraw the function on the buffer
		if (changedFunction || changedDimensions)
		{
			paintWhite(buffergc);
			paintAxes(buffergc);
			if (!hasError) paintCurve(buffergc);
			changedFunction = false;
		}

		// Copy the buffer to g
		g.drawImage(buffer, 0, 0, null);
	}	
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

/*
<applet code="org.nfunk.jepexamples.Fractal" width=300 height=320>
<param name=initialExpression value="z*z+c">
</applet>
*/
package org.nfunk.jepexamples;

import java.applet.*;
import java.awt.*;
import java.awt.event.*;

public class Fractal extends Applet implements ActionListener {
	private static final long serialVersionUID = -1825231934586941116L;
	private TextField exprField, itField;
	private Button button;
	private FractalCanvas complexCanvas;


	/** Initializes the applet Fractal */
	public void init () {
		initComponents();
	}


	private void initComponents () {
		GridBagLayout gridbag = new GridBagLayout();
		GridBagConstraints c = new GridBagConstraints();

		setLayout(gridbag);
		c.fill = GridBagConstraints.BOTH;
		
		// Expression field
		String expr = getParameter("initialExpression");
		if (expr!=null)
			exprField = new TextField(expr);
		else
			exprField = new TextField("");


		exprField.setBackground (java.awt.Color.white);
		exprField.setName ("exprField");
		exprField.setFont (new Font ("Dialog", 0, 11));
		exprField.setForeground (Color.black);
		exprField.addTextListener (new java.awt.event.TextListener () {
			public void textValueChanged (java.awt.event.TextEvent evt) {
				exprFieldTextValueChanged (evt);
			}
		}
		);

		c.gridx = 0;
		c.gridy = 0;
		c.weightx = 1;
		gridbag.setConstraints(exprField, c);
		add(exprField);

		// RENDER BUTTON
		c.gridx = 1;
		c.gridy = 0;
		c.weightx = 0.2;
		button = new Button("Render");
		gridbag.setConstraints(button, c);
		add(button);
		button.addActionListener(this);

		// Iterations field
		itField = new TextField("20");
		itField.addTextListener (new java.awt.event.TextListener () {
			public void textValueChanged (java.awt.event.TextEvent evt) {
				itFieldTextValueChanged(evt);
			}
		}
		);

		c.gridx = 0;
		c.gridy = 1;
		c.weightx = 1;
		gridbag.setConstraints(itField, c);
		add(itField);


		// CANVAS
		c.gridx = 0;
		c.gridy = 2;
		c.gridwidth = 2;
		c.weighty = 1;
//		button2 = new Button("test");
		
		complexCanvas = new FractalCanvas(expr, exprField);
		gridbag.setConstraints(complexCanvas, c);
		add(complexCanvas);
	}



	private void exprFieldTextValueChanged (java.awt.event.TextEvent evt) {
		String newExpressionString = exprField.getText();
		complexCanvas.setExpressionString(newExpressionString);
		//complexCanvas.repaint();
	}

	private void itFieldTextValueChanged (java.awt.event.TextEvent evt) {
		Integer newIterationsValue = new Integer(itField.getText());
		complexCanvas.setIterations(newIterationsValue.intValue());
		//complexCanvas.repaint();
	}

	public void actionPerformed(ActionEvent ae) {
		String str = ae.getActionCommand();
		if (str.equals("Render")) {
			String newExpressionString = exprField.getText();
			complexCanvas.setExpressionString(newExpressionString);
			complexCanvas.repaint();
		}
	}
}
/*
HTML code for applet:
<applet code="org.nfunk.jepexamples.FunctionPlotter" width=300 height=320>
<param name=initialExpression value="100 sin(x/3) cos(x/70)">
</applet>
*/

package org.nfunk.jepexamples;

import java.applet.*;
import java.awt.*;

/**
 * This applet is a demonstration of the possible applications of the JEP
 * mathematical expression parser.<p>
 * The FunctionPlotter class arranges the text field and GraphCanvas classes
 * and requests a repainting of the graph when the expression in the text
 * field changes. All plotting (and interaction with the JEP API) is preformed
 * in GraphCanvas class.
 */
public class FunctionPlotter extends Applet {
	private static final long serialVersionUID = -27867883051236035L;

	/** The expression field */
	private java.awt.TextField exprField;
	
	/** The canvas for plotting the graph */
	private GraphCanvas graphCanvas;

	/**
	 * Initializes the applet FunctionPlotter
	 */
	public void init () {
		initComponents();
	}

	/**
	 * Sets the layout of the applet window to BorderLayout, creates all
	 * the components and associates them with event listeners if neccessary.
	 */
	private void initComponents () {
		setLayout(new BorderLayout());
		setBackground (java.awt.Color.white);

		// get the initial expression from the parameters
		String expr = getParameter("initialExpression");
		
		// write the expression into the text field
		if (expr!=null)
			exprField = new java.awt.TextField(expr);
		else
			exprField = new java.awt.TextField("");

		// adjust various settings for the expression field
		exprField.setBackground (java.awt.Color.white);
		exprField.setName ("exprField");
		exprField.setFont (new java.awt.Font ("Dialog", 0, 11));
		exprField.setForeground (java.awt.Color.black);
		exprField.addTextListener (new java.awt.event.TextListener () {
			public void textValueChanged (java.awt.event.TextEvent evt) {
				exprFieldTextValueChanged (evt);
			}
		}
		);

		add ("North", exprField);
		
		// create the graph canvas and add it
		graphCanvas = new GraphCanvas(expr, exprField);
		add ("Center", graphCanvas);
	}


	/**
	 * Repaints the graphCanvas whenever the text in the expression field
	 * changes.
	 */
	private void exprFieldTextValueChanged(java.awt.event.TextEvent evt) {
		String newExpressionString = exprField.getText();
		graphCanvas.setExpressionString(newExpressionString);
		graphCanvas.repaint();
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jepexamples;
import org.nfunk.jep.*;

/**
 * A seven line program for testing whether the JEP library can be found
 * by the compiler and at run-time.<br>
 * Upon successful compilation and running of the program, the program should
 * print out one line: "1+2 = 3.0"
 */
public class SimpleTest {
	public static void main(String args[]) {
		JEP myParser = new JEP();
		myParser.parseExpression("1+2");
		System.out.println("1+2 = " + myParser.getValue());
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jepexamples;


/**
 * The ThreadTestThread waits for 5 seconds before calling the evaluate method
 * of the ThreadTest instance.
 * <p>
 * Thanks to Matthew Baird and Daniel Teng for this code.
 */
public class ThreadTestThread extends Thread
{
    ThreadTest test;

    public ThreadTestThread(ThreadTest test_in)
    {
        test = test_in;
    }

    public void run() {

        try {
            Thread.sleep(5000);
            test.evaluate();
            Thread.yield();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

    }
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jepexamples;

import java.util.*;

import org.nfunk.jep.JEP;

/**
 * This example tests how the evaluation time is influenced by the size of the
 * expression and symbol table.
 */
public class LargeExpressionTest {
	public static void main(String args[]) {
		int nEvals = 500;
		int nVars = 1000;
		Date start, finish;
		String str = "";
		
		JEP myParser = new JEP();

		// Test small symbol table
		for (int i=0; i<10; i++) {
			myParser.addVariable("v"+i, 0);
			str += "+" + "v" + i;
		}
		myParser.parseExpression(str);
		System.out.print("Evaluating with small symbol table... ");
		start = new Date();
		for (int i=0; i<nEvals; i++) {
			myParser.getValue();
		}
		finish = new Date();
		System.out.println("done.");
		System.out.println("Time: " +
							(finish.getTime() - start.getTime()));
		
		// Test large symbol table
		str = "";
		for (int i=0; i<nVars; i++) {
			myParser.addVariable("v" + i, 0);
			str += "+" + "v" + i;
		}
		myParser.parseExpression(str);
		System.out.print("Evaluating with large symbol table... ");
		start = new Date();
		for (int i=0; i<nEvals; i++) {
			myParser.getValue();
		}
		finish = new Date();
		System.out.println("done.");
		System.out.println("Time: " +
							(finish.getTime() - start.getTime()));
	}	
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jepexamples;

import java.awt.*;
import java.util.*;

import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
import org.nfunk.jep.evaluation.*;

/**
* This class performs the drawing of the fractal.
*/
public class FractalCanvas extends Canvas {
	private static final long serialVersionUID = -593341831485283712L;

	private int scaleX, scaleY;

	private Dimension dimensions;
	
	private int iterations, nEvals;

	private boolean hasError;

	private JEP myParser;
	private ExpressionCompiler expressionCompiler;
	private CommandEvaluator          evaluator;
	private CommandElement[]          commands;
	private SymbolTable        symTab;
	
	private java.awt.TextField exprField;

	/**
	* Constructor. 
	*/
	public FractalCanvas(String initialExpression, java.awt.TextField exprField_in) {
		iterations = 20;
		nEvals = 0;
		scaleX = 100;
		scaleY = 100;
		dimensions = getSize();
		hasError = true;
		exprField = exprField_in;
		initParser(initialExpression);
		expressionCompiler = new ExpressionCompiler();
		evaluator = new CommandEvaluator();
		symTab = myParser.getSymbolTable();
	}

	/**
	* Initializes the parser
	*/
	private void initParser(String initialExpression) {
		//Init Parser
		myParser = new JEP();

		//Load the standard functions
		myParser.addStandardFunctions();

		//Load the standard
		myParser.addStandardConstants();
		myParser.addComplex();	

		//Add and initialize z to (0,0)
		myParser.addVariable("z",0,0);
		myParser.addVariable("c",0,0);

		setExpressionString(initialExpression);
	}

	/**
	* Parses a new expression
	*/
	public void setExpressionString(String newString) {
		nEvals = 0;

		//Parse the new expression
		myParser.parseExpression(newString);

		//Find out whether there was an error in the expression
		hasError = myParser.hasError();
		if (hasError)
		  exprField.setForeground(Color.red);
		else
		  exprField.setForeground(Color.black);

	}

	public void setIterations(int iterations_in) {
		iterations = iterations_in;
	}

	private void paintWhite(Graphics g) {
		g.setColor(Color.white);
		g.fillRect(0,0,dimensions.width,dimensions.height);
	}


	private void paintFractalSansJEP(Graphics g) {
		System.out.println("paintFractalSansJEP()");

		//paintRegion(g, 0,0,256,256,0,8);

		System.out.println("done.");
	}
	
	private void paintRegion(Graphics g, int x, int y,
							int width, int height, int depth,
							int depth_max) {
		double re, im, p, q, resq, imsq, imtemp;
		int count;

		if (depth == depth_max) {
			p = (double)(x+width/2-230)/scaleX;
			q = (double)(y+height/2-150)/scaleY;
			count = 0;
			re = 0;
			im = 0;
			resq = 0;
			imsq = 0;

			while ((count < iterations) && ((resq + imsq) < 4.0)) {
				imtemp = 2 * re * im;
				re = resq - imsq + p;
				im = imtemp + q;
				count++;
				resq = re * re;
				imsq = im * im;
				nEvals++;
			}
			//System.out.println("At: " + x + ", " + y + ": " + count + " "+ result);
			if (count != iterations) {
				g.setColor(new Color(0, 0, (int)(255.0*(Math.sqrt(count)/Math.sqrt(iterations)))));
				g.fillRect(x, y, width, height);
			}

		} else {
			paintRegion(g,           x,            y, width/2, height - height/2, depth+1, depth_max);
			paintRegion(g, x + width/2,            y, width - width/2, height/2, depth+1, depth_max);
			paintRegion(g,           x, y + height/2, width/2, height - height/2, depth+1, depth_max);
			paintRegion(g, x + width/2, y + height/2, width - width/2, height - height/2, depth+1, depth_max);
		}
	}

	private void paintFractal(Graphics g) {
		Complex z,c,temp;
		int count;
		
		c = myParser.addVariable("c", 0, 0);
		z = myParser.addVariable("z", 0, 0);

		for (int x = 0; x <= (dimensions.width-1); x++) {
			for (int y = 0; y <= (dimensions.height-1); y++) {
				count = 0;
				c.set((double)(x-230)/scaleX,
				      (double)(y-150)/scaleY);
				z.set(0,0);
				
				while ((count < iterations) && (z.abs2() < 4.0)) {
					z.set(myParser.getComplexValue());
					count++;
					nEvals++;
				}

				if (count != iterations) {
					g.setColor(new Color(0, 0, (int)(255.0*(Math.sqrt(count)/Math.sqrt(iterations)))));
					g.fillRect(x, y, 1, 1);
				}
			}
		}
	}

	private void paintFractalWithCompiler(Graphics g) {
		Complex z,c,temp;
		int count;
		
		c = myParser.addVariable("c", 0, 0);
		z = myParser.addVariable("z", 0, 0);
		try {
			commands = expressionCompiler.compile(myParser.getTopNode());
		} catch (ParseException e) {
			System.out.println("Failed to compile expression");
			e.printStackTrace();
		}

		for (int x = 0; x <= (dimensions.width-1); x++) {
			for (int y = 0; y <= (dimensions.height-1); y++) {
				count = 0;
				c.set((double)(x-230)/scaleX,
					  (double)(y-150)/scaleY);
				z.set(0,0);
				
				while ((count < iterations) && (z.abs2() < 4.0)) {
					try {
						temp = (Complex)evaluator.evaluate(commands, symTab);
						z.set(temp);
					} catch (Exception e) {
						//System.out.println(e.toString());
						e.printStackTrace();
					}
					count++;
					nEvals++;
				}

				if (count != iterations) {
					g.setColor(new Color(0, 0, (int)(255.0*(Math.sqrt(count)/Math.sqrt(iterations)))));
					g.fillRect(x, y, 1, 1);
				}
			}
		}
	}

	private void paintNonJEPFractal(Graphics g) {
		double re, im, p, q, resq, imsq, imtemp;
		int count;

		for (int x = 0; x <= (dimensions.width-1); x++) {
			for (int y = 0; y <= (dimensions.height-1); y++) {
				p = (double)(x-230)/scaleX;
				q = (double)(y-150)/scaleY;
				count = 0;
				re = 0;
				im = 0;
				resq = 0;
				imsq = 0;
	
				while ( (count < iterations) && ((resq + imsq) < 4.0) ) {
					imtemp = 2 * re * im;
					re = resq - imsq + p;
					im = imtemp + q;
					resq = re * re;
					imsq = im * im;
					count++;
					nEvals++;
				}
				//System.out.println("At: " + x + ", " + y + ": " + count + " "+ result);
				if (count != iterations) {
					g.setColor(new Color(0, 0, (int)(255.0*(Math.sqrt(count)/Math.sqrt(iterations)))));
					g.fillRect(x, y, 1, 1);
				}
			}
		}
	}

	public void paint(Graphics g) {
		Date start, finish;

		dimensions = getSize();
		paintWhite(g);
		if (!hasError) {
			System.out.println("Painting... ");
			start = new Date();
			nEvals = 0;
			//paintFractal(g);
			paintFractalWithCompiler(g);
			//paintNonJEPFractal(g);
			finish = new Date();
			System.out.print("done. sec/eval: ");
			double seconds =  ( finish.getTime() - start.getTime() ) / 1000.0;
			System.out.println(seconds/nEvals);
		}
/*
		if (!initializedBuffer)
		{
			buffer = createImage(dimensions.width, dimensions.height);
			initializedBuffer = true;
		}

		Graphics buffergc = buffer.getGraphics();

		if (changedFunction)
		{
			paintWhite(buffergc);
			if (!hasError) paintFractal(buffergc);
			g.drawImage(buffer, 0, 0, null);
			changedFunction = false;
		}
		else
		{
			g.drawImage(buffer, 0, 0, null);
		}*/
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

/**
 * Console - JEP Example Applet
 * Copyright (c) 2000 Nathan Funk
 *
 * @author Nathan Funk 
 */

package org.nfunk.jepexamples;

import java.io.*;
import org.nfunk.jep.JEP;
//import org.nfunk.sovler.*;

/**
* This class implements a simple command line utility for evaluating
* mathematical expressions.
*
*   Usage: java org.nfunk.jepexamples.Console [expression]
*
* If an argument is passed, it is interpreted as an expression
* and evaluated. Otherwise, a prompt is printed, and the user can enter
* expressions to be evaluated. To exit from the command prompt a 'q' must
* be entered.
*/
class Console {
	
	/** The prompt string */
	private String prompt;
	
	/** The input reader */
	private BufferedReader br;
	
	/** Constructor */
	public Console() {
		prompt = "JEP > ";
		br = new BufferedReader(new InputStreamReader(System.in));

	}

	/** Creates a new Console object and calls run() */
	public static void main(String args[]) throws IOException {
		Console c = new Console();
		c.run(args);
	}
	
	/** The input loop */
	public void run(String args[]) throws IOException {
		String command="";
		JEP j = new JEP();
		j.addStandardConstants();
		j.addStandardFunctions();
		j.addComplex();
		//j.setTraverse(true);

		if (args.length>0) {
			// evaluate the expression passed as arguments
			String temp = args[0];
			for (int i=1; i<args.length; i++) temp += " " + args[i];
			j.parseExpression(temp);
			if (j.hasError())
				System.out.println(j.getErrorInfo());
			else
				System.out.println(j.getValueAsObject());
		} else {
			// no arguments - interactive mode
				
			System.out.println("JEP - Enter q to quit");	
			System.out.print(prompt);

			while ((command = getCommand()) != null) {
				j.parseExpression(command);
				
				if (j.hasError()) {
					System.out.println(j.getErrorInfo());
				} else {
					// expression is OK, get the value
					Object value = j.getValueAsObject();
					
					// did error occur during evaluation?
					if (j.hasError()) {
						System.out.println(j.getErrorInfo());
					} else {
						System.out.println(value);
					}

/*
					System.out.println(
						(LinearVisitor.isLinear(j.getTopNode())) ?
						"Linear" : "Not Linear");
					System.out.println(
						(ConstantVisitor.isConstant(j.getTopNode())) ?
						"Constant" : "Not Constant");
*/
				}
					
				System.out.print(prompt);
			}
		}
		
	}
	
	/**
	 * Get a command from the input.
	 * @return null if an error occures, or if the user enters a terminating
	 *  command
	 */
	private String getCommand() throws IOException {
		String s;
		
		if (br == null)
			return null;

		if ( (s = br.readLine()) == null)
			return null;

		if (s.equals("q")
			|| s.equals("quit")
			|| s.equals("exit"))
			return null;
		
		return s;
	}
}
/*****************************************************************************

 @header@
 @date@
 @copyright@
 @license@

 *****************************************************************************/

package org.nfunk.jepexamples;

/**
 * This class tests the thread safety of the JEP package with a brute force
 * approach. 1000 threads are started, and each one invokes the evaluate method.
 * The evaluate method creates 10 JEP instances. Note that running this class
 * successfully does not necessarily ensure that no errors will ever occur.
 * <p>
 * Thanks to Matthew Baird and Daniel Teng for this code.
 */
public class ThreadTest {

	static long time = 0;

	/**
	 * Main method. Launches many threads.
	 */
	public static void main(String[] args) {
		int n = 1000;
		System.out.println("Starting " + n + " threads...");
		ThreadTest test = new ThreadTest();

		for (int i = 0; i < n; i++) {
			ThreadTestThread t = new ThreadTestThread(test);
			t.start();
		}
		System.out.println("Returned from starting threads. Threads may still need to terminate.");
		// TODO: check why application appears to end before all thread exit
	}

	public ThreadTest() {

	}

	/**
	 * Perform a simple evaluation using a new JEP instance. This method is
	 * called by all ThreadTestThreads at very much the same time.
	 */
	public void evaluate() {
		for (int i = 0; i < 10; i++) {
			org.nfunk.jep.JEP myParser = new org.nfunk.jep.JEP();
			String fooValue = null;
			Math.random();

			if (Math.random() > 0.5) {
				fooValue = "NLS";
			} else {
				fooValue = "NLT";
			}

			// TODO: add more involved calculations so the execution time of the
			// evaluation is longer (leading to more possible thread conflicts)
			myParser.addVariable("foo", fooValue);
			myParser.parseExpression("foo == \"" + fooValue + "\"");

			if (myParser.getValue() != 1.0)
				System.out.println("Wrong value returned");
			
			if (myParser.hasError())
				System.out.println(myParser.getErrorInfo());
		}
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

/**
 * Evaluator - JEP Example Applet
 * Copyright (c) 2004 Nathan Funk
 *
 * @author Nathan Funk

HTML code for running the applet:
<applet code="org/nfunk/jepexamples/Evaluator.class" width=400 height=200>
</applet>

*/
package org.nfunk.jepexamples;

import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;

import org.nfunk.jep.JEP;


/**
 * This applet is an simple example for how JEP can be used to evaluate
 * expressions. It also displays the different options, and the effects of
 * their settings.
 */
public class Evaluator extends Applet {

	private static final long serialVersionUID = 4592714713689369505L;

	/** Parser */
	private JEP myParser;
	
	/** Current xValue */
	private double xValue;

	/* GUI components */
	private TextField exprField, xField;
	private TextArea errorTextArea;
	private Label resultLabel;
	private Checkbox implicitCheckbox, undeclaredCheckbox;

	
	/** 
	 * This method is called if the applet is run as an standalone
	 * program. It creates a frame for the applet and adds the applet
	 * to that frame.
	 */
	public static void main(String args[]) {
		Evaluator a = new Evaluator();
		a.init();
		a.start();

		Frame f = new Frame("Evaluator");
		f.add("Center", a);
		f.setSize(400,200);
		f.addWindowListener(
			new WindowAdapter() {
				public void windowClosing(WindowEvent e) {
					System.exit(0);
				}
			}
		);
		
//		f.show(); 
		f.setVisible(true);
	}

	/**
	 * The initialization function of the applet. It adds all the
	 * components such as text fields and also creates the JEP object
	 */
	public void init() {
		// initialize value for x
		xValue = 10;

		// add the interface components
		addGUIComponents();
		
		// Set up the parser (more initialization in parseExpression()) 
		myParser = new JEP();
		myParser.initFunTab(); // clear the contents of the function table
		myParser.addStandardFunctions();
		myParser.setTraverse(true);

		
		// simulate changed options to initialize output
		optionsChanged();
	}

	/**
	 * Creates and adds the necessary GUI components.
	 */
	private void addGUIComponents() {
		setBackground(Color.white);
		
		GridBagLayout gridbag = new GridBagLayout();
		GridBagConstraints c = new GridBagConstraints();
		setLayout(gridbag);

		// Expression
		c.fill = GridBagConstraints.HORIZONTAL;
		c.weightx = 0.0;
		Label exprFieldp = new Label("Expression: ", Label.RIGHT);
		gridbag.setConstraints(exprFieldp,c);
		add(exprFieldp);
		
		c.weightx = 0.8;
		exprField = new TextField(27);
		gridbag.setConstraints(exprField,c);
		add(exprField);
		
		// x
		c.weightx = 0.0;
		Label xFieldp = new Label("x: ", Label.RIGHT);
		gridbag.setConstraints(xFieldp,c);
		add(xFieldp);
		
		c.weightx = 0.2;
		c.gridwidth = GridBagConstraints.REMAINDER;
		xField = new TextField("" + xValue,4);
		gridbag.setConstraints(xField,c);
		add(xField);
		
		// Result
		c.weightx = 0.0;
		c.gridwidth = 1;
		Label resultLabelText = new Label("Result: ", Label.RIGHT);
		gridbag.setConstraints(resultLabelText,c);
		add(resultLabelText);
		
		c.weightx = 1.0;
		c.gridwidth = GridBagConstraints.REMAINDER;
		resultLabel = new Label("", Label.LEFT);
		gridbag.setConstraints(resultLabel,c);
		add(resultLabel);
		
		// Options
		c.weightx = 0.0;
		c.gridwidth = 1;
		Label optionsLabelText = new Label("Options: ", Label.RIGHT);
		gridbag.setConstraints(optionsLabelText,c);
		add(optionsLabelText);
		
		c.weightx = 1.0;
		c.gridwidth = GridBagConstraints.REMAINDER;
		implicitCheckbox = new Checkbox("Implicit multiplication", true);
		gridbag.setConstraints(implicitCheckbox,c);
		add(implicitCheckbox);
		
		c.weightx = 0.0;
		c.gridwidth = 1;
		Label spaceLabelText = new Label(" ", Label.RIGHT);
		gridbag.setConstraints(spaceLabelText,c);
		add(spaceLabelText);

		c.weightx = 1.0;
		c.gridwidth = GridBagConstraints.REMAINDER;
		undeclaredCheckbox = new Checkbox("Allow undeclared identifiers");
		gridbag.setConstraints(undeclaredCheckbox,c);
		add(undeclaredCheckbox);

		// Errors
		c.weightx = 0.0;
		c.gridwidth = 1;
		c.anchor = GridBagConstraints.NORTH;
		Label errorLabel = new Label("Errors: ", Label.RIGHT);
		gridbag.setConstraints(errorLabel,c);
		add(errorLabel);
		
		c.fill = GridBagConstraints.BOTH;
		c.weightx = 1.0;
		c.weighty = 1.0;
		c.gridwidth = GridBagConstraints.REMAINDER;
		errorTextArea = new TextArea("");
		errorTextArea.setEditable(false);
		errorTextArea.setBackground(Color.white);
		gridbag.setConstraints(errorTextArea,c);
		add(errorTextArea);

		// Set up listeners
		exprField.addTextListener(
			new TextListener() {
				public void textValueChanged(TextEvent evt) {
					exprFieldTextValueChanged();
				}
			}
		);

		xField.addTextListener(
			new TextListener() {
				public void textValueChanged(TextEvent evt) {
					xFieldTextValueChanged();
				}
			}
		);
		
		implicitCheckbox.addItemListener(
			new ItemListener() {
				public void itemStateChanged(ItemEvent evt) {
					optionsChanged();
				}
			}
		);
		
		undeclaredCheckbox.addItemListener(
			new ItemListener() {
				public void itemStateChanged(ItemEvent evt) {
					optionsChanged();
				}
			}
		);
	}

	/**
	 * Parses the current expression in the exprField. This method also
	 * re-initializes the contents of the symbol and function tables. This
	 * is necessary because the "allow undeclared variables" option adds
	 * variables from expressions to the symbol table.
	 */
	private void parseExpression() {
		myParser.initSymTab(); // clear the contents of the symbol table
		myParser.addStandardConstants();
		myParser.addComplex(); // among other things adds i to the symbol table
		myParser.addVariable("x", xValue);
		myParser.parseExpression(exprField.getText());
	}

	/**
	 * Whenever the expression is changed, this method is called.
	 * The expression is parsed, and the updateResult() method
	 * invoked.
	 */
	private void exprFieldTextValueChanged() {
		parseExpression();
		updateResult();
	}
	
	/**
	 * Every time the value in the x field is changed, this method is
	 * called. It takes the value from the field as a double, and
	 * sets the value of x in the parser.
	 */
	private void xFieldTextValueChanged() {
		
		try {
			xValue = Double.valueOf(xField.getText()).doubleValue();
		} catch (NumberFormatException e) {
			System.out.println("Invalid format in xField");
			xValue = 0;
		}

		myParser.addVariable("x", xValue);

		updateResult();
	}
	
	/**
	 * Every time one of the options is changed, this method is called. The
	 * parser settings are adjusted to the GUI settings, the expression is
	 * parsed again, and the results updated.
	 */
	private void optionsChanged() {
		myParser.setImplicitMul(implicitCheckbox.getState());
		myParser.setAllowUndeclared(undeclaredCheckbox.getState());
		parseExpression();
		updateResult();
	}
	
	/**
	 * This method uses JEP's getValueAsObject() method to obtain the current
	 * value of the expression entered.
	 */
	private void updateResult() {
		Object result;
		String errorInfo;
		
		// Get the value
		result = myParser.getValueAsObject();
		
		// Is the result ok?
		if (result!=null) {
			resultLabel.setText(result.toString());
		} else {
			resultLabel.setText("");
		}
		
		// Get the error information
		if ((errorInfo = myParser.getErrorInfo()) != null) {
			errorTextArea.setText(errorInfo);
		} else {
			errorTextArea.setText("");
		}
	}
}
package org.nfunk.jeptesting;

import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.NaturalLogarithm;

import junit.framework.Assert;
import junit.framework.TestCase;

public class NaturalLogarithmTest extends TestCase {

	NaturalLogarithmTest(String name) {
		super(name);
	}

	/**
	 * Test method for 'org.nfunk.jep.function.Logarithm.run(Stack)'
	 * Tests the return value of log(NaN). This is a test for bug #1177557
	 */
	public void testNaturalLogarithm() {
		NaturalLogarithm logFunction = new NaturalLogarithm();
		java.util.Stack stack = new java.util.Stack();
		stack.push(new Double(Double.NaN));
		try {
			logFunction.run(stack);
		} catch (ParseException e) {
			Assert.fail();
		}
		Object returnValue = stack.pop();

		if (returnValue instanceof Double) {
			Assert.assertTrue(Double.isNaN(((Double)returnValue).doubleValue()));
		} else {
			Assert.fail();
		}
	}

}
package org.nfunk.jeptesting;

import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.Logarithm;

import junit.framework.Assert;
import junit.framework.TestCase;

public class LogarithmTest extends TestCase {

	LogarithmTest(String name) {
		super(name);
	}

	/**
	 * Test method for 'org.nfunk.jep.function.Logarithm.run(Stack)'
	 * Tests the return value of log(NaN). This is a test for bug #1177557
	 */
	public void testLogarithm() {
		Logarithm logFunction = new Logarithm();
		java.util.Stack stack = new java.util.Stack();
		stack.push(new Double(Double.NaN));
		try {
			logFunction.run(stack);
		} catch (ParseException e) {
			Assert.fail();
		}
		Object returnValue = stack.pop();

		if (returnValue instanceof Double) {
			Assert.assertTrue(Double.isNaN(((Double)returnValue).doubleValue()));
		} else {
			Assert.fail();
		}
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jeptesting;

import junit.framework.*;

public class AllTests {
	
	public static void main (String[] args) {
		junit.textui.TestRunner.run(suite());
	}
	
	public static Test suite() {
		TestSuite suite = new TestSuite("All JUnit Tests");
		suite.addTest(new JEPTest("testParseExpression"));
		suite.addTest(new LogarithmTest("testLogarithm"));
		suite.addTest(new NaturalLogarithmTest("testNaturalLogarithm"));
		return suite;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jeptesting;

import java.io.*;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.nfunk.jep.*;
import org.nfunk.jep.type.Complex;

/**
 * This class is designed for testing the validity of JEP evaluations.
 * Expressions from a text file are evaluated with JEP in pairs of two, and
 * the results are compared. If they do not match, the two expressions are 
 * printed to standard output.<p>
 * Take for example an input text file containing the two lines
 * <pre>1+2
 *3.</pre>
 * The expressions '1+2' and '3' are evaluated with JEP and the results compared.
 */
public class JEPTest extends TestCase {

	/** The parser */
	JEP myParser;
	
	/** Current line position */
	int lineCount;

	/**
	 * Constructor
	 *
	public JEPTester() {
		// Set up the parser
		myParser = new JEP();
		myParser.setImplicitMul(true);
		myParser.addStandardFunctions();
		myParser.addStandardConstants();
		myParser.addComplex();
		myParser.setTraverse(false);
		lineCount = 0;
	}*/
	
	/**
	 * Creates a new JEPTest instance
	 */
	public JEPTest(String name) {
		super(name);
	}
	
	/**
	 * Sets up the parser.
	 */
	public void setUp() {
		// Set up the parser
		myParser = new JEP();
		myParser.setImplicitMul(true);
		myParser.addStandardFunctions();
		myParser.addStandardConstants();
		myParser.addComplex();
		myParser.setTraverse(false);
		lineCount = 0;
	}
	
	/**
	 * Runs the test.
	 */
	public void runTest() {
		String fileName = "JEPTestExpressions.txt";
		testWithFile(fileName);
		testGetValue();
		testGetComplexValue();
		testOpSetBug();
	}
	
	/**
	 * The main method checks the arguments and creates an instance
	 * and calls it's run method.
	 */
	public static void main(String args[]) {
		String fileName;
		
		// get filename from argument, or use default
		if (args!=null && args.length>0) {
			fileName = args[0];
		} else {
			fileName = "JEPTestExpressions.txt";
			println("Using default input file: " + fileName);
			println("Start with \"java org.nfunk.jepexamples."+
			"JEPTest <filename>\" to load a different input file.");
		}
		
		// Create an instance of this class and analyse the file
		JEPTest jt = new JEPTest("JEP Test");
		jt.setUp();
		jt.testWithFile(fileName);
	}

	/**
	 * Loads the file specified in fileName. Evaluates the expressions listed
	 * in it and compares the expressions with the results.
	 */
	public void testWithFile(String fileName) {
		BufferedReader reader;
		Object v1, v2;
		boolean hasError = false;

		// Load the input file
		try {
			reader = new BufferedReader(new FileReader(fileName));
		} catch (Exception e) {
			Assert.assertTrue(false);
			println("File \""+fileName+"\" not found");
			return;
		}
		
		// reset the line count
		lineCount = 0;
		
		// cycle through the expressions in pairs of two
		println("Evaluating and comparing expressions...");
		while (true) {
			// get values of a pair of two lines
			try {
				v1 = parseNextLine(reader); //returns null when end of file is reached
				v2 = parseNextLine(reader);
			} catch (Exception e) {
				println(e.getMessage());
				hasError = true;
				break;
			}

			// v1 or v2 is null when end of file is reached
			if (v1 == null || v2 == null) {
				println("Reached end of file.");
				break;
			}

			// compare the results
			try {			
				if (!equal(v1, v2)) {
					hasError = true;
					print("Line: " + lineCount + ": ");
					println(v1.toString() + " != " + v2.toString());
				}
			} catch (Exception e) {
				hasError = true;
				println(e.getMessage());
			}
		}
		
		// Closing remarks
		print("\n" + lineCount + " lines processed. ");
		if (hasError) {
			print("Errors were found.\n\n");
		} else {
			print("No errors were found.\n\n");
		}
	}
	
	/**
	 * Parses a single line from the reader, and returns the
	 * evaluation of that line.
	 * @return evaluated line. Returns null when the end of the file
	 *         is reached.
	 * @throws Exception when IOException occurs, parsing fails, or when
	 *         evaluation fails
	 */
	private Object parseNextLine(BufferedReader reader) throws Exception {
		Object value;
		String line, errorStr;
		
		// cycle till a valid line is found
		do {
			line = reader.readLine(); // returns null on end of file
			if (line == null) return null;
			lineCount++;
		} while (line.length() == 0 || line.trim().charAt(0) == '#');

		// parse the expression
		myParser.parseExpression(line);
		// did an error occur while parsing?
		if (myParser.hasError()) {
			errorStr = myParser.getErrorInfo();
			throw new Exception("Error while parsing line " + lineCount + ": " + errorStr);
		}
		
		// evaluate the expression
		value = myParser.getValueAsObject();
		// did an error occur while evaluating?
		if (value == null || myParser.hasError()) {
			errorStr = myParser.getErrorInfo();
			throw new Exception("Error while evaluating line " + lineCount + ": " + errorStr);
		}
			
		return value;
	}

	/**
	 * Compares o1 and o2. Copied from Comparative.java.
	 * @return true if o1 and o2 are equal. false otherwise.
	 */
	private boolean equal(Object param1, Object param2) throws Exception
	{
		double tolerance = 1e-15;
		if ((param1 instanceof Complex) && (param2 instanceof Complex)) {
			return ((Complex)param1).equals((Complex)param2, tolerance);
		}
		if ((param1 instanceof Complex) && (param2 instanceof Number)) {
			return ((Complex)param1).equals(new Complex((Number) param2), tolerance);
		}
		if ((param2 instanceof Complex) && (param1 instanceof Number)) {
			return ((Complex)param2).equals(new Complex((Number) param1), tolerance);
		}
		if ((param1 instanceof Number) && (param2 instanceof Number)) {
			return Math.abs(((Number)param1).doubleValue()-((Number)param2).doubleValue())
					< tolerance;
		}
		// test any other types here
		return param1.equals(param2);
		
//		throw new Exception("Unable to compare the values of this type");
	}

	/**
	 * Test the getValue() method.
	 */
	public void testGetValue() {
		// Test whether a normal double value is returned correctly
		myParser.parseExpression("2.1345");
		Assert.assertEquals(myParser.getValue(), 2.1345, 0);
		
		// Test whether NaN is returned for Somplex numbers
		myParser.parseExpression("i");
		Assert.assertTrue(Double.isNaN(myParser.getValue()));
		
		// Test whether NaN is returned for String results
		myParser.parseExpression("\"asdf\"");
		Assert.assertTrue(Double.isNaN(myParser.getValue()));
	}
	
	/**
	 * Test the getComplexValue() method.
	 */
	public void testGetComplexValue() {
		// Test whether a normal double value is returned as a Complex
		myParser.parseExpression("2.1345");
		Assert.assertTrue(new Complex(2.1345, 0).equals(
							myParser.getComplexValue(), 0));
		
		// Test whether (0, 1) is returned for i
		myParser.parseExpression("i");
		Complex z = myParser.getComplexValue();
		Assert.assertTrue(z != null);
		Assert.assertTrue(z.re() == 0);
		Assert.assertTrue(z.im() == 1);
		
		// Test whether NaN is returned for String results
		myParser.parseExpression("\"asdf\"");
		Assert.assertTrue(Double.isNaN(myParser.getValue()));
	}
	
	/**
	 * Tests the uninitialized OperatorSet bug 1061200
	 */
	public void testOpSetBug() {
		JEP j = new JEP(false, true, true, null);
		Assert.assertNotNull(j.getOperatorSet());
	}

	/**
	 * Helper function for printing.
	 */
	private static void print(String str) {
		System.out.print(str);
	}

	/**
	 * Helper function for printing lines.
	 */
	private static void println(String str) {
		System.out.println(str);
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
/* Generated By:JJTree: Do not edit this line. Node.java */

/* All AST nodes must implement this interface.  It provides basic
   machinery for constructing the parent and child relationships
   between nodes. */
package org.nfunk.jep;

import java.util.*;

public interface Node {

  /** This method is called after the node has been made the current
    node.  It indicates that child nodes can now be added to it. */
  public void jjtOpen();

  /** This method is called after all the child nodes have been
    added. */
  public void jjtClose();

  /** This pair of methods are used to inform the node of its
    parent. */
  public void jjtSetParent(Node n);
  public Node jjtGetParent();

  /** This method tells the node to add its argument to the node's
    list of children.  */
  public void jjtAddChild(Node n, int i);

  /** This method returns a child node.  The children are numbered
     from zero, left to right. */
  public Node jjtGetChild(int i);

  /** Return the number of children the node has. */
  public int jjtGetNumChildren();

  /** Accept the visitor. **/
  public Object jjtAccept(ParserVisitor visitor, Object data)  throws ParseException;

  /** Push the value of the node on the stack *
  public void evaluate(Stack stack) throws ParseException;
*/
}
/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */
package org.nfunk.jep;

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */

public class SimpleCharStream
{
  public static final boolean staticFlag = true;
  static int bufsize;
  static int available;
  static int tokenBegin;
  static public int bufpos = -1;
  static protected int bufline[];
  static protected int bufcolumn[];

  static protected int column = 0;
  static protected int line = 1;

  static protected boolean prevCharIsCR = false;
  static protected boolean prevCharIsLF = false;

  static protected java.io.Reader inputStream;

  static protected char[] buffer;
  static protected int maxNextCharInd = 0;
  static protected int inBuf = 0;
  static protected int tabSize = 8;

  static protected void setTabSize(int i) { tabSize = i; }
  static protected int getTabSize(int i) { return tabSize; }


  static protected void ExpandBuff(boolean wrapAround)
  {
     char[] newbuffer = new char[bufsize + 2048];
     int newbufline[] = new int[bufsize + 2048];
     int newbufcolumn[] = new int[bufsize + 2048];

     try
     {
        if (wrapAround)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;

           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
        }
        else
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           bufcolumn = newbufcolumn;

           maxNextCharInd = (bufpos -= tokenBegin);
        }
     }
     catch (Throwable t)
     {
        throw new Error(t.getMessage());
     }


     bufsize += 2048;
     available = bufsize;
     tokenBegin = 0;
  }

  static protected void FillBuff() throws java.io.IOException
  {
     if (maxNextCharInd == available)
     {
        if (available == bufsize)
        {
           if (tokenBegin > 2048)
           {
              bufpos = maxNextCharInd = 0;
              available = tokenBegin;
           }
           else if (tokenBegin < 0)
              bufpos = maxNextCharInd = 0;
           else
              ExpandBuff(false);
        }
        else if (available > tokenBegin)
           available = bufsize;
        else if ((tokenBegin - available) < 2048)
           ExpandBuff(true);
        else
           available = tokenBegin;
     }

     int i;
     try {
        if ((i = inputStream.read(buffer, maxNextCharInd,
                                    available - maxNextCharInd)) == -1)
        {
           inputStream.close();
           throw new java.io.IOException();
        }
        else
           maxNextCharInd += i;
        return;
     }
     catch(java.io.IOException e) {
        --bufpos;
        backup(0);
        if (tokenBegin == -1)
           tokenBegin = bufpos;
        throw e;
     }
  }

  static public char BeginToken() throws java.io.IOException
  {
     tokenBegin = -1;
     char c = readChar();
     tokenBegin = bufpos;

     return c;
  }

  static protected void UpdateLineColumn(char c)
  {
     column++;

     if (prevCharIsLF)
     {
        prevCharIsLF = false;
        line += (column = 1);
     }
     else if (prevCharIsCR)
     {
        prevCharIsCR = false;
        if (c == '\n')
        {
           prevCharIsLF = true;
        }
        else
           line += (column = 1);
     }

     switch (c)
     {
        case '\r' :
           prevCharIsCR = true;
           break;
        case '\n' :
           prevCharIsLF = true;
           break;
        case '\t' :
           column--;
           column += (tabSize - (column % tabSize));
           break;
        default :
           break;
     }

     bufline[bufpos] = line;
     bufcolumn[bufpos] = column;
  }

  static public char readChar() throws java.io.IOException
  {
     if (inBuf > 0)
     {
        --inBuf;

        if (++bufpos == bufsize)
           bufpos = 0;

        return buffer[bufpos];
     }

     if (++bufpos >= maxNextCharInd)
        FillBuff();

     char c = buffer[bufpos];

     UpdateLineColumn(c);
     return (c);
  }

  /**
   * @deprecated 
   * @see #getEndColumn
   */

  static public int getColumn() {
     return bufcolumn[bufpos];
  }

  /**
   * @deprecated 
   * @see #getEndLine
   */

  static public int getLine() {
     return bufline[bufpos];
  }

  static public int getEndColumn() {
     return bufcolumn[bufpos];
  }

  static public int getEndLine() {
     return bufline[bufpos];
  }

  static public int getBeginColumn() {
     return bufcolumn[tokenBegin];
  }

  static public int getBeginLine() {
     return bufline[tokenBegin];
  }

  static public void backup(int amount) {

    inBuf += amount;
    if ((bufpos -= amount) < 0)
       bufpos += bufsize;
  }

  public SimpleCharStream(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    if (inputStream != null)
       throw new Error("\n   ERROR: Second call to the constructor of a static SimpleCharStream.  You must\n" +
       "       either use ReInit() or set the JavaCC option STATIC to false\n" +
       "       during the generation of this class.");
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    available = bufsize = buffersize;
    buffer = new char[buffersize];
    bufline = new int[buffersize];
    bufcolumn = new int[buffersize];
  }

  public SimpleCharStream(java.io.Reader dstream, int startline,
                          int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }

  public SimpleCharStream(java.io.Reader dstream)
  {
     this(dstream, 1, 1, 4096);
  }
  public void ReInit(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    bufpos = -1;
  }

  public void ReInit(java.io.Reader dstream, int startline,
                     int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }

  public void ReInit(java.io.Reader dstream)
  {
     ReInit(dstream, 1, 1, 4096);
  }
  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
  {
     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  public SimpleCharStream(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
  }

  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
                          int startcolumn) throws java.io.UnsupportedEncodingException
  {
     this(dstream, encoding, startline, startcolumn, 4096);
  }

  public SimpleCharStream(java.io.InputStream dstream, int startline,
                          int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }

  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
  {
     this(dstream, encoding, 1, 1, 4096);
  }

  public SimpleCharStream(java.io.InputStream dstream)
  {
     this(dstream, 1, 1, 4096);
  }

  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
  {
     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  public void ReInit(java.io.InputStream dstream, int startline,
                          int startcolumn, int buffersize)
  {
     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
  }

  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
  {
     ReInit(dstream, encoding, 1, 1, 4096);
  }

  public void ReInit(java.io.InputStream dstream)
  {
     ReInit(dstream, 1, 1, 4096);
  }
  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                     int startcolumn) throws java.io.UnsupportedEncodingException
  {
     ReInit(dstream, encoding, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream, int startline,
                     int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }
  static public String GetImage()
  {
     if (bufpos >= tokenBegin)
        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
     else
        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
                              new String(buffer, 0, bufpos + 1);
  }

  static public char[] GetSuffix(int len)
  {
     char[] ret = new char[len];

     if ((bufpos + 1) >= len)
        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
     else
     {
        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                                                          len - bufpos - 1);
        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
     }

     return ret;
  }

  static public void Done()
  {
     buffer = null;
     bufline = null;
     bufcolumn = null;
  }

  /**
   * Method to adjust line and column numbers for the start of a token.
   */
  static public void adjustBeginLineColumn(int newLine, int newCol)
  {
     int start = tokenBegin;
     int len;

     if (bufpos >= tokenBegin)
     {
        len = bufpos - tokenBegin + inBuf + 1;
     }
     else
     {
        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
     }

     int i = 0, j = 0, k = 0;
     int nextColDiff = 0, columnDiff = 0;

     while (i < len &&
            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
     {
        bufline[j] = newLine;
        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
        bufcolumn[j] = newCol + columnDiff;
        columnDiff = nextColDiff;
        i++;
     } 

     if (i < len)
     {
        bufline[j] = newLine++;
        bufcolumn[j] = newCol + columnDiff;

        while (i++ < len)
        {
           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
              bufline[j] = newLine++;
           else
              bufline[j] = newLine;
        }
     }

     line = bufline[j];
     column = bufcolumn[j];
  }

}
/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
package org.nfunk.jep;

/**
 * This exception is thrown when parse errors are encountered.
 * You can explicitly create objects of this exception type by
 * calling the method generateParseException in the generated
 * parser.
 *
 * You can modify this class to customize your error reporting
 * mechanisms so long as you retain the public fields.
 */
public class ParseException extends Exception {
	private static final long serialVersionUID = 8169613785780477459L;

/**
   * This constructor is used by the method "generateParseException"
   * in the generated parser.  Calling this constructor generates
   * a new object of this type with the fields "currentToken",
   * "expectedTokenSequences", and "tokenImage" set.  The boolean
   * flag "specialConstructor" is also set to true to indicate that
   * this constructor was used to create this object.
   * This constructor calls its super class with the empty string
   * to force the "toString" method of parent class "Throwable" to
   * print the error message in the form:
   *     ParseException: <result of getMessage>
   */
  public ParseException(Token currentTokenVal,
                        int[][] expectedTokenSequencesVal,
                        String[] tokenImageVal
                       )
  {
    super("");
    specialConstructor = true;
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }

  /**
   * The following constructors are for use by you for whatever
   * purpose you can think of.  Constructing the exception in this
   * manner makes the exception behave in the normal way - i.e., as
   * documented in the class "Throwable".  The fields "errorToken",
   * "expectedTokenSequences", and "tokenImage" do not contain
   * relevant information.  The JavaCC generated code does not use
   * these constructors.
   */

  public ParseException() {
    super();
    specialConstructor = false;
  }

  public ParseException(String message) {
    super(message);
    specialConstructor = false;
  }

  /**
   * This variable determines which constructor was used to create
   * this object and thereby affects the semantics of the
   * "getMessage" method (see below).
   */
  protected boolean specialConstructor;

  /**
   * This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error, the token
   * following this token will (therefore) be the first error token.
   */
  public Token currentToken;

  /**
   * Each entry in this array is an array of integers.  Each array
   * of integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.
   */
  public int[][] expectedTokenSequences;

  /**
   * This is a reference to the "tokenImage" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in the generated ...Constants interface.
   */
  public String[] tokenImage;

  /**
   * This method has the standard behavior when this object has been
   * created using the standard constructors.  Otherwise, it uses
   * "currentToken" and "expectedTokenSequences" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch it (it gets thrown
   * from the parser), then this method is called during the printing
   * of the final stack trace, and hence the correct error message
   * gets displayed.
   */
  public String getMessage() {
    if (!specialConstructor) {
      return super.getMessage();
    }
    String expected = "";
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected += tokenImage[expectedTokenSequences[i][j]] + " ";
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected += "...";
      }
      expected += eol + "    ";
    }
    String retval = "Encountered \"";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += " ";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += add_escapes(tok.image);
      tok = tok.next; 
    }
    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
    retval += "." + eol;
    if (expectedTokenSequences.length == 1) {
      retval += "Was expecting:" + eol + "    ";
    } else {
      retval += "Was expecting one of:" + eol + "    ";
    }
    retval += expected;
    return retval;
  }
  
  /**
   * getErrorInfo() was added to the parser generated code to provide clean
   * output instead of the standard format of Exception.toString(). It returns
   * a short description of the error that occurred as well as the position of
   * next token as part of the string.
   */
  public String getErrorInfo()
  {
	if (!specialConstructor) {
	  try {
		return super.getMessage() + " at column " + currentToken.next.beginColumn + ".";
	  }
	  catch (Exception e) {
		return super.getMessage();
	  }
	}
	String expected = "";
	int maxSize = 0;
	for (int i = 0; i < expectedTokenSequences.length; i++) {
	  if (maxSize < expectedTokenSequences[i].length) {
		maxSize = expectedTokenSequences[i].length;
	  }
	  for (int j = 0; j < expectedTokenSequences[i].length; j++) {
		expected += tokenImage[expectedTokenSequences[i][j]] + " ";
	  }
	  if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
		expected += "...";
	  }
	  expected += eol + "    ";
	}

	String retval = "Unexpected \"";
	Token tok = currentToken.next;
	for (int i = 0; i < maxSize; i++) {
	  if (i != 0) retval += " ";
	  if (tok.kind == 0) {
		retval += tokenImage[0];
		break;
	  }
	  retval += add_escapes(tok.image);
	  tok = tok.next;
	}
	retval += "\" at column " + currentToken.next.beginColumn + ".";
	return retval;
  }

  /**
   * The end of line string for this machine.
   */
  protected String eol = System.getProperty("line.separator", "\n");
 
  /**
   * Used to convert raw characters to their escaped version
   * when these raw version cannot be used as part of an ASCII
   * string literal.
   */
  protected String add_escapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = "0000" + Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }

}
/* Generated By:JJTree: Do not edit this line. .\ParserTreeConstants.java */

package org.nfunk.jep;

public interface ParserTreeConstants
{
  public int JJTSTART = 0;
  public int JJTVOID = 1;
  public int JJTFUNNODE = 2;
  public int JJTVARNODE = 3;
  public int JJTCONSTANT = 4;


  public String[] jjtNodeName = {
    "Start",
    "void",
    "FunNode",
    "VarNode",
    "Constant",
  };
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep;
import java.util.Hashtable;
import org.nfunk.jep.function.PostfixMathCommandI;

/*
 * A Hashtable which holds a list of functions.
 */
public class FunctionTable extends Hashtable
{
	private static final long serialVersionUID = -1192898221311853572L;

	public FunctionTable()
	{
		
	}
	
	/** adds the PostfixMathCommandI for the function with name s. 
	 * RJM addition Oct 03
	 */
	public Object put(String s,PostfixMathCommandI pfmc)
	{
		return super.put(s,pfmc);
	}
	
	/** overrides the standard hashtable method.
	 * If the arguments are of the wrong type then throws
	 * ClassCastException
	 * RJM addition Oct 03
	 * TODO is Hashtable always index by Strings?
	 */
	public Object put(Object o,Object p) 
	{
		return put((String) o,(PostfixMathCommandI) p); 
	}
	
	/** returns the PostfixMathCommandI for function with name s. 
	 * RJM addition Oct 03
	 */
	public PostfixMathCommandI get(String s)
	{
		return (PostfixMathCommandI) super.get(s);
	}
	
	/** overrides the standard hashtable method.
	 * If the argument is of the wrong type (i.e. not a String) 
	 * then throws ClassCastException
	 * RJM addition Oct 03
	 */
	
	public Object get(Object o)
	{
		return get((String) o);
	}
}
/* @author rich
 * Created on 03-Aug-2003
 */
package org.nfunk.jep;

import org.nfunk.jep.function.*;
import org.nfunk.jep.Operator;

/**
 * The standard set of operators used in JEP.
 * <p>
 * This creates instances of the PostfixMathCommands for each operator,
 * saving the need for multiple objects to be created. To get a reference to a particular operator use
 * <pre>
 * OperatorSet opSet = jep.getOperatorSet();
 * Operator myOp = opSet.getAdd();
 * </pre> 
 * <p>
 * If a new operator ABC is added to the parser the this class
 * should be extended to include a method Operator getABC().
 * <p>
 * Sub classes can change which Operator is returned by each method.
 * @author Rich Morris
 * Created on 19-Oct-2003
 */
public class OperatorSet {
		
	/** everyone can read but not write these operators **/
	protected Operator OP_GT     =  new Operator(">",new Comparative(Comparative.GT));
	protected Operator OP_LT     =  new Operator("<",new Comparative(Comparative.LT));
	protected Operator OP_EQ     =  new Operator("==",new Comparative(Comparative.EQ));
	protected Operator OP_LE     =  new Operator("<=",new Comparative(Comparative.LE));
	protected Operator OP_GE     =  new Operator(">=",new Comparative(Comparative.GE));
	protected Operator OP_NE     =  new Operator("!=",new Comparative(Comparative.NE));

	protected Operator OP_AND    =  new Operator("&&",new Logical(0));
	protected Operator OP_OR     =  new Operator("||",new Logical(1));
	protected Operator OP_NOT    = new Operator("!",new Not());

	protected Operator OP_ADD   =  new Operator("+",new Add());
	protected Operator OP_SUBTRACT  =  new Operator("-",new Subtract());
	protected Operator OP_UMINUS =  new Operator("UMinus","-",new UMinus());

	protected Operator OP_MULTIPLY    =  new Operator("*",new Multiply());
	protected Operator OP_DIVIDE = new Operator("/",new Divide());
	protected Operator OP_MOD    = new Operator("%",new Modulus());
	/** unary division i.e. 1/x or x^(-1) **/ 
	protected Operator OP_UDIVIDE =  new Operator("UDivide","^-1",null);

	protected Operator OP_POWER  = new Operator("^",new Power());

	protected Operator OP_ASSIGN = new Operator("=",new Assign()); 
	protected Operator OP_DOT = new Operator(".",new Dot()); 
	protected Operator OP_CROSS = new Operator("^^",new Cross()); 
	protected Operator OP_LIST = new Operator("LIST",new List()); 
	protected Operator OP_ELEMENT = new Operator("[]",new Ele());
//	protected Operator OP_RANGE = new Operator(":",new Range());
	public OperatorSet()
	{
	}
	
	/** Gets the list of operators. Note subclasses should override this method. */	
	public Operator[] getOperators() {
		Operator ops[] = new Operator[]{
		OP_GT,OP_LT,OP_GE,OP_LE,OP_EQ,OP_NE,OP_AND,OP_OR,OP_NOT,
		OP_ADD,OP_SUBTRACT,OP_UMINUS,OP_MULTIPLY,
		OP_DIVIDE,OP_MOD,OP_POWER,
		OP_ASSIGN,OP_DOT,OP_CROSS,OP_LIST,OP_ELEMENT /*,OP_RANGE */};
		return ops;
	}

	public void printOperators()
	{
		Operator ops[] = getOperators();
		for(int i=0;i<ops.length;++i)
			System.out.println(ops[i].toString());
	}

	public Operator getAdd() {return OP_ADD;	}
	public Operator getSubtract() {return OP_SUBTRACT;	}
	public Operator getUMinus() {return OP_UMINUS;	}
	public Operator getMultiply() {return OP_MULTIPLY;	}
	public Operator getDivide() {return OP_DIVIDE;	}
	public Operator getMod() {return OP_MOD;	}
	public Operator getPower() {return OP_POWER;	}

	public Operator getEQ() {return OP_EQ;	}
	public Operator getNE() {return OP_NE;	}
	public Operator getGE() {return OP_GE;	}
	public Operator getGT() {return OP_GT;	}
	public Operator getLE() {return OP_LE;	}
	public Operator getLT() {return OP_LT;	}

	public Operator getAnd() {	return OP_AND;	}
	public Operator getOr() {return OP_OR;	}
	public Operator getNot() {return OP_NOT;	}
	public Operator getAssign() {return OP_ASSIGN;	}
	public Operator getDot() {return OP_DOT;	}
	public Operator getCross() {return OP_CROSS;	}
	public Operator getList() {return OP_LIST;	}
	public Operator getElement() {return OP_ELEMENT;	}
	//public Operator getRange() {return OP_RANGE;	}

}
/* Generated By:JJTree&JavaCC: Do not edit this line. ParserTokenManager.java */
package org.nfunk.jep;
import java.util.Vector;
import org.nfunk.jep.function.*;
import org.nfunk.jep.type.*;

public class ParserTokenManager implements ParserConstants
{
  public  java.io.PrintStream debugStream = System.out;
  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
private final int jjStopStringLiteralDfa_1(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x100000000L) != 0L)
            return 1;
         if ((active0 & 0x200000000L) != 0L)
            return 13;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_1(int pos, long active0)
{
   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
}
private final int jjStopAtPos(int pos, int kind)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   return pos + 1;
}
private final int jjStartNfaWithStates_1(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_1(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_1()
{
   switch(curChar)
   {
      case 33:
         jjmatchedKind = 35;
         return jjMoveStringLiteralDfa1_1(0x4000000L);
      case 37:
         return jjStopAtPos(0, 34);
      case 38:
         return jjMoveStringLiteralDfa1_1(0x8000000L);
      case 40:
         return jjStopAtPos(0, 40);
      case 41:
         return jjStopAtPos(0, 41);
      case 42:
         return jjStopAtPos(0, 31);
      case 43:
         return jjStopAtPos(0, 29);
      case 44:
         return jjStopAtPos(0, 20);
      case 45:
         return jjStopAtPos(0, 30);
      case 46:
         return jjStartNfaWithStates_1(0, 32, 1);
      case 47:
         return jjStartNfaWithStates_1(0, 33, 13);
      case 58:
         return jjStopAtPos(0, 42);
      case 59:
         return jjStopAtPos(0, 19);
      case 60:
         jjmatchedKind = 22;
         return jjMoveStringLiteralDfa1_1(0x1000000L);
      case 61:
         jjmatchedKind = 18;
         return jjMoveStringLiteralDfa1_1(0x800000L);
      case 62:
         jjmatchedKind = 21;
         return jjMoveStringLiteralDfa1_1(0x2000000L);
      case 91:
         return jjStopAtPos(0, 38);
      case 93:
         return jjStopAtPos(0, 39);
      case 94:
         jjmatchedKind = 36;
         return jjMoveStringLiteralDfa1_1(0x2000000000L);
      case 124:
         return jjMoveStringLiteralDfa1_1(0x10000000L);
      default :
         return jjMoveNfa_1(0, 0);
   }
}
private final int jjMoveStringLiteralDfa1_1(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_1(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 38:
         if ((active0 & 0x8000000L) != 0L)
            return jjStopAtPos(1, 27);
         break;
      case 61:
         if ((active0 & 0x800000L) != 0L)
            return jjStopAtPos(1, 23);
         else if ((active0 & 0x1000000L) != 0L)
            return jjStopAtPos(1, 24);
         else if ((active0 & 0x2000000L) != 0L)
            return jjStopAtPos(1, 25);
         else if ((active0 & 0x4000000L) != 0L)
            return jjStopAtPos(1, 26);
         break;
      case 94:
         if ((active0 & 0x2000000000L) != 0L)
            return jjStopAtPos(1, 37);
         break;
      case 124:
         if ((active0 & 0x10000000L) != 0L)
            return jjStopAtPos(1, 28);
         break;
      default :
         break;
   }
   return jjStartNfa_1(0, active0);
}
private final void jjCheckNAdd(int state)
{
   if (jjrounds[state] != jjround)
   {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
   }
}
private final void jjAddStates(int start, int end)
{
   do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
   } while (start++ != end);
}
private final void jjCheckNAddTwoStates(int state1, int state2)
{
   jjCheckNAdd(state1);
   jjCheckNAdd(state2);
}
private final void jjCheckNAddStates(int start, int end)
{
   do {
      jjCheckNAdd(jjnextStates[start]);
   } while (start++ != end);
}
private final void jjCheckNAddStates(int start)
{
   jjCheckNAdd(jjnextStates[start]);
   jjCheckNAdd(jjnextStates[start + 1]);
}
static final long[] jjbitVec0 = {
   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec2 = {
   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec3 = {
   0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L
};
static final long[] jjbitVec4 = {
   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL
};
static final long[] jjbitVec5 = {
   0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec6 = {
   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L
};
static final long[] jjbitVec7 = {
   0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L
};
static final long[] jjbitVec8 = {
   0x3fffffffffffL, 0x0L, 0x0L, 0x0L
};
private final int jjMoveNfa_1(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 36;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 13:
                  if (curChar == 42)
                     jjCheckNAddTwoStates(19, 20);
                  else if (curChar == 47)
                     jjCheckNAddStates(0, 2);
                  break;
               case 0:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 7)
                        kind = 7;
                     jjCheckNAddStates(3, 7);
                  }
                  else if (curChar == 47)
                     jjAddStates(8, 9);
                  else if (curChar == 36)
                  {
                     if (kind > 12)
                        kind = 12;
                     jjCheckNAdd(11);
                  }
                  else if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  else if (curChar == 46)
                     jjCheckNAdd(1);
                  break;
               case 1:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAddTwoStates(1, 2);
                  break;
               case 3:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(4);
                  break;
               case 4:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAdd(4);
                  break;
               case 5:
                  if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  break;
               case 6:
                  if ((0xfffffffbffffdbffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 8:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 9:
                  if (curChar == 34 && kind > 11)
                     kind = 11;
                  break;
               case 10:
                  if (curChar != 36)
                     break;
                  if (kind > 12)
                     kind = 12;
                  jjCheckNAdd(11);
                  break;
               case 11:
                  if ((0x3ff401000000000L & l) == 0L)
                     break;
                  if (kind > 12)
                     kind = 12;
                  jjCheckNAdd(11);
                  break;
               case 12:
                  if (curChar == 47)
                     jjAddStates(8, 9);
                  break;
               case 14:
                  if ((0xffffffffffffdbffL & l) != 0L)
                     jjCheckNAddStates(0, 2);
                  break;
               case 15:
                  if ((0x2400L & l) != 0L && kind > 5)
                     kind = 5;
                  break;
               case 16:
                  if (curChar == 10 && kind > 5)
                     kind = 5;
                  break;
               case 17:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 16;
                  break;
               case 18:
                  if (curChar == 42)
                     jjCheckNAddTwoStates(19, 20);
                  break;
               case 19:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(19, 20);
                  break;
               case 20:
                  if (curChar == 42)
                     jjAddStates(13, 14);
                  break;
               case 21:
                  if ((0xffff7fffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(22, 20);
                  break;
               case 22:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(22, 20);
                  break;
               case 23:
                  if (curChar == 47 && kind > 6)
                     kind = 6;
                  break;
               case 24:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjCheckNAddStates(3, 7);
                  break;
               case 25:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjCheckNAdd(25);
                  break;
               case 26:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(26, 27);
                  break;
               case 27:
                  if (curChar != 46)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAddTwoStates(28, 29);
                  break;
               case 28:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAddTwoStates(28, 29);
                  break;
               case 30:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(31);
                  break;
               case 31:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAdd(31);
                  break;
               case 32:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(32, 33);
                  break;
               case 34:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(35);
                  break;
               case 35:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAdd(35);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
               case 11:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 12)
                     kind = 12;
                  jjCheckNAdd(11);
                  break;
               case 2:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(15, 16);
                  break;
               case 6:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 7:
                  if (curChar == 92)
                     jjstateSet[jjnewStateCnt++] = 8;
                  break;
               case 8:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 14:
                  jjAddStates(0, 2);
                  break;
               case 19:
                  jjCheckNAddTwoStates(19, 20);
                  break;
               case 21:
               case 22:
                  jjCheckNAddTwoStates(22, 20);
                  break;
               case 29:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(17, 18);
                  break;
               case 33:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(19, 20);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
               case 11:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 12)
                     kind = 12;
                  jjCheckNAdd(11);
                  break;
               case 6:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(10, 12);
                  break;
               case 14:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(0, 2);
                  break;
               case 19:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(19, 20);
                  break;
               case 21:
               case 22:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(22, 20);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_0(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x100000000L) != 0L)
            return 1;
         if ((active0 & 0x200000000L) != 0L)
            return 13;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_0(int pos, long active0)
{
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
}
private final int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_0()
{
   switch(curChar)
   {
      case 33:
         jjmatchedKind = 35;
         return jjMoveStringLiteralDfa1_0(0x4000000L);
      case 37:
         return jjStopAtPos(0, 34);
      case 38:
         return jjMoveStringLiteralDfa1_0(0x8000000L);
      case 40:
         return jjStopAtPos(0, 40);
      case 41:
         return jjStopAtPos(0, 41);
      case 42:
         return jjStopAtPos(0, 31);
      case 43:
         return jjStopAtPos(0, 29);
      case 44:
         return jjStopAtPos(0, 20);
      case 45:
         return jjStopAtPos(0, 30);
      case 46:
         return jjStartNfaWithStates_0(0, 32, 1);
      case 47:
         return jjStartNfaWithStates_0(0, 33, 13);
      case 58:
         return jjStopAtPos(0, 42);
      case 59:
         return jjStopAtPos(0, 19);
      case 60:
         jjmatchedKind = 22;
         return jjMoveStringLiteralDfa1_0(0x1000000L);
      case 61:
         jjmatchedKind = 18;
         return jjMoveStringLiteralDfa1_0(0x800000L);
      case 62:
         jjmatchedKind = 21;
         return jjMoveStringLiteralDfa1_0(0x2000000L);
      case 91:
         return jjStopAtPos(0, 38);
      case 93:
         return jjStopAtPos(0, 39);
      case 94:
         jjmatchedKind = 36;
         return jjMoveStringLiteralDfa1_0(0x2000000000L);
      case 124:
         return jjMoveStringLiteralDfa1_0(0x10000000L);
      default :
         return jjMoveNfa_0(0, 0);
   }
}
private final int jjMoveStringLiteralDfa1_0(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 38:
         if ((active0 & 0x8000000L) != 0L)
            return jjStopAtPos(1, 27);
         break;
      case 61:
         if ((active0 & 0x800000L) != 0L)
            return jjStopAtPos(1, 23);
         else if ((active0 & 0x1000000L) != 0L)
            return jjStopAtPos(1, 24);
         else if ((active0 & 0x2000000L) != 0L)
            return jjStopAtPos(1, 25);
         else if ((active0 & 0x4000000L) != 0L)
            return jjStopAtPos(1, 26);
         break;
      case 94:
         if ((active0 & 0x2000000000L) != 0L)
            return jjStopAtPos(1, 37);
         break;
      case 124:
         if ((active0 & 0x10000000L) != 0L)
            return jjStopAtPos(1, 28);
         break;
      default :
         break;
   }
   return jjStartNfa_0(0, active0);
}
private final int jjMoveNfa_0(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 36;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 13:
                  if (curChar == 42)
                     jjCheckNAddTwoStates(19, 20);
                  else if (curChar == 47)
                     jjCheckNAddStates(0, 2);
                  break;
               case 0:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 7)
                        kind = 7;
                     jjCheckNAddStates(3, 7);
                  }
                  else if (curChar == 47)
                     jjAddStates(8, 9);
                  else if (curChar == 36)
                  {
                     if (kind > 15)
                        kind = 15;
                     jjCheckNAdd(11);
                  }
                  else if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  else if (curChar == 46)
                     jjCheckNAdd(1);
                  break;
               case 1:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAddTwoStates(1, 2);
                  break;
               case 3:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(4);
                  break;
               case 4:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAdd(4);
                  break;
               case 5:
                  if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  break;
               case 6:
                  if ((0xfffffffbffffdbffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 8:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 9:
                  if (curChar == 34 && kind > 11)
                     kind = 11;
                  break;
               case 10:
                  if (curChar != 36)
                     break;
                  if (kind > 15)
                     kind = 15;
                  jjCheckNAdd(11);
                  break;
               case 11:
                  if ((0x3ff001000000000L & l) == 0L)
                     break;
                  if (kind > 15)
                     kind = 15;
                  jjCheckNAdd(11);
                  break;
               case 12:
                  if (curChar == 47)
                     jjAddStates(8, 9);
                  break;
               case 14:
                  if ((0xffffffffffffdbffL & l) != 0L)
                     jjCheckNAddStates(0, 2);
                  break;
               case 15:
                  if ((0x2400L & l) != 0L && kind > 5)
                     kind = 5;
                  break;
               case 16:
                  if (curChar == 10 && kind > 5)
                     kind = 5;
                  break;
               case 17:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 16;
                  break;
               case 18:
                  if (curChar == 42)
                     jjCheckNAddTwoStates(19, 20);
                  break;
               case 19:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(19, 20);
                  break;
               case 20:
                  if (curChar == 42)
                     jjAddStates(13, 14);
                  break;
               case 21:
                  if ((0xffff7fffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(22, 20);
                  break;
               case 22:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(22, 20);
                  break;
               case 23:
                  if (curChar == 47 && kind > 6)
                     kind = 6;
                  break;
               case 24:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjCheckNAddStates(3, 7);
                  break;
               case 25:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjCheckNAdd(25);
                  break;
               case 26:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(26, 27);
                  break;
               case 27:
                  if (curChar != 46)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAddTwoStates(28, 29);
                  break;
               case 28:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAddTwoStates(28, 29);
                  break;
               case 30:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(31);
                  break;
               case 31:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAdd(31);
                  break;
               case 32:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(32, 33);
                  break;
               case 34:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(35);
                  break;
               case 35:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAdd(35);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
               case 11:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 15)
                     kind = 15;
                  jjCheckNAdd(11);
                  break;
               case 2:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(15, 16);
                  break;
               case 6:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 7:
                  if (curChar == 92)
                     jjstateSet[jjnewStateCnt++] = 8;
                  break;
               case 8:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 14:
                  jjAddStates(0, 2);
                  break;
               case 19:
                  jjCheckNAddTwoStates(19, 20);
                  break;
               case 21:
               case 22:
                  jjCheckNAddTwoStates(22, 20);
                  break;
               case 29:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(17, 18);
                  break;
               case 33:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(19, 20);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
               case 11:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 15)
                     kind = 15;
                  jjCheckNAdd(11);
                  break;
               case 6:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(10, 12);
                  break;
               case 14:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(0, 2);
                  break;
               case 19:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(19, 20);
                  break;
               case 21:
               case 22:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(22, 20);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
static final int[] jjnextStates = {
   14, 15, 17, 25, 26, 27, 32, 33, 13, 18, 6, 7, 9, 21, 23, 3, 
   4, 30, 31, 34, 35, 
};
private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec2[i2] & l2) != 0L);
      default : 
         if ((jjbitVec0[i1] & l1) != 0L)
            return true;
         return false;
   }
}
private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec4[i2] & l2) != 0L);
      case 48:
         return ((jjbitVec5[i2] & l2) != 0L);
      case 49:
         return ((jjbitVec6[i2] & l2) != 0L);
      case 51:
         return ((jjbitVec7[i2] & l2) != 0L);
      case 61:
         return ((jjbitVec8[i2] & l2) != 0L);
      default : 
         if ((jjbitVec3[i1] & l1) != 0L)
            return true;
         return false;
   }
}
public static final String[] jjstrLiteralImages = {
"", null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, "\75", "\73", "\54", "\76", "\74", "\75\75", "\74\75", 
"\76\75", "\41\75", "\46\46", "\174\174", "\53", "\55", "\52", "\56", "\57", "\45", 
"\41", "\136", "\136\136", "\133", "\135", "\50", "\51", "\72", };
public static final String[] lexStateNames = {
   "NO_DOT_IN_IDENTIFIERS", 
   "DEFAULT", 
};
public static final int[] jjnewLexState = {
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
};
static final long[] jjtoToken = {
   0x7fffffc9a81L, 
};
static final long[] jjtoSkip = {
   0x7eL, 
};
protected JavaCharStream input_stream;
private final int[] jjrounds = new int[36];
private final int[] jjstateSet = new int[72];
protected char curChar;
public ParserTokenManager(JavaCharStream stream){
   if (JavaCharStream.staticFlag)
      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
   input_stream = stream;
}
public ParserTokenManager(JavaCharStream stream, int lexState){
   this(stream);
   SwitchTo(lexState);
}
public void ReInit(JavaCharStream stream)
{
   jjmatchedPos = jjnewStateCnt = 0;
   curLexState = defaultLexState;
   input_stream = stream;
   ReInitRounds();
}
private final void ReInitRounds()
{
   int i;
   jjround = 0x80000001;
   for (i = 36; i-- > 0;)
      jjrounds[i] = 0x80000000;
}
public void ReInit(JavaCharStream stream, int lexState)
{
   ReInit(stream);
   SwitchTo(lexState);
}
public void SwitchTo(int lexState)
{
   if (lexState >= 2 || lexState < 0)
      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}

protected Token jjFillToken()
{
   Token t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   String im = jjstrLiteralImages[jjmatchedKind];
   t.image = (im == null) ? input_stream.GetImage() : im;
   t.beginLine = input_stream.getBeginLine();
   t.beginColumn = input_stream.getBeginColumn();
   t.endLine = input_stream.getEndLine();
   t.endColumn = input_stream.getEndColumn();
   return t;
}

int curLexState = 1;
int defaultLexState = 1;
int jjnewStateCnt;
int jjround;
int jjmatchedPos;
int jjmatchedKind;

public Token getNextToken() 
{
  int kind;
  Token specialToken = null;
  Token matchedToken;
  int curPos = 0;

  EOFLoop :
  for (;;)
  {   
   try   
   {     
      curChar = input_stream.BeginToken();
   }     
   catch(java.io.IOException e)
   {        
      jjmatchedKind = 0;
      matchedToken = jjFillToken();
      return matchedToken;
   }

   switch(curLexState)
   {
     case 0:
       try { input_stream.backup(0);
          while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)
             curChar = input_stream.BeginToken();
       }
       catch (java.io.IOException e1) { continue EOFLoop; }
       jjmatchedKind = 0x7fffffff;
       jjmatchedPos = 0;
       curPos = jjMoveStringLiteralDfa0_0();
       break;
     case 1:
       try { input_stream.backup(0);
          while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)
             curChar = input_stream.BeginToken();
       }
       catch (java.io.IOException e1) { continue EOFLoop; }
       jjmatchedKind = 0x7fffffff;
       jjmatchedPos = 0;
       curPos = jjMoveStringLiteralDfa0_1();
       break;
   }
     if (jjmatchedKind != 0x7fffffff)
     {
        if (jjmatchedPos + 1 < curPos)
           input_stream.backup(curPos - jjmatchedPos - 1);
        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
        {
           matchedToken = jjFillToken();
       if (jjnewLexState[jjmatchedKind] != -1)
         curLexState = jjnewLexState[jjmatchedKind];
           return matchedToken;
        }
        else
        {
         if (jjnewLexState[jjmatchedKind] != -1)
           curLexState = jjnewLexState[jjmatchedKind];
           continue EOFLoop;
        }
     }
     int error_line = input_stream.getEndLine();
     int error_column = input_stream.getEndColumn();
     String error_after = null;
     boolean EOFSeen = false;
     try { input_stream.readChar(); input_stream.backup(1); }
     catch (java.io.IOException e1) {
        EOFSeen = true;
        error_after = curPos <= 1 ? "" : input_stream.GetImage();
        if (curChar == '\n' || curChar == '\r') {
           error_line++;
           error_column = 0;
        }
        else
           error_column++;
     }
     if (!EOFSeen) {
        input_stream.backup(1);
        error_after = curPos <= 1 ? "" : input_stream.GetImage();
     }
     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
  }
}

}
/**
 *
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.
 *
 */

/* This is an example of how the Visitor pattern might be used to
   implement the dumping code that comes with SimpleNode.  It's a bit
   long-winded, but it does illustrate a couple of the main points.

   1) the visitor can maintain state between the nodes that it visits
   (for example the current indentation level).

   2) if you don't implement a jjtAccept() method for a subclass of
   SimpleNode, then SimpleNode's acceptor will get called.

   3) the utility method childrenAccept() can be useful when
   implementing preorder or postorder tree walks.

   Err, that's it. */
   
package org.nfunk.jep;

public class ParserDumpVisitor implements ParserVisitor
{
  private int indent = 0;

  private String indentString() {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < indent; ++i) {
      sb.append("  ");
    }
    return sb.toString();
  }

  public Object visit(SimpleNode node, Object data) throws ParseException {
    System.out.println(indentString() + node +
		       ": acceptor not unimplemented in subclass?");
    ++indent;
    data = node.childrenAccept(this, data);
    --indent;
    return data;
  }

  public Object visit(ASTStart node, Object data) throws ParseException {
    System.out.println(indentString() + node);
    ++indent;
    data = node.childrenAccept(this, data);
    --indent;
    return data;
  }

  public Object visit(ASTFunNode node, Object data) throws ParseException {
    System.out.println(indentString() + node);
    ++indent;
    data = node.childrenAccept(this, data);
    --indent;
    return data;
  }

  public Object visit(ASTVarNode node, Object data) throws ParseException {
    System.out.println(indentString() + node);
    ++indent;
    data = node.childrenAccept(this, data);
    --indent;
    return data;
  }

  public Object visit(ASTConstant node, Object data) throws ParseException {
    System.out.println(indentString() + node);
    ++indent;
    data = node.childrenAccept(this, data);
    --indent;
    return data;
  }
}

/*end*/
/* @author rich
 * Created on 03-Aug-2003
 */
package org.nfunk.jep;

import org.nfunk.jep.function.PostfixMathCommandI;

/**
 * A class containing information about an operator.
 *
 * @see OperatorSet 
 * @author Rich Morris
 * Created on 19-Oct-2003
 */
public class Operator {

	/** A unique name defining the operator. */
	private String name;
	/** The symbol for the operator, used for printing. */
	private String symbol;
	/** Postfix mathcommand */
	private PostfixMathCommandI pfmc;
	
	/** private default constructor, prevents calling with no arguments. */
	private Operator()
	{
	}

	/** construct a new operator.
	 * 
	 * @param name	printable name of operator
	 * @param pfmc  postfix math command for opperator
	 */
	public Operator(String name,PostfixMathCommandI pfmc)
	{
		this();
		this.name = name; this.pfmc = pfmc;
		this.symbol = name;
	}
	/** construct a new operator, with a different name and symbol
	 * 
	 * @param name	name of operator, must be unique, used when describing operator
	 * @param symbol printable name of operator, used for printing equations
	 * @param pfmc  postfix math command for opperator
	 */
	public Operator(String name,String symbol,PostfixMathCommandI pfmc)
	{
		this();
		this.name = name; this.pfmc = pfmc;
		this.symbol = symbol;
	}
	/** returns the symbol used by this operator. */
	public final String getSymbol() {return symbol;}
	/** returns a unique name definig this operator. */
	public final String getName() {return name;}
	public final PostfixMathCommandI getPFMC() { return pfmc;}
	public final void setPFMC(PostfixMathCommandI pfmc) { this.pfmc = pfmc;}
	/** returns a verbose representation of the operator. **/
	public String toString() { return "Operator: \""+name+"\""; }
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
/* Generated By:JJTree: Do not edit this line. ASTStart.java */
package org.nfunk.jep;

/**
 * Start Node
 */
public class ASTStart extends SimpleNode {
  public ASTStart(int id) {
    super(id);
  }

  public ASTStart(Parser p, int id) {
    super(p, id);
  }

  /** Accept the visitor. **/
  public Object jjtAccept(ParserVisitor visitor, Object data) throws ParseException
  {
    return visitor.visit(this, data);
  }
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
/* Generated By:JJTree: Do not edit this line. ASTVarNode.java */

package org.nfunk.jep;

/**
 * Variable Node
 */
public class ASTVarNode extends SimpleNode {
	
	//private String varName;
	private Variable var;
	
	public ASTVarNode(int id) {
		super(id);
		var = null;
	}
	
	public ASTVarNode(Parser p, int id) {
		super(p, id);
	}
	
	/**
	 * Accept the visitor.
	 */
	public Object jjtAccept(ParserVisitor visitor, Object data) throws ParseException
	{
		return visitor.visit(this, data);
	}

	/**
	 * Sets the name of the variable.
	 */
	//public void setName(String varName_in)
	//{
	//	var = varName_in;
	//}
	public void setVar(Variable variable) {	var = variable;	}
	public Variable getVar() { return var; }
	
	/**
	 * Returns the name of the variable.
	 */
	public String getName()
	{
		return var.getName();
	}

	/**
	* Creates a string containing the variable's name and value
	*/
	public String toString()
	{
		String temp = "Variable: \"" + getName() + "\"";
		
		return temp;
	}
}
/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
package org.nfunk.jep;

/**
 * Describes the input token stream.
 */

public class Token {

  /**
   * An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.
   */
  public int kind;

  /**
   * beginLine and beginColumn describe the position of the first character
   * of this token; endLine and endColumn describe the position of the
   * last character of this token.
   */
  public int beginLine, beginColumn, endLine, endColumn;

  /**
   * The string image of the token.
   */
  public String image;

  /**
   * A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.
   */
  public Token next;

  /**
   * This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.
   */
  public Token specialToken;

  /**
   * Returns the image.
   */
  public String toString()
  {
     return image;
  }

  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simlpy add something like :
   *
   *    case MyParserConstants.ID : return new IDToken();
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use it in your lexical actions.
   */
  public static final Token newToken(int ofKind)
  {
     switch(ofKind)
     {
       default : return new Token();
     }
  }

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package org.nfunk.jep;

/*
 * The parent class for all AST node classes. Contains basic tree node methods
 * for traversal, adding and removing children and parent nodes, and other
 * methods.
 */
public class SimpleNode implements Node {
	protected Node parent;
	protected Node[] children;
	protected int id;
	protected Parser parser;
	
	public SimpleNode(int i) {
		id = i;
	}
	
	public SimpleNode(Parser p, int i) {
		this(i);
		parser = p;
	}
	
	public void jjtOpen() {
	}
	
	public void jjtClose() {
	}
	
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }
	
	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
	}
	
	public Node jjtGetChild(int i) {
		return children[i];
	}
	
	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}
	
	/** Accept the visitor. **/
	public Object jjtAccept(ParserVisitor visitor, Object data)  throws ParseException
	{
		return visitor.visit(this, data);
	}
	
	/** Accept the visitor. **/
	public Object childrenAccept(ParserVisitor visitor, Object data)  throws ParseException
	{
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				children[i].jjtAccept(visitor, data);
			}
		}
		return data;
	}
	
	/* You can override these two methods in subclasses of SimpleNode to
	customize the way the node appears when the tree is dumped.  If
	your output uses more than one line you should override
	toString(String), otherwise overriding toString() is probably all
	you need to do. */
	
	public String toString() { return ParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }
	
	/* Override this method if you want to customize how the node dumps
	out its children. */
	
	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if (children != null)
		{
			for (int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode)children[i];
				if (n != null) {
					n.dump(prefix + " ");
				}
			}
		}
	}
	
	/**
	 * Returns the id of the node (for simpler identification).
	 */
	public int getId() {
		return id;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
/* Generated By:JJTree: Do not edit this line. JJTParserState.java */

package org.nfunk.jep;

class JJTParserState {
  private java.util.Stack nodes;
  private java.util.Stack marks;

  private int sp;		// number of nodes on stack
  private int mk;		// current mark
  private boolean node_created;

  JJTParserState() {
    nodes = new java.util.Stack();
    marks = new java.util.Stack();
    sp = 0;
    mk = 0;
  }

  /* Determines whether the current node was actually closed and
     pushed.  This should only be called in the final user action of a
     node scope.  */
  boolean nodeCreated() {
    return node_created;
  }

  /* Call this to reinitialize the node stack.  It is called
     automatically by the parser's ReInit() method. */
  void reset() {
    nodes.removeAllElements();
    marks.removeAllElements();
    sp = 0;
    mk = 0;
  }

  /* Returns the root node of the AST.  It only makes sense to call
     this after a successful parse. */
  Node rootNode() {
    return (Node)nodes.elementAt(0);
  }

  /* Pushes a node on to the stack. */
  void pushNode(Node n) {
    nodes.push(n);
    ++sp;
  }

  /* Returns the node on the top of the stack, and remove it from the
     stack.  */
  Node popNode() {
    if (--sp < mk) {
      mk = ((Integer)marks.pop()).intValue();
    }
    return (Node)nodes.pop();
  }

  /* Returns the node currently on the top of the stack. */
  Node peekNode() {
    return (Node)nodes.peek();
  }

  /* Returns the number of children on the stack in the current node
     scope. */
  int nodeArity() {
    return sp - mk;
  }


  void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = ((Integer)marks.pop()).intValue();
  }


  void openNodeScope(Node n) {
    marks.push(new Integer(mk));
    mk = sp;
    n.jjtOpen();
  }


  /* A definite node is constructed from a specified number of
     children.  That number of nodes are popped from the stack and
     made the children of the definite node.  Then the definite node
     is pushed on to the stack. */
  void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.pop()).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }


  /* A conditional node is constructed if its condition is true.  All
     the nodes that have been pushed since the node was opened are
     made children of the the conditional node, which is then pushed
     on to the stack.  If the condition is false the node is not
     constructed and they are left on the stack. */
  void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.pop()).intValue();
      while (a-- > 0) {
	Node c = popNode();
	c.jjtSetParent(n);
	n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.pop()).intValue();
      node_created = false;
    }
  }
}
/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
package org.nfunk.jep;

public class TokenMgrError extends Error
{
   /*
    * Ordinals for various reasons why an Error of this type can be thrown.
    */

   /**
    * Lexical error occured.
    */
   static final int LEXICAL_ERROR = 0;

   /**
    * An attempt wass made to create a second instance of a static token manager.
    */
   static final int STATIC_LEXER_ERROR = 1;

   /**
    * Tried to change to an invalid lexical state.
    */
   static final int INVALID_LEXICAL_STATE = 2;

   /**
    * Detected (and bailed out of) an infinite loop in the token manager.
    */
   static final int LOOP_DETECTED = 3;

   /**
    * Indicates the reason why the exception is thrown. It will have
    * one of the above 4 values.
    */
   int errorCode;

   /**
    * Replaces unprintable characters by their espaced (or unicode escaped)
    * equivalents in the given string
    */
   protected static final String addEscapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = "0000" + Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }

   /**
    * Returns a detailed message for the Error when it is thrown by the
    * token manager to indicate a lexical error.
    * Parameters : 
    *    EOFSeen     : indicates if EOF caused the lexicl error
    *    curLexState : lexical state in which this error occured
    *    errorLine   : line number when the error occured
    *    errorColumn : column number when the error occured
    *    errorAfter  : prefix that was seen before this error occured
    *    curchar     : the offending character
    * Note: You can customize the lexical error message by modifying this method.
    */
   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
      return("Lexical error at line " +
           errorLine + ", column " +
           errorColumn + ".  Encountered: " +
           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
           "after : \"" + addEscapes(errorAfter) + "\"");
   }

   /**
    * You can also modify the body of this method to customize your error messages.
    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
    * of end-users concern, so you can return something like : 
    *
    *     "Internal Error : Please file a bug report .... "
    *
    * from this method for such cases in the release version of your parser.
    */
   public String getMessage() {
      return super.getMessage();
   }

   /*
    * Constructors of various flavors follow.
    */

   public TokenMgrError() {
   }

   public TokenMgrError(String message, int reason) {
      super(message);
      errorCode = reason;
   }

   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
   }
}
/* @author rich
 * Created on 22-Apr-2005
 *
 * See LICENSE.txt for license information.
 */
package org.nfunk.jep;

/**
 * @author Rich Morris
 * Created on 22-Apr-2005
 */
public interface EvaluatorI {
	
	/**
	 * Evaluates a node and returns and object with the value of the node.
	 * 
	 * @throws ParseException if errors occur during evaluation;
	 */
	public abstract Object eval(Node node) throws ParseException;
}
/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package org.nfunk.jep;

import java.util.Vector;
import org.nfunk.jep.function.*;
import org.nfunk.jep.type.*;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();private JEP     jep;
        private SymbolTable symTab;
        private OperatorSet opSet;
        private int initialTokenManagerState = DEFAULT;

        public Node parseStream(java.io.Reader stream, JEP jep_in)
                                                        throws ParseException {
                restart(stream,jep_in);
                // Parse the expression, and return the 
                enable_tracing();
                try
                {
                        Node node = Start();
                        if (node == null) throw new ParseException("No expression entered");
                        return node.jjtGetChild(0);
                }
                catch(TokenMgrError e) {
                        throw new ParseException(e.getMessage());
                }
        }

        /** 
	 * Restart the parse with the given stream.
	 * @since 2.3.0 beta 1
	 */
        public void restart(java.io.Reader stream, JEP jep_in)
        {
                ReInit(stream);
                this.token_source.SwitchTo(initialTokenManagerState);
                jep = jep_in;
                symTab = jep.getSymbolTable();
                opSet = jep.getOperatorSet();
        }
        /**
	 * Continue parsing without re-initilising stream.
	 * Allows reentrance of parser so that strings like
	 * "x=1; y=2; z=3;" can be parsed.
	 * When a semi colon is encountered parsing finishes leaving the rest of the string unparsed.
	 * Parsing can be resumed from the current position by using this method.
	 * For example
	 * <pre>
	 * XJep j = new XJep();
	 * Parser parse = j.getParse();
	 * StringReader sr = new StringReader("x=1; y=2; z=3;");
	 * parse.restart(sr,j);
	 * Node node;
	 * try {
	 * while((node = j.continueParse())!=null) {
	 *    j.println(node);
	 * } }catch(ParseException e) {}
	 * </pre>
	 */
        public Node continueParse() throws ParseException
        {
                try
                {
                        Node node = Start();
                        if (node == null) return null;
                        return node.jjtGetChild(0);
                }
                catch(TokenMgrError e) {
                        throw new ParseException(e.getMessage());
                }
        }

        private void addToErrorList(String errorStr) {
                jep.errorList.addElement(errorStr);
        }

        /**
	 * Sets the initial state that the token manager is in.
	 * Can be used to change how x.x is interpreted, either as a single
	 * identifier (DEFAULT) or as x <DOT> x (NO_DOT_IN_IDENTIFIERS)
	 * @param state the state to be in. Currently the only legal values are DEFAULT and NO_DOT_IN_IDENTIFIER
	 */
        public void setInitialTokenManagerState(int state)
        {
                initialTokenManagerState = state;
        }
        /**
	 * Translate all escape sequences to characters. Inspired by Rob Millar's
	 * unescape() method in rcm.util.Str fron the Web Sphinx project.
	 *
	 * @param inputStr String containing escape characters.
	 * @return String with all escape sequences replaced.
	 */
        private String replaceEscape(String inputStr) {
                int len = inputStr.length();
                int p = 0;
                int i;
                String metachars = "tnrbf\\\"'";
                String chars = "\t\n\r\b\f\\\"'";

                StringBuffer output = new StringBuffer();

                while ((i = inputStr.indexOf('\\', p)) != -1) {
                        output.append(inputStr.substring(p, i));

                        if (i+1 == len) break;

                        // find metacharacter
            char metac = inputStr.charAt(i+1);

            // find the index of the metac
            int k = metachars.indexOf(metac);
            if (k == -1) {
                // didn't find the metachar, leave sequence as found.
                // This code should be unreachable if the parser
                // is functioning properly because strings containing
                // unknown escape characters should not be accepted.
                output.append('\\');
                output.append(metac);
            } else {
                // its corresponding true char
                output.append(chars.charAt(k));
            }

                        // skip over both escape character & metacharacter
            p = i + 2;
                }

                // add the end of the input string to the output
        if (p < len)
            output.append(inputStr.substring(p));

        return output.toString();
        }

/***************************************************************
GRAMMAR START
***************************************************************/
  final public ASTStart Start() throws ParseException {
 /*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_1(1)) {
        Expression();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 0:
          jj_consume_token(0);
          break;
        case SEMI:
          jj_consume_token(SEMI);
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                          {if (true) return jjtn000;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 0:
        case SEMI:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 0:
            jj_consume_token(0);
            break;
          case SEMI:
            jj_consume_token(SEMI);
            break;
          default:
            jj_la1[1] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                // njf - The next line is commented out in 2.3.0 since
                //       two "No expression entered" errors are reported
                //       in EvaluatorVisitor and Console (one from here
                //       the other from ParseStream() )
                //       Decided to just return null, and handle the error
                //       in ParseStream.
                // addToErrorList("No expression entered");
                {if (true) return null;}
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

// Expresions can be like
// x=3
// x=y=3 parsed as x=(y=3)
  final public void Expression() throws ParseException {
    if (jj_2_2(2147483647)) {
      AssignExpression();
    } else if (jj_2_3(1)) {
      RightExpression();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void AssignExpression() throws ParseException {
          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
    try {
      LValue();
      jj_consume_token(ASSIGN);
      Expression();
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
                        if (!jep.getAllowAssignment()) {if (true) throw new ParseException(
                "Syntax Error (assignment not enabled)");}

                        jjtn001.setOperator(opSet.getAssign());
    } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
    }
  }

  final public void RightExpression() throws ParseException {
    OrExpression();
  }

  final public void OrExpression() throws ParseException {
    AndExpression();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
            ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
      try {
        jj_consume_token(OR);
        AndExpression();
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
                        jjtn001.setOperator(opSet.getOr());
      } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              {if (true) throw (RuntimeException)jjte001;}
            }
            if (jjte001 instanceof ParseException) {
              {if (true) throw (ParseException)jjte001;}
            }
            {if (true) throw (Error)jjte001;}
      } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
      }
    }
  }

  final public void AndExpression() throws ParseException {
    EqualExpression();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
            ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
      try {
        jj_consume_token(AND);
        EqualExpression();
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
                        jjtn001.setOperator(opSet.getAnd());
      } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              {if (true) throw (RuntimeException)jjte001;}
            }
            if (jjte001 instanceof ParseException) {
              {if (true) throw (ParseException)jjte001;}
            }
            {if (true) throw (Error)jjte001;}
      } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
      }
    }
  }

  final public void EqualExpression() throws ParseException {
    RelationalExpression();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NE:
            ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
        try {
          jj_consume_token(NE);
          RelationalExpression();
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            jjtn001.setOperator(opSet.getNE());
        } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              {if (true) throw (RuntimeException)jjte001;}
            }
            if (jjte001 instanceof ParseException) {
              {if (true) throw (ParseException)jjte001;}
            }
            {if (true) throw (Error)jjte001;}
        } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
        }
        break;
      case EQ:
            ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
        try {
          jj_consume_token(EQ);
          RelationalExpression();
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
              jjtn002.setOperator(opSet.getEQ());
        } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              {if (true) throw (RuntimeException)jjte002;}
            }
            if (jjte002 instanceof ParseException) {
              {if (true) throw (ParseException)jjte002;}
            }
            {if (true) throw (Error)jjte002;}
        } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
            }
        }
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void RelationalExpression() throws ParseException {
    AdditiveExpression();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case LT:
      case LE:
      case GE:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
        try {
          jj_consume_token(LT);
          AdditiveExpression();
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
            jjtn001.setOperator(opSet.getLT());
        } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
        } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
        }
        break;
      case GT:
      ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
        try {
          jj_consume_token(GT);
          AdditiveExpression();
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
        jjtn002.setOperator(opSet.getGT());
        } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte002;}
      }
      if (jjte002 instanceof ParseException) {
        {if (true) throw (ParseException)jjte002;}
      }
      {if (true) throw (Error)jjte002;}
        } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  2);
      }
        }
        break;
      case LE:
      ASTFunNode jjtn003 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
        try {
          jj_consume_token(LE);
          AdditiveExpression();
        jjtree.closeNodeScope(jjtn003,  2);
        jjtc003 = false;
            jjtn003.setOperator(opSet.getLE());
        } catch (Throwable jjte003) {
      if (jjtc003) {
        jjtree.clearNodeScope(jjtn003);
        jjtc003 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte003 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte003;}
      }
      if (jjte003 instanceof ParseException) {
        {if (true) throw (ParseException)jjte003;}
      }
      {if (true) throw (Error)jjte003;}
        } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003,  2);
      }
        }
        break;
      case GE:
      ASTFunNode jjtn004 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
        try {
          jj_consume_token(GE);
          AdditiveExpression();
        jjtree.closeNodeScope(jjtn004,  2);
        jjtc004 = false;
        jjtn004.setOperator(opSet.getGE());
        } catch (Throwable jjte004) {
      if (jjtc004) {
        jjtree.clearNodeScope(jjtn004);
        jjtc004 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte004 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte004;}
      }
      if (jjte004 instanceof ParseException) {
        {if (true) throw (ParseException)jjte004;}
      }
      {if (true) throw (Error)jjte004;}
        } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004,  2);
      }
        }
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void AdditiveExpression() throws ParseException {
    MultiplicativeExpression();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
        try {
          jj_consume_token(PLUS);
          MultiplicativeExpression();
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
        jjtn001.setOperator(opSet.getAdd());
        } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
        } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
        }
        break;
      case MINUS:
      ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
        try {
          jj_consume_token(MINUS);
          MultiplicativeExpression();
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
        jjtn002.setOperator(opSet.getSubtract());
        } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte002;}
      }
      if (jjte002 instanceof ParseException) {
        {if (true) throw (ParseException)jjte002;}
      }
      {if (true) throw (Error)jjte002;}
        } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  2);
      }
        }
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void MultiplicativeExpression() throws ParseException {
    UnaryExpression();
    label_6:
    while (true) {
      if (jj_2_4(1)) {
        ;
      } else {
        break label_6;
      }
      if (jj_2_5(1)) {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
        try {
          PowerExpression();
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
        if (!jep.implicitMul) {if (true) throw new ParseException(
                "Syntax Error (implicit multiplication not enabled)");}

        jjtn001.setOperator(opSet.getMultiply());
        } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
        } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MUL:
      ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
          try {
            jj_consume_token(MUL);
            UnaryExpression();
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
        jjtn002.setOperator(opSet.getMultiply());
          } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte002;}
      }
      if (jjte002 instanceof ParseException) {
        {if (true) throw (ParseException)jjte002;}
      }
      {if (true) throw (Error)jjte002;}
          } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  2);
      }
          }
          break;
        case DOT:
      ASTFunNode jjtn003 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
          try {
            jj_consume_token(DOT);
            UnaryExpression();
        jjtree.closeNodeScope(jjtn003,  2);
        jjtc003 = false;
        jjtn003.setOperator(opSet.getDot());
          } catch (Throwable jjte003) {
      if (jjtc003) {
        jjtree.clearNodeScope(jjtn003);
        jjtc003 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte003 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte003;}
      }
      if (jjte003 instanceof ParseException) {
        {if (true) throw (ParseException)jjte003;}
      }
      {if (true) throw (Error)jjte003;}
          } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003,  2);
      }
          }
          break;
        case CROSS:
      ASTFunNode jjtn004 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
          try {
            jj_consume_token(CROSS);
            UnaryExpression();
        jjtree.closeNodeScope(jjtn004,  2);
        jjtc004 = false;
        jjtn004.setOperator(opSet.getCross());
          } catch (Throwable jjte004) {
      if (jjtc004) {
        jjtree.clearNodeScope(jjtn004);
        jjtc004 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte004 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte004;}
      }
      if (jjte004 instanceof ParseException) {
        {if (true) throw (ParseException)jjte004;}
      }
      {if (true) throw (Error)jjte004;}
          } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004,  2);
      }
          }
          break;
        case DIV:
      ASTFunNode jjtn005 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc005 = true;
      jjtree.openNodeScope(jjtn005);
          try {
            jj_consume_token(DIV);
            UnaryExpression();
        jjtree.closeNodeScope(jjtn005,  2);
        jjtc005 = false;
        jjtn005.setOperator(opSet.getDivide());
          } catch (Throwable jjte005) {
      if (jjtc005) {
        jjtree.clearNodeScope(jjtn005);
        jjtc005 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte005 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte005;}
      }
      if (jjte005 instanceof ParseException) {
        {if (true) throw (ParseException)jjte005;}
      }
      {if (true) throw (Error)jjte005;}
          } finally {
      if (jjtc005) {
        jjtree.closeNodeScope(jjtn005,  2);
      }
          }
          break;
        case MOD:
      ASTFunNode jjtn006 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc006 = true;
      jjtree.openNodeScope(jjtn006);
          try {
            jj_consume_token(MOD);
            UnaryExpression();
        jjtree.closeNodeScope(jjtn006,  2);
        jjtc006 = false;
        jjtn006.setOperator(opSet.getMod());
          } catch (Throwable jjte006) {
      if (jjtc006) {
        jjtree.clearNodeScope(jjtn006);
        jjtc006 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte006 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte006;}
      }
      if (jjte006 instanceof ParseException) {
        {if (true) throw (ParseException)jjte006;}
      }
      {if (true) throw (Error)jjte006;}
          } finally {
      if (jjtc006) {
        jjtree.closeNodeScope(jjtn006,  2);
      }
          }
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void UnaryExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
      UnaryExpression();
      break;
    case MINUS:
    ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
      try {
        jj_consume_token(MINUS);
        UnaryExpression();
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
          jjtn001.setOperator(opSet.getUMinus());
      } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  1);
    }
      }
      break;
    case NOT:
    ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
      try {
        jj_consume_token(NOT);
        UnaryExpression();
      jjtree.closeNodeScope(jjtn002,  1);
      jjtc002 = false;
          jjtn002.setOperator(opSet.getNot());
      } catch (Throwable jjte002) {
    if (jjtc002) {
      jjtree.clearNodeScope(jjtn002);
      jjtc002 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte002 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte002;}
    }
    if (jjte002 instanceof ParseException) {
      {if (true) throw (ParseException)jjte002;}
    }
    {if (true) throw (Error)jjte002;}
      } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002,  1);
    }
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      if (jj_2_6(1)) {
        PowerExpression();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void PowerExpression() throws ParseException {
    UnaryExpressionNotPlusMinus();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POWER:
    ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
      try {
        jj_consume_token(POWER);
        UnaryExpression();
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtn001.setOperator(opSet.getPower());
      } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
    }
      }
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
  }

  final public void UnaryExpressionNotPlusMinus() throws ParseException {
        String identString = "";
        int type;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
      AnyConstant();
      break;
    default:
      jj_la1[14] = jj_gen;
      if (jj_2_7(2147483647)) {
        ArrayAccess();
      } else if ((getToken(1).kind == INDENTIFIER1 || getToken(1).kind == INDENTIFIER2) &&
                                        jep.funTab.containsKey(getToken(1).image)) {
        Function();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INDENTIFIER1:
        case INDENTIFIER2:
          Variable();
          break;
        case LRND:
          jj_consume_token(LRND);
          Expression();
          jj_consume_token(RRND);
          break;
        case LSQ:
          ListExpression();
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void ListExpression() throws ParseException {
 /*@bgen(jjtree) FunNode */
        ASTFunNode jjtn000 = new ASTFunNode(JJTFUNNODE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);jjtn000.setOperator(opSet.getList());
    try {
      jj_consume_token(LSQ);
      Expression();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        Expression();
      }
      jj_consume_token(RSQ);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/*
void RangeExpression()  #FunNode:
{
	jjtThis.setOperator(opSet.getRange());
}
{
	<LSQ> Expression() ( <COLON> Expression() )+ <RSQ>
}
*/
  final public void LValue() throws ParseException {
    if (jj_2_8(2147483647)) {
      ArrayAccess();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDENTIFIER1:
      case INDENTIFIER2:
        Variable();
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void ArrayAccess() throws ParseException {
    Variable();
    ListExpression();
          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
    try {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtc001 = false;
     jjtn001.setOperator(opSet.getElement());
    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
    }
  }

  final public void Variable() throws ParseException {
        String identString = "";
          ASTVarNode jjtn001 = new ASTVarNode(JJTVARNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
    try {
      identString = Identifier();
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
                if (symTab.containsKey(identString)) {
                        jjtn001.setVar(symTab.getVar(identString));
                } else {
                        if (jep.allowUndeclared) {
                                jjtn001.setVar(symTab.makeVarIfNeeded(identString));
                        } else {
                                addToErrorList("Unrecognized symbol \"" + identString +"\"");
                        }
                }
    } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
    }
  }

  final public void Function() throws ParseException {
        int reqArguments = 0;
        String identString = "";
          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
    try {
      identString = Identifier();
                        if (jep.funTab.containsKey(identString)) {
                                //Set number of required arguments
                                reqArguments =
                                        ((PostfixMathCommandI)jep.funTab.get(identString)).getNumberOfParameters();
                                jjtn001.setFunction(identString,
                                        (PostfixMathCommandI)jep.funTab.get(identString));
                        } else {
                                addToErrorList("!!! Unrecognized function \"" + identString +"\"");
                        }
      jj_consume_token(LRND);
      ArgumentList(reqArguments, identString);
      jj_consume_token(RRND);
    } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
    }
  }

  final public void ArgumentList(int reqArguments, String functionName) throws ParseException {
        int count = 0;
        String errorStr = "";
    if (jj_2_9(1)) {
      Expression();
                       count++;
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_8;
        }
        jj_consume_token(COMMA);
        Expression();
                               count++;
      }
    } else {
      ;
    }
        if(reqArguments == -1) {
                if(!((PostfixMathCommandI)jep.funTab.get(functionName)).checkNumberOfParameters(count))
                {
                                errorStr = "Function \"" + functionName +"\" illegal number of arguments " + count;
                                addToErrorList(errorStr);
                        }
        }
        else if (reqArguments != count) {
                        errorStr = "Function \"" + functionName +"\" requires "
                                   + reqArguments + " parameter";
                        if (reqArguments!=1) errorStr += "s";
                        addToErrorList(errorStr);
                }
  }

  final public String Identifier() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INDENTIFIER1:
      t = jj_consume_token(INDENTIFIER1);
      break;
    case INDENTIFIER2:
      t = jj_consume_token(INDENTIFIER2);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                       {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public void AnyConstant() throws ParseException {
 /*@bgen(jjtree) Constant */
        ASTConstant jjtn000 = new ASTConstant(JJTCONSTANT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        Object value;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        t = jj_consume_token(STRING_LITERAL);
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                // strip away double quotes at end of string
                String temp = (t.image).substring(1,t.image.length()-1);

                // replace escape characters
                temp = replaceEscape(temp);

                jjtn000.setValue(temp);
        break;
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
        value = RealConstant();
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                jjtn000.setValue(value);
//	}
//	|
//	value = Array() {
//		jjtThis.setValue(value);

        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/*
Vector Array() :
{
	Object value;
	Vector result = new Vector();
}
{
	<LSQ>
	value = RealConstant()
	{
		result.addElement(value);
	}
	(
		<COMMA>
		value = RealConstant()
		{
			result.addElement(value);
		}
	)* 
	<RSQ>
	{
		return result;
	}
}
*/
  final public Object RealConstant() throws ParseException {
  Token t;
  Object value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
      break;
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                try {
                        value = jep.getNumberFactory().createNumber(t.image);
                } catch (Exception e) {
                        value = null;
                        addToErrorList("Can't parse \"" + t.image + "\"");
                }

                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) return true;
    }
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(GT)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3_6()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_3R_24()) return true;
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_9()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) return true;
    }
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_3R_42()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_52()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    }
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_9()) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_scan_token(MOD)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(EQ)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_scan_token(DIV)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(NE)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    return false;
  }

  final private boolean jj_3R_14() {
    if (jj_scan_token(CROSS)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_51()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_9()) return true;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_scan_token(LSQ)) return true;
    if (jj_3R_9()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_35()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RSQ)) return true;
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_12() {
    if (jj_scan_token(MUL)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_9()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_64()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_63() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_9()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(9)) return true;
    }
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_scan_token(LRND)) return true;
    if (jj_3R_9()) return true;
    if (jj_scan_token(RRND)) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_3R_36()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_47()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_3R_46()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = (getToken(1).kind == INDENTIFIER1 || getToken(1).kind == INDENTIFIER2) &&
                                  jep.funTab.containsKey(getToken(1).image);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_3R_27()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_45()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_44()) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_3R_34()) return true;
    if (jj_scan_token(LRND)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(RRND)) return true;
    return false;
  }

  final private boolean jj_3R_11() {
    if (jj_3R_22()) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_44()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) return true;
    }
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_3R_44()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_55()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_scan_token(POWER)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_3R_23()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_62()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_10()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_3R_10()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_9()) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(GE)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_11()) return true;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3_3()) return true;
    }
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(LE)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  public ParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[22];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x80001,0x80001,0x80001,0x10000000,0x8000000,0x4800000,0x4800000,0x3600000,0x3600000,0x60000000,0x60000000,0x80000000,0x60000000,0x0,0xa80,0x9000,0x100000,0x9000,0x100000,0x9000,0xa80,0x280,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x27,0x8,0x10,0x0,0x140,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[9];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[43];
    for (int i = 0; i < 43; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 22; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 43; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 9; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep;

import java.util.*;

import org.nfunk.jep.function.*;

/**
 * This class is used for the evaluation of an expression. It uses the Visitor
 * design pattern to traverse the function tree and evaluate the expression
 * using a stack.
 * <p>
 * Function nodes are evaluated by first evaluating all the children nodes,
 * then applying the function class associated with the node. Variable and
 * constant nodes are evaluated by pushing their value onto the stack.

 * <p>
 * Some changes implemented by rjm. Nov 03.
 * Added hook to SpecialEvaluationI.
 * Clears stack before evaluation.
 * Simplifies error handling by making visit methods throw ParseException.
 * Changed visit(ASTVarNode node) so messages not calculated every time. 
 */
public class EvaluatorVisitor implements ParserVisitor, EvaluatorI {
	/** Stack used for evaluating the expression */
	protected Stack stack;

	/** The current error list */
	//protected Vector errorList;

	/** The symbol table for variable lookup */
	protected SymbolTable symTab;

	/** Flag for errors during evaluation */
	//protected boolean errorFlag;

	/** Debug flag */
	protected static final boolean debug = false;

	/** TrapNull **/
	protected boolean trapNullValues = true;
	
	/** Constructor. Initialise the stack member */
	private EvaluatorVisitor() {
		//errorList = null;
		symTab = null;
		stack = new Stack();
	}

	public EvaluatorVisitor(SymbolTable st) {
		//errorList = null;
		symTab = st;
		stack = new Stack();
	}

	/**
	 * Adds an error message to the list of errors
	 */
	/*protected void addToErrorList(String errorStr) {
		if (errorList != null) {
			errorList.addElement(errorStr);
		}
	}*/

	/**
	 * Returns the value of the expression as an object. The expression
	 * tree is specified with its top node. The algorithm uses a stack
	 * for evaluation.
	 * <p>
	 * The <code>errorList_in</code> parameter is used to
	 * add error information that may occur during the evaluation. It is not
	 * required, and may be set to <code>null</code> if no error information is
	 * needed.
	 * <p>
	 * The symTab parameter can be null, if no variables are expected in the
	 * expression. If a variable is found, an error is added to the error list.
	 * <p>
	 * An exception is thrown, if an error occurs during evaluation.
	 * @return The value of the expression as an object.
	 * @throws ParseException if there is a problem with the evaluation.
	 */
	public Object getValue(Node topNode,SymbolTable symTab_in)
		throws ParseException {

		// check if arguments are ok
		if (topNode == null) {
			throw new ParseException("topNode parameter is null");
		}

		// set member vars
		//errorList = errorList_in;
		symTab = symTab_in;
		//errorFlag = false;
		stack.removeAllElements();
		// rjm addition ensure stack is correct before beginning.
		// njf changed from clear() to removeAllElements for 1.1 compatibility

		// evaluate by letting the top node accept the visitor
		topNode.jjtAccept(this,null);
		/*
		} catch (ParseException e) {
			this.addToErrorList("Error: "+e.getMessage());
			return null;
		}
		if(errorFlag) return null;
		*/
		
		// something is wrong if not exactly one item remains on the stack
		// or if the error flag has been set
		if (stack.size() != 1) {
			throw new ParseException("Stack corrupted");
		}

		// return the value of the expression
		return stack.pop();
	}

	/*
	 * The following methods was used to facilitate 
	 * using visitors which implemented a interface
	 * which sub-classed ParserVisitor.
	 *  
	 * If sub-classed to extend to implement a different visitor
	 * this method should be overwritten to ensure the correct 
	 * accept method is called.
	 * This method simply calls the jjtAccept(ParserVisitor this,Object data) of node.
	 *
	 * We no longer need this as we use ParseVisitor everywhere,
	 * but kept for future reference.
	 * 
	private Object nodeAccept(Node node, Object data) throws ParseException
	{
		return node.jjtAccept(this,data);
	}
	*/

	/**
	 * Evaluates a given node, in the current context.
	 * @param node The node to evaluate
	 * @return result of the evaluation
	 */
	public Object eval(Node node) throws ParseException {
		node.jjtAccept(this,null);
		return stack.pop();
	}
	
	/**
	 * This method should never be called when evaluation a normal
	 * expression.
	 */
	public Object visit(SimpleNode node, Object data) throws ParseException {
		throw new ParseException(
			"No visit method for " + node.getClass().getName());
	}

	/**
	 * This method should never be called when evaluating a normal
	 * expression.
	 */
	public Object visit(ASTStart node, Object data) throws ParseException {
		throw new ParseException("Start node encountered during evaluation");
	}

	/**
	 * Visit a function node. The values of the child nodes
	 * are first pushed onto the stack. Then the function class associated
	 * with the node is used to evaluate the function.
	 * <p>
	 * If a function implements SpecialEvaluationI then the
	 * evaluate method of PFMC is called.
	 */
	public Object visit(ASTFunNode node, Object data) throws ParseException {

		if (node == null)
			return null;
		PostfixMathCommandI pfmc = node.getPFMC();

		// check if the function class is set
		if (pfmc == null)
			throw new ParseException(
				"No function class associated with " + node.getName());

		// Some operators (=) need a special method for evaluation
		// as the pfmc.run method does not have enough information
		// in such cases we call the evaluate method which passes
		// all available info. Note evaluating the children is
		// the responsibility of the evaluate method. 
		if (pfmc instanceof SpecialEvaluationI) {
			return ((SpecialEvaluationI) pfmc).evaluate(
				node,data,this,stack,this.symTab);
		}
		if(pfmc instanceof CallbackEvaluationI) {
			Object val = ((CallbackEvaluationI) pfmc).evaluate(node,this);
			stack.push(val);
			return val;
		}
		if (debug == true) {
			System.out.println(
				"Stack size before childrenAccept: " + stack.size());
		}

		// evaluate all children (each leaves their result on the stack)

		data = node.childrenAccept(this, data);

		if (debug == true) {
			System.out.println(
				"Stack size after childrenAccept: " + stack.size());
		}

		if (pfmc.getNumberOfParameters() == -1) {
			// need to tell the class how many parameters it can take off
			// the stack because it accepts a variable number of params
			pfmc.setCurNumberOfParameters(node.jjtGetNumChildren());
		}

		// try to run the function

		pfmc.run(stack);

		if (debug == true) {
			System.out.println("Stack size after run: " + stack.size());
		}

		return data;
	}

	/**
	 * Visit a variable node. The value of the variable is obtained from the
	 * symbol table (symTab) and pushed onto the stack.
	 */
	public Object visit(ASTVarNode node, Object data) throws ParseException {

		// old code
		//		if (symTab == null)
		//			throw new ParseException(message += "the symbol table is null");

		// Optimise (table lookup is costly?)
		//		Object temp = symTab.get(node.getName());

		// new code

		Variable var = node.getVar();
		if (var == null) {
			String message = "Could not evaluate " + node.getName() + ": ";
			throw new ParseException(message + " variable not set");
		}

		Object temp = var.getValue();

		if (trapNullValues && temp == null) {
			String message = "Could not evaluate " + node.getName() + ": ";
			throw new ParseException(message + "the variable was not found in the symbol table");
		}
		// all is fine
		// push the value on the stack
		stack.push(temp);
		return data;
	}

	/**
	 * Visit a constant node. The value of the constant is pushed onto the
	 * stack.
	 */
	public Object visit(ASTConstant node, Object data) {
		stack.push(node.getValue());
		return data;
	}
	
	
	/**
	 * Tests whether null variable values are trapped by evaluator. 
	 * @return true is nulls are trapped
	 */
	public boolean isTrapNullValues()
	{
		return trapNullValues;
	}

	/**
	 * Sets the behaviour when a variable's value is null.
	 * If true an exception will be thrown is a variable value is null.
	 * If false then the value will be passed to other functions, this may cause error
	 * else where.
	 * 
	 * @param b 
	 */
	public void setTrapNullValues(boolean b)
	{
		trapNullValues = b;
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
/* @author rich
 * Created on 18-Nov-2003
 */
package org.nfunk.jep;
import java.util.*;

/**
 * Information about a variable. 
 * Each variable has a name, a value.
 * There is a flag to indicate
 * whether it is a constant or not (constants cannot have their value changed).
 * There is also a flag to indicate whether the value of the
 * variable is valid, if the variable is initialised without a value
 * then its value is said to be invalid.
 * <p>
 * @author Rich Morris
 * Created on 18-Nov-2003
 * @version 2.3.0 beta 2 Now extends Observable so observers can track if the value has been changed.
 */
public class Variable extends Observable {
	protected String name;
	private Object value;
	private boolean isConstant = false;
	private boolean validValue = false;
//	private static final Double ZERO = new Double(0.0);

	/** Constructors are protected. Variables should only
	 * be created through the associated {@link VariableFactory}
	 * which are in turned called by {@link SymbolTable}.
	 */
	protected Variable(String name)
	{
		this.name = name;
		this.value = null;
		validValue = false;
	}
	/** Constructors are protected. Variables should only
	 * be created through the associated {@link VariableFactory}
	 * which are in turned called by {@link SymbolTable}.
	 */
	protected Variable(String name,Object value)
	{
		this.name = name;
		this.value = value;
		validValue = (value!=null);
	}
	public String getName() {return name;}
	//private void setName(String string) {name = string;	}
	public boolean isConstant() { return this.isConstant; }
	public void setIsConstant(boolean b) { this.isConstant = b; }
	public Object getValue() { return value; }
	/** Is the value of this variable valid? **/
	public boolean hasValidValue() { return validValue; }
	/** Sets whether the value of variable is valid. **/
	public void setValidValue(boolean val) {
		if(isConstant()) return; validValue = val; }

	/**
	 * Sets the value of the variable. Constant values cannot be changed.
	 * <p>
	 * This method call java.util.Observable.notifyObservers()
	 * to indicate to anyone interested that the value has been changed.
	 * Note subclasses should override setValueRaw rather than this
	 * method so they do not need to handle the Observable methods.
	 *  
	 * @return false if tried to change a constant value.
	 * @since 2.3.0 beta 2 added Observable
	 */
	public boolean setValue(Object object) {
		if(!setValueRaw(object)) return false;
		setChanged();
		notifyObservers(object);
		return true;
	}

	/**
	 * In general subclasses should override this method rather than
	 * setValue. This is because setValue notifies any observers
	 * and then calls this method.
	 * @param object
	 * @return false if tried to change a constant value.
	 * @since 2.3.0 beta 2
	 */
	protected boolean setValueRaw(Object object) {
		if(isConstant) return false;
		validValue = true;
		value = object;
		return true;
	}

	/**
	 * Returns a string with the variable name followed by it's value.
	 * For example for the variable "a" with the value 10, the following
	 * string is returned:
	 * <pre>a: 10</pre>
	 * If the variable is a constant the string " (Constant" is appended.
	 * @return A string with the variable name and value.
	 */
	public String toString() {
		if(!validValue || value == null)
			return name + ": null";
		else if(isConstant)
			return name + ": " + value.toString() + " (Constant)";
		else
			return name + ": " + value.toString(); 
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
/* Generated By:JJTree: Do not edit this line. ASTInteger.java */
package org.nfunk.jep;

/**
 * Constant Node
 */
public class ASTConstant extends SimpleNode {
	private Object value;
	
	public ASTConstant(int id) {
		super(id);
	}
	
	public ASTConstant(Parser p, int id) {
		super(p, id);
	}
	
	public void setValue(Object val) {
		value = val;
	}
	
	public Object getValue() {
		return value;
	}

	/** Accept the visitor. **/
	public Object jjtAccept(ParserVisitor visitor, Object data)  throws ParseException
	{
		return visitor.visit(this, data);
	}
	
	public String toString() {
		return "Constant: " + getValue(); // rjm needed so sub classes print properly
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
/* @author rich
 * Created on 19-Dec-2003
 */
package org.nfunk.jep;
/**
 * A factory class which is used to create variables.
 * By default this class creates variables of type {@link Variable}.
 * This class should be subclassed if the type of variable used needs to be changed.
 * This class is passed to the constructor of {@link SymbolTable}
 * which ensures that variables of the correct type are always created.
 * <p>
 * This class should only be called from the SymbolTable class and not from application code.
 * @since 23 July 2006 - allows a defaultValue to be set.
 * @author Rich Morris
 * Created on 19-Dec-2003
 */
public class VariableFactory
{
	protected Object defaultValue=null;
	/** Create a variable with a name and value */
	public Variable createVariable(String name, Object value) {
		Variable var = new Variable(name,value);
		return var;
	}

	/** Create a variable with a name but not value */
	public Variable createVariable(String name)	{
		if(defaultValue!=null)
			return new Variable(name,defaultValue);
		else
			return new Variable(name);
	}

	/**
	 * @return Returns the defaultValue.
	 */
	public Object getDefaultValue() {
		return defaultValue;
	}

	/**
	 * Sets the default value used whenever a new variable is created.
	 * @param defaultValue The defaultValue to set.
	 */
	public void setDefaultValue(Object defaultValue) {
		this.defaultValue = defaultValue;
	}
	
	
}
/* Generated By:JJTree&JavaCC: Do not edit this line. ParserConstants.java */
package org.nfunk.jep;

public interface ParserConstants {

  int EOF = 0;
  int INTEGER_LITERAL = 7;
  int DECIMAL_LITERAL = 8;
  int FLOATING_POINT_LITERAL = 9;
  int EXPONENT = 10;
  int STRING_LITERAL = 11;
  int INDENTIFIER1 = 12;
  int LETTER1 = 13;
  int DIGIT1 = 14;
  int INDENTIFIER2 = 15;
  int LETTER2 = 16;
  int DIGIT2 = 17;
  int ASSIGN = 18;
  int SEMI = 19;
  int COMMA = 20;
  int GT = 21;
  int LT = 22;
  int EQ = 23;
  int LE = 24;
  int GE = 25;
  int NE = 26;
  int AND = 27;
  int OR = 28;
  int PLUS = 29;
  int MINUS = 30;
  int MUL = 31;
  int DOT = 32;
  int DIV = 33;
  int MOD = 34;
  int NOT = 35;
  int POWER = 36;
  int CROSS = 37;
  int LSQ = 38;
  int RSQ = 39;
  int LRND = 40;
  int RRND = 41;
  int COLON = 42;

  int NO_DOT_IN_IDENTIFIERS = 0;
  int DEFAULT = 1;

  String[] tokenImage = {
    "<EOF>",
    "\" \"",
    "\"\\t\"",
    "\"\\n\"",
    "\"\\r\"",
    "<token of kind 5>",
    "<token of kind 6>",
    "<INTEGER_LITERAL>",
    "<DECIMAL_LITERAL>",
    "<FLOATING_POINT_LITERAL>",
    "<EXPONENT>",
    "<STRING_LITERAL>",
    "<INDENTIFIER1>",
    "<LETTER1>",
    "<DIGIT1>",
    "<INDENTIFIER2>",
    "<LETTER2>",
    "<DIGIT2>",
    "\"=\"",
    "\";\"",
    "\",\"",
    "\">\"",
    "\"<\"",
    "\"==\"",
    "\"<=\"",
    "\">=\"",
    "\"!=\"",
    "\"&&\"",
    "\"||\"",
    "\"+\"",
    "\"-\"",
    "\"*\"",
    "\".\"",
    "\"/\"",
    "\"%\"",
    "\"!\"",
    "\"^\"",
    "\"^^\"",
    "\"[\"",
    "\"]\"",
    "\"(\"",
    "\")\"",
    "\":\"",
  };

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep;
import java.util.*;

/** A Hashtable which holds a list of all variables.
 * Heavily changed from Jep-2.24 which was just a Hashtable which stored
 * the values of each variable. Here the Hashtable contains
 * elements of type {@link Variable Variable} which contain
 * information about that variable.
 * Rather than using {@link #get get} the methods
 * {@link #getValue getValue(String)}, {@link #getVar getVar(String)}
 * should be used to return the value or variable.
 * The {@link #put put} method is deprecated and should be replace by one of
 * <ul>
 * <li>{@link #addVariable addVariable(String,Object)} adds a variable with a given name and value, returns null if variable already exists.
 * <li>{@link #addConstant addConstant(String,Object)} adds a 'constant' variable whos value cannot be changed.
 * <li>{@link #setVarValue setVarValue(String,Object)} sets the value of an existing variable. Returns false if variable does not exist.
 * <li>{@link #makeVarIfNeeded(String,Object)} if necessary creates a variable and set its value.
 * <li>{@link #makeVarIfNeeded(String)} if necessary creates a variable. Does not change the value.
 * </ul>
 * <p>
 * Variables which do not have a value set are deemed to be invalid.
 * When Variables need to be constructed then methods in the {@link VariableFactory}
 * should be called, which allows different types of variables to be used.
 * 
 * <p>
 * Both SymbolTable and Variable implement the Observer/Observable pattern.
 * This allows objects to be informed whenever a new variable is created
 * or when its value has been changed. The member class StObservable is used to implement
 * Observer. An example of use is
 * <pre>
 * public class MyObserver implements Observer
 * {
 * 	public void initialise()
 * 	{
 * 		SymbolTable st = j.getSymbolTable();
 * 		st.addObserver(this);
 * 		st.addObserverToExistingVariables(this);
 * 	}
 * 
 * 	public void update(Observable arg0, Object arg1)
 * 	{
 * 		if(arg0 instanceof Variable)
 * 			println("Var changed: "+arg0);
 * 		else if(arg0 instanceof SymbolTable.StObservable)
 * 		{
 * 			println("New var: "+arg1);
 * 
 * 			// This line is vital to ensure that 
 * 			// any new variable created will be observed. 
 * 			((Variable) arg1).addObserver(this);
 * 		}
 * 	}
 * }
 * </pre>

 *  
 * @author Rich Morris
 * Created on 28-Feb-2004
 */ 
public class SymbolTable extends Hashtable
{
	private static final long serialVersionUID = 1127787896437151144L;
	private VariableFactory vf;
	/** SymbolTable should always be constructed an associated variable factory. */
	public SymbolTable(VariableFactory varFac)
	{
		vf = varFac;
	}
	/** Private default constructors, SymbolTable should always be constructed with an explicit variable factory. */
	private SymbolTable() {}
	
	/**
	 * @deprecated The getValue or getVar methods should be used instead. 
	 */
	public Object get(Object key) { return getValue(key); }
	

	/** Finds the value of the variable with the given name. 
	 * Returns null if variable does not exist. */
	public Object getValue(Object key)
	{
		Variable var = (Variable) super.get(key);
		if(var==null) return null;
		return var.getValue();
	}
	
	/** Finds the variable with given name. 
	* Returns null if variable does not exist. */
	public Variable getVar(String name)
	{
		return (Variable) super.get(name);
	}

	/**
	 * @deprecated The setVarValue or makeVar methods should be used instead.
	 */
	public Object put(Object key,Object val)
	{
		return makeVarIfNeeded((String) key,val);
	}

	/**
	 * Sets the value of variable with the given name.
	 * @throws NullPointerException if the variable has not been previously created
	 * with {@link #addVariable(String,Object)} first.
	 */
	public void setVarValue(String name,Object val)
	{
		Variable var = (Variable) super.get(name);
		if(var != null) {
			var.setValue(val); 
			return; 
		}
		throw new NullPointerException("Variable "+name+" does not exist.");
	}

	/**
	 * Returns a new variable fro the variable factory. Notifies observers
	 * when a new variable is created. If a subclass need to create a new variable it should call this method.
	 * 
	 * @param name
	 * @param val
	 * @return an new Variable object.
	 */
	protected Variable createVariable(String name,Object val)
	{
		Variable var = vf.createVariable(name,val);
		obeservable.stSetChanged();
		obeservable.notifyObservers(var);
		return var;
	}

	protected Variable createVariable(String name)
	{
		Variable var = vf.createVariable(name);
		obeservable.stSetChanged();
		obeservable.notifyObservers(var);
		return var;
	}

	/** Creates a new variable with given value.
	 * 
	 * @param name name of variable
	 * @param val initial value of variable
	 * @return a reference to the created variable.
	 */
	public Variable addVariable(String name,Object val)
	{
		Variable var = (Variable) super.get(name);
		if(var != null)
		    throw new IllegalStateException("Variable "+name+" already exists.");
		
		var = createVariable(name,val);
		super.put(name,var);
		var.setValidValue(true);
		return var;
	}

	/** Create a constant variable with the given name and value.
	 * Returns null if variable already exists.
	 */
	public Variable addConstant(String name,Object val)
	{
		Variable var = addVariable(name,val);
		var.setIsConstant(true);
		return var;
	}

	/** Create a variable with the given name and value.
	 * It silently does nothing if the value cannot be set.
	 * @return the Variable.
	 */
	public Variable makeVarIfNeeded(String name,Object val)
	{
		Variable var = (Variable) super.get(name);
		if(var != null)
		{
		    if(var.isConstant())
		        throw new IllegalStateException("Attempt to change the value of constant variable "+name);
			var.setValue(val);
			return var; 
		}
		var = createVariable(name,val);
		super.put(name,var);
		return var;
	}

	/** If necessary create a variable with the given name.
	 * If the variable exists its value will not be changed.
	 * @return the Variable.
	 */
	public Variable makeVarIfNeeded(String name)
	{
		Variable var = (Variable) super.get(name);
		if(var != null)	return var; 

		var = createVariable(name);
		super.put(name,var);
		return var;
	}

	/**
	 * Returns a list of variables, one per line.
	 */
	public String toString()
	{
		StringBuffer sb = new StringBuffer();
		for(Enumeration e = this.elements(); e.hasMoreElements(); ) 
		{
			Variable var = (Variable) e.nextElement();
			sb.append(var.toString());
			sb.append("\n");
		}
		return sb.toString();
	}

	/**
	 * Clears the values of all variables.
	 * Finer control is available through the
	 * {@link Variable#setValidValue Variable.setValidValue} method.
	 */
	public void clearValues()
	{
		for(Enumeration e = this.elements(); e.hasMoreElements(); ) 
		{
			Variable var = (Variable) e.nextElement();
			var.setValidValue(false);
		}
	}
	/**
	 * Returns the variable factory of this instance.
	 */
	public VariableFactory getVariableFactory() {
		return vf;
	}

	public class StObservable extends Observable {
		protected synchronized void stSetChanged() {
			this.setChanged();
		}
		public SymbolTable getSymbolTable() {
			return SymbolTable.this;
		}
	}
	protected StObservable obeservable = new StObservable();
	/**
	 * Adds an observer which will be notified when a new variable is created.
	 * The observer's update method will be called whenever a new
	 * variable is created, the second argument of this will be
	 * a reference to the new variable.
	 * 
	 * <p>
	 * To find out if the values of variables are changed
	 * the Variable.addObserver method should be used.
	 * 
	 * @param arg the observer
	 * @see Variable#addObserver(Observer)
	 */	
	public synchronized void addObserver(Observer arg)	{
		obeservable.addObserver(arg);
	}

	public synchronized int countObservers() {
		return obeservable.countObservers();
	}

	public synchronized void deleteObserver(Observer arg)	{
		obeservable.deleteObserver(arg);
	}

	public synchronized void deleteObservers()	{
		obeservable.deleteObservers();
	}

	public synchronized boolean hasChanged()	{
		return obeservable.hasChanged();
	}

	/** Adds an observer to all variables currently in the SymbolTable.
	 * 
	 * @param arg the object to be notified when a variable changes.
	 */
	public synchronized void addObserverToExistingVariables(Observer arg)	{
		for(Enumeration en = this.elements();en.hasMoreElements();) {
			Variable var = (Variable) en.nextElement();
			var.addObserver(arg);
		}
	}
	/** Remove all non constant elements */
	public void clearNonConstants() {
		Vector tmp = new Vector();
		for(Enumeration en = this.elements();en.hasMoreElements();) {
			Variable var = (Variable) en.nextElement();
			if(var.isConstant()) tmp.add(var);
		}
		this.clear();
		for(Enumeration en = tmp.elements();en.hasMoreElements();) {
			Variable var = (Variable) en.nextElement();
			super.put(var.getName(),var);
		}
	}
}
/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.0 */
package org.nfunk.jep;

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (with java-like unicode escape processing).
 */

public class JavaCharStream
{
  public static final boolean staticFlag = false;
  static final int hexval(char c) throws java.io.IOException {
    switch(c)
    {
       case '0' :
          return 0;
       case '1' :
          return 1;
       case '2' :
          return 2;
       case '3' :
          return 3;
       case '4' :
          return 4;
       case '5' :
          return 5;
       case '6' :
          return 6;
       case '7' :
          return 7;
       case '8' :
          return 8;
       case '9' :
          return 9;

       case 'a' :
       case 'A' :
          return 10;
       case 'b' :
       case 'B' :
          return 11;
       case 'c' :
       case 'C' :
          return 12;
       case 'd' :
       case 'D' :
          return 13;
       case 'e' :
       case 'E' :
          return 14;
       case 'f' :
       case 'F' :
          return 15;
    }

    throw new java.io.IOException(); // Should never come here
  }

  public int bufpos = -1;
  int bufsize;
  int available;
  int tokenBegin;
  protected int bufline[];
  protected int bufcolumn[];

  protected int column = 0;
  protected int line = 1;

  protected boolean prevCharIsCR = false;
  protected boolean prevCharIsLF = false;

  protected java.io.Reader inputStream;

  protected char[] nextCharBuf;
  protected char[] buffer;
  protected int maxNextCharInd = 0;
  protected int nextCharInd = -1;
  protected int inBuf = 0;
  protected int tabSize = 8;

  protected void setTabSize(int i) { tabSize = i; }
  protected int getTabSize(int i) { return tabSize; }

  protected void ExpandBuff(boolean wrapAround)
  {
     char[] newbuffer = new char[bufsize + 2048];
     int newbufline[] = new int[bufsize + 2048];
     int newbufcolumn[] = new int[bufsize + 2048];

     try
     {
        if (wrapAround)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;

           bufpos += (bufsize - tokenBegin);
        }
        else
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           bufcolumn = newbufcolumn;

           bufpos -= tokenBegin;
        }
     }
     catch (Throwable t)
     {
        throw new Error(t.getMessage());
     }

     available = (bufsize += 2048);
     tokenBegin = 0;
  }

  protected void FillBuff() throws java.io.IOException
  {
     int i;
     if (maxNextCharInd == 4096)
        maxNextCharInd = nextCharInd = 0;

     try {
        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
                                            4096 - maxNextCharInd)) == -1)
        {
           inputStream.close();
           throw new java.io.IOException();
        }
        else
           maxNextCharInd += i;
        return;
     }
     catch(java.io.IOException e) {
        if (bufpos != 0)
        {
           --bufpos;
           backup(0);
        }
        else
        {
           bufline[bufpos] = line;
           bufcolumn[bufpos] = column;
        }
        throw e;
     }
  }

  protected char ReadByte() throws java.io.IOException
  {
     if (++nextCharInd >= maxNextCharInd)
        FillBuff();

     return nextCharBuf[nextCharInd];
  }

  public char BeginToken() throws java.io.IOException
  {     
     if (inBuf > 0)
     {
        --inBuf;

        if (++bufpos == bufsize)
           bufpos = 0;

        tokenBegin = bufpos;
        return buffer[bufpos];
     }

     tokenBegin = 0;
     bufpos = -1;

     return readChar();
  }     

  protected void AdjustBuffSize()
  {
     if (available == bufsize)
     {
        if (tokenBegin > 2048)
        {
           bufpos = 0;
           available = tokenBegin;
        }
        else
           ExpandBuff(false);
     }
     else if (available > tokenBegin)
        available = bufsize;
     else if ((tokenBegin - available) < 2048)
        ExpandBuff(true);
     else
        available = tokenBegin;
  }

  protected void UpdateLineColumn(char c)
  {
     column++;

     if (prevCharIsLF)
     {
        prevCharIsLF = false;
        line += (column = 1);
     }
     else if (prevCharIsCR)
     {
        prevCharIsCR = false;
        if (c == '\n')
        {
           prevCharIsLF = true;
        }
        else
           line += (column = 1);
     }

     switch (c)
     {
        case '\r' :
           prevCharIsCR = true;
           break;
        case '\n' :
           prevCharIsLF = true;
           break;
        case '\t' :
           column--;
           column += (tabSize - (column % tabSize));
           break;
        default :
           break;
     }

     bufline[bufpos] = line;
     bufcolumn[bufpos] = column;
  }

  public char readChar() throws java.io.IOException
  {
     if (inBuf > 0)
     {
        --inBuf;

        if (++bufpos == bufsize)
           bufpos = 0;

        return buffer[bufpos];
     }

     char c;

     if (++bufpos == available)
        AdjustBuffSize();

     if ((buffer[bufpos] = c = ReadByte()) == '\\')
     {
        UpdateLineColumn(c);

        int backSlashCnt = 1;

        for (;;) // Read all the backslashes
        {
           if (++bufpos == available)
              AdjustBuffSize();

           try
           {
              if ((buffer[bufpos] = c = ReadByte()) != '\\')
              {
                 UpdateLineColumn(c);
                 // found a non-backslash char.
                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
                 {
                    if (--bufpos < 0)
                       bufpos = bufsize - 1;

                    break;
                 }

                 backup(backSlashCnt);
                 return '\\';
              }
           }
           catch(java.io.IOException e)
           {
              if (backSlashCnt > 1)
                 backup(backSlashCnt);

              return '\\';
           }

           UpdateLineColumn(c);
           backSlashCnt++;
        }

        // Here, we have seen an odd number of backslash's followed by a 'u'
        try
        {
           while ((c = ReadByte()) == 'u')
              ++column;

           buffer[bufpos] = c = (char)(hexval(c) << 12 |
                                       hexval(ReadByte()) << 8 |
                                       hexval(ReadByte()) << 4 |
                                       hexval(ReadByte()));

           column += 4;
        }
        catch(java.io.IOException e)
        {
           throw new Error("Invalid escape character at line " + line +
                                         " column " + column + ".");
        }

        if (backSlashCnt == 1)
           return c;
        else
        {
           backup(backSlashCnt - 1);
           return '\\';
        }
     }
     else
     {
        UpdateLineColumn(c);
        return (c);
     }
  }

  /**
   * @deprecated 
   * @see #getEndColumn
   */

  public int getColumn() {
     return bufcolumn[bufpos];
  }

  /**
   * @deprecated 
   * @see #getEndLine
   */

  public int getLine() {
     return bufline[bufpos];
  }

  public int getEndColumn() {
     return bufcolumn[bufpos];
  }

  public int getEndLine() {
     return bufline[bufpos];
  }

  public int getBeginColumn() {
     return bufcolumn[tokenBegin];
  }

  public int getBeginLine() {
     return bufline[tokenBegin];
  }

  public void backup(int amount) {

    inBuf += amount;
    if ((bufpos -= amount) < 0)
       bufpos += bufsize;
  }

  public JavaCharStream(java.io.Reader dstream,
                 int startline, int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    available = bufsize = buffersize;
    buffer = new char[buffersize];
    bufline = new int[buffersize];
    bufcolumn = new int[buffersize];
    nextCharBuf = new char[4096];
  }

  public JavaCharStream(java.io.Reader dstream,
                                        int startline, int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }

  public JavaCharStream(java.io.Reader dstream)
  {
     this(dstream, 1, 1, 4096);
  }
  public void ReInit(java.io.Reader dstream,
                 int startline, int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
      nextCharBuf = new char[4096];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    nextCharInd = bufpos = -1;
  }

  public void ReInit(java.io.Reader dstream,
                                        int startline, int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }

  public void ReInit(java.io.Reader dstream)
  {
     ReInit(dstream, 1, 1, 4096);
  }
  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
  {
     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  public JavaCharStream(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }

  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
                        int startcolumn) throws java.io.UnsupportedEncodingException
  {
     this(dstream, encoding, startline, startcolumn, 4096);
  }

  public JavaCharStream(java.io.InputStream dstream, int startline,
                        int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }

  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
  {
     this(dstream, encoding, 1, 1, 4096);
  }

  public JavaCharStream(java.io.InputStream dstream)
  {
     this(dstream, 1, 1, 4096);
  }

  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
  {
     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  public void ReInit(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
  }
  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                     int startcolumn) throws java.io.UnsupportedEncodingException
  {
     ReInit(dstream, encoding, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream, int startline,
                     int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
  {
     ReInit(dstream, encoding, 1, 1, 4096);
  }

  public void ReInit(java.io.InputStream dstream)
  {
     ReInit(dstream, 1, 1, 4096);
  }

  public String GetImage()
  {
     if (bufpos >= tokenBegin)
        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
     else
        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
                              new String(buffer, 0, bufpos + 1);
  }

  public char[] GetSuffix(int len)
  {
     char[] ret = new char[len];

     if ((bufpos + 1) >= len)
        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
     else
     {
        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                                                          len - bufpos - 1);
        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
     }

     return ret;
  }

  public void Done()
  {
     nextCharBuf = null;
     buffer = null;
     bufline = null;
     bufcolumn = null;
  }

  /**
   * Method to adjust line and column numbers for the start of a token.
   */
  public void adjustBeginLineColumn(int newLine, int newCol)
  {
     int start = tokenBegin;
     int len;

     if (bufpos >= tokenBegin)
     {
        len = bufpos - tokenBegin + inBuf + 1;
     }
     else
     {
        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
     }

     int i = 0, j = 0, k = 0;
     int nextColDiff = 0, columnDiff = 0;

     while (i < len &&
            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
     {
        bufline[j] = newLine;
        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
        bufcolumn[j] = newCol + columnDiff;
        columnDiff = nextColDiff;
        i++;
     } 

     if (i < len)
     {
        bufline[j] = newLine++;
        bufcolumn[j] = newCol + columnDiff;

        while (i++ < len)
        {
           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
              bufline[j] = newLine++;
           else
              bufline[j] = newLine;
        }
     }

     line = bufline[j];
     column = bufcolumn[j];
  }

}
/* Generated By:JJTree: Do not edit this line. .\ParserVisitor.java */

package org.nfunk.jep;

public interface ParserVisitor
{
  public Object visit(SimpleNode node, Object data) throws ParseException;
  public Object visit(ASTStart node, Object data) throws ParseException;
  public Object visit(ASTFunNode node, Object data) throws ParseException;
  public Object visit(ASTVarNode node, Object data) throws ParseException;
  public Object visit(ASTConstant node, Object data) throws ParseException;
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep;

import java.io.*;
import java.util.*;
import org.nfunk.jep.function.*;
import org.nfunk.jep.type.*;

/**
 * The JEP class is the main interface with which the user should
 * interact. It contains all necessary methods to parse and evaluate
 * expressions.
 * <p>
 * The most important methods are parseExpression(String), for parsing the
 * mathematical expression, and getValue() for obtaining the value of the
 * expression.
 * <p>
 * Visit <a href="http://www.singularsys.com/jep">http://www.singularsys.com/jep</a>
 * for the newest version of JEP, and complete documentation.
 *
 * @author Nathan Funk
 * @since 04/02/13 added Binom function
 */
public class JEP {

	/** Debug flag for extra command line output */
	private static final boolean debug = false;
	
	/** Traverse option */
	private boolean traverse;
	
	/** Allow undeclared variables option */
	protected boolean allowUndeclared;
	
	/** Allow undeclared variables option */
	protected boolean allowAssignment;
	
	/** Implicit multiplication option */
	protected boolean implicitMul;
	
	/** Symbol Table */
	protected SymbolTable symTab;

	/** Function Table */
	protected FunctionTable funTab;
	
	/** Error List */
	protected Vector errorList;
	
	/** The parser object */
	protected Parser parser;
	
	/** Node at the top of the parse tree */
	private Node topNode;

	/** Evaluator */
	protected EvaluatorVisitor ev;
	
	/** Number factory */
	protected NumberFactory numberFactory;

	/** OperatorSet */
	protected OperatorSet opSet;
	
	/**
	 * Creates a new JEP instance with the default settings.
	 * <p>
	 * Traverse = false<br>
	 * Allow undeclared variables = false<br>
	 * Implicit multiplication = false<br>
	 * Number Factory = DoubleNumberFactory
	 */
	public JEP() {
		topNode = null;
		traverse = false;
		allowUndeclared = false;
		allowAssignment  = false;
		implicitMul = false;
		numberFactory = new DoubleNumberFactory();
		opSet = new OperatorSet();
		initSymTab();
		initFunTab();
		errorList = new Vector();
		ev = new EvaluatorVisitor(this.getSymbolTable());
		parser = new Parser(new StringReader(""));

		//Ensure errors are reported for the initial expression
		//e.g. No expression entered
		//parseExpression("");
	}

	/**
	 * Creates a new JEP instance with custom settings. If the
	 * numberFactory_in is null, the default number factory is used.
	 * @param traverse_in The traverse option.
	 * @param allowUndeclared_in The "allow undeclared variables" option.
	 * @param implicitMul_in The implicit multiplication option.
	 * @param numberFactory_in The number factory to be used.
	 */
	public JEP(boolean traverse_in,
			   boolean allowUndeclared_in,
			   boolean implicitMul_in,
			   NumberFactory numberFactory_in) {
		topNode = null;
		traverse = traverse_in;
		allowUndeclared = allowUndeclared_in;
		implicitMul = implicitMul_in;
		if (numberFactory_in == null) {
			numberFactory = new DoubleNumberFactory();
		} else {
			numberFactory = numberFactory_in;
		}
		opSet = new OperatorSet();
		initSymTab();
		initFunTab();
		errorList = new Vector();
		ev = new EvaluatorVisitor(this.getSymbolTable());
		parser = new Parser(new StringReader(""));

		//Ensure errors are reported for the initial expression
		//e.g. No expression entered
		parseExpression("");		
	}

	/** This constructor copies the SymbolTable and other components 
	 * of the arguments to the new instance. Subclasses can call this 
	 * protected constructor and set the individual components
	 * themselves.
	 * @since 2.3.0 alpha
	 */
	protected JEP(JEP j)
	{
		this.topNode = null;
		this.traverse = j.traverse;
		this.allowUndeclared = j.allowUndeclared;
		this.allowAssignment  = j.allowAssignment;
		this.implicitMul = j.implicitMul;
		this.ev = j.ev;
		this.funTab = j.funTab;
		this.opSet = j.opSet;
		this.numberFactory = j.numberFactory;
		this.parser = j.parser;
		this.symTab = j.symTab;
		this.errorList = j.errorList;
	}

	/**
	 * Creates a new SymbolTable object as symTab.
	 */
	public void initSymTab() {
		//Init SymbolTable
		symTab = new SymbolTable(new VariableFactory());
	}

	/**
	 * Creates a new FunctionTable object as funTab.
	 */
	public void initFunTab() {
		//Init FunctionTable
		funTab = new FunctionTable();
	}

	/**
	 * Adds the standard functions to the parser. If this function is not called
	 * before parsing an expression, functions such as sin() or cos() would
	 * produce an "Unrecognized function..." error.
	 * In most cases, this method should be called immediately after the JEP
	 * object is created.
	 * @since 2.3.0 alpha added if and exp functions
	 * @since 2.3.0 beta 1 added str function
	 */
	public void addStandardFunctions() {
		//add functions to Function Table
		funTab.put("sin", new Sine());
		funTab.put("cos", new Cosine());
		funTab.put("tan", new Tangent());
		funTab.put("asin", new ArcSine());
		funTab.put("acos", new ArcCosine());
		funTab.put("atan", new ArcTangent());
		funTab.put("atan2", new ArcTangent2());

		funTab.put("sinh", new SineH());
		funTab.put("cosh", new CosineH());
		funTab.put("tanh", new TanH());
		funTab.put("asinh", new ArcSineH());
		funTab.put("acosh", new ArcCosineH());
		funTab.put("atanh", new ArcTanH());

		funTab.put("log", new Logarithm());
		funTab.put("ln", new NaturalLogarithm());
		funTab.put("exp", new Exp());
		funTab.put("pow", new Power());

		funTab.put("sqrt",new SquareRoot());
		funTab.put("abs", new Abs());
		funTab.put("mod", new Modulus());
		funTab.put("sum", new Sum());

		funTab.put("rand", new org.nfunk.jep.function.Random());
		
		// rjm additions
		funTab.put("if", new If());
		funTab.put("str", new Str());
		
		// rjm 13/2/05
		funTab.put("binom", new Binomial());
	}

	/**
	 * Adds the constants pi and e to the parser. As addStandardFunctions(),
	 * this method should be called immediately after the JEP object is
	 * created.
	 */
	public void addStandardConstants() {
		//add constants to Symbol Table
		symTab.addConstant("pi", new Double(Math.PI));
		symTab.addConstant("e", new Double(Math.E));
	}
	
	/**
	 * Call this function if you want to parse expressions which involve
	 * complex numbers. This method specifies "i" as the imaginary unit
	 * (0,1). Two functions re() and im() are also added for extracting the
	 * real or imaginary components of a complex number respectively.
	 *<p>
	 * @since 2.3.0 alpha The functions cmod and arg are added to get the modulus and argument. 
	 * @since 2.3.0 beta 1 The functions complex and polar to convert x,y and r,theta to Complex.
	 * @since Feb 05 added complex conjugate conj. 
	 */
	public void addComplex() {
		//add constants to Symbol Table
		symTab.addConstant("i", new Complex(0,1));
		funTab.put("re", new Real());
		funTab.put("im", new Imaginary());
		funTab.put("arg", new Arg());
		funTab.put("cmod", new Abs());
		funTab.put("complex", new ComplexPFMC());
		funTab.put("polar", new Polar());
		funTab.put("conj",new Conjugate());
	}

	/**
	 * Adds a new function to the parser. This must be done before parsing
	 * an expression so the parser is aware that the new function may be
	 * contained in the expression.
	 * @param functionName The name of the function
	 * @param function The function object that is used for evaluating the
	 * function
	 */
	public void addFunction(String functionName,
							PostfixMathCommandI function) {
		funTab.put(functionName, function);
	}
	
	/** Adds a constant.
	 * This is a variable whose value cannot be changed.
	 * @since 2.3.0 beta 1
	 */
	public void addConstant(String name,Object value) {
		symTab.addConstant(name, value);
	}
	
	/**
	 * Adds a new variable to the parser, or updates the value of an
	 * existing variable. This must be done before parsing
	 * an expression so the parser is aware that the new variable may be
	 * contained in the expression.
	 * @param name Name of the variable to be added
	 * @param value Initial value or new value for the variable
	 * @return Double object of the variable
	 */
	public Double addVariable(String name, double value) {
		Double object = new Double(value);
		symTab.makeVarIfNeeded(name, object);
		return object;
	}


	/**
	 * Adds a new complex variable to the parser, or updates the value of an
	 * existing variable. This must be done before parsing
	 * an expression so the parser is aware that the new variable may be
	 * contained in the expression.
	 * @param name Name of the variable to be added
	 * @param re Initial real value or new real value for the variable
	 * @param im Initial imaginary value or new imaginary value for the variable
	 * @return Complex object of the variable
	 */
	public Complex addVariable(String name, double re, double im) {
		Complex object = new Complex(re,im);
		symTab.makeVarIfNeeded(name, object);
		return object;
	}
		
	/**
	 * Adds a new variable to the parser as an object, or updates the value of an
	 * existing variable. This must be done before parsing
	 * an expression so the parser is aware that the new variable may be
	 * contained in the expression.
	 * @param name Name of the variable to be added
	 * @param object Initial value or new value for the variable
	 */
	public void addVariable(String name, Object object) {
		symTab.makeVarIfNeeded(name, object);
	}
	
	/**
	 * Removes a variable from the parser. For example after calling
	 * addStandardConstants(), removeVariable("e") might be called to remove
	 * the euler constant from the set of variables.
	 *
	 * @return The value of the variable if it was added earlier. If
	 * the variable is not in the table of variables, <code>null</code> is
	 * returned.
	 */
	public Object removeVariable(String name) {
		return symTab.remove(name);
	}
	
	/** 
	 * Returns the value of the variable with given name.
	 * @param name name of the variable.
	 * @return the current value of the variable.
	 * @since 2.3.0 alpha
	 */
	public Object getVarValue(String name) {
		return symTab.getVar(name).getValue();
	}
	
	/** 
	 * Sets the value of a variable.
	 * The variable must exist before hand.
	 * @param name name of the variable.
	 * @param val the initial value of the variable.
	 * @throws NullPointerException if the variable has not been previously created
	 * with {@link #addVariable(String,Object)} first.
	 * @since 2.3.0 alpha
	 * @since April 05 - throws an exception if variable unset.
	 */
	public void setVarValue(String name,Object val) {
		symTab.setVarValue(name,val);
	}
	
	/** 
	 * Gets the object representing the variable with a given name. 
	 * @param name the name of the variable to find.
	 * @return the Variable object or null if name not found.
	 * @since 2.3.0 alpha
	 */
	public Variable getVar(String name) {
		return symTab.getVar(name);
	}
	
	/**
	 * Removes a function from the parser.
	 *
	 * @return If the function was added earlier, the function class instance
	 * is returned. If the function was not present, <code>null</code>
	 * is returned.
	 */
	public Object removeFunction(String name) {
		return funTab.remove(name);
	}

	/**
	 * Sets the value of the traverse option. setTraverse is useful for
	 * debugging purposes. When traverse is set to true, the parse-tree
	 * will be dumped to the standard output device.
	 * <p>
	 * The default value is false.
	 * @param value The boolean traversal option.
	 */
	public void setTraverse(boolean value) {
		traverse = value;
	}
	
	/**
	 * Returns the value of the traverse option.
	 * @return True if the traverse option is enabled. False otherwise.
	 */
	public boolean getTraverse() { return traverse; }

	/**
	 * Sets the value of the implicit multiplication option.
	 * If this option is set to true before parsing, implicit multiplication
	 * will be allowed. That means that an expression such as
	 * <pre>"1 2"</pre> is valid and is interpreted as <pre>"1*2"</pre>.
	 * <p>
	 * The default value is false.
	 * @param value The boolean implicit multiplication option.
	 */
	public void setImplicitMul(boolean value) {
		implicitMul = value;
	}
	
	/**
	 * Returns the value of the implicit multiplication option.
	 * @return True if the implicit multiplication option is enabled. False otherwise.
	 */
	public boolean getImplicitMul() { return implicitMul; }
	
	/**
	 * Sets the value for the undeclared variables option. If this option
	 * is set to true, expressions containing variables that were not
	 * previously added to JEP will not produce an "Unrecognized Symbol"
	 * error. The new variables will automatically be added while parsing,
	 * and initialized to 0.
	 * <p>
	 * If this option is set to false, variables that were not previously
	 * added to JEP will produce an error while parsing.
	 * <p>
	 * The default value is false.
	 * @param value The boolean option for allowing undeclared variables.
	 */
	public void setAllowUndeclared(boolean value) {
		allowUndeclared = value;
	}

	/**
	 * Returns the value of the allowUndeclared option.
	 * @return True if the allowUndeclared option is enabled. False otherwise.
	 */
	public boolean getAllowUndeclared() { return allowUndeclared; }
	
	/**
	 * Sets whether assignment equations like <tt>y=x+1</tt> are allowed.
	 * @since 2.3.0 alpha
	 */
	public void setAllowAssignment(boolean value) {
		allowAssignment = value;
	}

	/**
	 * Whether assignment equation <tt>y=x+1</tt> equations are allowed.
	 * @since 2.3.0 alpha
	 */
	public boolean getAllowAssignment() { return allowAssignment; }


	/**
	 * Parses the expression. If there are errors in the expression,
	 * they are added to the <code>errorList</code> member.
	 * @param expression_in The input expression string
	 */
	public void parseExpression(String expression_in) {
		Reader reader = new StringReader(expression_in);
		
		try {
			// try parsing
			errorList.removeAllElements();
			topNode = parser.parseStream(reader, this);
		} 
		catch (Throwable e) 
		{
			// an exception was thrown, so there is no parse tree
			topNode = null;
			
			// check the type of error
			if (e instanceof ParseException) {
				// the ParseException object contains additional error
				// information
				errorList.addElement(((ParseException)e).getMessage());
				//getErrorInfo());
			} else {
				// if the exception was not a ParseException, it was most
				// likely a syntax error
				if (debug) {
					System.out.println(e.getMessage());
					e.printStackTrace();
				}
				errorList.addElement("Syntax error");
			}
		}
		
				
		// If traversing is enabled, print a dump of the tree to
		// standard output
		if (traverse && !hasError()) {
			ParserVisitor v = new ParserDumpVisitor();
			try
			{
				topNode.jjtAccept(v, null);
			}
			catch(ParseException e) 
			{
				errorList.addElement(e.getMessage());
			}
		}
	}

	/**
	 * Parses an expression. 
	 * Returns a object of type Node, does not catch errors.
	 * Does not set the topNode variable of the JEP instance.
	 * This method should generally be used with the {@link #evaluate evaluate}
	 * method rather than getValueAsObject.
	 * @param expression represented as a string.
	 * @return The top node of an tree representing the parsed expression.
	 * @throws ParseException
	 * @since 2.3.0 alpha
	 * @since 2.3.0 beta - will raise exception if errorList non empty
	 */
	public Node parse(String expression) throws ParseException
	{
		java.io.StringReader sr = new java.io.StringReader(expression);
		errorList.removeAllElements();
		Node node = parser.parseStream(sr, this);
		if (this.hasError())
			throw new ParseException(getErrorInfo());
		return node;
	}

	/**
	 * Evaluate an expression. This method evaluates the argument
	 * rather than the topNode of the JEP instance.
	 * It should be used in conjunction with {@link #parse parse}
	 * rather than {@link #parseExpression parseExpression}.
	 * @param node the top node of the tree representing the expression.
	 * @return The value of the expression
	 * @throws ParseException if for some reason the expression could not be evaluated
     * @throws RuntimeException could potentially be thrown.
	 * @since 2.3.0 alpha
	 */
	public Object evaluate(Node node) throws ParseException
	{
		return ev.getValue(node, this.symTab);
	}

	/**
	 * Evaluates and returns the value of the expression as a double number.
	 * @return The calculated value of the expression as a double number.
	 * If the type of the value does not implement the Number interface
	 * (e.g. Complex), NaN is returned. If an error occurs during evaluation,
	 * NaN is returned and hasError() will return true.
	 *
	 * @see #getComplexValue()
	 */
	public double getValue() {
		Object value = getValueAsObject();
		
		if(value == null) return Double.NaN;
		
		if(value instanceof Complex)
		{
			Complex c = (Complex) value;
			if( c.im() != 0.0) return Double.NaN;
			return c.re();
		}
		if (value != null && value instanceof Number) {
			return ((Number)value).doubleValue();
		}
		
		return Double.NaN;
	}


	/**
	 * Evaluates and returns the value of the expression as a complex number.
	 * @return The calculated value of the expression as a complex number if
	 * no errors occur. Returns null otherwise.
	 */
	public Complex getComplexValue() {
		Object value = getValueAsObject();
		
		if (value == null) {
			return null;
		} else if (value instanceof Complex) {
			return (Complex)value;
		} else if (value instanceof Number) {
			return new Complex(((Number)value).doubleValue(), 0);
		} else {
			return null;
		}
	}



	/**
	 * Evaluates and returns the value of the expression as an object.
	 * The EvaluatorVisitor member ev is used to do the evaluation procedure.
	 * This method is useful when the type of the value is unknown, or
	 * not important.
	 * @return The calculated value of the expression if no errors occur.
	 * Returns null otherwise.
	 */
	public Object getValueAsObject() {
		Object result;
		
		if (topNode == null || hasError()) return null;
			// evaluate the expression
		try {
			result = ev.getValue(topNode,symTab);
		}
		catch(ParseException e)	{
			if (debug) System.out.println(e);
			errorList.addElement("Error during evaluation: "+e.getMessage());
			return null;
		}
		catch(RuntimeException e) {
			if (debug) System.out.println(e);
			errorList.addElement(e.getClass().getName()+": "+e.getMessage());
			return null;
		}
		return result;
	}

	/**
	 * Returns true if an error occurred during the most recent
	 * action (parsing or evaluation).
	 * @return Returns <code>true</code> if an error occurred during the most
	 * recent action (parsing or evaluation).
	 */
	public boolean hasError() {
		return !errorList.isEmpty();
	}

	/**
	 * Reports information on the errors that occurred during the most recent
	 * action.
	 * @return A string containing information on the errors, each separated
	 * by a newline character; null if no error has occurred
	 */
	public String getErrorInfo() {
		if (hasError()) {
			String str = "";
			
			// iterate through all errors and add them to the return string
			for (int i=0; i<errorList.size(); i++) {
				str += errorList.elementAt(i) + "\n";
			}
			return str;
		}
		return null;
	}

	/**
	 * Returns the top node of the expression tree. Because all nodes are
	 * pointed to either directly or indirectly, the entire expression tree
	 * can be accessed through this node. It may be used to manipulate the
	 * expression, and subsequently evaluate it manually.
	 * @return The top node of the expression tree
	 */
	public Node getTopNode() {
		return topNode;
	}

	/**
	 * Returns the symbol table (the list of all variables that the parser
	 * recognizes).
	 * @return The symbol table
	 */
	public SymbolTable getSymbolTable() {
		return symTab;
	}

	/**
	 * Returns the function table (the list of all functions that the parser
	 * recognizes).
	 * @return The function table
	 */
	public FunctionTable getFunctionTable() {
			return funTab;
	}

	/**
	 * Returns the EvaluatorVisitor
	 * @return the EvaluatorVisitor.
	 */
	public EvaluatorI getEvaluatorVisitor() {
	    return ev;
	}
	/**
	 * Returns the number factory.
	 * @return the NumberFactory used by this JEP instance.
	 */
	public NumberFactory getNumberFactory() {
		return numberFactory;
	}

	/**
	 * Returns the operator set.
	 * @return the OperatorSet used by this JEP instance.
	 * @since 2.3.0 alpha
	 */
	public OperatorSet getOperatorSet() {
		return opSet;
	}

	/**
	 * Returns the parse object.
	 * @return the Parse used by this JEP.
	 * @since 2.3.0 beta 1
	 */
	public Parser getParser() {return parser;	}
//------------------------------------------------------------------------
// Old code


/*
	/**
	* Returns the position (vertical) at which the last error occurred.
	/
	public int getErrorColumn() {
		if (hasError && parseException != null)
			return parseException.getColumn();
		else
			return 0;
	}

	/**
	* Returns the line in which the last error occurred.
	/
	public int getErrorLine() {
		if (hasError && parseException != null)
			return parseException.getLine();
		else
			return 0;
	}
*/
}

/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
/* Generated By:JJTree: Do not edit this line. ASTFunNode.java */
package org.nfunk.jep;

import org.nfunk.jep.function.*;
// rjm unneeded import
// import java.util.*;

/**
 * Function Node
 */
public class ASTFunNode extends SimpleNode {
	
	/** The function class used to evaluate the node */
	private PostfixMathCommandI pfmc;
	
	/** Name of the function */
	private String name;
	
	/** ID of the operator (if it is one) */
	private Operator opID=null;
	
	/**
	 * Creates a new ASTFunNode
	 */
	public ASTFunNode(int id) {
		super(id);
	}
	
	/**
	 * Creates a new ASTFunNode
	 */
	public ASTFunNode(Parser p, int id) {
		super(p, id);
	}
	
	/**
	 * Accept the visitor.
	 */
	public Object jjtAccept(ParserVisitor visitor, Object data) throws ParseException
	{
		return visitor.visit(this, data);
	}

	/**
	 * Sets the function for a node. A name and function class must
	 * be specified.
	 */	
	public void setFunction(String name_in, PostfixMathCommandI pfmc_in) {
		name = name_in;
		pfmc = pfmc_in;
	}
	
	/**
	 * Sets the opID, name and pfmc for this node by looking up the values
	 * in the Operators class
	 */
	public void setOperator(Operator op) {
			opID = op;
			pfmc = op.getPFMC();
			name = op.getName();
	}

	/**
	 * Returns a string containing the function name.
	 */
	public String toString() {
		return "Function \"" + name + "\"";
	}

	/**
	 * Returns the math command class associated with this node.
	 */
	public PostfixMathCommandI getPFMC() {
		return pfmc;
	}
	
	/**
	 * Returns the name of the node (operator symbol or function name).
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * Returns the id number of the operator if the node is an operator.
	 */
	public Operator getOperator() {
		return opID;
	}

	/**
	 * Returns true if node is an operator.
	 */
	public boolean isOperator() {
		return (opID != null);
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/


package org.nfunk.jep.evaluation;

import org.nfunk.jep.*;
import java.util.*;


public class ExpressionCompiler implements ParserVisitor {
	/** Commands */
	private Vector commands;
		
	public ExpressionCompiler() {
		commands = new Vector();
	}
	
	public CommandElement[] compile(Node node) throws ParseException{
		commands.removeAllElements();
		node.jjtAccept(this, null);
		CommandElement[] temp = new CommandElement[commands.size()];
		Enumeration en = commands.elements();
		int i = 0;
		while (en.hasMoreElements()) {
			 temp[i++] = (CommandElement)en.nextElement();
		}
		return temp;
	}

	public Object visit(ASTFunNode node, Object data) throws ParseException {
		node.childrenAccept(this,data);
		
		CommandElement c = new CommandElement();
		c.setType(CommandElement.FUNC);
		c.setPFMC(node.getPFMC());
		c.setNumParam(node.jjtGetNumChildren());
		commands.addElement(c);
		
		return data;
	}

	public Object visit(ASTVarNode node, Object data) {
		CommandElement c = new CommandElement();
		c.setType(CommandElement.VAR);
		c.setVarName(node.getName());
		commands.addElement(c);

		return data;
	}

	public Object visit(ASTConstant node, Object data) {
		CommandElement c = new CommandElement();
		c.setType(CommandElement.CONST);
		c.setValue(node.getValue());
		commands.addElement(c);

		return data;
	}
	
	public Object visit(SimpleNode node, Object data) {
		return data;
	}
	
	public Object visit(ASTStart node, Object data) {
		return data;
	}
}
/*
 * 
 * Created on 15-Aug-2003
 */
package org.nfunk.jep.evaluation;

import org.nfunk.jep.function.*;
/**
 * 
 * @author nathan
 */
public class CommandElement {
	public final static int VAR   = 0; 
	public final static int CONST = 1; 
	public final static int FUNC  = 2; 
	private int                 type;
	private String              varName;
	private PostfixMathCommandI pfmc;
	private int                 nParam;
	private Object              value;

	/**
	 * @return The function associated with this element.
	 */
	public final PostfixMathCommandI getPFMC() {
		return pfmc;
	}

	/**
	 * @return The type.
	 */
	public final int getType() {
		return type;
	}

	/**
	 * @return The value of this element.
	 */
	public final Object getValue() {
		return value;
	}

	/**
	 * @return The variable name.
	 */
	public final String getVarName() {
		return varName;
	}

	/**
	 * @return The number of parameters.
	 */
	public final int getNumParam() {
		return nParam;
	}

	/**
	 * @param commandI The function associated with this element.
	 */
	public final void setPFMC(PostfixMathCommandI commandI) {
		pfmc = commandI;
	}

	/**
	 * @param i The type identifier.
	 */
	public final void setType(int i) {
		type = i;
	}

	/**
	 * @param object The value of the element.
	 */
	public final void setValue(Object object) {
		value = object;
	}

	/**
	 * @param string The name of the variable.
	 */
	public final void setVarName(String string) {
		varName = string;
	}

	/**
	 * @param i The number of parameters.
	 */
	public final void setNumParam(int i) {
		nParam = i;
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.evaluation;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.function.*;

/**
 * 
 * @author nathan
 */
public class CommandEvaluator {
	private int                 nCommands, nParam;
	private CommandElement      command;
	private Stack               stack;
	private PostfixMathCommandI pfmc;
	private int                 i;
	
	public CommandEvaluator() {
		stack = new Stack();
	}
	
	public Object evaluate(CommandElement[] commands, SymbolTable symTab) throws Exception {
		
		int nCommands = commands.length;
		
		stack.removeAllElements();
		
		// for each command
		i = 0;
		while (i<nCommands) {
			command = commands[i];

			switch (command.getType()) {
				case CommandElement.FUNC: {
					// Function
					pfmc = command.getPFMC();
				
					// set the number of current parameters 
					// (it is no faster to first check getNumberOfParameters()==-1)
					pfmc.setCurNumberOfParameters(command.getNumParam());
				
					pfmc.run(stack);
					break;
				}
				case CommandElement.VAR: {
					// Variable
					stack.push(symTab.getValue(command.getVarName()));					
					break;
				}
				default: {
					// Constant
					stack.push(command.getValue());
				}
			}
			/*
			if (command instanceof ASTVarNode) {
				// Variable
				stack.push(symTab.get(((ASTVarNode)command).getName()));
			} else if (command instanceof PostfixMathCommandI) {
				// Function
				pfmc = (PostfixMathCommandI)command;
				
				// set the number of current parameters 
				// (it is no faster to first check getNumberOfParameters()==-1)
				nParam = ((Integer)commands.elementAt(++i)).intValue();
				pfmc.setCurNumberOfParameters(nParam);
				
				pfmc.run(stack);
			} else {
			}*/
			
			i++;
		}
		if (stack.size() != 1) {
			throw new Exception("CommandEvaluator.evaluate(): Stack size is not 1");
		}
		return stack.pop();
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;

/** The list function.
 * Returns a Vector comprising all the children.
 * 
 * @author Rich Morris
 * Created on 29-Feb-2004
 */
public class Range extends PostfixMathCommand
{
	public Range()
	{
		numberOfParameters = -1;
	}

	/**
	 * Generates a range [low,low+inc,...,low+inc*(steps-1)]
	 * @param low
	 * @param inc
	 * @param steps
	 * @return a Vector
	 */
	public Object genRange(double low,double inc,int steps)
	{
		Vector res = new Vector(steps);
		res.setSize(steps);
		for(int i=0;i<steps;++i)
			res.set(i,new Double(low+inc*i));
		return res;
	}
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack); // check the stack
		if(curNumberOfParameters <1)
			throw new ParseException("Empty list");
		
		Object res;
		if(curNumberOfParameters == 2)
		{
			Object lastObj = inStack.pop();
			Object firstObj  = inStack.pop();
			double last = ((Number) lastObj).doubleValue();
			double first = ((Number) firstObj).doubleValue();
			double diff = last-first;
			int steps = 1+(int) diff;
			res=genRange(first,1.0,steps);
		}
		else if(curNumberOfParameters == 3)
		{
			Object incObj = inStack.pop();
			Object lastObj = inStack.pop();
			Object firstObj  = inStack.pop();
			double inc = ((Number) incObj).doubleValue();
			double last = ((Number) lastObj).doubleValue();
			double first = ((Number) firstObj).doubleValue();
			double diff = (last-first)/inc;
			int steps = 1+(int) diff;
			res=genRange(first,inc,steps);
		}
		else if(curNumberOfParameters == 4)
		{
			Object stepsObj = inStack.pop();
			Object incObj = inStack.pop();
			Object lastObj = inStack.pop();
			Object firstObj  = inStack.pop();
			int steps = ((Number) stepsObj).intValue();
			double last = ((Number) lastObj).doubleValue();
			double first = ((Number) firstObj).doubleValue();
			double inc = (last-first)/(steps-1);
			res=genRange(first,inc,steps);
		}
		else throw new ParseException("Range:only a maximum of four arguments can be specified");
		inStack.push(res);
		return;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;

/**
 * Converts an object into its string representation.
 * Calls the toString method of the object. 
 * 
 * @author Rich Morris
 * Created on 27-Mar-2004
 */
public class Str extends PostfixMathCommand
{
	public Str()
	{
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(param.toString());//push the result on the inStack
		return;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class Subtract extends PostfixMathCommand
{
	public Subtract()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack); // check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		inStack.push(sub(param1, param2));

		return;
	}
	
	public Object sub(Object param1, Object param2)
		throws ParseException
	{
		if (param1 instanceof Complex)
		{
			if (param2 instanceof Complex)
			{
				return sub((Complex)param1, (Complex)param2);
			}
			else if( param2 instanceof Number)
			{
				return sub((Complex)param1, (Number)param2);
			}
		}
		else if (param1 instanceof Number)
		{
			if (param2 instanceof Complex)
			{
				return sub((Number)param1, (Complex)param2);
			}
			else if (param2 instanceof Number)
			{
				return sub((Number)param1, (Number)param2);
			}
		} 
		throw new ParseException("Invalid parameter type");
	}
	

	public Double sub(Number d1, Number d2)
	{
		return new Double(d1.doubleValue() - d2.doubleValue());
	}
	
	public Complex sub(Complex c1, Complex c2)
	{
		return new Complex(c1.re() - c2.re(), c1.im() - c2.im());
	}
	
	public Complex sub(Complex c, Number d)
	{
		return new Complex(c.re() - d.doubleValue(), c.im());
	}

	public Complex sub(Number d, Complex c)
	{
		return new Complex(d.doubleValue() - c.re(), -c.im());
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * Implements the arcTanH function.
 * 
 * @author Nathan Funk
 * @since 2.3.0 beta 2 - Now returns Double result rather than Complex for -1<x<1 
 */
public class ArcTanH extends PostfixMathCommand
{
	public ArcTanH()
	{
		numberOfParameters = 1;
	}

	public void run(Stack inStack)
		throws ParseException
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(atanh(param));//push the result on the inStack
		return;
	}

	public Object atanh(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).atanh();
		}
		else if (param instanceof Number)
		{
			double val = ((Number)param).doubleValue();
			if(val > -1.0 && val < 1) {
				double res = Math.log((1+val)/(1-val))/2;
				return new Double(res);
			}
			else
			{
				Complex temp = new Complex(val,0.0);
				return temp.atanh();
			}
		}

		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class SineH extends PostfixMathCommand
{
	public SineH()
	{
		numberOfParameters = 1;
	}

	public void run(Stack inStack)
		throws ParseException
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(sinh(param));//push the result on the inStack
		return;
	}

	public Object sinh(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).sinh();
		}
		else if (param instanceof Number)
		{
			double value = ((Number)param).doubleValue();
			return new Double((Math.exp(value)-Math.exp(-value))/2);
		}

		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;


/**
 * All function classes must implement this interface to ensure that the run()
 * method is implemented.
 */
public interface PostfixMathCommandI
{
	/**
	 * Run the function on the stack. Pops the arguments from the stack, and
	 * pushes the result on the top of the stack.
	 */
	public void run(Stack aStack) throws ParseException;
	
	/**
	 * Returns the number of required parameters, or -1 if any number of
	 * parameters is allowed.
	 */
	public int getNumberOfParameters();

	/**
	 * Sets the number of current number of parameters used in the next call
	 * of run(). This method is only called when the reqNumberOfParameters is
	 * -1.
	 */
	public void setCurNumberOfParameters(int n);
	
	/**
	 * Checks the number of parameters of the function.
	 * This method is called during the parsing of the equation to check syntax.
	 * Functions which set numberOfParameter=-1 should overwrite this method.
	 * @param n number of parameters function will be called with.
	 * @return False if an illegal number of parameters is supplied, true otherwise.
	 */
	public boolean checkNumberOfParameters(int n);

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * The acos function.
 * @author Nathan Funk
 * TODO How to handle acos(x) for real x with x>1 or x<-1
 */
public class ArcCosine extends PostfixMathCommand
{
	public ArcCosine()
	{
		numberOfParameters = 1;
	
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(acos(param));//push the result on the inStack
		return;
	}

	public Object acos(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).acos();
		}
		else if (param instanceof Number)
		{
			return new Double(Math.acos(((Number)param).doubleValue()));
		}

		throw new ParseException("Invalid parameter type");
	}
	
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
/**
* Encapsulates the Math.random() function.
*/
public class Random extends PostfixMathCommand
{
	public Random()
	{
		numberOfParameters = 0;

	}

	public void run(Stack inStack)
		throws ParseException
	{
		checkStack(inStack);// check the stack
		inStack.push(new Double(Math.random()));
		return;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class TanH extends PostfixMathCommand
{
	public TanH()
	{
		numberOfParameters = 1;
	}

	public void run(Stack inStack)
		throws ParseException
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(tanh(param));//push the result on the inStack
		return;
	}

	public Object tanh(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).tanh();
		}
		else if (param instanceof Number)
		{
			double value = ((Number)param).doubleValue();
			return new Double((Math.exp(value)-Math.exp(-value))/(Math.pow(Math.E,value)+Math.pow(Math.E,-value)));
		}
		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/** 
 * Implements the comparative operations <, >, <=, >=, != and ==.
 * Caverts should work where arguments are Double, Complex or String
 * for the last two only != and == work.
 * For other types care might be needed.
 * 
 * Complex numbers are compared using a tolerance which can be set
 * using setTolerance().  
 * 
 * @author N Funk and R Morris
 * @since 2.3.0 beta 1 a bit of a rewrite to make sub classing easier, now allows Complex to be compared to Double i.e. 1+0 i == 1.
 * @since 2.3.0 beta 2 changed the internal lt,gt,le,ge,ne and eq method to return boolean.
 * If this breaks anything use
 * 		if(lt(obj1,obj2)) inStack.push(new Double(1));
 *		else 	inStack.push(new Double(0));
 */
public class Comparative extends PostfixMathCommand
{
	protected int id;
	double tolerance;
	public static final int LT = 0;
	public static final int GT = 1;
	public static final int LE = 2;
	public static final int GE = 3;
	public static final int NE = 4;
	public static final int EQ = 5;

	/**
	 * Constructor. Sets the number of parameters to 2. Initializes the
	 * tolerance for comparing Complex values.
	 * @param id_in The id of the comparative operator.
	 */
	public Comparative(int id_in)
	{
		id = id_in;
		numberOfParameters = 2;
		tolerance = 1e-6;
	}
	
	public void run(Stack inStack)	throws ParseException 
	{
		checkStack(inStack);// check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		boolean res=false;
		switch(id)
		{
		case LT: res = lt(param1,param2); break;
		case GT: res = gt(param1,param2); break;
		case LE: res = le(param1,param2); break;
		case GE: res = ge(param1,param2); break;
		case NE: res = ne(param1,param2); break;
		case EQ: res = eq(param1,param2); break;
		}
		if(res) inStack.push(new Double(1));
		else inStack.push(new Double(0));
	}
	
	public boolean lt(Object param1, Object param2)	throws ParseException
	{
		if ((param1 instanceof Complex) || (param2 instanceof Complex))
			throw new ParseException("< not defined for complex numbers");
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Number)param2).doubleValue();
			return (x<y);
		}
		throw new ParseException("< not defined for object of type "+param1.getClass().getName()+" and "+param1.getClass().getName());
	}
	
	public boolean gt(Object param1, Object param2)	throws ParseException
	{
		if ((param1 instanceof Complex) || (param2 instanceof Complex))
			throw new ParseException("> not defined for complex numbers");
		
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Number)param2).doubleValue();
			return (x>y);
		}
		throw new ParseException("> not defined for object of type "+param1.getClass().getName()+" and "+param1.getClass().getName());
	}
	
	public boolean le(Object param1, Object param2)	throws ParseException
	{
		if ((param1 instanceof Complex) || (param2 instanceof Complex))
			throw new ParseException("<= not defined for complex numbers");
		
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Number)param2).doubleValue();
			return (x<=y);
		}
		throw new ParseException("<= not defined for object of type "+param1.getClass().getName()+" and "+param1.getClass().getName());
	}
	
	public boolean ge(Object param1, Object param2)	throws ParseException
	{
		if ((param1 instanceof Complex) || (param2 instanceof Complex))
			throw new ParseException(">= not defined for complex numbers");
		
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Number)param2).doubleValue();
			return (x>=y);
		}
		throw new ParseException(">= not defined for object of type "+param1.getClass().getName()+" and "+param1.getClass().getName());
	}

	public boolean eq(Object param1, Object param2)	throws ParseException
	{
		if ((param1 instanceof Complex) && (param2 instanceof Complex))
		{
			return ((Complex)param1).equals((Complex)param2, tolerance);
		}
		if ((param1 instanceof Complex) && (param2 instanceof Number))
		{
			return ((Complex)param1).equals(new Complex((Number)param2), tolerance);
		}
		if ((param2 instanceof Complex) && (param1 instanceof Number))
		{
			return ((Complex)param2).equals(new Complex((Number)param1), tolerance);
		}
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Number)param2).doubleValue();
			return (x==y);
		}
		if ((param1 instanceof Boolean) && (param2 instanceof Boolean))
		{
			boolean x = ((Boolean)param1).booleanValue();
			boolean y = ((Boolean)param2).booleanValue();
			return (x==y);
		}
		if ((param1 instanceof Number) && (param2 instanceof Boolean))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Boolean)param2).booleanValue()?1.0:0.0;
			return (x==y);
		}
		if ((param1 instanceof Boolean) && (param2 instanceof Number))
		{
			double x = ((Boolean)param1).booleanValue()?1.0:0.0;
			double y = ((Number)param2).doubleValue();
			return (x==y);
		}
		
		// if we get to here, just use the equal function
		return param1.equals(param2);
	}
	
	public boolean ne(Object param1, Object param2)	throws ParseException
	{
		if ((param1 instanceof Complex) && (param2 instanceof Complex))
		{
			return !((Complex)param1).equals((Complex)param2, tolerance);
		}
		if ((param1 instanceof Complex) && (param2 instanceof Number))
		{
			return !((Complex)param1).equals(new Complex((Number) param2), tolerance);
		}
		if ((param2 instanceof Complex) && (param1 instanceof Number))
		{
			return !((Complex)param2).equals(new Complex((Number) param1), tolerance);
		}
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Number)param2).doubleValue();
			return (x!=y);
		}
		if ((param1 instanceof Boolean) && (param2 instanceof Boolean))
		{
			boolean x = ((Boolean)param1).booleanValue();
			boolean y = ((Boolean)param2).booleanValue();
			return (x!=y);
		}
		if ((param1 instanceof Number) && (param2 instanceof Boolean))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Boolean)param2).booleanValue()?1.0:0.0;
			return (x!=y);
		}
		if ((param1 instanceof Boolean) && (param2 instanceof Number))
		{
			double x = ((Boolean)param1).booleanValue()?1.0:0.0;
			double y = ((Number)param2).doubleValue();
			return (x!=y);
		}
		return !param1.equals(param2);
	}


/* old code
		if ((param1 instanceof Complex) || (param2 instanceof Complex))
			throw new ParseException(">= not defined for complex numbers");
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Number)param2).doubleValue();
			int r = (x>=y) ? 1 : 0;
			return new Double(r);
		}
		throw new ParseException(">= not defined for object of type "+param1.getClass().getName()+" and "+param1.getClass().getName());
	}
	
		{
			int r;
			
			switch (id)
			{
				case NE:
					r = ((Complex)param1).equals((Complex)param2, tolerance) ? 0 : 1;
					break;
				case EQ:
					r = ((Complex)param1).equals((Complex)param2, tolerance) ? 1 : 0;
					break;
				default:
					throw new ParseException("Relational operator type error");
			}
			
			inStack.push(new Double(r));//push the result on the inStack
		}
		else if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double x = ((Number)param1).doubleValue();
			double y = ((Number)param2).doubleValue();
			int r;
			
			switch (id)
			{
				case LT:
					r = (x<y) ? 1 : 0;
					break;
				case GT:
					r = (x>y) ? 1 : 0;
					break;
				case LE:
					r = (x<=y) ? 1 : 0;
					break;
				case GE:
					r = (x>=y) ? 1 : 0;
					break;
				case NE:
					r = (x!=y) ? 1 : 0;
					break;
				case EQ:
					r = (x==y) ? 1 : 0;
					break;
				default:
					throw new ParseException("Unknown relational operator");
			}
			
			inStack.push(new Double(r));//push the result on the inStack
		} 
		else if ((param1 instanceof String) && (param2 instanceof String))
		{
			int r;
			
			switch (id)
			{
				case NE:
					r = ((String)param1).equals((String)param2) ? 0 : 1;
					break;
				case EQ:
					r = ((String)param1).equals((String)param2) ? 1 : 0;
					break;
				default:
					throw new ParseException("Relational operator type error");
			}
			
			inStack.push(new Double(r));//push the result on the inStack
		} else
		{
			throw new ParseException("Invalid parameter type");
		}
		
		
		return;
	}
	*/
	
	/**
	 * Returns the tolerance used for comparing complex numbers
	 */
	public double getTolerance() {
		return tolerance;
	}

	/**
	 * Sets the tolerance used for comparing complex numbers
	 * @param d
	 */
	public void setTolerance(double d) {
		tolerance = d;
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class ArcSine extends PostfixMathCommand
{
	public ArcSine()
	{
		numberOfParameters = 1;
	
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(asin(param));//push the result on the inStack
		return;
	}

	public Object asin(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).asin();
		}
		else if (param instanceof Number)
		{
			return new Double(Math.asin(((Number)param).doubleValue()));
		}

		throw new ParseException("Invalid parameter type");
	}
	
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * Implements the arcSinH function.
 * 
 * @author Nathan Funk
 * @since 2.3.0 beta 2 - Now returns Double result rather than Complex for Double arguments. 
 */
public class ArcSineH extends PostfixMathCommand
{
	public ArcSineH()
	{
		numberOfParameters = 1;
	}

	public void run(Stack inStack)
		throws ParseException
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(asinh(param));//push the result on the inStack
		return;
	}

	public Object asinh(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).asinh();
		}
		else if (param instanceof Number)
		{
			double val = ((Number)param).doubleValue();
			double res = Math.log(val+Math.sqrt(val*val+1));
			return new Double(res);
//			Complex temp = new Complex(((Number)param).doubleValue(),0.0);
//			return temp.asinh();
		}
		throw new ParseException("Invalid parameter type");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class Imaginary extends PostfixMathCommand
{
	public Imaginary() {
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack) throws ParseException {
		
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(im(param));//push the result on the inStack
		return;
	}
	
	public Number im(Object param) throws ParseException {
		
		if (param instanceof Complex)
			return new Double(((Complex)param).im());
		else if (param instanceof Number)
			return new Double(0);
		

		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;

public class Dot extends PostfixMathCommand
{
	static Add add = new Add();
	static Multiply mul = new Multiply();	
	public Dot()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack); // check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		inStack.push(dot(param1, param2));

		return;
	}
	
	public Object dot(Object param1, Object param2)
		throws ParseException
	{
		if (param1 instanceof Vector && param2 instanceof Vector)
		{
			return dot((Vector) param1,(Vector) param2);
		}
		throw new ParseException("Dot: Invalid parameter type, both arguments must be vectors");
	}
	

	public Object dot(Vector v1,Vector v2) throws ParseException
	{
		if(v1.size()!=v2.size())
			throw new ParseException("Dot: both sides of dot must be same length");
		int len = v1.size();
		if(len<1)
			throw new ParseException("Dot: empty vectors parsed");
		
		Object res = mul.mul(v1.elementAt(0),v2.elementAt(0));
		for(int i=1;i<len;++i)
		{
			res = add.add(res,
				mul.mul(v1.elementAt(i),v2.elementAt(i)));
		}
		return res;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * Log bass 10.
 * <p>
 * RJM change return real results for positive real arguments.
 * Speedup by using static final fields.
 */
public class Logarithm extends PostfixMathCommand
{
	private static final double LOG10 = Math.log(10);
	private static final Complex CLOG10 = new Complex(Math.log(10),0);
	
	public Logarithm() {
		numberOfParameters = 1;
	}

	public void run(Stack inStack) throws ParseException {
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(log(param));//push the result on the inStack
		return;
	}
	

	public Object log(Object param) throws ParseException 
	{
		if (param instanceof Complex) {
		   return ((Complex)param).log().div(CLOG10);
		}
		else if (param instanceof Number) 
		{
			double num = ((Number) param).doubleValue();
			if( num >= 0)
				return new Double(Math.log(num)/LOG10);
			else if(num != num)
				return new Double(Double.NaN);
			else
			{	
				Complex temp = new Complex(num);
				return temp.log().div(CLOG10);
			}
		}
		throw new ParseException("Invalid parameter type");
	}
	

}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.nfunk.jep.function;
import org.nfunk.jep.*;
/**
 * Functions which require greater control over their evaluation should implement this interface.
 *
 * @author Rich Morris
 * Created on 18-Nov-2003
 */
public interface CallbackEvaluationI {

	/**
	 * Performs some special evaluation on the node.
	 * This method has the responsibility for evaluating the children of the node
	 * and it should generally call
	 * <pre>
	 * pv.eval(node.jjtGetChild(i))	
	 * </pre>
	 * for each child.
	 * 
	 * The SymbolTable is not passed as an argument. This is because
	 * it is better practice to get and set variable values by using
	 * node.getVar().setValue() rather that through the SymbolTable with
	 * requires a hashtable lookup.
	 *
	 * @param node	The current node
	 * @param pv	The visitor, can be used evaluate the children
	 * @return the value after evaluation
	 * @throws ParseException
	 */
	public Object evaluate(Node node,EvaluatorI pv) throws ParseException;
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * Computes the power of an number.
 * Implements a fast algorithm for integer powers by Patricia Shanahan pats@acm.org.
 * @author N Funk
 * @author R Morris 
 * @author Patricia Shanahan
 */
public class Power extends PostfixMathCommand
{
	public Power()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack); // check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		inStack.push(power(param1, param2));
	}
	
	public Object power(Object param1, Object param2)
		throws ParseException
	{
		if (param1 instanceof Complex) {
			if (param2 instanceof Complex)
				return power((Complex)param1, (Complex)param2);
			else if (param2 instanceof Number) 
				return power((Complex)param1, (Number)param2);
		}
		else if (param1 instanceof Number) {
			if (param2 instanceof Complex)
				return power((Number)param1, (Complex)param2);
			else if (param2 instanceof Number) 
				return power((Number)param1, (Number)param2);
		}

		throw new ParseException("Invalid parameter type");
	}
	

	public Object power(Number d1, Number d2)
	{
		int ival = d2.shortValue();
		double dval = d2.doubleValue();
		if (d1.doubleValue()<0 && dval != ival)
		{
			Complex c = new Complex(d1.doubleValue(), 0.0);
			return c.power(d2.doubleValue());
		}
		else
		{
			if(dval == ival)
			{
				if(dval>=0)
					return new Double(power(d1.doubleValue(),ival));
				else
					return new Double(1.0/power(d1.doubleValue(),-ival));
			}

			return new Double(Math.pow(d1.doubleValue(),d2.doubleValue()));
		}
	}
	
	public Object power(Complex c1, Complex c2)
	{
		Complex temp = c1.power(c2);

		if (temp.im()==0)
			return new Double(temp.re());
		else
			return temp;
	}
	
	public Object power(Complex c, Number d)
	{
		Complex temp = c.power(d.doubleValue());
		
		if (temp.im()==0)
			return new Double(temp.re());
		else
			return temp;
	}

	public Object power(Number d, Complex c)
	{
		Complex base = new Complex(d.doubleValue(), 0.0);
		Complex temp = base.power(c);
		
		if (temp.im()==0)
			return new Double(temp.re());
		else
			return temp;
	}
	
	/**
	 * A fast routine for computing integer powers.
	 * Code adapted from {@link http://mindprod.com/jgloss/power.html} by Patricia Shanahan pats@acm.org
	 * Almost identical to the method Knuth gives on page 462 of The Art of Computer Programming Volume 2 Seminumerical Algorithms.
	 * @param x number to be taken to a power.
	 * @param n power to take x to. 0 <= n <= Integer.MAX_VALUE
	 * Negative numbers will be treated as unsigned positives.
 	 * @return x to the power n
	 * 
	 */
	public double power(double x,int n)
	{
		switch(n){
		case 0: x = 1.0; break;
		case 1: break;
		case 2: x *= x; break;
		case 3: x *= x*x; break;
		case 4: x *= x*x*x; break;
		case 5: x *= x*x*x*x; break;
		case 6: x *= x*x*x*x*x; break;
		case 7: x *= x*x*x*x*x*x; break;
		case 8: x *= x*x*x*x*x*x*x; break;
		default:
			{
			   int bitMask = n;
			   double evenPower = x;
			   double result;
			   if ( (bitMask & 1) != 0 )
			      result = x;
			   else
			      result = 1;
			   bitMask >>>= 1;
			   while ( bitMask != 0 ) {
			      evenPower *= evenPower;
			      if ( (bitMask & 1) != 0 )
			         result *= evenPower;
			      bitMask >>>= 1;
			   } // end while
			   x = result;
			}
		}
		return x;
	} 
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class Cosine extends PostfixMathCommand
{
	public Cosine()
	{
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(cos(param));//push the result on the inStack
		return;
	}
	
	public Object cos(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).cos();
		}
		else if (param instanceof Number)
		{
			return new Double(Math.cos(((Number)param).doubleValue()));
		}

		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;

public class Cross extends PostfixMathCommand
{
	static Subtract sub = new Subtract();
	static Multiply mul = new Multiply();	
	public Cross()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack); // check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		inStack.push(cross(param1, param2));

		return;
	}
	
	public Object cross(Object param1, Object param2)
		throws ParseException
	{
		if (param1 instanceof Vector && param2 instanceof Vector)
		{
			return cross((Vector) param1,(Vector) param2);
		}
		throw new ParseException("Cross: Invalid parameter type, both arguments must be vectors");
	}

	public Object cross(Vector lhs,Vector rhs) throws ParseException
	{
		int len = lhs.size();
		if((len!=2 && len!=3) || len !=rhs.size())
			throw new ParseException("Cross: both sides must be of length 3");
		if(len==3)
		{
			Vector res = new Vector(3);
			res.setSize(3);
			res.setElementAt(sub.sub(
					mul.mul(lhs.elementAt(1),rhs.elementAt(2)),
					mul.mul(lhs.elementAt(2),rhs.elementAt(1))),0);
			res.setElementAt(sub.sub(
					mul.mul(lhs.elementAt(2),rhs.elementAt(0)),
					mul.mul(lhs.elementAt(0),rhs.elementAt(2))),1);
			res.setElementAt(sub.sub(
					mul.mul(lhs.elementAt(0),rhs.elementAt(1)),
					mul.mul(lhs.elementAt(1),rhs.elementAt(0))),2);
			return res;
		}
		else
		{
			return sub.sub(
				mul.mul(lhs.elementAt(0),rhs.elementAt(1)),
				mul.mul(lhs.elementAt(1),rhs.elementAt(0)));
			
		}
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class Sine extends PostfixMathCommand
{
	public Sine()
	{
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(sin(param));//push the result on the inStack
		return;
	}

	public Object sin(Object param)
		throws ParseException
	{
		if (param instanceof Complex) {
			return ((Complex)param).sin();
		}
		else if (param instanceof Number) {
			return new Double(Math.sin(((Number)param).doubleValue()));
		}
		
		throw new ParseException("Invalid parameter type");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * Implements the arcCosH function.
 * 
 * @author Nathan Funk
 * @since 2.3.0 beta 2 - Now returns Double result rather than Complex for x >= 1 
 */
public class ArcCosineH extends PostfixMathCommand
{
	public ArcCosineH()
	{
		numberOfParameters = 1;
	}

	public void run(Stack inStack)
		throws ParseException
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(acosh(param));//push the result on the inStack
		return;
	}

	public Object acosh(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).acosh();
		}
		else if (param instanceof Number)
		{
			double val = ((Number)param).doubleValue();
			if(val >= 1.0) {
				double res = Math.log(val+Math.sqrt(val*val-1));
				return new Double(res);
			}
			else
			{
				Complex temp = new Complex(((Number)param).doubleValue(),0.0);
				return temp.acosh();
			}
		}

		throw new ParseException("Invalid parameter type");
	}
}
/*
Created 16-May-2006 - Richard Morris
*/
package org.nfunk.jep.function;

import org.nfunk.jep.EvaluatorI;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;

/**
 * @author Richard Morris
 * An interface for functions which can be used on the left hand side of an assignment.
 * For instance
 * a[3] = 5
 * sets the third element of a to the value 5.
 */
public interface LValueI {
	/**
	 * Performs appropriate action to set an LValue.
	 * @param pv a pointer to the evaluator. The pv.eval() method can be used to evaluate the children of the node.
	 * @param node The top node for the LValue
	 * @param value the value obtained by evaluating the right hand side.
	 * @throws ParseException
	 */
	public void set(EvaluatorI pv,Node node,Object value) throws ParseException;
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
/**
 * Converts a pair of real numbers to a complex number Complex(x,y)=x+i y.
 * 
 * @author Rich Morris
 * Created on 24-Mar-2004
 */
public class ComplexPFMC extends PostfixMathCommand
{
	public ComplexPFMC()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double real = ((Number)param1).doubleValue();
			double imag = ((Number)param2).doubleValue();
		
			inStack.push(new Complex(real,imag));
		}
		else
		{
			throw new ParseException("Complex: Invalid parameter types "+param1.getClass().getName()+" "+param1.getClass().getName());
		}
		return;
	}
}
/*
Created 26-May-2006 - Richard Morris
*/
package org.nfunk.jep.function;

import java.util.Stack;
import java.util.Vector;

import org.nfunk.jep.ASTVarNode;
import org.nfunk.jep.EvaluatorI;
import org.nfunk.jep.Node;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.Variable;

/**
 * Function which allows array access using the a[3] notation on left and right hand side.
 * <code>
 * a=[4,3,2,1];
 * a[2]; // returns 2
 * a[2]=5; // a is now [4,5,2,1]
 * </code>
 * @author Richard Morris
 */
public class Ele extends PostfixMathCommand implements LValueI {

	/**
	 * 
	 */
	public Ele() {
		numberOfParameters = 2;
	}

	public void set(EvaluatorI pv, Node node, Object value)
			throws ParseException {
		Node lhsNode = node.jjtGetChild(0);
		Node rhsNode = node.jjtGetChild(1);
		if(!(lhsNode instanceof ASTVarNode))
			throw new ParseException("Ele: lhs must be a variable");
		ASTVarNode vn = (ASTVarNode) lhsNode;
		Variable var = vn.getVar();
		Object rhs = pv.eval(node.jjtGetChild(1));
		int index=-1;
		if(rhs instanceof Number)
		{
			index=((Number) rhs).intValue()-1;
		}
		else if(rhs instanceof Vector)
		{
			Vector vec = (Vector) rhs;
			if(vec.size()!=1) throw new ParseException("Ele: only single dimension arrays supported in JEP");
			index = ((Number) vec.firstElement()).intValue()-1;
		}
		else throw new ParseException("Ele: rhs must be a number");
		Object oldVarVal = var.getValue();
		if(!(oldVarVal instanceof Vector))
			throw new ParseException("Ele: the value of the variable must be a Vector");
		Vector newVarVal = (Vector) ((Vector) oldVarVal).clone();
		newVarVal.set(index,value);
		var.setValue(newVarVal);
	}

	public void run(Stack s) throws ParseException {
		checkStack(s);// check the stack
		Object rhs = s.pop();
		Object lhs = s.pop();
		if(!(lhs instanceof Vector)) throw new ParseException("Ele: lhs must be an instance of Vector");

		if(rhs instanceof Number)
		{
			int index = ((Number) rhs).intValue();
			Object val = ((Vector) lhs).elementAt(index-1);
			s.push(val);
			return;
		}
		if(rhs instanceof Vector)
		{
			Vector vec = (Vector) rhs;
			if(vec.size()!=1) throw new ParseException("Ele: only single dimension arrays supported in JEP");
			int index = ((Number) vec.firstElement()).intValue();
			Object val = ((Vector) lhs).elementAt(index-1);
			s.push(val);
			return;
			
		}
		throw new ParseException("Ele: only single dimension arrays supported in JEP");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;

/** The list function.
 * Returns a Vector comprising all the children.
 * 
 * @author Rich Morris
 * Created on 29-Feb-2004
 */
public class List extends PostfixMathCommand
{
	public List()
	{
		numberOfParameters = -1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack); // check the stack
		if(curNumberOfParameters <1)
			throw new ParseException("Empty list");
		Vector res = new Vector(curNumberOfParameters);
		res.setSize(curNumberOfParameters);
		for(int i=curNumberOfParameters-1;i>=0;--i)
		{
			Object param = inStack.pop();
			res.setElementAt(param,i);
		}
		inStack.push(res);
		return;
	}
}
/* @author rich
 * Created on 13-Feb-2005
 *
 * See LICENSE.txt for license information.
 */
package org.nfunk.jep.function;

import java.util.Stack;

import org.nfunk.jep.ParseException;

/**
 * Binomial coeficients: binom(n,i).
 * Requires n,i integers >=0.
 * Often written nCi or column vector (n,i).
 * (n,0) = 1, (n,1) = n, (n,n-1) = n, (n,n) = 1<br>
 * (n,i) = n! / ( i! (n-i)! )<br>
 * Pascals triangle rule: (n,i) = (n-1,i-1) + (n-1,i)<br>
 * Binomial theorem: (a+b)^n = sum (n,i) a^i b^(n-i), i=0..n.
 * <p>
 * For efficiency the binomial coefficients are stored in a static array. 
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class Binomial extends PostfixMathCommand
{
	static final int initN = 20;
	static int[][] coeffs = new int[initN+1][];
	/** Static initialiser for binomial coeffs */
	{
		coeffs[0] = new int[1];
		coeffs[0][0] = 1;
		coeffs[1] = new int[2];
		coeffs[1][0] = 1; coeffs[1][1] = 1;
		for(int n=2;n<=initN;++n)
		{
			coeffs[n] = new int[n+1];
			coeffs[n][0] = 1;
			coeffs[n][n] = 1;
			for(int j=1;j<n;++j)
				coeffs[n][j] = coeffs[n-1][j-1]+coeffs[n-1][j];
		}
	}
	/** If necessary expand the table to include coeffs(N,i) */
	static void expand(int N)
	{
		int oldN = coeffs.length-1;
		if(N<=oldN) return;
		int[][] newCoeffs = new int[N+1][];
		for(int i=0;i<=oldN;++i)
			newCoeffs[i] = coeffs[i];
		for(int n=oldN+1;n<=N;++n)
		{
			newCoeffs[n] = new int[n+1];
			newCoeffs[n][0] = 1;
			newCoeffs[n][n] = 1;
			for(int j=1;j<n;++j)
				newCoeffs[n][j] = newCoeffs[n-1][j-1]+newCoeffs[n-1][j];
		}
		coeffs = newCoeffs;
	}
	/**
	 * 
	 */
	public Binomial()
	{
		super();
		this.numberOfParameters = 2;
	}

	public void run(Stack s) throws ParseException
	{
		Object iObj = s.pop();
		Object nObj = s.pop();
		if((!(iObj instanceof Number )) || (!(nObj instanceof Number)))
			throw new ParseException("Binomial: both arguments must be integers. They are "+nObj+"("+nObj.getClass().getName()+") and "+iObj+"("+nObj.getClass().getName()+")");
		int iInt = ((Number) iObj).intValue();
		int nInt = ((Number) nObj).intValue();
		if(nInt < 0 || iInt < 0 || iInt > nInt)
			throw new ParseException("Binomial: illegal values for arguments 0<i<n. They are "+nObj+" and "+iObj);
		
		expand(nInt);
		int res = coeffs[nInt][iInt];
		s.push(new Integer(res));
	}
	/** Returns the binomial coefficients.
	 * 
	 * @throws ArrayIndexOutOfBoundsException if n<0, i<0 or i>n
	 */
	static public int binom(int n,int i) throws ArrayIndexOutOfBoundsException
	{
		expand(n);
		return coeffs[n][i];
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * Addition function. Supports any number of parameters although typically
 * only 2 parameters are used. 
 * @author nathan
 */
public class Add extends PostfixMathCommand
{
	
	public Add()
	{
		numberOfParameters = -1;
	}
	
	/**
	 * Calculates the result of applying the "+" operator to the arguments from
	 * the stack and pushes it back on the stack.
	 */
	public void run(Stack stack) throws ParseException {
		checkStack(stack);// check the stack
		
		Object sum = stack.pop();
		Object param;
		int i = 1;
        
		// repeat summation for each one of the current parameters
		while (i < curNumberOfParameters) {
			// get the parameter from the stack
			param = stack.pop();
			
			// add it to the sum (order is important for String arguments)
			sum = add(param, sum);
			
			i++;
		}
        		
		stack.push(sum);
		
		return;
	}

	/**
	 * Adds two numbers together. The parameters can be of type Number,
	 * Complex, or String. If a certain combination of types is not supported,
	 * a ParseException is thrown.
	 * 
	 * @param param1 The first parameter to be added.
	 * @param param2 The second parameter to be added.
	 * @return The sum of param1 and param2, or concatenation of the two if
	 *         they are Strings.
	 * @throws ParseException
	 */
	public Object add(Object param1, Object param2) throws ParseException {
		if (param1 instanceof Complex) 
		{
			if (param2 instanceof Complex) 
				return add((Complex)param1, (Complex)param2);
			else if (param2 instanceof Number)
				return add((Complex)param1, (Number)param2);
		}
		else if (param1 instanceof Number) 
		{
			if (param2 instanceof Complex) 
				return add((Complex)param2, (Number)param1);
			else if (param2 instanceof Number) 
				return add((Number)param1, (Number)param2);
		}
		else if ((param1 instanceof String) && (param2 instanceof String)) {
			return (String)param1 + (String)param2;
		}
		
		throw new ParseException("Invalid parameter type");
	}
	
	public Double add(Number d1, Number d2) {
		return new Double(d1.doubleValue() + d2.doubleValue());
	}
	
	public Complex add(Complex c1, Complex c2) {
		return new Complex(c1.re() + c2.re(), c1.im() + c2.im());
	}
	
	public Complex add(Complex c, Number d) {
		return new Complex(c.re() + d.doubleValue(), c.im());
	}	
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * Natural logarithm.
 *
 * RJM Change: fixed so ln(positive Double) is Double.
 */
public class NaturalLogarithm extends PostfixMathCommand
{
	public NaturalLogarithm()
	{
		numberOfParameters = 1;

	}

	public void run(Stack inStack)
		throws ParseException
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(ln(param));//push the result on the inStack
		return;
	}

	public Object ln(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).log();
		}
		else if (param instanceof Number)
		{
			// Now returns Complex if param is <0
			double num = ((Number) param).doubleValue();
			if( num >= 0)
				return new Double(Math.log(num));
			else if(num != num)
				return new Double(Double.NaN);
			else
			{	
				Complex temp = new Complex(num);
				return temp.log();
			}
		}

		throw new ParseException("Invalid parameter type");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;

public class Not extends PostfixMathCommand
{
	public Not()
	{
		numberOfParameters = 1;
	
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		if (param instanceof Number)
		{
			int r = (((Number)param).doubleValue() == 0) ? 1 : 0;
			inStack.push(new Double(r));//push the result on the inStack
		}
		else if(param instanceof Boolean)
		{
			int r = (((Boolean)param).booleanValue()) ? 0 : 1;
			inStack.push(new Double(r));//push the result on the inStack
		}
		else
			throw new ParseException("Invalid parameter type");
		return;
	}

}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.nfunk.jep.function;

import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
/**
 * The if(condExpr,posExpr,negExpr) function.
 * The value of trueExpr will be returned if condExpr is &gt;0 or Boolean.TRUE
 * and value of negExpr will be returned if condExpr is &lt;= 0 or Boolean.TRUE.
 * <p>
 * This function performs lazy evaluation so that
 * only posExpr or negExpr will be evaluated.
 * For Complex numbers only the real part is used.
 * <p>
 * An alternate form if(condExpr,posExpr,negExpr,zeroExpr)
 * is also available. Note most computations
 * are carried out over floating point doubles so
 * testing for zero can be dangerous.
 * <p>
 * This function implements the SpecialEvaluationI interface
 * so that it handles setting the value of a variable. 
 * @author Rich Morris
 * Created on 18-Nov-2003
 * @version 2.3.0 beta 1 now supports a Boolean first argument.
 * @since Feb 05 Handles Number arguments, so works with Integers rather than just Doubles
 */
public class If extends PostfixMathCommand implements CallbackEvaluationI {

	/**
	 * 
	 */
	public If() {
		super();
		numberOfParameters = -1;
	}

	/*
	 * Performs the specified action on an expression tree.
	 * Serves no function in standard JEP but 
	 * @param node top node of the tree
	 * @param pv	The visitor, can be used evaluate the children.
	 * @return top node of the results.
	 * @throws ParseException
	public Node process(Node node,Object data,ParserVisitor pv) throws ParseException
	{
		return null;
	}
    */
	/**
	 * Checks the number of parameters of the call.
	 * 
	 */
	public boolean checkNumberOfParameters(int n) {
		return (n == 3 || n == 4);
	}

	/**
	 * 
	 */
	public Object evaluate(Node node,EvaluatorI pv) throws ParseException
	{
		int num = node.jjtGetNumChildren(); 
		if( !checkNumberOfParameters(num))
			throw new ParseException("If operator must have 3 or 4 arguments.");

		// get value of argument

		Object condVal = pv.eval(node.jjtGetChild(0));
		
		// convert to double
		double val;
		if(condVal instanceof Boolean)
		{
			if(((Boolean) condVal).booleanValue())
				return pv.eval(node.jjtGetChild(1));
			return pv.eval(node.jjtGetChild(2));
		}
		else if(condVal instanceof Complex)
			val = ((Complex) condVal).re();
		else if(condVal instanceof Number)
			val = ((Number) condVal).doubleValue();
		else
			throw new ParseException("Condition in if operator must be double or complex");

		if(val>0.0)
			return pv.eval(node.jjtGetChild(1));
		else if(num ==3 || val <0.0)
			return pv.eval(node.jjtGetChild(2));
		return pv.eval(node.jjtGetChild(3));
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class ArcTangent extends PostfixMathCommand
{
	public ArcTangent()
	{
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(atan(param));//push the result on the inStack
		return;
	}

	public Object atan(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).atan();
		}
		else if (param instanceof Number)
		{
			return new Double(Math.atan(((Number)param).doubleValue()));
		}

		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class Real extends PostfixMathCommand
{
	public Real()
	{
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(re(param));//push the result on the inStack
		return;
	}
	
	public Number re(Object param) throws ParseException {
		if (param instanceof Complex)
			return new Double(((Complex)param).re());
		else if (param instanceof Number)
			return ((Number)param);

		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
/**
 * Converts a pair of real numbers to a complex number Complex(x,y)=x+i y.
 * 
 * @author Rich Morris
 * Created on 24-Mar-2004
 */
public class Polar extends PostfixMathCommand
{
	public Polar()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			inStack.push(Complex.polarValueOf((Number) param1,(Number) param2));
		}
		else
		{
			throw new ParseException("Complex: Invalid parameter types "+param1.getClass().getName()+" "+param1.getClass().getName());
		}
		return;
	}
}
/*****************************************************************************

Exp function

created by R. Morris

JEP - Java Math Expression Parser 2.24
      December 30 2002
      (c) Copyright 2002, Nathan Funk
      See LICENSE.txt for license information.

*****************************************************************************/

package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
import org.nfunk.jep.function.PostfixMathCommand;

/**
 * The exp function.
 * Defines a method exp(Object param)
 * which calculates 
 * @author Rich Morris
 * Created on 20-Jun-2003
 */
public class Exp extends PostfixMathCommand
{
	public Exp()
	{
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(exp(param));//push the result on the inStack
		return;
	}

	public Object exp(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
		  	Complex z = (Complex) param;
		  	double x = z.re();
		  	double y = z.im();
		  	double mod = Math.exp(x);
			return new Complex(mod*Math.cos(y),mod*Math.sin(y));
		}
		else if (param instanceof Number) 
		{
			return new Double(Math.exp(((Number)param).doubleValue()));
		}

		throw new ParseException("Invalid parameter type");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/** The complex conjugate of a number conj(c)
 * 
 * @author Rich Morris
 * Created on 13-Feb-2005
 */
public class Conjugate extends PostfixMathCommand
{
	public Conjugate() {
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack) throws ParseException {
		
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(conj(param));//push the result on the inStack
		return;
	}
	
	public Object conj(Object param) throws ParseException {
		
		if (param instanceof Complex)
			return ((Complex)param).conj();
		else if (param instanceof Number)
			return param;
		

		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

/**
 * Argument of a complex number
 * @author Rich Morris
 * Created on 20-Nov-2003
 */
public class Arg extends PostfixMathCommand
{
	private static final Double ONE = new Double(1.0);
	public Arg()
	{
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(arg(param));//push the result on the inStack
		return;
	}
	
	public Number arg(Object param) throws ParseException {
		if (param instanceof Complex) {
					return new Double(((Complex)param).arg());
				}
		else if (param instanceof Number) {
			return (ONE);
		} 
		throw new ParseException("Invalid parameter type");
	}

}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.nfunk.jep.function;

import org.nfunk.jep.*;
/**
 * An assignment operator so we can do
 * x=3+4.
 * This function implements the CallbackEvaluationI interface
 * so that it handles setting the value of a variable. 
 * 
 * Any Variable or function which implements the LValueI can appear on the left hand side of the equation.
 *  
 * @author Rich Morris
 * Created on 18-Nov-2003
 */
public class Assign extends PostfixMathCommand implements CallbackEvaluationI {

	public Assign() {
		super();
		numberOfParameters = 2;
	}

	/** For assignment set the value of the variable on the lhs to value returned by evaluating the righthand side.
	 *   
	 */
	public Object evaluate(Node node,EvaluatorI pv) throws ParseException
	{
		if(node.jjtGetNumChildren()!=2)
			throw new ParseException("Assignment operator must have 2 operators.");

		// evaluate the value of the righthand side.
		Object rhsVal = pv.eval(node.jjtGetChild(1));	

		// Set the value of the variable on the lhs. 
		Node lhsNode = node.jjtGetChild(0);
		if(lhsNode instanceof ASTVarNode)
		{
			ASTVarNode vn = (ASTVarNode) lhsNode;
			Variable var = vn.getVar();
			var.setValue(rhsVal);
			return rhsVal;
		}
		else if(lhsNode instanceof ASTFunNode && ((ASTFunNode) lhsNode).getPFMC() instanceof LValueI)
		{
			((LValueI) ((ASTFunNode) lhsNode).getPFMC()).set(pv,lhsNode,rhsVal);
			return rhsVal;
		}
		throw new ParseException("Assignment should have a variable or LValue for the lhs.");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class SquareRoot extends PostfixMathCommand
{
	public SquareRoot() {
		numberOfParameters = 1;
	}
	
	/**
	 * Applies the function to the parameters on the stack.
	 */
	public void run(Stack inStack) throws ParseException {
			
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(sqrt(param));//push the result on the inStack
		return;
	}

	/**
	 * Calculates the square root of the parameter. The parameter must
	 * either be of type Double or Complex.
	 *
	 * @return The square root of the parameter.
	 */
	public Object sqrt(Object param) throws ParseException 
	{
		if (param instanceof Complex)
			return ((Complex)param).sqrt();
		if (param instanceof Number) {
			double value = ((Number)param).doubleValue();
			
			// a value less than 0 will produce a complex result
			if (value < 0.0) {
				return (new Complex(value).sqrt());
			} else {
				return new Double(Math.sqrt(value));
			}
		}

		throw new ParseException("Invalid parameter type");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;

public class Logical extends PostfixMathCommand
{
	int id;
	public static final int AND = 0;
	public static final int OR = 1;
	public Logical(int id_in)
	{
		id = id_in;
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		double x,y;
		if ((param1 instanceof Number))
			x = ((Number)param1).doubleValue();
		else if((param1 instanceof Boolean))
			x= ((Boolean) param1).booleanValue()?1.0:0.0;
		else throw new ParseException("Logical: require a number or Boolean value on lhs, have "+
				param1.getClass().getName());
		if ((param2 instanceof Number))
			y = ((Number)param2).doubleValue();
		else if((param2 instanceof Boolean))
			y= ((Boolean) param2).booleanValue()?1.0:0.0;
		else throw new ParseException("Logical: require a number or Boolean value on lhs, have "+
				param1.getClass().getName());
		
		int r;
			
		switch (id)
		{
		case 0:
			// AND
			r = ((x!=0d) && (y!=0d)) ? 1 : 0;
			break;
		case 1:
			// OR
			r = ((x!=0d) || (y!=0d)) ? 1 : 0;
			break;
		default:
			r = 0;
		}
		inStack.push(new Double(r)); // push the result on the inStack
		return;
	}
}
/* @author rich
 * Created on 18-Nov-2003
 */
package org.nfunk.jep.function;
import org.nfunk.jep.*;
import java.util.Stack;
/**
 * Functions which require greater control over their evaluation should implement this interface.
 *
 * @author Rich Morris
 * @deprecated The interface CallbackEvaluationI should generally be used instead as its simpler and allows different evaluation schemes to be used.
 * @see CallbackEvaluationI
 * Created on 18-Nov-2003
 */
public interface SpecialEvaluationI {

	/**
	 * Performs some special evaluation on the node.
	 * This method has the responsibility for evaluating the children of the node
	 * and it should generally call
	 * <pre>
	 * node.jjtGetChild(i).jjtAccept(pv,data);	
	 * </pre>
	 * for each child. Briefly the symbol table was removed as arguments to this method, it is now reinserted.
	 *
	 * @param node	The current node
	 * @param data	The data passed to visitor, typically not used
	 * @param pv	The visitor, can be used evaluate the children
	 * @param stack	The stack of the evaluator
	 * @param symTab The symbol table
	 * @return the value after evaluation
	 * @throws ParseException
	 */
	public Object evaluate(Node node,Object data,ParserVisitor pv,Stack stack,SymbolTable symTab) throws ParseException;
}
/*****************************************************************************

 @header@
 @date@
 @copyright@
 @license@

 *****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;

/**
 * This class serves mainly as an example of a function that accepts any number
 * of parameters. Note that the numberOfParameters is initialized to -1.
 */
public class Sum extends PostfixMathCommand {
	private Add addFun = new Add();

	/**
	 * Constructor.
	 */
	public Sum() {
		// Use a variable number of arguments
		numberOfParameters = -1;
	}

	/**
	 * Calculates the result of summing up all parameters, which are assumed to
	 * be of the Double type.
	 */
	public void run(Stack stack) throws ParseException {
		checkStack(stack);// check the stack

		if (curNumberOfParameters < 1) throw new ParseException("No arguments for Sum");

		// initialize the result to the first argument
		Object sum = stack.pop();
		Object param;
		int i = 1;
        
		// repeat summation for each one of the current parameters
		while (i < curNumberOfParameters) {
			// get the parameter from the stack
			param = stack.pop();
			
			// add it to the sum (order is important for String arguments)
			sum = addFun.add(param, sum);
			
			i++;
		}

		// push the result on the inStack
		stack.push(sum);
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;

/**
 * atan2(y, x) Returns the angle whose tangent is y/x. 
 * @author nathan
 */
public class ArcTangent2 extends PostfixMathCommand
{
	public ArcTangent2()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double y = ((Number)param1).doubleValue();
			double x = ((Number)param2).doubleValue();
			inStack.push(new Double(Math.atan2(y, x)));//push the result on the inStack
		}
		else
			throw new ParseException("Invalid parameter type");
		return;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;

public class Modulus extends PostfixMathCommand
{
	public Modulus()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		
		if ((param1 instanceof Number) && (param2 instanceof Number))
		{
			double divisor = ((Number)param2).doubleValue();
			double dividend = ((Number)param1).doubleValue();
		
			double result = dividend % divisor;
	
			inStack.push(new Double(result));
		}
		else
		{
			throw new ParseException("Invalid parameter type");
		}
		return;
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class Abs extends PostfixMathCommand
{
	public Abs()
	{
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(abs(param));//push the result on the inStack
		return;
	}


	public Object abs(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return new Double(((Complex)param).abs());
		}
		else if (param instanceof Number)
		{
			return new Double(Math.abs(((Number)param).doubleValue()));
		}

		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class Multiply extends PostfixMathCommand
{
	
	public Multiply() {
		numberOfParameters = -1;
	}
	
	public void run(Stack stack) throws ParseException 
	{
		checkStack(stack); // check the stack

		Object product = stack.pop();
		Object param;
        int i = 1;
        
        // repeat summation for each one of the current parameters
        while (i < curNumberOfParameters) {
        	// get the parameter from the stack
            param = stack.pop();
            
            // multiply it with the product, order is important
            // if matricies are used
            product = mul(param,product);
                
            i++;
        }
        		
		stack.push(product);

		return;
	}
	
	public Object mul(Object param1, Object param2)
		throws ParseException
	{
		if (param1 instanceof Complex)
		{
			if (param2 instanceof Complex)
				return mul((Complex)param1, (Complex)param2);
			else if (param2 instanceof Number)
				return mul((Complex)param1, (Number)param2);
			else if (param2 instanceof Vector)
				return mul((Vector)param2, (Complex)param1);
		}
		else if (param1 instanceof Number)
		{
			if (param2 instanceof Complex)
				return mul((Complex)param2, (Number)param1);
			else if (param2 instanceof Number)
				return mul((Number)param1, (Number)param2);
			else if (param2 instanceof Vector)
				return mul((Vector)param2, (Number)param1);
		}
		else if (param1 instanceof Vector)
		{
			if (param2 instanceof Complex)
				return mul((Vector)param1, (Complex)param2);
			else if (param2 instanceof Number)
				return mul((Vector)param1, (Number)param2);
		}
		
		throw new ParseException("Invalid parameter type");
	}
	
	public Double mul(Number d1, Number d2)
	{
		return new Double(d1.doubleValue()*d2.doubleValue());	
	}	
	
	public Complex mul(Complex c1, Complex c2)
	{
		return c1.mul(c2);
	}
	
	public Complex mul(Complex c, Number d)
	{
		return c.mul(d.doubleValue());	
	}
	
	public Vector mul(Vector v, Number d)
	{
		Vector result = new Vector();

		for (int i=0; i<v.size(); i++)
			result.addElement(mul((Number)v.elementAt(i), d));
		
		return result;
	}
	
	public Vector mul(Vector v, Complex c)
	{
		Vector result = new Vector();

		for (int i=0; i<v.size(); i++)
			result.addElement(mul(c, (Number)v.elementAt(i)));
		
		return result;
	}	
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;
 
public class UMinus extends PostfixMathCommand
{
	public UMinus() {
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack) throws ParseException {
		checkStack(inStack);// check the stack

		Object param = inStack.pop();
		
		inStack.push(umin(param));
		return;
	}
	
	public Object umin(Object param) throws ParseException {
		if (param instanceof Complex)
			return ((Complex)param).neg();
		if (param instanceof Number)
			return new Double(-((Number)param).doubleValue());

		throw new ParseException("Invalid parameter type");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class Tangent extends PostfixMathCommand
{
	public Tangent()
	{
		numberOfParameters = 1;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(tan(param));//push the result on the inStack
		return;
	}

	public Object tan(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
			return ((Complex)param).tan();
		else if (param instanceof Number)
			return new Double(Math.tan(((Number)param).doubleValue()));

		throw new ParseException("Invalid parameter type");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.lang.Math;
import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class CosineH extends PostfixMathCommand
{
	public CosineH()
	{
		numberOfParameters = 1;
	}

	public void run(Stack inStack)
		throws ParseException
	{
		checkStack(inStack);// check the stack
		Object param = inStack.pop();
		inStack.push(cosh(param));//push the result on the inStack
		return;
	}

	public Object cosh(Object param)
		throws ParseException
	{
		if (param instanceof Complex)
		{
			return ((Complex)param).cosh();
		}
		else if (param instanceof Number)
		{
			double value = ((Number)param).doubleValue();
			return new Double((Math.exp(value) + Math.exp(-value))/2);
		}

		throw new ParseException("Invalid parameter type");
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;
import java.util.*;
import org.nfunk.jep.*;

/**
 * Function classes extend this class. It is an implementation of the 
 * PostfixMathCommandI interface.
 * <p>
 * It includes a numberOfParameters member, that is checked when parsing the
 * expression. This member should be initialized to an appropriate value for
 * all classes extending this class. If an arbitrary number of parameters
 * should be allowed, initialize this member to -1.
 */
public class PostfixMathCommand implements PostfixMathCommandI
{
	/**
	 * Number of parameters a the function requires. Initialize this value to
	 * -1 if any number of parameters should be allowed.
	 */
	protected int numberOfParameters;
	
	/**
	 * Number of parameters to be used for the next run() invocation. Applies
	 * only if the required umber of parameters is variable
	 * (numberOfParameters = -1).
	 */
	protected int curNumberOfParameters;
	
	/**
	 * Creates a new PostfixMathCommand class.
	 */
	public PostfixMathCommand() {
		numberOfParameters = 0;
		curNumberOfParameters = 0;
	}

	/**
	 * Check whether the stack is not null, throw a ParseException if it is.
	 */
	protected void checkStack(Stack inStack) throws ParseException {
		/* Check if stack is null */
		if (null == inStack) {
			throw new ParseException("Stack argument null");
		}
	}

	/**
	 * Return the required number of parameters.
	 */
	public int getNumberOfParameters() {
		return numberOfParameters;
	}
	
	/**
	 * Sets the number of current number of parameters used in the next call
	 * of run(). This method is only called when the reqNumberOfParameters is
	 * -1.
	 */
	public void setCurNumberOfParameters(int n) {
		curNumberOfParameters = n;
	}
	
	/**
	 * Checks the number of parameters of the function.
 	 * Functions which set numberOfParameter=-1 should overload this method

	 * @param n number of parameters function will be called with.
	 * @return False if an illegal number of parameters is supplied, true otherwise.
	 */
	public boolean checkNumberOfParameters(int n) {
		if(numberOfParameters == -1) return true;
		return (numberOfParameters==n);
	}
	/**
	 * Throws an exception because this method should never be called under
	 * normal circumstances. Each function should use it's own run() method
	 * for evaluating the function. This includes popping off the parameters
	 * from the stack, and pushing the result back on the stack.
	 */
	public void run(Stack s) throws ParseException {
		throw new ParseException("run() method of PostfixMathCommand called");
	}
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/
package org.nfunk.jep.function;

import java.util.*;
import org.nfunk.jep.*;
import org.nfunk.jep.type.*;

public class Divide extends PostfixMathCommand
{
	public Divide()
	{
		numberOfParameters = 2;
	}
	
	public void run(Stack inStack)
		throws ParseException 
	{
		checkStack(inStack); // check the stack
		Object param2 = inStack.pop();
		Object param1 = inStack.pop();
		inStack.push(div(param1, param2)); //push the result on the inStack
		return;
	}
	
	public Object div(Object param1, Object param2)
		throws ParseException
	{
		if (param1 instanceof Complex)
		{
			if (param2 instanceof Complex)
				return div((Complex)param1, (Complex)param2);
			else if (param2 instanceof Number)
				return div((Complex)param1, (Number)param2);
			else if (param2 instanceof Vector)
				return div((Complex)param1, (Vector)param2);
		}
		else if (param1 instanceof Number)
		{
			if (param2 instanceof Complex)
				return div((Number)param1, (Complex)param2);
			else if (param2 instanceof Number)
				return div((Number)param1, (Number)param2);
			else if (param2 instanceof Vector)
				return div((Number)param1, (Vector)param2);
		}
		else if (param1 instanceof Vector)
		{
			if (param2 instanceof Complex)
				return div((Vector)param1, (Complex)param2);
			else if (param2 instanceof Number)
				return div((Vector)param1, (Number)param2);
		}

		throw new ParseException("Invalid parameter type");
	}


	public Double div(Number d1, Number d2)
	{
		return new Double(d1.doubleValue() / d2.doubleValue());
	}
	
	public Complex div(Complex c1, Complex c2)
	{
		return c1.div(c2);
	}
	
	public Complex div(Number d, Complex c)
	{
		Complex c1 = new Complex(d.doubleValue(), 0);

		return c1.div(c);
	}

	public Complex div(Complex c, Number d)
	{
		return new Complex(c.re()/d.doubleValue(), c.im()/d.doubleValue());
	}
	
	public Vector div(Vector v, Number d)
	{
		Vector result = new Vector();

		for (int i=0; i<v.size(); i++)
			result.addElement(div((Number)v.elementAt(i), d));
		
		return result;
	}
	
	public Vector div(Number d, Vector v)
	{
		Vector result = new Vector();

		for (int i=0; i<v.size(); i++)
			result.addElement(div(d, (Number)v.elementAt(i)));
		
		return result;
	}
	
	public Vector div(Vector v, Complex c)
	{
		Vector result = new Vector();

		for (int i=0; i<v.size(); i++)
			result.addElement(div((Number)v.elementAt(i), c));
		
		return result;
	}
	
	public Vector div(Complex c, Vector v)
	{
		Vector result = new Vector();

		for (int i=0; i<v.size(); i++)
			result.addElement(div(c, (Number)v.elementAt(i)));
		
		return result;
	}	
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.type;

import org.nfunk.jep.ParseException;

/**
 * This interface can be implemented to create numbers of any object type.
 * By implementing this interface and calling the setNumberFactory() method of
 * the JEP class, the constants in an expression will be created with that
 * class.
 */
public interface NumberFactory {
	
	/**
	 * Creates a number object and initializes its value.
	 * @param value The initial value of the number as a string.
	 */
	public Object createNumber(String value) throws ParseException;
	/** Creates a number object with given double value. */
	public Object createNumber(double value) throws ParseException;
	/** Create a number object with given int value */
	public Object createNumber(int value) throws ParseException;
	/** Create a number object with given short value */
	public Object createNumber(short value) throws ParseException;
	/** Create a number object with given float value */
	public Object createNumber(float value) throws ParseException;
	/** Create a number object with given boolean value */
	public Object createNumber(boolean value) throws ParseException;
	/** Creates a number object from a class implementing Number,
	 * May actually just return the class. */
	public Object createNumber(Number value) throws ParseException;
	/** Create a number object with given Complex value */
	public Object createNumber(Complex value) throws ParseException;
	
	/** Return an object representing ZERO the additive identity. */
	public Object getZero();
	/** Return an object representing ONE the multiplicative identity. */
	public Object getOne();
	/** Return an object representing ZERO-ONE. */
	public Object getMinusOne();
	/** Return an object representing ONE+ONE. */
	public Object getTwo();
}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/


package  org.nfunk.jep.type;
import java.text.NumberFormat;

/**
 * Represents a complex number with double precision real and imaginary
 * components. Includes complex arithmetic functions.<p>
 * The two main sources of reference used for creating this class were:<br>
 * - "Numerical Recipes in C - The Art of Scientific Computing"
 *    (ISBN 0-521-43108-5) http://www.nr.com and <br>
 * - The org.netlib.math.complex package (http://www.netlib.org) which was 
 *   developed by Sandy Anderson and Priyantha Jayanetti (published under
 *   GPL).<p>
 * Some of the arithmetic functions in this class are based on the mathematical
 * equations given in the source of the netlib package. The functions were
 * validated by comparing results with the netlib complex class.<p>
 * It is important to note that the netlib complex package is more
 * extensive and efficient (e.g. Garbage collector friendly) than this
 * implementation. If high precision and efficiency if of necessity it is 
 * recommended to use the netlib package.
 *
 * @author Nathan Funk
 * @version 2.3.0 alpha now extends Number, has add and sub methods.
 * @version 2.3.0 beta 1 now overrides equals and hashCode.
/* @version 2.3.0 beta 2 does not implement Number anymore, as caused too many problems.
 */

public class Complex
{
	/** the real component */
	private double re;
	
	/** the imaginary component */
	private double im;
	

//------------------------------------------------------------------------
// Constructors

	/**
	 * Default constructor.
	 */
	public Complex() {
		re = 0;
		im = 0;
	}

	/**
	 * Constructor from a single double value. The complex number is
	 * initialized with the real component equal to the parameter, and
	 * the imaginary component equal to zero.
	 */
	public Complex(double re_in) {
		re = re_in;
		im = 0;
	}

	/**
	 * Construct from a Number. This constructor uses the doubleValue()
	 * method of the parameter to initialize the real component of the
	 * complex number. The imaginary component is initialized to zero.
	 */
	public Complex(Number re_in) {
		re = re_in.doubleValue();
		im = 0;
	}
	
	/**
	 * Copy constructor
	 */
	public Complex(Complex z) {
		re = z.re;
		im = z.im;
	}

	/**
	 * Initialize the real and imaginary components to the values given
	 * by the parameters.
	 */
	public Complex(double re_in, double im_in) {
		re = re_in;
		im = im_in;
	}

	/**
	 * Returns the real component of this object
	 */
	public double re() {
		return re;	
	}

	/**
	 * Returns the imaginary component of this object
	 */
	public double im() {
		return im;
	}
	
	/**
	 * Copies the values from the parameter object to this object
	 */
	public void set(Complex z) {
		re = z.re;
		im = z.im;
	}
	
	/**
	 * Sets the real and imaginary values of the object.
	 */
	public void set(double re_in, double im_in) {
		re = re_in;
		im = im_in;
	}

	/**
	 * Sets the real component of the object
	 */
	public void setRe(double re_in) {
		re = re_in;
	}

	/**
	 * Sets the imaginary component of the object
	 */
	public void setIm(double im_in) {
		im = im_in;
	}

//------------------------------------------------------------------------
// Various functions

	/**
	 * Compares this object with the Complex number given as parameter
	 * <pre>b</pre>. The <pre>tolerance</pre> parameter is the radius
	 * within which the <pre>b</pre> number must lie for the two
	 * complex numbers to be considered equal.
	 *
	 * @return <pre>true</pre> if the complex number are considered equal,
	 * <pre>false</pre> otherwise.
	 */
	public boolean equals(Complex b, double tolerance) {
		double temp1 = (re - b.re);
		double temp2 = (im - b.im);
		
		return (temp1*temp1 + temp2*temp2) <= tolerance*tolerance;
	}
	/**
	 * Compares this object against the specified object. 
	 * The result is true if and only if the argument is not null 
	 * and is a Complex object that represents the same complex number. 
	 * Equality follows the same pattern as Double aplies to each field:
	 * <ul>
     * <li>If d1 and d2 both represent Double.NaN, then the equals method returns true, even though Double.NaN==Double.NaN has the value false.
     * <li>If d1 represents +0.0 while d2 represents -0.0, or vice versa, the equal test has the value false, even though +0.0==-0.0 has the value true.
     * </ul>
     * This definition allows hash tables to operate properly.

	 * @since 2.3.0.2
	 */
	public boolean equals(Object o) {
		if(!(o instanceof Complex)) return false;
		Complex c = (Complex) o;
		return(Double.doubleToLongBits(this.re) == Double.doubleToLongBits(c.re) 
			&& Double.doubleToLongBits(this.im) == Double.doubleToLongBits(c.im));
	}
	/**
	 * Always override hashCode when you override equals.
	 * Efective Java, Joshua Bloch, Sun Press
	 */
	public int hashCode() {
		int result = 17;
		long xl = Double.doubleToLongBits(this.re);
		long yl = Double.doubleToLongBits(this.im);
		int xi = (int)(xl^(xl>>32));
		int yi = (int)(yl^(yl>>32));
		result = 37*result+xi;
		result = 37*result+yi;
		return result;
	}
	/**
	 * Returns the value of this complex number as a string in the format:
	 * <pre>(real, imaginary)</pre>.
	 */
	public String toString() {
		return "(" + re	+ ", " + im + ")";
	}

	public String toString(NumberFormat format)
	{
		return "(" + format.format(re) +", "+format.format(im)+")";	
	}
	
	/** Prints using specified number format in format or "2" or "3 i"
	 * or "(2+3 i)"  if flag is true
	 * or "2+3 i" if flag is false
	 */
	
	public String toString(NumberFormat format,boolean flag)
	{
		if(im == 0.0)
			return format.format(re);
		else if(re == 0.0)
			return format.format(im)+" i)";	
		else if(flag)
			return "(" + format.format(re) +"+"+format.format(im)+" i)";	
		else
			return format.format(re) +"+"+format.format(im)+" i";	
	}

	/**
	 * Returns <tt>true</tt> if either the real or imaginary component of this
	 * <tt>Complex</tt> is an infinite value.
	 *
	 * <p>
	 * @return  <tt>true</tt> if either component of the <tt>Complex</tt> object is infinite; <tt>false</tt>, otherwise.
	 * <p>
	 **/
	public boolean isInfinite() {
		return (Double.isInfinite(re) || Double.isInfinite(im));
	}

	/**
	 * Returns <tt>true</tt> if either the real or imaginary component of this
	 * <tt>Complex</tt> is a Not-a-Number (<tt>NaN</tt>) value.
	 *
	 * <p>
	 * @return  <tt>true</tt> if either component of the <tt>Complex</tt> object is <tt>NaN</tt>; <tt>false</tt>, otherwise.
	 * <p>
	 **/
	public boolean isNaN() {
		return (Double.isNaN(re) || Double.isNaN(im));
	}
	
	/**
	 * Returns the absolute value of the complex number.
	 * <p>
	 * Adapted from Numerical Recipes in C -
	 * The Art of Scientific Computing<br>
	 * ISBN 0-521-43108-5
	 */
	public double abs() {
		double absRe = Math.abs(re);
		double absIm = Math.abs(im);
		
		if (absRe == 0 && absIm == 0) {
			return 0;
		} else if (absRe>absIm) {
			double temp = absIm/absRe;
			return absRe*Math.sqrt(1 + temp*temp);	
		} else {
			double temp = absRe/absIm;
			return absIm*Math.sqrt(1 + temp*temp);
		}
	}

	/**
	 * Returns the square of the absolute value (re*re+im*im).
	 */
	public double abs2() {
		return re*re+im*im;	
	}

	/**
	 * Returns the argument of this complex number (Math.atan2(re,im))
	 */
	public double arg() {
		return Math.atan2(im,re);
	}

	/**
	 * Returns the negative value of this complex number.
	 */
	public Complex neg() {
		return new Complex(-re,-im);
	}

	/**
	 * Multiply the complex number with a double value.
	 * @return The result of the multiplication
	 */
	public Complex mul(double b) {
		return new Complex(re*b, im*b);
	}

	/**
	 * Adds the complex number with another complex value.
	 * @return The result of the addition
	 * @since 2.3.0.1
	 */
	public Complex add(Complex b) {
		return new Complex(re+b.re,im+b.im);
	}

	/**
	 * Adds the complex number with another complex value.
	 * @return The result of the addition
	 * @since 2.3.0.1
	 */
	public Complex sub(Complex b) {
		return new Complex(re-b.re,im-b.im);
	}
	/**
	 * Multiply the complex number with another complex value.
	 * @return The result of the multiplication
	 */
	public Complex mul(Complex b) {
		return new Complex(re*b.re - im*b.im,
						   im*b.re + re*b.im);
	}
	
	/**
	 * Returns the result of dividing this complex number by the parameter.
	 */
	public Complex div(Complex b) {
		// Adapted from Numerical Recipes in C - The Art of Scientific Computing
		// ISBN 0-521-43108-5
		double resRe, resIm;
		double r, den;
		
		if (Math.abs(b.re) >= Math.abs(b.im)) {
			r = b.im/b.re;
			den = b.re + r*b.im;
			resRe = (re+r*im)/den;
			resIm = (im-r*re)/den;
		} else {
			r = b.re/b.im;
			den = b.im + r*b.re;
			resRe = (re*r+im)/den;
			resIm = (im*r-re)/den;
		}
		
		return new Complex(resRe, resIm);
	}

	/**
	  * Returns the value of this complex number raised to the power
	  * of a real component (in double precision).<p>
	  * This method considers special cases where a simpler algorithm
	  * would return "ugly" results.<br>
	  * For example when the expression (-1e40)^0.5 is evaluated without
	  * considering the special case, the argument of the base is the
	  * double number closest to pi. When sin and cos are used for the
	  * final evaluation of the result, the slight difference of the
	  * argument from pi causes a non-zero value for the real component
	  * of the result. Because the value of the base is so high, the error
      * is magnified.Although the error is normal for floating 
	  * point calculations, the consideration of commonly occuring special
	  * cases improves the accuracy and aesthetics of the results.<p>
	  * If you know a more elegant way to solve this problem, please let
	  * me know at nathanfunk@hotmail.com .
	  */
	public Complex power(double exponent) {
		// z^exp = abs(z)^exp * (cos(exp*arg(z)) + i*sin(exp*arg(z)))
		double scalar = Math.pow(abs(),exponent);
		boolean specialCase = false;
		int factor = 0;

		// consider special cases to avoid floating point errors
		// for power expressions such as (-1e20)^2
		if (im==0 && re<0) {specialCase = true; factor = 2;}
		if (re==0 && im>0) {specialCase = true; factor = 1;}
		if (re==0 && im<0) {specialCase = true; factor = -1;}
		
		if (specialCase && factor*exponent == (int)(factor*exponent)) {
			short[] cSin = {0,1,0,-1}; //sin of 0, pi/2, pi, 3pi/2
			short[] cCos = {1,0,-1,0}; //cos of 0, pi/2, pi, 3pi/2
			
			int x = ((int)(factor*exponent))%4;
			if (x<0) x = 4+x;
			
			return new Complex(scalar*cCos[x], scalar*cSin[x]);
		}
		
		double temp = exponent * arg();
		
		return new Complex(scalar*Math.cos(temp), scalar*Math.sin(temp));
	}
	
	/**
	 * Returns the value of this complex number raised to the power of
	 * a complex exponent
	 */
	public Complex power(Complex exponent) {
		if (exponent.im == 0) return power(exponent.re);
		
		double temp1Re = Math.log(abs());
		double temp1Im = arg();
		
		double temp2Re = (temp1Re*exponent.re) - (temp1Im*exponent.im);
		double temp2Im = (temp1Re*exponent.im) + (temp1Im*exponent.re);

		double scalar = Math.exp(temp2Re);
		
		return new Complex(scalar*Math.cos(temp2Im), scalar*Math.sin(temp2Im));
	}
	/** Returns the complex conjugate. */
	public Complex conj() {
		return new Complex(re,-im);
	}
	/**
	 * Returns the logarithm of this complex number.
	 */	
	public Complex log() {
		return new Complex(Math.log(abs()), arg());	
	}
	
	/**
	 * Calculates the square root of this object.
	 * Adapted from Numerical Recipes in C - The Art of Scientific Computing
	 * (ISBN 0-521-43108-5)
	 */
	public Complex sqrt() {
		Complex c;
		double absRe,absIm,w,r;
		
		if (re == 0 && im == 0) {
			c = new Complex(0,0);
		} else {
			absRe = Math.abs(re);
			absIm = Math.abs(im);
			
			if (absRe>=absIm) {
				r = absIm/absRe;
				w = Math.sqrt(absRe)*Math.sqrt(0.5*(1.0+Math.sqrt(1.0+r*r)));
			} else {
				r = absRe/absIm;
				w = Math.sqrt(absIm)*Math.sqrt(0.5*(r  +Math.sqrt(1.0+r*r)));
			}
			
			if (re>=0) {
				c = new Complex(w, im/(2.0*w));
			} else {
				if (im<0) w = -w;
				c = new Complex(im/(2.0*w), w);
			}
		}
		
		return c;
	}

//------------------------------------------------------------------------
// Trigonometric functions

	/**
	 * Returns the sine of this complex number.
	 */
	public Complex sin() {
		double izRe, izIm;
		double temp1Re, temp1Im;
		double temp2Re, temp2Im;
		double scalar;
		
		//  sin(z)  =  ( exp(i*z) - exp(-i*z) ) / (2*i)
		izRe = -im;
		izIm =  re;
		
		// first exp
		scalar = Math.exp(izRe);
		temp1Re = scalar * Math.cos(izIm);
		temp1Im = scalar * Math.sin(izIm);
		
		// second exp
		scalar = Math.exp(-izRe);
		temp2Re = scalar * Math.cos(-izIm);
		temp2Im = scalar * Math.sin(-izIm);
		
		temp1Re -= temp2Re;
		temp1Im -= temp2Im;
		
		return new Complex(0.5*temp1Im, -0.5*temp1Re);
	}

	/**
	 * Returns the cosine of this complex number.
	 */
	public Complex cos() {
		double izRe, izIm;
		double temp1Re, temp1Im;
		double temp2Re, temp2Im;
		double scalar;
		
		//  cos(z)  =  ( exp(i*z) + exp(-i*z) ) / 2
		izRe = -im;
		izIm =  re;
		
		// first exp
		scalar = Math.exp(izRe);
		temp1Re = scalar * Math.cos(izIm);
		temp1Im = scalar * Math.sin(izIm);
		
		// second exp
		scalar = Math.exp(-izRe);
		temp2Re = scalar * Math.cos(-izIm);
		temp2Im = scalar * Math.sin(-izIm);
		
		temp1Re += temp2Re;
		temp1Im += temp2Im;
		
		return new Complex(0.5*temp1Re, 0.5*temp1Im);
	}


	/**
	 * Returns the tangent of this complex number.
	 */
	public Complex tan() {
		// tan(z) = sin(z)/cos(z)
		double izRe, izIm;
		double temp1Re, temp1Im;
		double temp2Re, temp2Im;
		double scalar;
		Complex sinResult, cosResult;
		
		//  sin(z)  =  ( exp(i*z) - exp(-i*z) ) / (2*i)
		izRe = -im;
		izIm =  re;
		
		// first exp
		scalar = Math.exp(izRe);
		temp1Re = scalar * Math.cos(izIm);
		temp1Im = scalar * Math.sin(izIm);
		
		// second exp
		scalar = Math.exp(-izRe);
		temp2Re = scalar * Math.cos(-izIm);
		temp2Im = scalar * Math.sin(-izIm);
		
		temp1Re -= temp2Re;
		temp1Im -= temp2Im;
		
		sinResult = new Complex(0.5*temp1Re, 0.5*temp1Im);

		//  cos(z)  =  ( exp(i*z) + exp(-i*z) ) / 2
		izRe = -im;
		izIm =  re;
		
		// first exp
		scalar = Math.exp(izRe);
		temp1Re = scalar * Math.cos(izIm);
		temp1Im = scalar * Math.sin(izIm);
		
		// second exp
		scalar = Math.exp(-izRe);
		temp2Re = scalar * Math.cos(-izIm);
		temp2Im = scalar * Math.sin(-izIm);
		
		temp1Re += temp2Re;
		temp1Im += temp2Im;
		
		cosResult = new Complex(0.5*temp1Re, 0.5*temp1Im);
		
		return sinResult.div(cosResult);
	}
	

//------------------------------------------------------------------------
// Inverse trigonometric functions
	
	public Complex asin() {
		Complex result;
		double tempRe, tempIm;
		
		//  asin(z)  =  -i * log(i*z + sqrt(1 - z*z))

		tempRe =  1.0 - ( (re*re) - (im*im) );
		tempIm =  0.0 - ( (re*im) + (im*re) );

		result =  new Complex(tempRe, tempIm);
		result = result.sqrt();
		
		result.re += -im;
		result.im +=  re;
		
		tempRe = Math.log(result.abs());
		tempIm = result.arg();
		
		result.re =   tempIm;
		result.im = - tempRe;
		
		return result;
	}

	public Complex acos() {
		Complex result;
		double tempRe, tempIm;
		
		//  acos(z)  =  -i * log( z + i * sqrt(1 - z*z) )

		tempRe =  1.0 - ( (re*re) - (im*im) );
		tempIm =  0.0 - ( (re*im) + (im*re) );

		result =  new Complex(tempRe, tempIm);
		result = result.sqrt();
		
		tempRe = -result.im;
		tempIm =  result.re;
		
		result.re = re + tempRe;
		result.im = im + tempIm;
		
		tempRe = Math.log(result.abs());
		tempIm = result.arg();
		
		result.re =   tempIm;
		result.im = - tempRe;
		
		return result;
	}

	public Complex atan() {
		// atan(z) = -i/2 * log((i-z)/(i+z))
		
		double tempRe, tempIm;
		Complex result = new Complex(-re, 1.0 - im);
		
		tempRe = re;
		tempIm = 1.0 + im;
		
		result = result.div(new Complex(tempRe, tempIm));
		
		tempRe = Math.log(result.abs());
		tempIm = result.arg();
		
		result.re =  0.5*tempIm;
		result.im = -0.5*tempRe;
		
		return result;
	}


//------------------------------------------------------------------------
// Hyperbolic trigonometric functions

	public Complex sinh() {
		double scalar;
		double temp1Re, temp1Im;
		double temp2Re, temp2Im;
		//  sinh(z)  =  ( exp(z) - exp(-z) ) / 2
		
		// first exp
		scalar = Math.exp(re);
		temp1Re = scalar * Math.cos(im);
		temp1Im = scalar * Math.sin(im);
		
		// second exp
		scalar = Math.exp(-re);
		temp2Re = scalar * Math.cos(-im);
		temp2Im = scalar * Math.sin(-im);
		
		temp1Re -= temp2Re;
		temp1Im -= temp2Im;
		
		return new Complex(0.5*temp1Re, 0.5*temp1Im);
	}


	public Complex cosh() {
		double scalar;
		double temp1Re, temp1Im;
		double temp2Re, temp2Im;
		//  cosh(z)  =  ( exp(z) + exp(-z) ) / 2
		
		// first exp
		scalar = Math.exp(re);
		temp1Re = scalar * Math.cos(im);
		temp1Im = scalar * Math.sin(im);
		
		// second exp
		scalar = Math.exp(-re);
		temp2Re = scalar * Math.cos(-im);
		temp2Im = scalar * Math.sin(-im);
		
		temp1Re += temp2Re;
		temp1Im += temp2Im;
		
		return new Complex(0.5*temp1Re, 0.5*temp1Im);
	}

	public Complex tanh() {
		double scalar;
		double temp1Re, temp1Im;
		double temp2Re, temp2Im;
		Complex sinRes, cosRes;
		//  tanh(z)  =  sinh(z) / cosh(z)

		scalar = Math.exp(re);
		temp1Re = scalar * Math.cos(im);
		temp1Im = scalar * Math.sin(im);
		
		scalar = Math.exp(-re);
		temp2Re = scalar * Math.cos(-im);
		temp2Im = scalar * Math.sin(-im);
		
		temp1Re -= temp2Re;
		temp1Im -= temp2Im;
		
		sinRes = new Complex(0.5*temp1Re, 0.5*temp1Im);

		scalar = Math.exp(re);
		temp1Re = scalar * Math.cos(im);
		temp1Im = scalar * Math.sin(im);
		
		scalar = Math.exp(-re);
		temp2Re = scalar * Math.cos(-im);
		temp2Im = scalar * Math.sin(-im);
		
		temp1Re += temp2Re;
		temp1Im += temp2Im;
		
		cosRes = new Complex(0.5*temp1Re, 0.5*temp1Im);
		
		return sinRes.div(cosRes);
	}

	
//------------------------------------------------------------------------
// Inverse hyperbolic trigonometric functions

	public Complex asinh() {
		Complex result;
		//  asinh(z)  =  log(z + sqrt(z*z + 1))

		result = new Complex(
			((re*re) - (im*im)) + 1,
			(re*im) + (im*re));

		result = result.sqrt();
		
		result.re += re;
		result.im += im;
		
		double temp = result.arg();
		result.re = Math.log(result.abs());
		result.im = temp;
		
		return result;
	}

	public Complex acosh() {
		Complex result;
		
		//  acosh(z)  =  log(z + sqrt(z*z - 1))

		result = new Complex(
			((re*re) - (im*im)) - 1,
			(re*im) + (im*re));

		result = result.sqrt();
		
		result.re += re;
		result.im += im;
		
		double temp = result.arg();
		result.re = Math.log(result.abs());
		result.im = temp;
		
		return result;
	}

	public Complex atanh() {
		//  atanh(z)  =  1/2 * log( (1+z)/(1-z) )
		
		double tempRe, tempIm;
		Complex result = new Complex(1.0 + re, im);
		
		tempRe = 1.0 - re;
		tempIm =     - im;
		
		result = result.div(new Complex(tempRe, tempIm));
		
		tempRe = Math.log(result.abs());
		tempIm = result.arg();
		
		result.re = 0.5*tempRe;
		result.im = 0.5*tempIm;
		
		return result;
	}

	/**
	 * Converts an [r,theta] pair to a complex number r * e^(i theta).
	 * @param r The radius
	 * @param theta The angle
	 * @return The complex result.
	 * @since 2.3.0.1
	 */
	public static Complex polarValueOf(Number r,Number theta)
	{
		double rad = r.doubleValue();
		double ang = theta.doubleValue();
		return new Complex(rad*Math.cos(ang), rad*Math.sin(ang));
		
	}
	/** Returns real part.
	 * @since 2.3.0.1
	 */
	public double doubleValue() {
		return re;
	}

	/** Returns real part.
	 * @since 2.3.0.1
	 */
	public float floatValue() {
		return (float) re;
	}

	/** Returns real part.
	 * @since 2.3.0.1
	 */
	public int intValue() {
		return (int) re;
	}

	/** Returns real part.
	 * @since 2.3.0.1
	 */
	public long longValue() {
		return (long) re;
	}

}
/*****************************************************************************

@header@
@date@
@copyright@
@license@

*****************************************************************************/

package org.nfunk.jep.type;

import org.nfunk.jep.ParseException;

/**
 * Default class for creating number objects. This class can be replaced by
 * other NumberFactory implementations if other number types are required. This
 * can be done using the 
 */
public class DoubleNumberFactory implements NumberFactory {
	public static Double ZERO = new Double(0.0);
	public static Double ONE = new Double(1.0);
	public static Double TWO = new Double(2.0);
	public static Double MINUSONE = new Double(-1.0);
	
	/**
	 * Creates a Double object initialized to the value of the parameter.
	 *
	 * @param value The initialization value for the returned object.
	 */
	public Object createNumber(String value) {	return new Double(value);	}
	public Object createNumber(double value) {	return new Double(value);	}
	public Object createNumber(Number value) {	return value;	}
	public Object createNumber(boolean value) { return (value?ONE:ZERO); }
	public Object createNumber(float value) {return new Double(value);	}
	public Object createNumber(int value) {return new Double(value);	}
	public Object createNumber(short value) {return new Double(value);	}
	public Object createNumber(Complex value)  throws ParseException {
		throw new ParseException("Cannot create a number from a Complex value");	
	}
	public Object getMinusOne() {return MINUSONE;}
	public Object getOne() {return ONE;}
	public Object getTwo() {return TWO;}
	public Object getZero() {return ZERO;}
}
