package edu.umd.cs.dmonner.tweater;

/**
 * A <code>QueryItem</code> that matches on the user ID of the originator of the <code>Status</code>
 * .
 * 
 * @author dmonner
 */
public class QueryFollow extends QueryItem
{
	private static final long serialVersionUID = 1L;

	/**
	 * The user ID whose <code>Status</code>es this object will match.
	 */
	public final long userid;

	/**
	 * Creates a new <code>QueryFollow</code> with the given group number, unique ID, and the user ID
	 * of the user we wish to follow.
	 * 
	 * @param group
	 * @param id
	 * @param userid
	 */
	public QueryFollow(final int group, final long id, final int userid)
	{
		super(Type.FOLLOW, group, id);
		this.userid = userid;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#compareTo(tweater.QueryItem)
	 */
	@Override
	public int compareTo(final QueryItem that)
	{
		int result;

		result = super.compareTo(that);
		if(result != 0)
			return result;

		return (int) (this.userid - ((QueryFollow) that).userid);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(final Object other)
	{
		boolean result;

		result = super.equals(other);
		if(!result)
			return result;

		return this.userid == ((QueryFollow) other).userid;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#hashCode()
	 */
	@Override
	public int hashCode()
	{
		return super.hashCode() + (int) userid;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#matches(tweater.MatchableStatus)
	 */
	@Override
	public boolean matches(final MatchableStatus status)
	{
		return status.status.getUser().getId() == userid;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString()
	{
		return String.valueOf(userid);
	}
}
package edu.umd.cs.dmonner.tweater;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import twitter4j.Status;

/**
 * Classes implementing this interface are responsible for receiving <code>Status</code> objects via
 * <code>process</code>, performing any desired preprocessing on them, and transferring them to
 * long-term storage. Optionally, tweets and location information should be removed (per user
 * request) if the <code>delete</code> or <code>scrubGeo</code> methods are called.
 * 
 * @author dmonner
 */
public interface StatusEater
{
	/**
	 * Adds a <code>QueryItem</code> to the list of items that this <code>StatusEater</code> cares
	 * about.
	 * 
	 * @param item
	 */
	public void addItem(QueryItem item);

	/**
	 * Adds several <code>QueryItem</code>s to the list of items that this <code>StatusEater</code>
	 * cares about.
	 * 
	 * @param item
	 */
	public void addItems(Collection<? extends QueryItem> items);

	/**
	 * Empties this <code>StatusEater</code>'s list of <code>QueryItems</code>.
	 */
	public void clearItems();

	/**
	 * Remotes a specific <code>QueryItem</code> from the list of items that this
	 * <code>StatusEater</code> cares about.
	 * 
	 * @param item
	 */
	public void delItem(QueryItem item);

	public Set<QueryItem> getQuery();

	/**
	 * Instructs this <code>StatusEater</code> to persist the given <code>Status</code>, possibly
	 * including which <code>QueryItem</code>s were matched. The method of persistent storage (for
	 * example, a database or a text file) is chosen by the implementing class.
	 * 
	 * @param matches
	 * @param status
	 */
	public void persist(List<QueryItem> matches, Status status);

	/**
	 * Instructs this <code>StatusEater</code> to match the given <code>Status</code> against its list
	 * of <code>QueryItem</code>s to see which match, and then pass the results along to
	 * <code>persist</code>.
	 * 
	 * @param status
	 */
	public void process(Status status);
}
package edu.umd.cs.dmonner.tweater;

import java.rmi.Remote;
import java.rmi.RemoteException;

/**
 * The interface with which another process can control a running TwEater instance.
 * 
 * @author dmonner
 */
public interface TwEaterControl extends Remote
{
	/**
	 * @return <code>true</code> iff this TwEater instance is currently collecting data from Twitter
	 *         (and not merely working through its backlog)
	 * @throws RemoteException
	 *           If a network error occurs
	 */
	public boolean collecting() throws RemoteException;

	/**
	 * @return The fraction of possible memory this TwEater instance is currently using.
	 * @throws RemoteException
	 *           If a network error occurs
	 */
	public float memory() throws RemoteException;

	/**
	 * Instructs this TwEater instance to cease collection from Twitter (though it can continue
	 * working through its backlog).
	 * 
	 * @throws RemoteException
	 *           If a network error occurs
	 */
	public void shutdown() throws RemoteException;

	/**
	 * @return The number of statuses in this TwEater instance's backlog
	 * @throws RemoteException
	 *           If a network error occurs
	 */
	public int size() throws RemoteException;
}
package edu.umd.cs.dmonner.tweater;

import twitter4j.Status;

/**
 * A wrapper for a <code>Status</code> that makes certain attributes easier to match against
 * <code>QueryItem</code>s. This is done by copying the status text, lowercasing it, and removing
 * newlines.
 * 
 * @author dmonner
 */
public class MatchableStatus
{
	/**
	 * The original status
	 */
	public final Status status;
	/**
	 * The modified status text, suitable for matching.
	 */
	public final String text;

	public MatchableStatus(final Status status)
	{
		this.status = status;
		this.text = status.getText().toLowerCase().replaceAll("\n", " ");
	}
}
package edu.umd.cs.dmonner.tweater;

import java.util.Collection;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.TreeSet;
import java.util.logging.Logger;

import twitter4j.FilterQuery;
import twitter4j.TwitterStream;
import edu.umd.cs.dmonner.tweater.util.Util;

/**
 * The main point of contact with the Twitter Streaming API. It handles connecting to the API, and
 * then sends all pertinent info to every <code>StatusQueue</code> that was registered via the
 * <code>addServer</code> method.
 * 
 * This class periodically asks the supplied <code>QueryBuilder</code> for the current query, and
 * handles re-connecting to the Twitter Streaming API if the query is out of date.
 * 
 * @author dmonner
 */
public class Querier extends Thread
{
	/**
	 * Identifier specifying the log file to use
	 */
	private final String id;
	/**
	 * List of queues to which to send statuses
	 */
	private final List<StatusQueue> queues;
	/**
	 * The connection to Twitter
	 */
	private final TwitterStream tw;
	/**
	 * The collection of track keywords
	 */
	private String[] track;
	/**
	 * The collection of user IDs to follow
	 */
	private long[] follow;
	/**
	 * The minimum amount of time (ms) allowed between each request to Twitter for a change in the
	 * query
	 */
	private static final long MIN_INTERVAL = 1 * 60 * 1000;
	/**
	 * Reference to the query builder
	 */
	private final QueryBuilder builder;
	/**
	 * Collection of active query items
	 */
	private TreeSet<QueryItem> active;
	/**
	 * Collection of query items added since the last update; for logging purposes
	 */
	private final TreeSet<QueryItem> added;
	/**
	 * Collection of query items removed since the last update; for logging purposes
	 */
	private final TreeSet<QueryItem> removed;
	/**
	 * The time (in ms since the epoch) when the query was last sent to Twitter
	 */
	private long lastUpdate;
	/**
	 * Whether or not we need to send a new query to Twitter at the next opportunity
	 */
	private boolean needsUpdate;
	/**
	 * Whether or not we are shut down (permanently disconnected for this session)
	 */
	private boolean shutdown;

	private final Logger log;

	public Querier(final String id, final TwitterStream tw, final QueryBuilder qb)
	{
		this.id = id;
		this.queues = new LinkedList<StatusQueue>();

		this.tw = tw;
		this.track = new String[0];
		this.follow = new long[0];

		this.builder = qb;
		this.active = new TreeSet<QueryItem>();
		this.added = new TreeSet<QueryItem>();
		this.removed = new TreeSet<QueryItem>();

		this.lastUpdate = -MIN_INTERVAL;
		this.needsUpdate = true;
		this.shutdown = false;

		this.log = Logger.getLogger(id);
	}

	/**
	 * Adds a <code>QueryItem</code> to this querier, as well as all associated queues.
	 * 
	 * @param item
	 */
	protected void addItem(final QueryItem item)
	{
		added.add(item);
		for(final StatusQueue server : queues)
			server.addItem(item);
	}

	/**
	 * Adds a new queue which will receive all statuses that this querier receives.
	 * 
	 * @param queue
	 */
	public void addQueue(final StatusQueue queue)
	{
		queues.add(queue);
		tw.addListener(queue);
	}

	/**
	 * Connects to the Twitter Streaming API with the current query. If this querier has been marked
	 * as shut down, this method does nothing.
	 */
	public void connect()
	{
		if(!shutdown && (track.length > 0 || follow.length > 0))
		{
			final FilterQuery fq = new FilterQuery();
			fq.track(track);
			fq.follow(follow);
			log.info("Querier connecting: " + this.toString());
			log.info("+" + added);
			log.info("-" + removed);
			added.clear();
			removed.clear();
			tw.filter(fq);
		}
	}

	/**
	 * Removes a specific <code>QueryItem</code> from this querier, as well as all associated queues.
	 * 
	 * @param item
	 */
	protected void delItem(final QueryItem item)
	{
		removed.add(item);
		for(final StatusQueue server : queues)
			server.delItem(item);
	}

	/**
	 * Disconnects from the Twitter Streaming API.
	 */
	public void disconnect()
	{
		tw.cleanUp();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Thread#run()
	 */
	@Override
	public void run()
	{
		// Loop until we are shut down, periodically asking the QueryBuilder if the query has been
		// updated
		while(!shutdown)
		{
			synchronized(this)
			{
				final long now = new Date().getTime();
				final TreeSet<QueryItem> current = builder.at(now);

				log.finest("Queryier.run():");
				log.finest("active query: " + active);
				log.finest("new query: " + current);

				// compare the "current" tree to the "active" tree
				final TreeSet<QueryItem> toAdd = new TreeSet<QueryItem>(current);
				toAdd.removeAll(active);

				final TreeSet<QueryItem> toRemove = new TreeSet<QueryItem>(active);
				toRemove.removeAll(current);

				// if there are differences
				if(!toAdd.isEmpty() || !toRemove.isEmpty())
				{
					// set the flag to disconnect/update query/reconnect
					needsUpdate = true;

					// set the active set to reflect the new current set
					active = current;

					// send the change deltas to all servers
					for(final QueryItem qi : toAdd)
						addItem(qi);

					for(final QueryItem qi : toRemove)
						delItem(qi);
				}

				// if we need to update, and it's been long enough since the last update
				if(needsUpdate && now > lastUpdate + MIN_INTERVAL)
				{
					setQuery(active);
					lastUpdate = now;
					needsUpdate = false;
				}
			}

			// Wait a while before starting the loop again
			try
			{
				Thread.sleep((int) (2000.0 + Math.random() * 1000.0));
			}
			catch(final InterruptedException ex)
			{
				Logger.getLogger(id).severe(Util.traceMessage(ex));
			}
		}

		Logger.getLogger(id).info("Querier shut down.");
	}

	/**
	 * Replaces the current query with one defined by the given collection. Disconnects from Twitter
	 * if necessary and immediately reconnects with the new query.
	 * 
	 * @param items
	 */
	public void setQuery(final Collection<QueryItem> items)
	{
		final List<String> tracks = new LinkedList<String>();
		final List<Long> follows = new LinkedList<Long>();

		for(final QueryItem item : items)
			if(item instanceof QueryTrack)
				tracks.add(((QueryTrack) item).string);
			else if(item instanceof QueryPhrase)
				tracks.add(((QueryPhrase) item).string);
			else if(item instanceof QueryFollow)
				follows.add(((QueryFollow) item).userid);

		track = tracks.toArray(new String[tracks.size()]);
		follow = new long[follows.size()];
		int i = 0;
		for(final long userid : follows)
			follow[i++] = userid;

		disconnect();
		connect();
	}

	/**
	 * Shuts down this querier, disconnecting it permanently from Twitter.
	 */
	public void shutdown()
	{
		shutdown = true;
		disconnect();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Thread#toString()
	 */
	@Override
	public String toString()
	{
		final StringBuilder sb = new StringBuilder();

		sb.append("{Track&Phrase=");

		sb.append("[");

		if(track.length > 0)
			sb.append(track[0]);

		for(int i = 1; i < track.length; i++)
		{
			sb.append(", ");
			sb.append(track[i]);
		}

		sb.append("]");

		sb.append(", Follow=");

		sb.append("[");

		if(follow.length > 0)
			sb.append(follow[0]);

		for(int i = 1; i < follow.length; i++)
		{
			sb.append(", ");
			sb.append(follow[i]);
		}

		sb.append("]");

		sb.append("}");

		return sb.toString();
	}
}
package edu.umd.cs.dmonner.tweater;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.TreeSet;
import java.util.logging.Logger;

import edu.umd.cs.dmonner.tweater.util.Properties;
import edu.umd.cs.dmonner.tweater.util.Util;

/**
 * This class builds a set of query phrases that are currently active based on an external data
 * source. The data source should specify what all query phrases to be collected, as well as their
 * start and end times. This class runs the <code>update</code> method once per hour in order to
 * re-sync with the data source, as that is where query changes should be made.
 * 
 * @author dmonner
 */
public abstract class QueryBuilder extends Thread
{
	/**
	 * The identifier of the log file
	 */
	protected final String id;
	/**
	 * The interval (ms) between updates from the data source
	 */
	protected final long buildInterval;
	/**
	 * The time (in ms since the epoch) at which we should next update the query from the data source
	 */
	protected long nextUpdate;
	/**
	 * If <code>true</code>, we should stop updating
	 */
	protected boolean shutdown;
	/**
	 * Parallel-indexed with <code>times</code>. The idea is that the <code>times</code> list contains
	 * all the times at which the query changes. The first index is when the first query begins, and
	 * the last index is when the last query ends. If the current time is between
	 * <code>times[i]</code> and <code>times[i+1]</code>, the current set of query phrases will be in
	 * <code>queries[i+1]</code>. <code>queries[0]</code> should always contain an empty set of
	 * queries, to be returned before/after the time bounds.
	 * 
	 * Both of these data structures should be built from the data source, from scratch, every time
	 * the <code>update</code> method is called.
	 */
	protected final ArrayList<TreeSet<QueryItem>> queries;
	/**
	 * Parallel-indexed with <code>queries</code>; see that variable's description.
	 */
	protected final ArrayList<Long> times;
	/**
	 * The log file
	 */
	protected final Logger log;

	public QueryBuilder(final String id, final Properties props)
	{
		this.id = id;
		this.log = Logger.getLogger(id);
		this.buildInterval = props.getIntegerProperty("tweater.builder.interval") * 1000;
		this.times = new ArrayList<Long>();
		this.queries = new ArrayList<TreeSet<QueryItem>>();
		this.nextUpdate = 0; // always update right away
		this.shutdown = false;
	}

	/**
	 * Based on the information from the data source, constructs the query that would be active at the
	 * specified time.
	 * 
	 * @param time
	 * @return The query active at the given time
	 */
	public TreeSet<QueryItem> at(final long time)
	{
		synchronized(queries)
		{
			if(times.isEmpty())
				return new TreeSet<QueryItem>();

			// if the time is less than the first entry in the array, query is empty (queries[0])
			if(time < times.get(0))
				return queries.get(0);

			// otherwise, search array for the appropriate slot by finding first time greater
			for(int i = 1; i < times.size(); i++)
				if(time < times.get(i))
					return queries.get(i);

			// otherwise, time > biggest time, so query is empty (queries[0])
			return queries.get(0);
		}
	}

	/**
	 * @return The next time (ms since the epoch) that we need to update the query
	 */
	protected long calculateNextUpdate()
	{
		return ((new Date().getTime() / buildInterval) + 1) * buildInterval;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Thread#run()
	 */
	@Override
	public void run()
	{
		// Main loop periodically updates the query from the data source
		while(!shutdown)
		{
			if(new Date().getTime() > nextUpdate)
			{
				final List<QueryItemTime> all = update();
				if(all != null)
					set(all);
				nextUpdate = calculateNextUpdate();
			}

			// Wait a while before starting the loop again
			try
			{
				Thread.sleep((int)(5000.0 + Math.random() * 1000.0));
			}
			catch(final InterruptedException ex)
			{
				Logger.getLogger(id).severe(Util.traceMessage(ex));
			}
		}

		Logger.getLogger(id).info("QueryBuilder shut down.");
	}

	/**
	 * Uses the most recent query information from the data source to intelligently update the query
	 * builder's timeline.
	 * 
	 * @param all
	 *          The most recent query information from the data source
	 */
	public void set(final List<QueryItemTime> all)
	{
		synchronized(queries)
		{
			final TreeSet<Long> alltimes = new TreeSet<Long>();
			for(final QueryItemTime qpt : all)
			{
				alltimes.add(qpt.startTime);
				alltimes.add(qpt.endTime);
			}
			times.clear();
			times.addAll(alltimes);

			queries.clear();
			for(int i = 0; i < times.size(); i++)
				queries.add(new TreeSet<QueryItem>());

			for(final QueryItemTime qpt : all)
				for(int i = 0; i < times.size(); i++)
					if(qpt.startTime <= times.get(i) && times.get(i) < qpt.endTime)
						queries.get(i + 1).add(qpt.item);
		}
	}

	/**
	 * Instructs the query builder to stop checking the data source for query updates
	 */
	public void shutdown()
	{
		shutdown = true;
	}

	/**
	 * Reads all query information from the data source and returns it, without regard to the
	 * information that the query builder currently knows; this will be computed by <code>set</code>
	 * separately.
	 * 
	 * @return A list of query items and associated times, fresh from the data source.
	 */
	public abstract List<QueryItemTime> update();
}
package edu.umd.cs.dmonner.tweater;

import java.util.Calendar;
import java.util.Date;
import java.util.Set;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

import javax.mail.MessagingException;

import twitter4j.StallWarning;
import twitter4j.Status;
import twitter4j.StatusDeletionNotice;
import twitter4j.StatusListener;
import edu.umd.cs.dmonner.tweater.util.AlertEmailer;
import edu.umd.cs.dmonner.tweater.util.LogDiffKeeper;
import edu.umd.cs.dmonner.tweater.util.Properties;
import edu.umd.cs.dmonner.tweater.util.Util;

/**
 * This class is an intermediary between a <code>Querier</code> and a <code>StatusEater</code> that
 * uses a thread pool to allow many statuses to be persisted in parallel. The queue holding statuses
 * to be processed may grow without bound, limited only by available memory allocated to the JVM.
 * The queue can be configured to produce periodic log and email messages about the state of the
 * queue, such as the number of statuses that have been track-limited (due to an overly broad
 * Twitter query), the fraction of available memory in use, and the number of statuses that have
 * been rejected to prevent resource over-utilization.
 * 
 * @author dmonner
 */
public class StatusQueue extends Thread implements StatusListener
{
	/**
	 * The thread pool allowing statuses to be processed in parallel
	 */
	private final ThreadPoolExecutor pool;
	/**
	 * The class that processes and persists statuses
	 */
	private final StatusEater eater;
	/**
	 * The destination for email alert messages
	 */
	private final AlertEmailer alert;
	/**
	 * The log file
	 */
	private final Logger log;
	/**
	 * The log handler that keeps log diffs used in status messages
	 */
	private final LogDiffKeeper logdiff;
	/**
	 * The name of the host machine
	 */
	private final String host = Util.getHost();
	/**
	 * The total number of rejected executions so far
	 */
	private int rejectedExecutions = 0;
	/**
	 * The last time (in ms since the epoch) that a rejected-executions message was logged; used to
	 * prevent log spamming
	 */
	private long rejectionMessageLastUpdate = 0;
	/**
	 * <code>true</code> iff we need to log a rejected-executions message the next time we are able
	 */
	private boolean rejectionMessageNeedsUpdate = false;
	/**
	 * The minimum interval (ms) between logging rejected-executions messages
	 */
	private final int rejectionMessageInterval;
	/**
	 * The last time (in ms since the epoch) that a status message was sent via email
	 */
	private long statusEmailNextUpdate = 0;
	/**
	 * The interval (ms) between emailing status messages
	 */
	private final int statusEmailInterval;
	/**
	 * The last time (in ms since the epoch) that a rejected-executions message was sent via email;
	 * used to prevent email spamming
	 */
	private long rejectionEmailLastUpdate = 0;
	/**
	 * <code>true</code> iff we need to email a rejected-executions message the next time we are able
	 */
	private boolean rejectionEmailNeedsUpdate = false;
	/**
	 * The minimum interval (ms) between emailing rejected-executions messages
	 */
	private final int rejectionEmailInterval;
	/**
	 * The total number of track limitations so far
	 */
	private int trackLimitations = 0;
	/**
	 * Twitter sometimes loses the track limitation count if you disconnect. If we detect that
	 * happening, we put the previous total here to add into the reported total.
	 */
	private int previousTrackLimitations = 0;
	/**
	 * The last time (in ms since the epoch) that a track-limitations message was logged; used to
	 * prevent log spamming
	 */
	private long trackLimitMessageLastUpdate = 0;
	/**
	 * <code>true</code> iff we need to log a track-limitations message the next time we are able
	 */
	private boolean trackLimitMessageNeedsUpdate = false;
	/**
	 * The minimum interval (ms) between logging rejected-executions messages
	 */
	private final int trackLimitMessageInterval;
	/**
	 * The threshold, as a fraction of available memory, at and above which we explicitly reject new
	 * additions to the queue so as to prevent <code>OutOfMemoryError</code>s.
	 */
	private final float resourceLimitRejectionThreshold;
	/**
	 * The threshold, as a fraction of available memory, at and above which we periodically log a
	 * resource limitation message. After reaching this threshold, we will also log the first instance
	 * when we fall back below the threshold.
	 */
	private final float resourceLimitMessageThreshold;
	/**
	 * The last time (in ms since the epoch) that a resource-limitations message was logged; used to
	 * prevent log spamming
	 */
	private long resourceLimitMessageLastUpdate = 0;
	/**
	 * <code>true</code> iff we need to email a resource-limitations message the next time we are able
	 */
	private boolean resourceLimitMessageNeedsUpdate = false;
	/**
	 * The minimum interval (ms) between logging resource-limitations messages
	 */
	private final int resourceLimitMessageInterval;
	/**
	 * The threshold, as a fraction of available memory, at and above which we periodically email a
	 * resource limitation message. After reaching this threshold, we will also email at the first
	 * instance when we fall back below the threshold.
	 */
	private final float resourceLimitEmailThreshold;
	/**
	 * The last time (in ms since the epoch) that a resource-limitations message was sent via email;
	 * used to prevent email spamming
	 */
	private long resourceLimitEmailLastUpdate = 0;
	/**
	 * <code>true</code> iff we need to email a resource-limitations message the next time we are able
	 */
	private boolean resourceLimitEmailNeedsUpdate = false;
	/**
	 * The minimum interval (ms) between emailing resource-limitations messages
	 */
	private final int resourceLimitEmailInterval;

	/**
	 * Creates a new status queue using the given properties.
	 * 
	 * @param id
	 *          The ID of the log file to use
	 * @param eater
	 *          The consumer of statuses
	 * @param prop
	 *          The TwEater configuration
	 * @param alert
	 *          The destination for email alerts
	 */
	public StatusQueue(final String id, final StatusEater eater, final Properties prop,
			final AlertEmailer alert)
	{
		this.eater = eater;
		this.alert = alert;
		log = Logger.getLogger(id);
		logdiff = new LogDiffKeeper();
		log.addHandler(logdiff);
		log.info("Initializing StatusQueue.");

		// -- Create an unbounded Executor queue with appropriate parameters

		pool = new ThreadPoolExecutor( //
				prop.getIntegerProperty("tweater.queue.coreThreads"), // in threads
				prop.getIntegerProperty("tweater.queue.maxThreads"), // in threads
				prop.getIntegerProperty("tweater.queue.idleTimeout"), // in s
				TimeUnit.SECONDS, //
				new LinkedBlockingQueue<Runnable>());

		// -- Read in properties about status emails and set up the times

		final int statusEmailHour = prop.getIntegerProperty("tweater.queue.statusEmailHour");
		statusEmailInterval = 1000 * prop.getIntegerProperty("tweater.queue.statusEmailInterval");
		final Calendar first = Calendar.getInstance();
		first.set(Calendar.AM_PM, statusEmailHour < 12 ? Calendar.AM : Calendar.PM);
		first.set(Calendar.HOUR, statusEmailHour % 12);
		first.set(Calendar.MINUTE, 0);
		first.set(Calendar.SECOND, 0);
		first.set(Calendar.MILLISECOND, 0);
		statusEmailNextUpdate = first.getTimeInMillis();
		final long now = new Date().getTime();
		while(statusEmailNextUpdate < now)
		{
			statusEmailNextUpdate += statusEmailInterval;
		}

		// -- Read in the message intervals from the properties file, converting s to ms

		rejectionMessageInterval = 1000 * prop
				.getIntegerProperty("tweater.queue.rejectionMessageInterval");
		rejectionEmailInterval = 1000 * prop.getIntegerProperty("tweater.queue.rejectionEmailInterval");
		trackLimitMessageInterval = 1000 * prop
				.getIntegerProperty("tweater.queue.trackLimitMessageInterval");
		resourceLimitMessageInterval = 1000 * prop
				.getIntegerProperty("tweater.queue.resourceLimitMessageInterval");
		resourceLimitEmailInterval = 1000 * prop
				.getIntegerProperty("tweater.queue.resourceLimitEmailInterval");

		// -- Read in the resource limitation thresholds from the properties file

		resourceLimitMessageThreshold = prop
				.getFloatProperty("tweater.queue.resourceLimitMessageThreshold");
		resourceLimitEmailThreshold = prop
				.getFloatProperty("tweater.queue.resourceLimitEmailThreshold");
		resourceLimitRejectionThreshold = prop
				.getFloatProperty("tweater.queue.resourceLimitRejectionThreshold");
	}

	/**
	 * Adds a <code>QueryItem</code> to the queue's associated <code>StatusEater</code>.
	 * 
	 * @param item
	 */
	public void addItem(final QueryItem item)
	{
		eater.addItem(item);
	}

	/**
	 * Removes a specific <code>QueryItem</code> from the queue's associated <code>StatusEater</code>.
	 * 
	 * @param item
	 */
	public void delItem(final QueryItem item)
	{
		eater.delItem(item);
	}

	/**
	 * @return <code>true</code> iff the queue has been shutdown AND has completed its backlog
	 */
	public boolean finished()
	{
		return pool.isTerminated();
	}

	/**
	 * @return The collection of <code>QueryItem</code>s held by the queue's associated
	 *         <code>StatusEater</code>
	 */
	public Set<QueryItem> getQuery()
	{
		return eater.getQuery();
	}

	/**
	 * @return The size of the queue
	 */
	public int getQueueSize()
	{
		return pool.getQueue().size();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see twitter4j.StatusListener#onDeletionNotice(twitter4j.StatusDeletionNotice)
	 */
	@Override
	public void onDeletionNotice(final StatusDeletionNotice statusDeletionNotice)
	{
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see twitter4j.StreamListener#onException(java.lang.Exception)
	 */
	@Override
	public void onException(final Exception ex)
	{
		if(!ex.getMessage().contains("Stream closed"))
		{
			log.severe(Util.traceMessage(ex));
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see twitter4j.StatusListener#onScrubGeo(int, long)
	 */
	@Override
	public void onScrubGeo(final long userId, final long upToStatusId)
	{
	}

	@Override
	public void onStallWarning(final StallWarning warn)
	{
		// TODO: Implement something to do on StallWarnings
		// See also: https://dev.twitter.com/docs/streaming-apis/parameters#stall_warnings
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see twitter4j.StatusListener#onStatus(twitter4j.Status)
	 */
	@Override
	public void onStatus(final Status status)
	{
		// If we are below the memory utilization threshold
		if(Util.getMemoryUtilizationPercent() < resourceLimitRejectionThreshold)
		{
			// Create and submit a Runnable that will process the status
			pool.execute(new Runnable()
			{
				@Override
				public void run()
				{
					try
					{
						log.finest("Calling StatusEater.process() on status id " + status.getId());
						eater.process(status);
					}
					catch(final Exception ex)
					{
						log.severe("Unhandled error in ThreadPool thread:\n" + Util.traceMessage(ex));
					}
				}
			});
		}
		// Otherwise, reject the status and log that fact
		else
		{
			log.finest("Rejected execution on status id " + status.getId());
			rejectedExecutions++;
			rejectionMessageNeedsUpdate = true;
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see twitter4j.StatusListener#onTrackLimitationNotice(int)
	 */
	@Override
	public void onTrackLimitationNotice(final int numberOfLimitedStatuses)
	{
		// If we detect that Twitter has lost our track limitation count, save the old number
		if(numberOfLimitedStatuses < trackLimitations)
			previousTrackLimitations += trackLimitations;

		// Also save the new number, and calculate the total
		trackLimitations = numberOfLimitedStatuses;
		final int totalTrackLimitations = previousTrackLimitations + trackLimitations;

		log.finest("Track Limitation notice: " + totalTrackLimitations);
		trackLimitMessageNeedsUpdate = true;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Thread#run()
	 */
	@Override
	public void run()
	{
		final Runtime rt = Runtime.getRuntime();

		// This loop waits until the queue is done processing statuses, periodically logging and
		// emailing warning messages
		while(!finished())
		{
			final long now = new Date().getTime();

			// Email a status message
			if(statusEmailInterval >= 0 && now > statusEmailNextUpdate)
			{
				statusEmailNextUpdate = statusEmailNextUpdate + statusEmailInterval;
				try
				{
					alert.send("TwEater status: " + host, logdiff.get());
				}
				catch(final MessagingException ex)
				{
					log.severe(Util.traceMessage(ex));
				}
				log.fine("Sent status email.");
			}

			// Log a rejected-executions message if necessary
			if(rejectionMessageNeedsUpdate && rejectionMessageInterval >= 0
					&& now > rejectionMessageLastUpdate + rejectionMessageInterval)
			{
				rejectionMessageLastUpdate = now;
				rejectionMessageNeedsUpdate = false;
				log.severe("Rejected Executions to date: " + rejectedExecutions);
			}

			// Email a rejected-executions message if necessary
			if(rejectionEmailNeedsUpdate && rejectionEmailInterval >= 0
					&& now > rejectionEmailLastUpdate + rejectionEmailInterval)
			{
				rejectionEmailLastUpdate = now;
				rejectionEmailNeedsUpdate = false;
				try
				{
					alert.send("Rejected Exs at " + rejectedExecutions + " on " + host,
							"Rejected Executions to date: " + rejectedExecutions + " on host " + host);
				}
				catch(final MessagingException ex)
				{
					log.severe(Util.traceMessage(ex));
				}
				log.fine("Sent Rejected Execution email.");
			}

			// Log a track-limitations message if necessary
			if(trackLimitMessageNeedsUpdate && trackLimitMessageInterval >= 0
					&& now > trackLimitMessageLastUpdate + trackLimitMessageInterval)
			{
				trackLimitMessageLastUpdate = now;
				trackLimitMessageNeedsUpdate = false;
				log.warning("Track Limitations to date: " + trackLimitations);
			}

			// Compute the amount of memory used and available
			final long used = rt.totalMemory() - rt.freeMemory();
			final long avail = rt.maxMemory();
			final float pct = (float) used / avail;

			// Log a resource-limitations message if necessary
			if((resourceLimitMessageNeedsUpdate || pct > resourceLimitMessageThreshold)
					&& resourceLimitMessageInterval >= 0
					&& now > resourceLimitMessageLastUpdate + resourceLimitMessageInterval)
			{
				resourceLimitMessageLastUpdate = now;
				resourceLimitMessageNeedsUpdate = pct > resourceLimitMessageThreshold;
				log.warning("Resource utilization at " + used / Util.MB + "MB/" + avail / Util.MB + "MB ("
						+ (int) (pct * 100) + "%)");
			}

			// Email a resource-limitations message if necessary
			if((resourceLimitEmailNeedsUpdate || pct > resourceLimitEmailThreshold)
					&& resourceLimitEmailInterval >= 0
					&& now > resourceLimitEmailLastUpdate + resourceLimitEmailInterval)
			{
				resourceLimitEmailLastUpdate = now;
				resourceLimitEmailNeedsUpdate = pct > resourceLimitEmailThreshold;
				try
				{
					alert.send("Resources at " + pct + "% on " + host, "StatusQueue resource utilization at "
							+ used / Util.MB + "MB/" + avail / Util.MB + "MB (" + (int) (pct * 100)
							+ "%) on host " + host);
				}
				catch(final MessagingException ex)
				{
					log.severe(Util.traceMessage(ex));
				}
				log.fine("Sent Resource Limit email.");
			}

			// Wait a little while to start the loop again
			try
			{
				Thread.sleep((int) (5000.0 + Math.random() * 1000.0));
			}
			catch(final InterruptedException ex)
			{
				log.severe(Util.traceMessage(ex));
			}
		}

		log.info("StatusServer shut down.");
	}

	/**
	 * Prevents the queue from accepting new jobs (but allows it to continue working on jobs already
	 * in the queue).
	 */
	public void shutdown()
	{
		pool.shutdown();
	}
}
package edu.umd.cs.dmonner.tweater;

import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.rmi.AccessException;
import java.rmi.ConnectException;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.sql.Driver;
import java.sql.DriverManager;
import java.util.Date;
import java.util.logging.FileHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;

import snaq.db.DBPoolDataSource;
import twitter4j.TwitterStream;
import twitter4j.TwitterStreamFactory;
import twitter4j.auth.AccessToken;
import edu.umd.cs.dmonner.tweater.csv.CSVQueryBuilder;
import edu.umd.cs.dmonner.tweater.csv.CSVStatusEater;
import edu.umd.cs.dmonner.tweater.mysql.MySQLQueryBuilder;
import edu.umd.cs.dmonner.tweater.mysql.MySQLStatusEater;
import edu.umd.cs.dmonner.tweater.util.AlertEmailer;
import edu.umd.cs.dmonner.tweater.util.OneLineFormatter;
import edu.umd.cs.dmonner.tweater.util.Properties;
import edu.umd.cs.dmonner.tweater.util.Util;

public class TwEater extends Thread implements TwEaterControl
{
	/**
	 * @return A new property list containing defaults
	 */
	public static Properties getDefaultProperties()
	{
		final Properties prop = new Properties();

		// -- Load all property defaults, where applicable

		prop.setProperty("tweater.dbType", "csv", //
				"Type of persistent storage to use; valid values are: csv, mysql");
		prop.setProperty("tweater.logging.level", "INFO", //
				"Granularity of log messages; valid values (from rarest to most frequent) are: " + //
						"SEVERE, WARNING, INFO, FINE, FINER, FINEST");
		prop.setProperty("tweater.logging.maxLogSizeMB", "10", //
				"Maximum size of a TwEater log file.");
		prop.setProperty("tweater.logging.maxLogs", "10", //
				"Maximum number of Tweater log files. After this many logs reach the maximum size, " + //
						"the first file will be overwritten. To avoid this, set a large maxLogs and/or " + //
						"maxLogSizeMB, or turn down your logging level. Beware filling your disk!");

		// Properties specific to CSV configuration

		prop.setProperty("tweater.csv.infile", "query.csv", //
				"CSV file specifying Twitter query");
		prop.setProperty("tweater.csv.outfile", "results.csv", //
				"CSV file to which to write the received tweet data");

		// Properties specific to MySQL configuration

		prop.setProperty("tweater.mysql.minConnections", "3", //
				"Minimum number of database connections to maintain; for performance tuning");
		prop.setProperty("tweater.mysql.coreConnections", "30", //
				"Base number of database connections to maintain; for performance tuning");
		prop.setProperty("tweater.mysql.maxConnections", "50", //
				"Minimum number of database connections allowed; for performance tuning");
		prop.setProperty("tweater.mysql.idleTimeout", "120", //
				"Idle timeout on database connection (in seconds); for performance tuning");
		prop.setProperty("tweater.mysql.queryGroups", "", //
				"Subset of query group numbers to include in query; leave blank for all");
		prop.setProperty("tweater.mysql.host", "", //
				"Hostname of the MySQL database server");
		prop.setProperty("tweater.mysql.name", "", //
				"Name of the MySQL database");
		prop.setProperty("tweater.mysql.user", "", //
				"Username for the MySQL database");
		prop.setProperty("tweater.mysql.pass", "", //
				"Password for the MySQL database");

		// Properties specific to email notifications

		prop.setProperty("tweater.mail.smtp", "", //
				"SMTP server from which to send email alerts");
		prop.setProperty("tweater.mail.to", "", //
				"Email address to which to send email alerts");
		prop.setProperty("tweater.mail.from", "", //
				"Email address from which email alerts will originate");

		// Properties of the QueryBuilder

		prop.setProperty("tweater.builder.interval", "180", //
				"Interval (in seconds) between QueryBuilder trips to the data source");

		// Properties of the StatusEater

		prop.setProperty("tweater.eater.useSentimentAnalysis", "true", //
				"Sentiment-analyze tweets as they come in; incurs additional memory overhead");

		// Properties of the tweet queue in StatusServer

		prop.setProperty("tweater.queue.coreThreads", "50", //
				"Base number of status-processing threads; for performance tuning");
		prop.setProperty("tweater.queue.maxThreads", "50", //
				"Maximum number of status-processing threads; for performance tuning");
		prop.setProperty("tweater.queue.idleTimeout", "60", //
				"Idle timeout on processing threads; for performance tuning");
		prop.setProperty("tweater.queue.rejectionMessageInterval", "600", //
				"Interval (in seconds) between log messages about rejected statuses");
		prop.setProperty("tweater.queue.statusEmailHour", "6", // 6 am
				"Interval (in seconds) between email messages about rejected statuses");
		prop.setProperty("tweater.queue.statusEmailInterval", "43200", // 12 hours
				"Interval (in seconds) between email messages about rejected statuses");
		prop.setProperty("tweater.queue.rejectionEmailInterval", "3600", //
				"Interval (in seconds) between email messages about rejected statuses");
		prop.setProperty("tweater.queue.rejectionEmailInterval", "3600", //
				"Interval (in seconds) between email messages about rejected statuses");
		prop.setProperty("tweater.queue.trackLimitMessageInterval", "600", //
				"Interval (in seconds) between log messages about track limitations");
		prop.setProperty("tweater.queue.resourceLimitMessageInterval", "600", //
				"Interval (in seconds) between log messages about resource limitations");
		prop.setProperty("tweater.queue.resourceLimitEmailInterval", "3600", //
				"Interval (in seconds) between email messages about resource limitations");
		prop.setProperty("tweater.queue.resourceLimitMessageThreshold", "0.50", //
				"Fraction of memory use above which to log resource limitations");
		prop.setProperty("tweater.queue.resourceLimitEmailThreshold", "0.80", //
				"Fraction of memory use above which to send email alerts about resource limitations");
		prop.setProperty("tweater.queue.resourceLimitRejectionThreshold", "0.95", //
				"Fraction of memory use above which to reject new statuses");

		// Properties of Twitter OAuth

		prop.setProperty("oauth.accessToken", "", //
				"Your Access Token from Twitter for use with TwEater");
		prop.setProperty("oauth.accessTokenSecret", "", //
				"Your Access Token Secret from Twitter for use with TwEater");
		prop.setProperty("oauth.consumerKey", "RTojEz16nwhI3IrBrZpNQ", //
				"TwEater's Consumer Token Key");
		prop.setProperty("oauth.consumerSecret", "lNfVdu2cFKrlEbaw1OiM2Y3TgVKLGBI3AuEEblZilek", //
				"TwEater's Consumer Token Secret");

		return prop;
	}

	/**
	 * Loads the default properties, replacing them as necessary with properties read from the input
	 * file.
	 * 
	 * @param propfile
	 *          The file to read
	 * @return The resulting property list
	 */
	public static Properties loadPropertiesFile(final String propfile)
	{
		final Properties prop = getDefaultProperties();

		// -- Try to load the properties file given on the command line, overwriting defaults
		try
		{
			prop.load(propfile);
		}
		catch(final FileNotFoundException ex)
		{
			System.out.println("Cannot find properties file: " + propfile);
			System.exit(1);
		}
		catch(final IOException ex)
		{
			ex.printStackTrace();
			System.exit(1);
		}

		// -- Check to make sure necessary properties have been provided in the proper ranges

		// OAuth properties

		prop.requireProperty("oauth.accessToken");
		prop.requireProperty("oauth.accessTokenSecret");
		prop.requireProperty("oauth.consumerKey");
		prop.requireProperty("oauth.consumerSecret");

		// MySQL properties

		if(prop.getProperty("tweater.dbType").equalsIgnoreCase("mysql"))
		{
			prop.requireProperty("tweater.mysql.host");
			prop.requireProperty("tweater.mysql.name");
			prop.requireProperty("tweater.mysql.user");
			prop.requireProperty("tweater.mysql.pass");
			prop.requireIntegerProperty("tweater.mysql.minConnections", 0);
			prop.requireIntegerProperty("tweater.mysql.coreConnections", 1);
			prop.requireIntegerProperty("tweater.mysql.maxConnections", 1);
			prop.requireIntegerProperty("tweater.mysql.idleTimeout", 0);
		}

		// StatusQueue properties

		prop.requireIntegerProperty("tweater.queue.coreThreads", 1);
		prop.requireIntegerProperty("tweater.queue.maxThreads", 1);
		prop.requireIntegerProperty("tweater.queue.idleTimeout", 0);
		prop.requireIntegerProperty("tweater.queue.rejectionMessageInterval", -1);
		prop.requireIntegerProperty("tweater.queue.trackLimitMessageInterval", -1);
		prop.requireIntegerProperty("tweater.queue.resourceLimitMessageInterval", -1);
		prop.requireIntegerProperty("tweater.queue.resourceLimitEmailInterval", -1);
		prop.requireFloatProperty("tweater.queue.resourceLimitMessageThreshold", 0.0f, 1.0f);
		prop.requireFloatProperty("tweater.queue.resourceLimitEmailThreshold", 0.0f, 1.0f);
		prop.requireFloatProperty("tweater.queue.resourceLimitRejectionThreshold", 0.0f, 1.0f);

		// -- Return finalized properties

		return prop;
	}

	/**
	 * Allows for launching and controlling TwEater instances via the command line.
	 * 
	 * @param args
	 */
	public static void main(final String[] args)
	{
		// System.setSecurityManager(new RMISecurityManager());
		final String usage = "USAGE:\n" + //
				"tweater start <file.properties>   // start a new TwEater instance\n" + //
				"tweater list                      // list all instances\n" + //
				"tweater prop                      // write default properties to stdout\n" + //
				"tweater stop <instance_number>    // shut down a running instance\n";

		// If called with no arguments, print a usage message
		if(args.length < 1)
		{
			System.out.print(usage);
		}
		// If called with "start", begin a new TwEater instance
		else if(args[0].equalsIgnoreCase("start"))
		{
			String propfile = "tweater.properties";

			if(args.length > 1)
			{
				propfile = args[1];
			}

			try
			{
				new TwEater(propfile).start();
			}
			catch(final Exception ex)
			{
				ex.printStackTrace();
			}
		}
		// If called with "list", pretty print info about running TwEater instances
		else if(args[0].equalsIgnoreCase("list"))
		{
			System.out.println(" num |        name          |    size    | collecting | mem% ");
			System.out.println("-----|----------------------|------------|------------|------");
			final String tpl = "     |                      |            |            |      ";
			final int numStart = 1;
			final int nameStart = 7;
			final int sizeStart = 30;
			final int collStart = 43;
			final int memStart = 56;

			try
			{
				int index = 0;
				for(final String name : LocateRegistry.getRegistry().list())
				{
					try
					{
						final Remote obj = LocateRegistry.getRegistry().lookup(name);
						if(obj instanceof TwEaterControl)
						{
							final TwEaterControl tw = (TwEaterControl) obj;
							final StringBuffer s = new StringBuffer(tpl.toString());
							final String numStr = String.valueOf(index);
							final String sizeStr = String.valueOf(tw.size());
							final String collStr = String.valueOf(tw.collecting());
							final String memStr = String.valueOf((int) (tw.memory() * 100)) + "%";

							s.replace(numStart, numStart + numStr.length(), numStr);
							s.replace(nameStart, nameStart + name.length(), name);
							s.replace(sizeStart, sizeStart + sizeStr.length(), sizeStr);
							s.replace(collStart, collStart + collStr.length(), collStr);
							s.replace(memStart, memStart + memStr.length(), memStr);

							System.out.println(s.toString());
							index++;
						}
					}
					catch(final NotBoundException ex)
					{
						ex.printStackTrace();
					}
					catch(final ConnectException ex)
					{
						rmiRemove(LocateRegistry.getRegistry(), name);
					}
					catch(final RemoteException ex)
					{
						ex.printStackTrace();
					}
				}
			}
			catch(final RemoteException ex)
			{
				ex.printStackTrace();
			}
		}
		// If called with "prop", generate a default TwEater configuration file
		else if(args[0].equalsIgnoreCase("prop"))
		{
			getDefaultProperties().save(System.out,
					"Default TwEater properties file, generated " + new Date());
		}
		// If called with "stop", shut down the given TwEater instance (after prompting for
		// confirmation)
		else if(args[0].equalsIgnoreCase("stop") && args.length > 1)
		{
			try
			{
				final int target = Integer.parseInt(args[1]);
				int index = 0;
				for(final String name : LocateRegistry.getRegistry().list())
				{
					try
					{
						final Remote obj = LocateRegistry.getRegistry().lookup(name);
						if(obj instanceof TwEaterControl)
						{
							if(index == target)
							{
								final TwEaterControl tw = (TwEaterControl) obj;

								if(tw.collecting())
								{
									System.out.print("Stop collection on instance " + name + "? [y|N] ");
									final char answer = (char) System.in.read();

									if(answer == 'y' || answer == 'Y')
									{
										tw.shutdown();
										System.out.println("Collection stopped on instance " + name + ".");
									}
								}
								else
								{
									System.out.println("Collection is already stopped on instance " + name + ".");
								}

								break;
							}

							index++;
						}
					}
					catch(final ConnectException ex)
					{
						rmiRemove(LocateRegistry.getRegistry(), name);
					}
					catch(final NotBoundException ex)
					{
						ex.printStackTrace();
					}
					catch(final RemoteException ex)
					{
						ex.printStackTrace();
					}
					catch(final IOException ex)
					{
						ex.printStackTrace();
					}
				}
			}
			catch(final NumberFormatException ex)
			{
				ex.printStackTrace();
			}
			catch(final RemoteException ex)
			{
				ex.printStackTrace();
			}
		}
		// If we got an argument we don't recognize, print the usage message
		else
		{
			System.out.print(usage);
		}
	}

	private static void rmiRemove(final Registry registry, final String name)
	{
		System.out.println("Failed to connect to " + name + "; removing from registry.");
		try
		{
			registry.unbind(name);
		}
		catch(final NotBoundException ex)
		{
			ex.printStackTrace();
		}
		catch(final AccessException ex)
		{
			ex.printStackTrace();
		}
		catch(final RemoteException ex)
		{
			ex.printStackTrace();
		}
	}

	/**
	 * The identifier for this TwEater instance; also used as the log file name
	 */
	public final String id;
	/**
	 * The destination for urgent email alert messages
	 */
	public final AlertEmailer alert;
	/**
	 * The configuration properties of this TwEater instance
	 */
	public final Properties prop;
	/**
	 * A reference to the query builder associated with this TwEater instance
	 */
	public final QueryBuilder builder;
	/**
	 * A reference to the querier associated with this TwEater instance
	 */
	public final Querier querier;
	/**
	 * A reference to the status queue associated with this TwEater instance
	 */
	public final StatusQueue queue;
	/**
	 * The log file associated with this TwEater instance
	 */
	public final Logger log;

	/**
	 * Tells whether this TwEater instance is currently collecting data from Twitter, or shut down and
	 * merely working through its backlog
	 */
	private boolean collecting;

	public TwEater(final String propfile) throws Exception
	{
		// -- Read properties file
		prop = loadPropertiesFile(propfile);

		// -- Setup up a Twitter stream and its OAuth info
		final TwitterStream tw = new TwitterStreamFactory().getInstance();
		loadConsumerToken(tw);
		loadAccessToken(tw);

		alert = new AlertEmailer(prop);
		id = "tweater" + new Date().getTime();
		collecting = true;

		// -- Initial logging configuration
		log = Logger.getLogger(id);
		final int maxLogSizeMB = prop.getIntegerProperty("tweater.logging.maxLogSizeMB");
		final int maxLogs = prop.getIntegerProperty("tweater.logging.maxLogs");
		final Handler filehandler = new FileHandler(id + ".log", maxLogSizeMB * Util.MB, maxLogs);
		filehandler.setFormatter(new OneLineFormatter());
		log.addHandler(filehandler);
		log.setLevel(Level.parse(prop.getProperty("tweater.logging.level")));
		log.info("Initializing " + id);

		final String dbtype = prop.getProperty("tweater.dbType").toLowerCase();
		final StatusEater eater;

		if(dbtype.equals("mysql"))
		{
			final String driverclass = "com.mysql.jdbc.Driver";
			DriverManager.registerDriver((Driver) Class.forName(driverclass).newInstance());
			final DBPoolDataSource ds = new DBPoolDataSource();
			ds.setDriverClassName(driverclass);
			ds.setUrl("jdbc:" + dbtype + "://" + prop.getProperty("tweater.mysql.host") + "/"
					+ prop.getProperty("tweater.mysql.name") + "?continueBatchOnError=false"
					+ "&useUnicode=true" + "&characterEncoding=utf8" + "&characterSetResults=utf8");
			ds.setUser(prop.getProperty("tweater.mysql.user"));
			ds.setPassword(prop.getProperty("tweater.mysql.pass"));
			ds.setMinPool(Integer.parseInt(prop.getProperty("tweater.mysql.minConnections")));
			ds.setMaxPool(Integer.parseInt(prop.getProperty("tweater.mysql.coreConnections")));
			ds.setMaxSize(Integer.parseInt(prop.getProperty("tweater.mysql.maxConnections")));
			ds.setIdleTimeout(Integer.parseInt(prop.getProperty("tweater.mysql.idleTimeout")));
			ds.setValidatorClassName("snaq.db.AutoCommitValidator");

			builder = new MySQLQueryBuilder(id, prop, ds);
			eater = new MySQLStatusEater(id, prop, ds);
		}
		else if(dbtype.equals("csv"))
		{
			String outfile = "results.csv";

			if(prop.containsKey("tweater.csv.outfile"))
				outfile = prop.getProperty("tweater.csv.outfile");

			builder = new CSVQueryBuilder(id, prop);
			eater = new CSVStatusEater(id, prop, new PrintWriter(new FileWriter(outfile, true), true));
		}
		else
		{
			builder = null;
			eater = null;
			log.severe("Database type \"" + dbtype + "\" not supported.");
			System.exit(1);
		}

		// start the querier
		querier = new Querier(id, tw, builder);
		queue = new StatusQueue(id, eater, prop, alert);
		querier.addQueue(queue);

		try
		{
			final TwEaterControl stub = (TwEaterControl) UnicastRemoteObject.exportObject(this, 0);
			LocateRegistry.getRegistry().rebind(id, stub);
			log.info("Registered successfully on " + Util.getHost());
		}
		catch(final RemoteException ex)
		{
			log.severe(Util.traceMessage(ex));
			System.exit(1);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.umd.cs.dmonner.tweater.TwEaterControl#collecting()
	 */
	@Override
	public boolean collecting() throws RemoteException
	{
		return collecting;
	}

	/**
	 * Reads an Access Token from this instance's configuration and adds the token to the given
	 * Twitter stream object.
	 * 
	 * @param tw
	 */
	private void loadAccessToken(final TwitterStream tw)
	{
		AccessToken accessToken = null;

		if(prop.getProperty("oauth.accessToken") == null
				|| prop.getProperty("oauth.accessTokenSecret") == null)
		{
			log.severe("Cannot find a valid User Access Token.");
			System.exit(1);
		}
		else
		{
			accessToken = new AccessToken(prop.getProperty("oauth.accessToken"),
					prop.getProperty("oauth.accessTokenSecret"));
		}

		// get an authorized Twitter instance
		tw.setOAuthAccessToken(accessToken);
	}

	/**
	 * Reads a Consumer Token from this instance's configuration and adds the token to the given
	 * Twitter stream object.
	 * 
	 * @param tw
	 */
	private void loadConsumerToken(final TwitterStream tw)
	{
		if(prop.getProperty("oauth.consumerKey") == null
				|| prop.getProperty("oauth.consumerSecret") == null)
		{
			log.severe("Cannot find a valid Consumer Key.");
			System.exit(1);
		}

		tw.setOAuthConsumer(prop.getProperty("oauth.consumerKey"),
				prop.getProperty("oauth.consumerSecret"));
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.umd.cs.dmonner.tweater.TwEaterControl#memory()
	 */
	@Override
	public float memory()
	{
		return Util.getMemoryUtilizationPercent();
	}

	/**
	 * Starts the associated query builder, status queue, and querier threads. Waits in a loop until
	 * the TwEater instance has been shut down and the status queue has worked through its backlog.
	 */
	@Override
	public void run()
	{
		builder.start();
		queue.start();
		querier.start();

		while(collecting || !queue.finished())
		{
			if(!collecting)
			{
				log.info("Post-shutdown jobs remaining: " + queue.getQueueSize());
			}

			// Wait a little while to start the loop again
			try
			{
				Thread.sleep((int) (5000.0 + Math.random() * 1000.0));
			}
			catch(final InterruptedException ex)
			{
				log.severe(Util.traceMessage(ex));
			}
		}

		System.out.println("All post-shutdown jobs finished.");

		try
		{
			LocateRegistry.getRegistry().unbind(id);
			log.info("De-registered successfully on " + Util.getHost());
		}
		catch(final NotBoundException ex)
		{
			log.severe(Util.traceMessage(ex));
			System.exit(1);
		}
		catch(final RemoteException ex)
		{
			log.severe(Util.traceMessage(ex));
			System.exit(1);
		}

		System.out.println("Exiting.");
		System.exit(0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.umd.cs.dmonner.tweater.TwEaterControl#shutdown()
	 */
	@Override
	public void shutdown()
	{
		queue.shutdown();
		querier.shutdown();
		builder.shutdown();
		collecting = false;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.umd.cs.dmonner.tweater.TwEaterControl#size()
	 */
	@Override
	public int size()
	{
		return queue.getQueueSize();
	}
}
package edu.umd.cs.dmonner.tweater;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.logging.Logger;

import edu.umd.cs.dmonner.tweater.util.Util;

import twitter4j.Status;

/**
 * Base implementation of a <code>StatusEater</code> that maintains a set of <code>QueryItem</code>s
 * that it cares about. It implements basic methods for adding to and deleting from this set, and
 * implements <code>process</code> to find all <code>QueryItem</code>s associated with a given
 * <code>Status<code>. Leaves the <code>persist</code> method for implementation by subclasses
 * focusing on a specific long-term storage system.
 * 
 * @author dmonner
 * 
 */
public abstract class BaseStatusEater implements StatusEater
{
	/**
	 * The log to which this class writes error messages.
	 */
	protected final Logger log;
	/**
	 * The set of <code>QueryItem</code>s that this <code>StatusEater</code> cares about.
	 */
	protected final Set<QueryItem> items;
	/**
	 * The number of milliseconds before an HTTP connection is considered to have timed out.
	 */
	private final int MS_CONN_TIMEOUT = 10 * 1000;

	/**
	 * @param id
	 *          The identifier of the log file that this class should use.
	 */
	public BaseStatusEater(final String id)
	{
		this.log = Logger.getLogger(id);
		this.items = new CopyOnWriteArraySet<QueryItem>();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.StatusEater#addItem(tweater.QueryItem)
	 */
	public void addItem(final QueryItem item)
	{
		items.add(item);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.StatusEater#addItems(java.util.Collection)
	 */
	public void addItems(final Collection<? extends QueryItem> items)
	{
		this.items.addAll(items);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.StatusEater#clearItems()
	 */
	public void clearItems()
	{
		items.clear();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.StatusEater#delItem(tweater.QueryItem)
	 */
	public void delItem(final QueryItem item)
	{
		items.remove(item);
	}

	/**
	 * A utility method that takes any URL and follows all redirects recursively until the true target
	 * is reached. Useful for finding the true destination of URL-shortened links.
	 * 
	 * @param urlStr
	 *          A URL, possibly shortened.
	 * @return The true destination URL.
	 */
	protected String expand(final String urlStr)
	{
		URLConnection conn = null;

		try
		{
			// to expand the URL, just open a connection and follow it!
			final URL inputURL = new URL(urlStr);
			conn = inputURL.openConnection();
			conn.setConnectTimeout(MS_CONN_TIMEOUT);
			conn.setReadTimeout(MS_CONN_TIMEOUT);

			// this is necessary to update the header fields and can lead to
			// StringIndexOutOfBoundsException if bad page returned
			conn.getHeaderFields();

			return conn.getURL().toString();
		}
		catch(final SocketTimeoutException ex)
		{
			log.info("Socket timeout when trying to access " + urlStr);
		}
		catch(final NullPointerException ex)
		{
			log.info("Null URL");
		}
		catch(final StringIndexOutOfBoundsException ex)
		{
			String badURL = urlStr;

			try
			{
				badURL = conn.getURL().toString();
			}
			catch(final Exception ex2)
			{
				log.severe(Util.traceMessage(ex2));
			}

			log.info("Header issue with URL: " + badURL);
		}
		catch(final IllegalArgumentException ex)
		{
			if(ex.getMessage().contains("host = null"))
			{
				log.info("Null hostname in URL.");
			}
			else
			{
				log.info("URL Error: " + ex.getMessage());
			}
		}
		catch(final MalformedURLException ex)
		{
			log.info("Invalid URL: " + urlStr);
		}
		catch(final IOException ex)
		{
			log.info("Cannot connect to URL: " + urlStr);
		}

		return urlStr;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.StatusEater#getQuery()
	 */
	public Set<QueryItem> getQuery()
	{
		return new TreeSet<QueryItem>(items);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.StatusEater#process(twitter4j.Status)
	 */
	@Override
	public void process(final Status status)
	{
		log.finest("Entering process() for status id " + status.getId());

		// create a new MatchableStatus, optimized for matching
		final MatchableStatus mstat = new MatchableStatus(status);

		// generate a list of QueryItems that match the status
		final List<QueryItem> matched = new LinkedList<QueryItem>();
		for(final QueryItem item : items)
			if(item.matches(mstat))
				matched.add(item);

		// if there are any matches, persist the status
		if(!matched.isEmpty())
			persist(matched, status);
		else
			log.fine("Skipping persist() because there are not QueryItem matches for status id "
				+ status.getId() + ".");
	}
}
package edu.umd.cs.dmonner.tweater;

/**
 * A <code>QueryItem</code> that matches exactly on a sequence of keywords given as a single
 * <code>String</code>.
 * 
 * @author dmonner
 */
public class QueryPhrase extends QueryItem
{
	private static final long serialVersionUID = 1L;

	/**
	 * The phrase to match.
	 */
	public final String string;

	/**
	 * Creates a new <code>QueryPhrase</code> with the given group number, unique ID, and the phrase
	 * that we wish to find.
	 * 
	 * @param group
	 * @param id
	 * @param string
	 */
	public QueryPhrase(final int group, final int id, final String string)
	{
		super(Type.PHRASE, group, id);
		this.string = string.trim().toLowerCase();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#compareTo(tweater.QueryItem)
	 */
	@Override
	public int compareTo(final QueryItem that)
	{
		int result;

		result = super.compareTo(that);
		if(result != 0)
			return result;

		return this.string.compareTo(((QueryPhrase)that).string);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(final Object other)
	{
		boolean result;

		result = super.equals(other);
		if(!result)
			return result;

		return this.string.equals(((QueryPhrase)other).string);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#hashCode()
	 */
	@Override
	public int hashCode()
	{
		return super.hashCode() + string.hashCode();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#matches(tweater.MatchableStatus)
	 */
	@Override
	public boolean matches(final MatchableStatus status)
	{
		return status.text.contains(string);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString()
	{
		return "\"" + string + "\"";
	}
}
package edu.umd.cs.dmonner.tweater;

import java.io.Serializable;

/**
 * Represents some property that can be matched in a <code>Status</code> object. Many
 * <code>QueryItem</code>s can belong to the same group, thus associating them with each other when
 * persisted; one might want to do this for related variations on a query, such as "Ma Bell" and
 * "AT&amp;T".
 * 
 * @author dmonner
 */
public abstract class QueryItem implements Comparable<QueryItem>, Serializable
{
	/**
	 * The types of <code>QueryItem</code>s.
	 * 
	 * @author dmonner
	 */
	public enum Type
	{
		/**
		 * Matches on set of keywords, which need not necessarily be in order or adjacent
		 */
		TRACK,
		/**
		 * Matches exactly on a sequence of keywords
		 */
		PHRASE,
		/**
		 * Matches on the user ID of the originator of the <code>Status</code>
		 */
		FOLLOW
	}

	private static final long serialVersionUID = 1L;;

	/**
	 * The type of this <code>QueryItem</code>
	 */
	public final Type type;
	/**
	 * The number of the group to which this <code>QueryItem</code> belongs
	 */
	public final int group;
	/**
	 * A unique ID number for this <code>QueryItem</code>
	 */
	public final long id;

	/**
	 * Creates a <code>QueryItem</code> with the specified type, group number, and unique ID.
	 * 
	 * @param type
	 * @param group
	 * @param id2
	 */
	public QueryItem(final Type type, final int group, final long id)
	{
		this.type = type;
		this.group = group;
		this.id = id;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Comparable#compareTo(java.lang.Object)
	 */
	@Override
	public int compareTo(final QueryItem that)
	{
		int result;

		result = this.type.compareTo(that.type);
		if(result != 0)
			return result;

		result = this.group - that.group;
		if(result != 0)
			return result;

		result = (int) (this.id - that.id);
		if(result != 0)
			return result;

		return 0;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(final Object other)
	{
		if(other instanceof QueryItem)
		{
			final QueryItem that = (QueryItem) other;
			return this.type == that.type && this.group == that.group && this.id == that.id;
		}

		return false;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode()
	{
		return type.hashCode() + 13 * group + 7 * (int) id;
	}

	/**
	 * Determines whether the given status matches this <code>QueryItem</code>.
	 * 
	 * @param status
	 * @return <code>true</code> iff the given status matches this <code>QueryItem</code>
	 */
	public abstract boolean matches(MatchableStatus status);
}
package edu.umd.cs.dmonner.tweater;

/**
 * A simple container that pairs a <code>QueryItem</code> with a start and end time, as is necessary
 * internally to a <code>QueryBuilder</code>.
 * 
 * @author dmonner
 */
public class QueryItemTime
{
	/**
	 * A <code>QueryItem</code> that is given time bounds.
	 */
	public final QueryItem item;
	/**
	 * The time (in ms since the epoch) that the associated <code>QueryItem</code> should start
	 * matching.
	 */
	public final long startTime;
	/**
	 * The time (in ms since the epoch) that the associated <code>QueryItem</code> should stop
	 * matching.
	 */
	public final long endTime;

	/**
	 * @param item
	 * @param startTime
	 * @param endTime
	 */
	public QueryItemTime(final QueryItem item, final long startTime, final long endTime)
	{
		this.item = item;
		this.startTime = startTime;
		this.endTime = endTime;
	}
}
package edu.umd.cs.dmonner.tweater;

/**
 * A <code>QueryItem</code> that matches on set of keywords, which need not necessarily be in order
 * or adjacent, specified as a single whitespace-separated <code>String</code>.
 * 
 * @author dmonner
 */
public class QueryTrack extends QueryItem
{
	private static final long serialVersionUID = 1L;

	/**
	 * Individual keywords being tracked, as extracted from the input string.
	 */
	public final String[] words;
	/**
	 * The original tracking string
	 */
	public final String string;

	/**
	 * Creates a new <code>QueryTrack</code> with the given group number, unique ID, and the
	 * whitespace-separated keywords that we wish to find.
	 * 
	 * @param group
	 * @param id
	 * @param string
	 */
	public QueryTrack(final int group, final int id, final String string)
	{
		super(Type.TRACK, group, id);
		this.string = string.trim().toLowerCase();
		this.words = this.string.split("\\s");
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#compareTo(tweater.QueryItem)
	 */
	@Override
	public int compareTo(final QueryItem that)
	{
		int result;

		result = super.compareTo(that);
		if(result != 0)
			return result;

		return this.string.compareTo(((QueryTrack)that).string);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(final Object other)
	{
		boolean result;

		result = super.equals(other);
		if(!result)
			return result;

		return this.string.equals(((QueryTrack)other).string);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#hashCode()
	 */
	@Override
	public int hashCode()
	{
		return super.hashCode() + string.hashCode();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tweater.QueryItem#matches(tweater.MatchableStatus)
	 */
	@Override
	public boolean matches(final MatchableStatus status)
	{
		for(final String word : words)
			if(!status.text.contains(word))
				return false;
		return true;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString()
	{
		return string;
	}
}
