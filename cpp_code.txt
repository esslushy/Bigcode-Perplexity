/*  License
 
    _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
    ----
     
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
   
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    See also  http: www.gnu.org/licenses/gpl.html
   
    If this software is modified please retain this statement and add a notice
    that it had been modified (and by whom).  
 
    Endlicense */

#include "bisApproximateLandmarkDisplacementsWithGridTransform.h"
#include "bisImageAlgorithms.h"
#include "bisUtil.h"
#include <sstream>
#include <iomanip>
#include <time.h>

static int count=0;

bisApproximateLandmarkDisplacementsWithGridTransform::bisApproximateLandmarkDisplacementsWithGridTransform(std::string s) : bisOptimizableAlgorithm(s)
{
  this->class_name="bisApproximateLandmarkDisplacementsWithGridTransform";
  this->enable_feedback=0;
}

bisApproximateLandmarkDisplacementsWithGridTransform::~bisApproximateLandmarkDisplacementsWithGridTransform()
{
  this->lastSmoothness=-1.0;
  this->lastSimilarity=-1.0;
  this->debug_flag=0;
}


void bisApproximateLandmarkDisplacementsWithGridTransform::generateFeedback(std::string input)
{

  std::cout << input << "  (" << std::fixed << std::setw(5) << this->lastSimilarity << "," << std::setw(5) << this->lastSmoothness << ")" << std::endl;
}


void bisApproximateLandmarkDisplacementsWithGridTransform::generateFeedback2(std::string input)
{
  std::cout << input << std::endl;
}

// Optimizer Stuff
float bisApproximateLandmarkDisplacementsWithGridTransform::computeValue(std::vector<float>& position)
{
  this->currentGridTransformation->setParameterVector(position);

  int numpoints=this->sourcePoints->getNumRows();
  float* inp_pts=this->sourcePoints->getData();
  float* out_pts=this->targetPoints->getData();
  float* wgt_pts=this->sourceWeights->getData();


  float sum=0.0;
  for (int i=0;i<numpoints;i++)
    {
      float x[3],tx[3],x2[3];
      for (int ia=0;ia<=2;ia++) {
        x[ia]=inp_pts[i*3+ia];
        tx[ia]=out_pts[i*3+ia];
      }
      this->currentGridTransformation->transformPoint(x,x2);
      if (count < 1 && i %1400 == 0 ) 
        std::cout << "x=" << x[0] << "," << x[1] << "," << x[2] << "-->" << x2[0] << "," << x2[1] << "," << x[2] << std::endl;
      

      double d=pow(tx[0]-x2[0],2.0f)+pow(tx[1]-x2[1],2.0f)+pow(tx[2]-x2[2],2.0f);
      float w=wgt_pts[i];

      if (count <1 && i %1400 == 0 ) 
        std::cout << "tx=" << tx[0] << "," << tx[1] << "," << tx[2] << " and d=" << d << " w=" << w << std::endl;

      
      sum+=w*sqrt(d);
    }

  this->lastSimilarity=sum/float(numpoints);
  float v=this->lastSimilarity;
  if (this->lambda>0.0)
    {
      this->lastSmoothness=this->currentGridTransformation->getTotalBendingEnergy();
      v+=this->lambda*this->lastSmoothness;
    }
  //if (count < 11) {
  //std::cout << "sum=" << sum << " last=" << this->lastSimilarity << " v=" << v << std::endl;
  //}
  count=count+1;
  return v;
}

float bisApproximateLandmarkDisplacementsWithGridTransform::computeValueFunctionPiece(int cp)
{

  int numpoints=this->sourcePoints->getNumRows();
  int npc=this->gridPointList[cp].size();
  
  float* inp_pts=this->sourcePoints->getData();
  float* out_pts=this->targetPoints->getData();
  float* wgt_pts=this->sourceWeights->getData();
  float sum=0.0;

  for (int l=0;l<npc;l++)
    {
      int pt=this->gridPointList[cp][l];
      float wb=this->gridPointWeight[cp][l];

      float x[3],tx[3],x2[3];

      for (int ia=0;ia<=2;ia++) {
        x[ia]=inp_pts[pt*3+ia];
        tx[ia]=out_pts[pt*3+ia];
      }
      
      this->currentGridTransformation->transformPoint(x,x2);
      double d=pow(tx[0]-x2[0],2.0f)+pow(tx[1]-x2[1],2.0f)+pow(tx[2]-x2[2],2.0f);
      float w=wgt_pts[pt];
      sum+=wb*w*sqrt(d);
    }

  float v=sum/float(numpoints);
  if (this->lambda>0.0)
    {
      float sm=this->currentGridTransformation->getBendingEnergyAtControlPoint(cp);
      v+=this->lambda*sm;
    }
  
  return v;
}

float bisApproximateLandmarkDisplacementsWithGridTransform::computeGradient(std::vector<float>& params,std::vector<float>& grad)
{
  unsigned int numc=this->currentGridTransformation->getNumberOfControlPoints();
  if (params.size()!=numc*3 || grad.size()!=params.size()) {
    std::cerr << "Bad dimensions for computing grdient optimization in grid transform";
    return 0;
  }

  this->currentGridTransformation->setParameterVector(params);
  float* dispfield=this->currentGridTransformation->getData();
  float GradientNorm = 0.000001f;

  for (unsigned int cp_index=0;cp_index<numc;cp_index++) { 
    for (int coord=0;coord<=2;coord++)
      {
        int index=cp_index+coord*numc;
        dispfield[index]=params[index]-this->stepsize;
        float a=this->computeValueFunctionPiece(cp_index);
        dispfield[index]=params[index]+this->stepsize;
        float b=this->computeValueFunctionPiece(cp_index);
        dispfield[index]=params[index];
        float g=-0.5f*(b-a)/this->stepsize;
        grad[index]=g;
        GradientNorm+=g*g;
      }
  }
  
  GradientNorm = float( sqrt(GradientNorm));
  for (unsigned int i=0;i<grad.size(); i++)
    grad[i]=grad[i]/GradientNorm;
  return GradientNorm;
}

  
int bisApproximateLandmarkDisplacementsWithGridTransform::checkInputParameters(bisJSONParameterList* plist)
{
  std::unique_ptr<bisJSONParameterList> tmp(new bisJSONParameterList(this->name+":plist"));
  this->internalParameters=std::move(tmp);

  
  this->internalParameters->setFloatValue("lambda",bisUtil::frange(plist->getFloatValue("lambda",0.0f),0.0f,1.0f));
  this->internalParameters->setFloatValue("stepsize",bisUtil::frange(plist->getFloatValue("stepsize",1.0f),0.05f,4.0f));
  this->internalParameters->setIntValue("steps",bisUtil::irange(plist->getIntValue("steps",2),1,100));
  this->internalParameters->setIntValue("iterations",bisUtil::irange(plist->getIntValue("iterations",15),1,100));
  this->internalParameters->setFloatValue("tolerance",bisUtil::frange(plist->getFloatValue("tolerance",0.001f),0.0f,0.5f));
  this->lambda=this->internalParameters->getFloatValue("lambda",0.0f);
  this->stepsize=  this->internalParameters->getFloatValue("stepsize",1.0f);
  if (this->enable_feedback)
    this->internalParameters->print("Approximate Landmark Displacement Field");
  return 1;
}

double B(int i, double t)
{
  switch (i) 
    {
    case 0:
      return (1-t)*(1-t)*(1-t)/6.0;
      break;
      
    case 1:
      return (3*t*t*t - 6*t*t + 4)/6.0;
    case 2:
      return (-3*t*t*t + 3*t*t + 3*t + 1)/6.0;
      
    case 3:
      return (t*t*t)/6.0;
    }
  return 0;
}


void bisApproximateLandmarkDisplacementsWithGridTransform::initializePointLists() {

  const float thr=0.01;
 
  int numc=this->currentGridTransformation->getNumberOfControlPoints();
  float ori[3],spa[3];
  int dim[3];
  this->currentGridTransformation->getGridOrigin(ori);
  this->currentGridTransformation->getGridSpacing(spa);
  this->currentGridTransformation->getGridDimensions(dim);

  this->gridPointList.clear();
  this->gridPointWeight.clear();
  for (int i=0;i<numc;i++) {
    std::vector<int> a;
    this->gridPointList.push_back(a);
    std::vector<float> b;
    this->gridPointWeight.push_back(b);

  }

  int gridslicedims=dim[0]*dim[1];
  int numpoints=this->sourcePoints->getNumRows();
  float* pts=this->sourcePoints->getData();
  for (int node=0;node<numpoints;node++)
    {
      double p1[3],s[3];
      int  lat[3];
      for (int ia=0;ia<=2;ia++) {
        p1[ia]=pts[node*3+ia];
        float x=(p1[ia]-ori[ia])/spa[ia];
        lat[ia]=int(floor(x+0.0001));
        s[ia]=x-lat[ia];
      }

      if (node==10 && this->debug_flag>1) {
        std::cout << "__ Point 100 " << p1[0] << "," << p1[1] << "," << p1[2] << std::endl;
        std::cout << "__   lat = " << lat[0] << "," << lat[1] << "," << lat[2] << std::endl;
        std::cout << "__     s = " << s[0] << "," << s[1] << "," << s[2] << std::endl;
      }
      
      for (int k = 0; k < 4; k++)
        {
          int K = bisUtil::irange(k + lat[2] - 1,0,dim[2]-1);
          for (int j = 0; j < 4; j++)
            {
              int J = bisUtil::irange(j + lat[1] - 1,0,dim[1]-1);
              for (int i = 0; i < 4; i++)
                {
                  int I = bisUtil::irange(i + lat[0] - 1,0,dim[0]-1);
                  int   cpoint=I+J*dim[0]+K*gridslicedims;
                  double wgt= B(i, s[0]) * B(j, s[1]) * B(k, s[2]);
                  
                  if (wgt>=thr)
                    {
                      unsigned int found=0 ,index=0;
                      
                      while (found ==0 && index <this->gridPointList[cpoint].size()) {
                        if (this->gridPointList[cpoint][index]==node) {
                          found=1;
                          this->gridPointWeight[cpoint][index]+=wgt;
                          if (node==10 && this->debug_flag>1) {
                            std::cout << "____ " << i << "," << j << "," << k << " ---> " << I << "," << J << "," << K << "  --> " << cpoint << " " << wgt << std::endl;
                            std::cout << "Incrementing " << cpoint << std::endl;
                          }
                        } else {
                          index=index+1;
                        }
                      }
                      
                      if (!found) {
                        if (node==10 && this->debug_flag>1) {
                          std::cout << "____ " << i << "," << j << "," << k << " ---> " << I << "," << J << "," << K << "  --> " << cpoint << " " << wgt << std::endl;
                          std::cout << "Adding to " << cpoint << std::endl;
                        }
                        
                        this->gridPointList[cpoint].push_back(node);
                        this->gridPointWeight[cpoint].push_back(wgt);
                      }
                    }
                }
            }
        }
    }
  
  /*int lst[3]={ 12,12,12 };
  for (int i=0;i<1;i++) {
    int node=lst[i];
    int sz=this->gridPointList[node].size();
    std::cout << "For cp = " << node << std::endl << "\t";
    for (int i=0;i<sz;i++) {
      std::cout << "(" << this->gridPointList[node][i] << "," << this->gridPointWeight[node][i] << ") ";
    }
    std::cout << std::endl;
    }*/
}


// Set Parameters and Run
float bisApproximateLandmarkDisplacementsWithGridTransform::run(bisSimpleMatrix<float>* in_sourceLandmarks,
                                                                bisSimpleMatrix<float>* in_targetLandmarks,
                                                                bisSimpleVector<float>* in_sourceWeights,
                                                                bisGridTransformation* transformation,
                                                                bisJSONParameterList* plist,
                                                                int dbg)
{

  this->debug_flag=dbg;
  if (this->debug_flag<2)
    count=10;
  
  this->currentGridTransformation=transformation;
  this->sourcePoints=in_sourceLandmarks;
  this->targetPoints=in_targetLandmarks;
  this->sourceWeights=in_sourceWeights;

  int rows1=this->sourcePoints->getNumRows();
  int rows2=this->targetPoints->getNumRows();
  int rows3=this->sourceWeights->getLength();

  int cols1=this->sourcePoints->getNumCols();
  int cols2=this->targetPoints->getNumCols();

  if (rows1 < 4 || rows1 != rows2 || rows1 !=rows3 || cols1 !=3  || cols2 !=3 ) {
    std::cerr << "Bad Landmark sets =" << rows1 << "*" << cols1 << " and " << rows2 << "*" << cols2 << " and weights=" << rows3  << std::endl;
    return -1.0;
  }
  this->initializePointLists();

  
  if (this->enable_feedback)
    this->generateFeedback2("++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ +");
  this->checkInputParameters(plist);

  std::stringstream strss;
  strss.precision(5);

  int numsteps=   this->internalParameters->getIntValue("steps");
  int iterations=this->internalParameters->getIntValue("iterations");
  float tolerance=this->internalParameters->getFloatValue("tolerance",0.001f);

  strss.clear();
  std::stringstream strss2;
  strss2 << "++   Beginning to appproximate landmark displacement field . numsteps= " << numsteps << "  tolerance=" << tolerance << " lambda=" << this->lambda;
  this->generateFeedback2(strss2.str());
  
  int numdof=this->currentGridTransformation->getNumberOfDOF();
  this->generateFeedback2("++  ");
  std::stringstream strss3;
  strss3 << "++   Approx numdof=" << numdof << " step=" << this->stepsize;
  this->generateFeedback2(strss3.str());
  this->generateFeedback2("++  ");


  std::unique_ptr<bisOptimizer> optimizer(new bisOptimizer(this));
  std::vector<float> position(numdof);
  // Get current state ...
  this->currentGridTransformation->getParameterVector(position);
  float last=0.0;
  for (int step=numsteps;step>=1;step=step-1)
    {
      std::cout << "~~~~ optimizing. step = " << step << ", iterations = " << iterations << " cur=" << this->stepsize;
      strss.clear();
      this->generateFeedback2(strss.str());
      last=optimizer->computeConjugateGradient(position,iterations,tolerance);
      this->stepsize*=0.5;
    }
  this->generateFeedback2("++  ");
  return last;
}




/*  License
 
 _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
 ----
     
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   See also  http: www.gnu.org/licenses/gpl.html
   
   If this software is modified please retain this statement and add a notice
   that it had been modified (and by whom).  
 
 Endlicense */


#include "bisLinearRPMRegistration.h"
#include "bisUtil.h"

bisLinearRPMRegistration::bisLinearRPMRegistration(std::string n) : bisRPMCorrespondenceFinder(n) {
  this->Output=new bisMatrixTransformation();
}

bisLinearRPMRegistration::~bisLinearRPMRegistration()
{
  if (this->Output)
    delete this->Output;
}


  // Description:
  // get Output Transformation  
bisSimpleMatrix<float>* bisLinearRPMRegistration::getOutputMatrix() {
  return this->Output->getSimpleMatrix("lin_reg_matrix");
}

/** run transformation
 * @param transformMode (0=rigid,1=similarity,2=affine)
 * @param initialTemperature initial temperature
 * @param finalTemperature final temperature
 * @param annealRate anneal rate for RPM
 * @param useCentroids if true center points first
 * @param initialTransformaiton use this to initialize the mappings
 * @param debug if true print extra messages
 * @returns 1 if success, 0 if failed
 */
int bisLinearRPMRegistration::run(int in_transformMode,
                                  int in_correspondenceMode,
                                  float in_initialTemperature,
                                  float in_finalTemperature,
                                  int in_iterationPerTemperature,
                                  float in_annealRate,
                                  int in_useCentroids,
                                  bisMatrixTransformation* in_initialTransformation,
                                  int in_debug) {


  if (this->locator==NULL) {
    std::cerr << "___ bisLinearRPMRegistration not initialized" << std::endl;
    return 0;
  }


  int IterationPerTemperature = bisUtil::irange(in_iterationPerTemperature,1,10);
  int TransformMode=bisUtil::irange(in_transformMode,0,2);
  int CorrespondenceMode=bisUtil::irange(in_correspondenceMode,0,2);
  float FinalTemperature=bisUtil::frange(in_finalTemperature,0.01,1000.0);
  float InitialTemperature=bisUtil::frange(in_initialTemperature,FinalTemperature,1000.0);
  float AnnealRate=bisUtil::frange(in_annealRate,0.5,0.999);
  int debug=in_debug;

  // Initial Mapping including centroid shift!
  bisUtil::mat44 m;
  if (!in_initialTransformation) {
    bisUtil::makeIdentityMatrix(m);
    if (in_useCentroids) {
      float cx[3],cy[3];
      bisPointRegistrationUtils::computeCentroid(this->SampledReferencePoints.get(),cx,debug);
      bisPointRegistrationUtils::computeCentroid(this->SampledTargetPoints.get(),cy,debug);
      if (debug)
        std::cout << "___ using initial centroid alignment :";
      for (int ia=0;ia<=2;ia++) {
        m[ia][3]=cy[ia]-cx[ia];
        if (debug)
          std::cout << m[ia][3] << " ";
      }
      
      if (debug)
        std::cout << std::endl;
    } else {
      if (debug)
        std::cout << "Not using centroids " << std::endl;
    }
    this->Output->setMatrix(m);
  }  else {
    if (debug)
      std::cout << "Using Initial Transformation" << std::endl;
    in_initialTransformation->getMatrix(m);
    this->Output->setMatrix(m);
  }
    bisPointRegistrationUtils::printMatrix(this->Output,"Initial Mapping");

  bisSimpleMatrix<float>* OutputRefLandmarks=new bisSimpleMatrix<float>();
  bisSimpleMatrix<float>* OutputTargetLandmarks=new bisSimpleMatrix<float>();
  bisSimpleVector<float>* OutputWeights=new bisSimpleVector<float>();
                                       
  
  float Temperature=InitialTemperature;
  int numpoints=this->SampledReferencePoints->getNumRows();
  int numpoints2=this->SampledTargetPoints->getNumRows();
    
  if (debug) {
    std::cout << "___ Beginning  Linear RPM Registration tmode=" << TransformMode << " cmode=" << CorrespondenceMode << std::endl;
    std::cout << "___            NumPoints= " << numpoints << " vs " << numpoints2 << " temperatures=" << InitialTemperature << ":" << AnnealRate << ":" << FinalTemperature << std::endl;
  }

  int iteration=0;
  int totaliter=int(fabs(log(InitialTemperature/FinalTemperature)/log(AnnealRate))+1.0)*IterationPerTemperature;
  int incr=int(numpoints/5);
  
  while (Temperature > FinalTemperature)
    {
      for (int it=0;it<IterationPerTemperature;it++) {
        iteration=iteration+1;
        if (debug) 
          std::cout << "___ Beginning iteration " << iteration << "/" << totaliter << ". Temp=" << Temperature << "  TransformMode=" << TransformMode << std::endl;
        
        
        this->estimateCorrespondence(this->Output,
                                     Temperature,
                                     CorrespondenceMode,
                                     OutputRefLandmarks,
                                     OutputTargetLandmarks,
                                     OutputWeights,
                                     debug);
        
        if (debug) {
          bisPointRegistrationUtils::printJointPoints(OutputRefLandmarks,OutputTargetLandmarks,OutputWeights,"out_ref->targ",incr);
        }
        bisPointRegistrationUtils::computeLandmarkTransformation(OutputRefLandmarks,
                                                                 OutputTargetLandmarks,
                                                                 TransformMode,
                                                                 this->Output,
                                                                 OutputWeights,
                                                                 0);
        
        if (debug) {
          bisPointRegistrationUtils::printMatrix(this->Output,"End");
          std::cout << "__ Mean RMS=" << bisPointRegistrationUtils::computeMappingError(OutputRefLandmarks,OutputTargetLandmarks,this->Output) << std::endl;
        }
      }
      Temperature*=AnnealRate;
      // Check error
      
    }

  delete OutputRefLandmarks;
  delete OutputTargetLandmarks;
  delete OutputWeights;

  return iteration;
}


/*  License
 
 _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
 ----
     
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   See also  http: www.gnu.org/licenses/gpl.html
   
   If this software is modified please retain this statement and add a notice
   that it had been modified (and by whom).  
 
 Endlicense */
#include "bisGPLTestFunctions.h"
#include "bisSimpleDataStructures.h"
#include "bisJSONParameterList.h"
#include "bisMatrixTransformation.h"
#include "bisGridTransformation.h"
#include "bisOptimizer.h"
#include "bisApproximateLandmarkDisplacementsWithGridTransform.h"
#include "bisRPMCorrespondenceFinder.h"
#include "bisPointLocator.h"
#include <memory>



class bisTestOptimizable : public bisOptimizableAlgorithm {

public:
  bisTestOptimizable() : bisOptimizableAlgorithm("test") { };
  
  float computeGradient(std::vector<float>& params,std::vector<float>& grad) {

    int num=params.size();
    if (num==2) {
      
      float x=params[0],y=params[1];
      float dx=2*(x-9), dy=2*y;
      float s=float(sqrt(dx*dx+dy*dy)+0.00001);
      grad[0]=dx/s; grad[1]=dy/s;
      return s;
    }
    
    double x=params[0], dx=2.0f*(x-9.0f);
    grad[0]=float(dx/fabs(dx));
    return float(fabs(dx));
  };
  
  float computeValue(std::vector<float>& params) {

    int num=params.size();
    float x=params[0];
    float v=0.0,y=0.0;
    if (num==2)
      y=params[1];
    v=(x-9)*(x-9)+y*y;
    return v;
  };
  
  float comparePos(std::vector<float> p,std::vector<float> tp) {
    float sum=0.0;
    for (unsigned int ia=0;ia<p.size();ia++)
      sum+=powf(p[ia]-tp[ia],2.0f);
    return sum;
  }
};


int  test_optimizer(int numparam) {

  int numdof=numparam;
  int numfail=0;
  
  for (int mode=0;mode<=2;mode++)
    {
      std::unique_ptr<bisTestOptimizable> test_optimizable(new bisTestOptimizable());
      std::unique_ptr<bisOptimizer> optimizer(new bisOptimizer(test_optimizable.get()));

      std::vector<float> position(numdof);
      position[0]=15;
      if (numdof>1)
	position[1]=5;
      
      std::vector<float> truepos(numdof);
      truepos[0]=9;
      if (numdof>1)
	truepos[1]=0;


      if (position.size()==2)
	std::cout << std::endl << "________________ mode=" << mode << " pos="  << position[0] << ", " << position[1] << std::endl;
      else
	std::cout << std::endl << "________________ mode=" << mode << " pos="  << position[0] << ", " << std::endl;
      
      if (mode==0) 
	optimizer->computeSlowClimb(position,0.5,25);
      else if (mode==1)
	optimizer->computeGradientDescent(position,25,0.01f);
      else
	optimizer->computeConjugateGradient(position,25,0.01f);
      
      float d=test_optimizable->comparePos(position,truepos);

      if (d>0.1)
	numfail++;

      if (position.size()==2)
	std::cout << "\t\t Final " << position[0] << ", " << position[1] << ". Diff2=" << d << " numfail=" << numfail << std::endl;
      else
      	std::cout << "\t\t Final " << position[0] << ". Diff2=" << d << " numfail=" << numfail << std::endl;
      
      if (d>0.1)
	return numfail;
      

    }
  return numfail;
}

// ------------------------------------------------------------------------

unsigned char*  test_landmarkApproximationWASM(unsigned char* in_source_ptr,
                                               unsigned char* in_target_ptr,
                                               const char* jsonstring,
                                               int debug)
{

  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  float spacing=params->getFloatValue("spacing",20.0);
  if (debug)
    std::cout << "___ spacing=" << spacing << std::endl;

  std::unique_ptr<bisSimpleMatrix<float> > source(new bisSimpleMatrix<float>("source_points_json"));
  if (!source->linkIntoPointer(in_source_ptr))
    return 0;

  if (debug)
    std::cout << "___ Ref Allocated = " << source->getNumRows() << "*" << source->getNumCols() << std::endl;
  
  std::unique_ptr<bisSimpleMatrix<float> > target(new bisSimpleMatrix<float>("target_points_json"));
  if (!target->linkIntoPointer(in_target_ptr))
    return 0;

  if (debug) 
    std::cout << "___ Target Allocated = " << target->getNumRows() << "*" << target->getNumCols() << std::endl;

  int numpoints=source->getNumRows();
  std::unique_ptr<bisSimpleVector<float> > weights(new bisSimpleVector<float>("weights_points_json"));
  weights->allocate(numpoints);
  weights->fill(1.0);

  if (debug) 
    std::cout << "___ Weights Allocated = " << weights->getLength() << std::endl;

  
  float minc[3],maxc[3];
  float* pts=source->getData();

  // Find min and max and create bounds
  for (int ia=0;ia<=2;ia++) {
    minc[ia]=pts[ia];
    maxc[ia]=pts[ia];
  }

  for (int index=1;index<numpoints;index++) {
    int offset=index*3;
    
    for (int ia=0;ia<=2;ia++) {
      float p=pts[offset+ia];
      if (minc[ia]>p) minc[ia]=p;
      if (maxc[ia]<p) maxc[ia]=p;
    }
  }

  int dim[3];
  float ori[3],spa[3];
  
  for (int ia=0;ia<=2;ia++) {
    float l=maxc[ia]-minc[ia];
    dim[ia]=int(l/spacing)+1;
    float l2=(dim[ia]-1)*spacing;
    ori[ia]=minc[ia]-(l2-l)*0.5;
    spa[ia]=spacing;
  }

  if (debug) {
    std::cout << "__ Creating Grid " << std::endl;
    std::cout << "__    min bounds " << minc[0] << "," << minc[1] << "," << minc[2] << std::endl;
    std::cout << "__    max bounds " << maxc[0] << "," << maxc[1] << "," << maxc[2] << std::endl;
    std::cout << "__    grid dim   " << dim[0] << "," << dim[1] << "," << dim[2] << std::endl;
    std::cout << "__    grid spa   " << spa[0] << "," << spa[1] << "," << spa[2] << std::endl;
    std::cout << "__    grid ori   " << ori[0] << "," << ori[1] << "," << ori[2] << std::endl;
  }
  std::unique_ptr<bisGridTransformation> grid(new bisGridTransformation());
  grid->initializeGrid(dim,spa,ori,1);
  
  std::unique_ptr<bisApproximateLandmarkDisplacementsWithGridTransform> landmarkFit(new bisApproximateLandmarkDisplacementsWithGridTransform());
  landmarkFit->run(source.get(),target.get(),weights.get(),grid.get(),params.get(),debug);

  if (debug)
    std::cout << "___ Transforming points " << std::endl;
  
  std::unique_ptr<bisSimpleMatrix<float> > output(new bisSimpleMatrix<float>("warped_points_json"));
  output->zero(source->getNumRows(),3);

  float* srcPts=source->getData();
  float* outPts=output->getData();
  for (int i=0;i<source->getNumRows();i++) {
    float x1[3],x2[3];
    for (int ia=0;ia<=2;ia++) 
      x1[ia]=srcPts[i*3+ia];
    grid->transformPoint(x1,x2);
    for (int ia=0;ia<=2;ia++)
      outPts[i*3+ia]=x2[ia];
  }
    
      
  return output->releaseAndReturnRawArray();

}
// ------------------------------------------------------------------------

unsigned char*  test_rpmCorrespondenceEstimatorWASM(unsigned char* in_source,
                                                    unsigned char* in_target,
                                                    const char* jsonstring,
                                                    int debug)
{
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  float temperature=params->getFloatValue("temperature",10.0);
  int mode=params->getIntValue("mode",2);
  int numlandmarks=params->getIntValue("numpoints",1000);
    
  if (debug)
    std::cout << "___ temperature=" << temperature << " mode=" << mode << " numpoints=" << numlandmarks << std::endl;

  std::unique_ptr<bisSimpleMatrix<float> > source(new bisSimpleMatrix<float>("source_points_json"));
  if (!source->linkIntoPointer(in_source))
    return 0;

  if (debug)
    std::cout << "___ Ref Allocated = " << source->getNumRows() << "*" << source->getNumCols() << std::endl;
  
  std::shared_ptr<bisSimpleMatrix<float> > target(new bisSimpleMatrix<float>("target_points_json"));
  if (!target->linkIntoPointer(in_target))
    return 0;

  if (debug) 
    std::cout << "___ Target Allocated = " << target->getNumRows() << "*" << target->getNumCols() << std::endl;

  std::unique_ptr<bisPointLocator> locator(new bisPointLocator());
  locator->initialize(target,0.2,0);

  std::unique_ptr<bisMatrixTransformation> matrix(new bisMatrixTransformation());
  matrix->identity();

  int numref=source->getNumRows();
  int numtarget=target->getNumRows();  
  std::unique_ptr<bisSimpleMatrix<float> > OutputRefLandmarks(new bisSimpleMatrix<float>());
  std::unique_ptr<bisSimpleMatrix<float> > OutputTargetLandmarks(new bisSimpleMatrix<float>());
  std::unique_ptr<bisSimpleVector<float> > OutputWeights(new bisSimpleVector<float>());
  OutputRefLandmarks->zero(numref,3);
  OutputTargetLandmarks->zero(numref,3);
  OutputWeights->zero(numref);


  std::unique_ptr<bisSimpleVector<int> > RefLabels(new bisSimpleVector<int>());
  RefLabels->zero(numref);

  std::unique_ptr<bisSimpleVector<int> > TargLabels(new bisSimpleVector<int>());
  TargLabels->zero(numtarget);
  

  if (mode == 0) {
    bisRPMCorrespondenceFinder::computeCorrespodnencesICP(matrix.get(),locator.get(),
                                                          source->getData(),
                                                          OutputRefLandmarks->getData(),
                                                          OutputTargetLandmarks->getData(),
                                                          OutputWeights->getData(),
                                                          numref,debug);

    return OutputTargetLandmarks->releaseAndReturnRawArray();
  }


  bisRPMCorrespondenceFinder::computeCorrespondencesRPM(matrix.get(),locator.get(),
                                                        mode,
                                                        source->getData(),RefLabels->getData(),
                                                        target->getData(),TargLabels->getData(),
                                                        OutputRefLandmarks->getData(),
                                                        OutputTargetLandmarks->getData(),
                                                        OutputWeights->getData(),
                                                        temperature,numref,numtarget,debug);

  //  std::cout << "M=" << M << std::endl;
  
  return OutputTargetLandmarks->releaseAndReturnRawArray();
}

unsigned char*  test_rpmSamplingWASM(unsigned char* in_points,
                                     unsigned char* in_labels,
                                     const char* jsonstring,
                                     int debug)
{

  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  int prefsampling=params->getIntValue("prefsampling",2);
  int numlandmarks=params->getIntValue("numpoints",1000);

    
  if (debug)
    std::cout << " prefsampling=" << prefsampling << " numpoints=" << numlandmarks << std::endl;

  std::unique_ptr<bisSimpleMatrix<float> > points(new bisSimpleMatrix<float>("points_points_json"));
  if (!points->linkIntoPointer(in_points))
    return 0;

  if (debug)
    std::cout << "___ Ref Allocated = " << points->getNumRows() << "*" << points->getNumCols() << std::endl;
  
  std::unique_ptr<bisSimpleVector<int> > labels(new bisSimpleVector<int>("labels_points_json"));
  if (!labels->linkIntoPointer(in_labels))
    return 0;

  if (debug) 
    std::cout << "___ Labels Allocated = " << labels->getLength()  << std::endl;


  std::unique_ptr<bisSimpleMatrix<float> > out_points(new bisSimpleMatrix<float>("out_points_points_json"));
  std::unique_ptr<bisSimpleVector<int> > out_labels(new bisSimpleVector<int>("out_labels_points_json"));
  
  bisRPMCorrespondenceFinder::samplePoints(points.get(),
                                           labels.get(),
                                           numlandmarks,
                                           prefsampling,
                                           out_points.get(),
                                           out_labels.get(),
                                           debug);

  return out_points->releaseAndReturnRawArray();
}
/*  License
 
 _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
 ----
     
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   See also  http: www.gnu.org/licenses/gpl.html
   
   If this software is modified please retain this statement and add a notice
   that it had been modified (and by whom).  
 
 Endlicense */


#include "bisAbstractImageRegistration.h"
#include "bisImageAlgorithms.h"
#include "bisUtil.h"
#include "bisIdentityTransformation.h"


bisAbstractImageRegistration::bisAbstractImageRegistration(std::string n) : bisOptimizableAlgorithm(n)
{
  this->use_weights=0;
  this->has_reference_weight=0;
  this->has_target_weight=0;}
  
bisAbstractImageRegistration::~bisAbstractImageRegistration()
{
}

void bisAbstractImageRegistration::initializeLevel(int level,bisAbstractTransformation* initial)
{
  float rsc=this->internalParameters->getFloatValue("resolution",1.5f);
  float rate=this->internalParameters->getFloatValue("resolutionrate",2.0f);
  float resolution=rsc*powf(rate,level-1.0f);

  if (this->enable_feedback)
    std::cout << "+ +  Initializing level r=" << rsc << ", rate=" << rate << " resol= " << resolution << std::endl;
  this->prepareImagesForRegistration(resolution,initial);

}


// Set Input and Output Images
void bisAbstractImageRegistration::setReferenceImage(std::shared_ptr<bisSimpleImage<float> > im) {
  this->reference=im;
}

void bisAbstractImageRegistration::setTargetImage(std::shared_ptr<bisSimpleImage<float> > im) {
  this->target=im;
}

void bisAbstractImageRegistration::setReferenceWeightImage(std::shared_ptr<bisSimpleImage<short> > im)
{
  this->reference_weight=im;
  this->has_reference_weight=1;
}

void bisAbstractImageRegistration::setTargetWeightImage(std::shared_ptr<bisSimpleImage<short> > im)
{
  this->target_weight=im;
  this->has_target_weight=1;
}
 

  // Ensure all parameters are there
int bisAbstractImageRegistration::checkInputParameters(bisJSONParameterList* plist)
{

  std::unique_ptr<bisJSONParameterList> tmp(new bisJSONParameterList(this->name+":plist"));
  this->internalParameters=std::move(tmp);

  // 0 = SSD,1=CC,2=MI,3=NMI
  this->internalParameters->setIntValue("metric",bisUtil::irange(plist->getIntValue("metric",3),0,3));

  // 0 = HillClimb,1=Gradient Descent,2=Conjuhgate
  this->internalParameters->setIntValue("optimization",bisUtil::irange(plist->getIntValue("optimization",2),0,2));

  // Num levels
  this->internalParameters->setIntValue("levels",bisUtil::irange(plist->getIntValue("levels",3),1,4));
  this->internalParameters->setIntValue("steps",bisUtil::irange(plist->getIntValue("steps",1),1,4));
  this->internalParameters->setFloatValue("stepsize",bisUtil::frange(plist->getFloatValue("stepsize",1.0),0.05f,4.0f));
  this->internalParameters->setIntValue("iterations",bisUtil::irange(plist->getIntValue("iterations",15),1,100));
  this->internalParameters->setIntValue("numbins",bisUtil::irange(plist->getIntValue("numbins",64),4,1024));
  this->internalParameters->setIntValue("intscale",bisUtil::irange(plist->getIntValue("intscale",10),1,10));
  this->internalParameters->setFloatValue("resolution",bisUtil::frange(plist->getFloatValue("resolution",1.5),0.5f,10.0f));
  this->internalParameters->setFloatValue("resolutionrate",bisUtil::frange(plist->getFloatValue("resolutionrate",2.0f),1.5f,3.0f));
  this->internalParameters->setFloatValue("tolerance",bisUtil::frange(plist->getFloatValue("tolerance",0.001f),0.0f,0.5f));
  this->internalParameters->setFloatValue("smoothing",bisUtil::frange(plist->getFloatValue("smoothing",1.0),0.0,20.0));
  
  this->internalParameters->setIntValue("referenceFrame",plist->getIntValue("referenceFrame",0));
  this->internalParameters->setIntValue("targetFrame",plist->getIntValue("targetFrame",0));
  this->internalParameters->setBooleanValue("normalize",plist->getBooleanValue("normalize",1));
  this->internalParameters->setBooleanValue("debug",plist->getBooleanValue("debug",1));

  if (this->internalParameters->getBooleanValue("debug",1))
    this->enable_feedback=1;
  else
    this->enable_feedback=0;
  this->metric=this->internalParameters->getIntValue("metric",3);

  return 1;
}


int bisAbstractImageRegistration::prepareImagesForRegistration(float resolution_factor,bisAbstractTransformation* initial)
{
  
  int numbins=this->internalParameters->getIntValue("numbins",64);
  int normalize=this->internalParameters->getBooleanValue("normalize",1);

  float smoothing=this->internalParameters->getFloatValue("smoothing",1.0);
  int intscale=this->internalParameters->getIntValue("intscale",1);
  
  int ref_frame=this->internalParameters->getIntValue("referenceFrame",0);
  int targ_frame=this->internalParameters->getIntValue("targetFrame",0);

  this->use_weights=0;
  if (this->has_reference_weight!=0)
    {
      this->use_weights=1;
      if (this->has_target_weight!=0)
	this->use_weights=2;
    }

  std::unique_ptr<bisSimpleImage<short> > tl(bisImageAlgorithms::prepareImageForRegistration(this->reference.get(),numbins,normalize,resolution_factor,smoothing,intscale,ref_frame,this->name+":level_ref_image",this->enable_feedback));
  this->level_reference=std::move(tl);


  if (initial)
    {
      
      int refdim[5]; this->level_reference->getDimensions(refdim);
      float refspa[5]; this->level_reference->getSpacing(refspa);
      std::unique_ptr<bisSimpleImage<short > > tempt(bisImageAlgorithms::prepareAndResliceImageForRegistration(this->target.get(),
                                                                                                               initial,
                                                                                                               refdim,refspa,
                                                                                                               numbins,normalize,
                                                                                                               smoothing,
                                                                                                               intscale,targ_frame,
                                                                                                               this->name+":level_targ_resl_image",
                                                                                                               1));
      this->level_target=std::move(tempt);
    }
  else
    {
      std::unique_ptr<bisSimpleImage<short> > tempt(bisImageAlgorithms::prepareImageForRegistration(this->target.get(),numbins,normalize,
                                                                                                    resolution_factor,smoothing,intscale,targ_frame,
                                                                                                    this->name+":level_targ_image",this->enable_feedback));
      this->level_target=std::move(tempt);
    }

  // This resolution factor should be 1 !!!!!!!!11 (do not reslice until later .. i.e. do not reslice!)
  
  // Temp for reslicing into
  std::unique_ptr<bisSimpleImage<short> > tmp25(new bisSimpleImage<short>(this->name+":temp_target_image"));
  this->temp_target=std::move(tmp25);
  this->temp_target->copyStructure(this->level_reference.get());


  if (this->use_weights>0)
    {
      std::unique_ptr<bisIdentityTransformation> xform(new bisIdentityTransformation(this->name+"ident"));

      std::unique_ptr<bisSimpleImage<short> > tmp3(new bisSimpleImage<short>(this->name+":level_reference_weight"));
      this->level_reference_weight=std::move(tmp3);
      this->level_reference_weight->copyStructure(this->level_reference.get());
      bisImageAlgorithms::resliceImage(this->reference_weight.get(),this->level_reference_weight.get(),xform.get(),1,0.0);

      if (this->use_weights==2) {
	std::unique_ptr<bisSimpleImage<short> > tmp4(new bisSimpleImage<short>(this->name+":level_target_weight"));
	this->level_target_weight=std::move(tmp4);
	this->level_target_weight->copyStructure(this->level_target.get());
	// This resolution factor should be 1 !!!!!!!!11 (do not reslice until later .. i.e. do not reslice!)
	if (initial==0)
	  bisImageAlgorithms::resliceImage(this->target_weight.get(),this->level_target_weight.get(),xform.get(),1,0.0);
	else
	  bisImageAlgorithms::resliceImage(this->target_weight.get(),this->level_target_weight.get(),initial,1,0.0);

	// Temp for reslicing into
	std::unique_ptr<bisSimpleImage<short> > tmp45(new bisSimpleImage<short>(this->name+":this_temp_target_weight"));
	this->temp_target_weight=std::move(tmp45);
	this->temp_target_weight->copyStructure(this->level_reference.get());
      }
    }

  std::unique_ptr<bisJointHistogram> tmp(new bisJointHistogram(this->name+":joint_histo"));
  this->internalHistogram=std::move(tmp);
  internalHistogram->initialize(numbins,numbins,intscale);

   this->level_reference->getImageDimensions(level_dimensions);
  for (int ia=0;ia<=2;ia++)
    {
      this->level_bounds[2*ia]=0;
      this->level_bounds[2*ia+1]=this->level_dimensions[ia]-1;
    }
  
  return 1;

}
float bisAbstractImageRegistration::getCurrentStepSize() {
  return this->current_step_size;
}


/*  License
 
 _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
 ----
     
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   See also  http: www.gnu.org/licenses/gpl.html
   
   If this software is modified please retain this statement and add a notice
   that it had been modified (and by whom).  
 
 Endlicense */

#include "bisSimpleDataStructures.h"
#include "bisGPLExportedFunctions.h"
#include "bisJSONParameterList.h"
#include "bisMatrixTransformation.h"
#include "bisGridTransformation.h"
#include "bisComboTransformation.h"
#include "bisDataObjectFactory.h"
#include "bisDTIAlgorithms.h"
#include "bisImageSegmentationAlgorithms.h"
#include "bisLinearImageRegistration.h"
#include "bisNonLinearImageRegistration.h"
#include "bisApproximateDisplacementField.h"
#include "bisLinearRPMRegistration.h"
#include "bisNonLinearRPMRegistration.h"
#include <memory>


int uses_gpl() {
  return 1;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------
// Linear Image Registration
// --------------------------------------------------------------------------------------------------------------------------------------------------------

unsigned char* runLinearRegistrationWASM(unsigned char* reference,
					 unsigned char* target,
					 unsigned char* initial_ptr,
					 const char* jsonstring,
					 int debug)
{  
  if (debug)
    std::cout << "_____ Beginning runLinearRegistrationJSON" << std::endl;
  
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  int return_vector=params->getBooleanValue("return_vector",0);
  
  //  if(debug)
  //    params->print("from runLinearRegistrationJSON","_____");

  std::shared_ptr<bisSimpleImage<float> > reference_image(new bisSimpleImage<float>("reference_image_json"));
  if (!reference_image->linkIntoPointer(reference))
    return 0;
  
  std::shared_ptr<bisSimpleImage<float> > target_image(new bisSimpleImage<float>("target_image_json"));
  if (!target_image->linkIntoPointer(target))
    return 0;

  std::unique_ptr<bisMatrixTransformation> initial_transformation(new bisMatrixTransformation("parse_initial"));
  initial_transformation->identity();
  
  std::unique_ptr<bisSimpleMatrix<float> > initial_matrix(new bisSimpleMatrix<float>("initial_matrix_json"));
  if (initial_ptr!=0)
    {
      if (!initial_matrix->linkIntoPointer(initial_ptr))
	return 0;
      if (!initial_transformation->setSimpleMatrix(initial_matrix.get()))
	return 0;
    }

  std::unique_ptr<bisLinearImageRegistration> reg(new bisLinearImageRegistration("linear registration"));
  reg->setReferenceImage(reference_image);
  reg->setTargetImage(target_image);
  reg->setInitialTransformation(initial_transformation.get());
  reg->run(params.get());


  
  if (return_vector==0)
    {
      std::unique_ptr<bisSimpleMatrix<float> > output(reg->getOutputMatrix());
      bisUtil::mat44 m; output->exportMatrix(m);
      return output->releaseAndReturnRawArray();
    }

  std::unique_ptr<bisSimpleVector<float> > output(reg->getTransformationParameterVector());
  int length=output->getLength();

  Eigen::MatrixXf outmat=Eigen::MatrixXf::Zero(length,1);
  for (int i=0;i<length;i++)
    outmat(i,0)=output->getData()[i];
  return bisEigenUtil::serializeAndReturn(outmat,"param_vector");
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------
// Non Linear Image Registration
// --------------------------------------------------------------------------------------------------------------------------------------------------------

unsigned char* runNonLinearRegistrationWASM(unsigned char* reference,
					    unsigned char* target,
					    unsigned char* initial_ptr,
					    const char* jsonstring,
					    int debug)
{

  if (debug)
    std::cout << "_____ Beginning runNonLinearRegistrationJSON" << std::endl;
  
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  //  if(debug)
  //    params->print("from runNonLinearRegistrationJSON","_____");

  std::shared_ptr<bisSimpleImage<float> > reference_image(new bisSimpleImage<float>("reference_image_json"));
  if (!reference_image->linkIntoPointer(reference))
    return 0;
  
  std::shared_ptr<bisSimpleImage<float> > target_image(new bisSimpleImage<float>("target_image_json"));
  if (!target_image->linkIntoPointer(target))
    return 0;

  std::unique_ptr<bisNonLinearImageRegistration> reg(new bisNonLinearImageRegistration("nonlinear"));
  reg->setReferenceImage(reference_image);
  reg->setTargetImage(target_image);

  if (initial_ptr) {
    std::shared_ptr<bisAbstractTransformation> initial_transformation=bisDataObjectFactory::deserializeTransformation(initial_ptr,"initialxform");
    reg->setInitialTransformation(initial_transformation);
  }
  reg->run(params.get());

  std::shared_ptr<bisComboTransformation> output(reg->getOutputTransformation());
  unsigned char* pointer=output->serialize();
  return pointer;
}


// -----------------------------------------------------------------------------------------------------
// Image Segmentation
// -----------------------------------------------------------------------------------------------------
template <class BIS_TT> unsigned char* segmentImageTemplate(unsigned char* input,bisJSONParameterList* params,int debug,BIS_TT*)
{
  std::unique_ptr<bisSimpleImage<BIS_TT> > inp_image(new bisSimpleImage<BIS_TT>("inp_image"));
  if (!inp_image->linkIntoPointer(input))
    return 0;

  int frame=params->getIntValue("frame",0);
  int component=params->getIntValue("component",0);
  int numclasses=params->getIntValue("numclasses",3);
  float maxsigmaratio=params->getFloatValue("maxsigmaratio",0.2f);
  int robust=params->getBooleanValue("robust",1);
  int smhisto=params->getBooleanValue("smoothhisto",1);
  int num_bins=params->getIntValue("numbins",256);
  int max_iterations=params->getIntValue("maxiterations",30);
  float convergence=params->getFloatValue("convergence",0.05f);
  int use_variance=params->getBooleanValue("usevariance",1);
  float smoothness=params->getFloatValue("smoothness",0.0f);
  int mrfiterations=params->getIntValue("mrfiterations",8);
  int internaliterations=params->getIntValue("internaliterations",4);
  float noisesigma2=params->getFloatValue("noisesigma2",25.0f);
  float mrfconvergence=params->getFloatValue("mrfconvergence",0.2f);
  
  
  if (debug) {
    std::cout << "Image Segmentation Parameters: smoothness=" << smoothness << std::endl;
    std::cout << "Parsed parameters  frame=" << frame << " comp=" << component << std::endl;
    std::cout << "\t numclasses=" << numclasses << " maxsigmaratio=" << maxsigmaratio << " maxiter=" << max_iterations << " conv=" << convergence << " numbins=" << num_bins << std::endl;
    std::cout << "\t robust=" << robust << " smoothisto=" << smhisto << std::endl;
    if (smoothness>0.0)
      std::cout << "\t MRF -- mrfiterations=" << mrfiterations << "internaliter=" << internaliterations << " noisesigma2=" << noisesigma2 << " mrfconvergence=" << mrfconvergence << std::endl;
    std::cout << "-----------------------------------" << std::endl;
  }
  
  
  if (debug)
    std::cout << std::endl << "..... Begin Histogram Segmentation" << std::endl;
  std::unique_ptr<bisSimpleImage<short> > out_image(bisImageSegmentationAlgorithms::histogramSegmentation(inp_image.get(),
													  numclasses,maxsigmaratio,
													  max_iterations,convergence,use_variance,
													  num_bins,robust,smhisto,
													  frame,component));
  if (debug)
    std::cout << std::endl << "..... Histogram Segmentation done" << std::endl;

  if (smoothness>0.0)
    {
      if (debug)
	std::cout << std::endl << "..... Begin MRF Segmentation" << std::endl;
      
      bisImageSegmentationAlgorithms::doMRFSegmentation(inp_image.get(),
							out_image.get(),
							smoothness,
							noisesigma2,
							convergence,
							mrfiterations,internaliterations,
							frame,component);
      if (debug)
	std::cout << std::endl << "..... MRF Segmentation done" << std::endl;
    }
  
  return out_image->releaseAndReturnRawArray();
}

unsigned char* segmentImageWASM(unsigned char* input,
				     const char* jsonstring,int debug)
{
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  int ok=params->parseJSONString(jsonstring);
  if (!ok) 
    return 0;

  if(debug)
    params->print();

  int* header=(int*)input;
  int in_type=header[1];

  switch (in_type)
      {
	bisvtkTemplateMacro( return segmentImageTemplate(input,params.get(),debug, static_cast<BIS_TT*>(0)));
      }
  return 0;
}

// ------------------------------------------------------------------------------------
unsigned char* approximateDisplacementFieldWASM(unsigned char* dispfield_ptr,
						unsigned char* initial_grid_ptr,
						const char* jsonstring,
						int debug)
{
  if (debug)
    std::cout << "_____ Beginning approximateDisplacementFieldJSON" << std::endl;
  
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  //  if(debug)
  //    params->print("from runApproximateDisplacementField","_____");

  std::unique_ptr<bisSimpleImage<float> > disp_field(new bisSimpleImage<float>("disp_field_json"));
  if (!disp_field->linkIntoPointer(dispfield_ptr))
    return 0;

  
  std::unique_ptr<bisGridTransformation> initial_grid(new bisGridTransformation("initial_grid_json"));
  if (!initial_grid->deSerialize(initial_grid_ptr))
    return 0;


  std::unique_ptr<bisApproximateDisplacementField> reg(new bisApproximateDisplacementField("approx"));
  reg->run(disp_field.get(),initial_grid.get(),params.get());


  unsigned char* pointer=initial_grid->serialize();
  return pointer;
}

// ------------------------------------------------------------------------------------
unsigned char* approximateDisplacementFieldWASM2(unsigned char* dispfield_ptr,
						 const char* jsonstring,
						 int debug)
{
  if (debug)
    std::cout << "_____ Beginning approximateDisplacementFieldJSON" << std::endl;
  
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  if(debug)
    params->print("from runApproximateDisplacementField","_____");

  std::unique_ptr<bisSimpleImage<float> > disp_field(new bisSimpleImage<float>("disp_field_json"));
  if (!disp_field->linkIntoPointer(dispfield_ptr))
    return 0;


  float spacing=params->getFloatValue("spacing",10.0);
  int dim[3]; disp_field->getImageDimensions(dim);
  float spa[3]; disp_field->getImageSpacing(spa);
  int griddim[3];
  float gridspa[3],gridori[3];
  
  for (int ia=0;ia<=2;ia++) {
    griddim[ia] = int((dim[ia]*spa[ia])/spacing)+1;
    gridspa[ia] = spacing;
    gridori[ia] = -0.5*(griddim[ia]*gridspa[ia]-dim[ia]*spa[ia]);
  }
  
  if (debug)  {
    std::cout << "\t input spacing of grid=" << spacing << std::endl;
    std::cout << "\t initialized grid: dim=" << griddim[0] << "," << griddim[1] << "," << griddim[2] << ",";
    std::cout << "\t spa=" << gridspa[0] << "," << gridspa[1] << "," << gridspa[2] << ",";
    std::cout << "\t ori=" << gridori[0] << "," << gridori[1] << "," << gridori[2] << std::endl;
  }

  std::unique_ptr<bisGridTransformation> output_grid(new bisGridTransformation("output_grid"));
  output_grid->initializeGrid(griddim,gridspa,gridori,1);

  std::unique_ptr<bisApproximateDisplacementField> reg(new bisApproximateDisplacementField("approx"));
  reg->run(disp_field.get(),output_grid.get(),params.get());

  unsigned char* pointer=output_grid->serialize();
  return pointer;
}
// -----------------------------------------------------------------------------------------------------
// Regularize Objectmap
// -----------------------------------------------------------------------------------------------------
  unsigned char* regularizeObjectmapWASM(unsigned char* input,const char* jsonstring,int debug)
{
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  int ok=params->parseJSONString(jsonstring);
  if (!ok) 
    return 0;

  if(debug)
    params->print();

  std::unique_ptr<bisSimpleImage<short> > in_image(new bisSimpleImage<short>("in_image"));
  // This 1 at the end means "copy data" as this is an in/out function
  if (!in_image->linkIntoPointer(input,1))
    return 0;

  float smoothness=params->getFloatValue("smoothness",2.0f);
  int maxiter=params->getIntValue("iterations",8);
  int internal_iter=params->getIntValue("internaliterations",4);
  float mrfconvergence=params->getFloatValue("convergence",0.2f);
  
  
  if (debug) {
    std::cout << "Objectmap Regularization Parameters: smoothness=" << smoothness << std::endl;
    std::cout << "\t iterations=" << maxiter << "internaliter=" << internal_iter <<  " convergence=" << mrfconvergence << std::endl;
    std::cout << "-----------------------------------" << std::endl;
  }
  
  
  if (debug)
    std::cout << std::endl << "..... Begin Objectmap Regularization" << std::endl;
  std::unique_ptr<bisSimpleImage<short> > out_image(bisImageSegmentationAlgorithms::doObjectMapRegularization(in_image.get(),
                                                                                                              smoothness,
                                                                                                              mrfconvergence,
                                                                                                              maxiter,internal_iter));
  if (debug)
    std::cout << std::endl << "..... Objectmap Regularization done " << std::endl;

  
  return out_image->releaseAndReturnRawArray();
}

// ---------------------------------------- DTI Stuff --------------------------------
unsigned char* computeDTITensorFitWASM(unsigned char* input_ptr,
				       unsigned char* baseline_ptr,
				       unsigned char* mask_ptr,
				       unsigned char* directions_ptr,
				       const char* jsonstring,
				       int debug)
{

  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  if(debug)
    params->print("computeCorrelationMatrixJSON","_____");

  
  std::unique_ptr<bisSimpleImage<short> > in_image(new bisSimpleImage<short>("input_dti_data"));
  if (!in_image->linkIntoPointer(input_ptr))
    return 0;

  std::unique_ptr<bisSimpleImage<short> > baseline_image(new bisSimpleImage<short>("baseline_dti_data"));
  if (!baseline_image->linkIntoPointer(baseline_ptr))
    return 0;
  
  

  Eigen::MatrixXf directions;
  std::unique_ptr<bisSimpleMatrix<float> > s_matrix(new bisSimpleMatrix<float>("directions"));
  if (!bisEigenUtil::deserializeAndMapToEigenMatrix(s_matrix.get(),directions_ptr,directions,debug))
    return 0;

  std::unique_ptr<bisSimpleImage<float> > out_image(new bisSimpleImage<float>("output_dti_data"));


  float bvalue=params->getFloatValue("bvalue",1000.0f);
  if (debug)
    std::cout << "Beginning Fit " << bvalue << std::endl;

  int ok=0;
  if (mask_ptr==0)
    {
      if (debug)
	std::cout << "Not using mask " << std::endl;
      ok=bisDTIAlgorithms::computeTensorFit(in_image.get(),
					    baseline_image.get(),
					    0,
					    directions,
					    bvalue,
					    out_image.get());
    }
  else
    {
      std::unique_ptr<bisSimpleImage<unsigned char> > mask_image(new bisSimpleImage<unsigned char>("mask_dti_data"));
      if (!mask_image->linkIntoPointer(mask_ptr))
	return 0;
      if (debug)
	std::cout << "Using mask " << std::endl;
      ok=bisDTIAlgorithms::computeTensorFit(in_image.get(),
					    baseline_image.get(),
					    mask_image.get(),
					    directions,
					    bvalue,
					    out_image.get());
    }


  if (debug)
    std::cout << "Fitting Done " << ok << std::endl;

  return out_image->releaseAndReturnRawArray();
}


/** Computes Eigenvalues and Eigenvector as a single image of 4 components x 3 frames
 * component 0 = eigenvalues
 * components 1-3 eigenvectors
 * frames are x,y,z
 * @param tensor the input dti tensor (from computeTensorFit)
 * @param mask the input mask image (can be NULL,0)
 * @param eigenSystem the output images as defined above
 * @returns 1 if success, 0 if failed */
unsigned char* computeTensorEigenSystemWASM(unsigned char* input_ptr,
					    unsigned char* mask_ptr,
					    int debug) 
{
  std::unique_ptr<bisSimpleImage<float> > in_image(new bisSimpleImage<float>("input_eigensystem_data"));
  if (!in_image->linkIntoPointer(input_ptr))
    return 0;


  std::unique_ptr<bisSimpleImage<unsigned char> > mask_image(new bisSimpleImage<unsigned char>("mask_dti_data"));
  bisSimpleImage<unsigned char>* mask=0;
  if (mask_ptr!=0)
    {
      if (!mask_image->linkIntoPointer(mask_ptr))
	return 0;
      mask=mask_image.get();
    }
  
  if (debug)
    {
      std::cout << "Beginning Compute Tensor Eigen System ";
      if (mask!=0)
	std::cout <<  "using mask";
      std::cout << std::endl;
    }
  
  std::unique_ptr<bisSimpleImage<float> > output(new bisSimpleImage<float>("out_dti_eigensystem"));
  
  int ok=bisDTIAlgorithms::computeTensorEigenSystem(in_image.get(),mask,output.get());

  if (debug)
    std::cout << "Done Computing ok=" << ok << std::endl;
  
  return output->releaseAndReturnRawArray();
  
}
/** Compute DTI Tensor Invariants
 * @param input_ptr the image tensor eigensystem as a serialized array
 * @param mask_ptr the Mask Image (optional, set this to 0) as a serialized array
 * @param jsonstring { "mode": 0 } // mode 0=FA, 1=RA etc. -- see bisDTIAlgorithms::computeTensorInvariants
 * @param debug if > 0 print debug messages
 * @returns a pointer to the invarient image */
BISEXPORT unsigned char* computeDTITensorInvariantsWASM(unsigned char* input_ptr,
							unsigned char* mask_ptr,
							const char* jsonstring,
							int debug)
{
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  int ok=params->parseJSONString(jsonstring);
  if (!ok) 
    return 0;

  if(debug)
    params->print();

  std::unique_ptr<bisSimpleImage<float> > in_image(new bisSimpleImage<float>("input_eigensystem_data"));
  if (!in_image->linkIntoPointer(input_ptr))
    return 0;


  std::unique_ptr<bisSimpleImage<unsigned char> > mask_image(new bisSimpleImage<unsigned char>("mask_dti_data"));
  if (mask_ptr!=0)
    {
      if (!mask_image->linkIntoPointer(mask_ptr))
	return 0;
    }
  else
    {
      std::unique_ptr<bisSimpleImage<unsigned char> >m(bisImageAlgorithms::createMaskImage<float>(in_image.get()));
      mask_image=std::move(m);
    }

  int mode=params->getIntValue("mode",0);
  
  if (debug)
    std::cout << "Beginning Compute Tensor Invariants mode=" << mode  << std::endl;
  
  std::unique_ptr<bisSimpleImage<float> > output(new bisSimpleImage<float>("out_dti_eigensystem"));
  
  ok=bisDTIAlgorithms::computeTensorInvariants(in_image.get(),mask_image.get(),mode,output.get());

  if (debug)
    std::cout << "Done Computing ok=" << ok << std::endl;
  
  return output->releaseAndReturnRawArray();


}

/** Compute DTI Orientation Map
 * @param input_ptr the image tensor eigensystem as a serialized array
 * @param mask_ptr the Mask Image (optional, set this to 0) as a serialized array
 * @param magnitude_ptr the Magnitude Image (e.g. FA map) (optional, set this to 0) as a serialized array
 * @param jsonstring { "scaling": 1.0 } Optional extra scaling
 * @param debug if > 0 print debug messages
 * @returns a pointer to the colormap image */
BISEXPORT unsigned char* computeDTIColorMapImageWASM(unsigned char* input_ptr,
						     unsigned char* mask_ptr,
						     unsigned char* magnitude_ptr,
						     const char* jsonstring,
						     int debug)
{
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  int ok=params->parseJSONString(jsonstring);
  if (!ok) 
    return 0;

  if(debug)
    params->print();

  std::unique_ptr<bisSimpleImage<float> > in_image(new bisSimpleImage<float>("input_eigensystem_data"));
  if (!in_image->linkIntoPointer(input_ptr))
    return 0;


  std::unique_ptr<bisSimpleImage<unsigned char> > mask_image(new bisSimpleImage<unsigned char>("mask_dti_data"));
  if (mask_ptr!=0)
    {
      if (!mask_image->linkIntoPointer(mask_ptr))
	return 0;
    }
  else
    {
      std::unique_ptr<bisSimpleImage<unsigned char> >m(bisImageAlgorithms::createMaskImage<float>(in_image.get()));
      mask_image=std::move(m);
    }
  

  std::unique_ptr<bisSimpleImage<float> > magn_image(new bisSimpleImage<float>("magnitude_dti_data"));
  bisSimpleImage<float>* magn=0;
  if (magnitude_ptr!=0)
    {
      if (!magn_image->linkIntoPointer(magnitude_ptr))
	return 0;
      magn=magn_image.get();
    }


  float scaling=params->getFloatValue("scaling",1.0);
  
  if (debug)
    std::cout << "Beginning Compute Tensor Colormap scaling=" << scaling  << std::endl;
  
  std::unique_ptr<bisSimpleImage<unsigned char> > output(new bisSimpleImage<unsigned char>("out_dti_colormap"));
  
  ok=bisDTIAlgorithms::computeTensorColormap(in_image.get(),mask_image.get(),magn,scaling,output.get());
  
  if (debug)
    std::cout << "Done Computing ok=" << ok << std::endl;
  
  return output->releaseAndReturnRawArray();
}




    /** runWeighted Linear Image Registration using \link bisLinearImageRegistration  \endlink
   * @param reference serialized reference image as unsigned char array 
   * @param target    serialized target image as unsigned char array 
   * @param ref_weight  serialized reference weight image as unsigned char array 
   * @param targ_weight  serialized target weight image as unsigned char array 
   * @param initial_xform serialized initial transformation as unsigned char array 
   * @param jsonstring the parameter string for the algorithm including return_vector which if true returns a length-28 vector
   * containing the 4x4 matrix and the 12 transformation parameters
   * @param debug if > 0 print debug messages
   * @returns a pointer to a serialized vector or matrix depending on the value of return_vector
   */
  // BIS: { 'runWeightedLinearRegistrationWASM', 'bisLinearTransformation', [ 'bisImage', 'bisImage', 'bisImage', 'bisImage_opt', 'bisLinearTransformation_opt', 'ParamObj', 'debug' ], {"checkorientation" : "python matlab"} } 
unsigned char*  runWeightedLinearRegistrationWASM(unsigned char* reference_ptr,
                                                  unsigned char* target_ptr,
                                                  unsigned char* reference_weight_ptr,
                                                  unsigned char* target_weight_ptr,
                                                  unsigned char* initial_ptr,
                                                  const char* jsonstring,
                                                  int debug)
{
  if (debug)
    std::cout << "_____ Beginning runWeightedLinearRegistrationJSON" << std::endl;
  
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  int return_vector=params->getBooleanValue("return_vector",0);
  
  //  if(debug)
  //    params->print("from runWeightedLinearRegistrationJSON","_____");

  std::shared_ptr<bisSimpleImage<float> > reference_image(new bisSimpleImage<float>("reference_image_json"));
  if (!reference_image->linkIntoPointer(reference_ptr))
    return 0;
  
  std::shared_ptr<bisSimpleImage<float> > target_image(new bisSimpleImage<float>("target_image_json"));
  if (!target_image->linkIntoPointer(target_ptr))
    return 0;

  std::shared_ptr<bisSimpleImage<short> > reference_weight_image(new bisSimpleImage<short>("reference_weight_json"));
  if (!reference_weight_image->linkIntoPointer(reference_weight_ptr))
    return 0;

  
  std::unique_ptr<bisMatrixTransformation> initial_transformation(new bisMatrixTransformation("parse_initial"));
  initial_transformation->identity();
  
  std::unique_ptr<bisSimpleMatrix<float> > initial_matrix(new bisSimpleMatrix<float>("initial_matrix_json"));
  if (initial_ptr!=0)
    {
      if (!initial_matrix->linkIntoPointer(initial_ptr))
	return 0;
      if (!initial_transformation->setSimpleMatrix(initial_matrix.get()))
	return 0;
    }

  std::unique_ptr<bisLinearImageRegistration> reg(new bisLinearImageRegistration("linear registration"));
  reg->setReferenceImage(reference_image);
  reg->setTargetImage(target_image);
  reg->setReferenceWeightImage(reference_weight_image);
  if (target_weight_ptr!=0) {
    std::shared_ptr<bisSimpleImage<short> > target_weight_image(new bisSimpleImage<short>("target_weight_json"));
    if (!target_weight_image->linkIntoPointer(reference_weight_ptr))
      return 0;
    reg->setTargetWeightImage(target_weight_image);
  }
  reg->setInitialTransformation(initial_transformation.get());
  reg->run(params.get());
  
  if (return_vector==0)
    {
      std::unique_ptr<bisSimpleMatrix<float> > output(reg->getOutputMatrix());
      bisUtil::mat44 m; output->exportMatrix(m);
      return output->releaseAndReturnRawArray();
    }

  std::unique_ptr<bisSimpleVector<float> > output(reg->getTransformationParameterVector());
  int length=output->getLength();

  Eigen::MatrixXf outmat=Eigen::MatrixXf::Zero(length,1);
  for (int i=0;i<length;i++)
    outmat(i,0)=output->getData()[i];
  return bisEigenUtil::serializeAndReturn(outmat,"param_vector");


}
  
  
/** runWeighted Non Linear Image Registration using \link bisNonLinearImageRegistration  \endlink
 * @param reference serialized reference image as unsigned char array 
 * @param target    serialized target image as unsigned char array 
 * @param ref_weight  serialized reference weight image as unsigned char array 
 * @param targ_weight  serialized target weight image as unsigned char array 
 * @param initial_xform serialized initial transformation as unsigned char array 
 * @param jsonstring the parameter string for the algorithm 
 * @param debug if > 0 print debug messages
 * @returns a pointer to a serialized combo transformation (bisComboTransformation)
 */
// BIS: { 'runWeightedNonLinearRegistrationWASM', 'bisComboTransformation', [ 'bisImage', 'bisImage', 'bisImage', 'bisImage_opt', 'bisLinearTransformation_opt', 'ParamObj', 'debug' ], {"checkorientation" : "python matlab"}  } 
unsigned char* runWeightedNonLinearRegistrationWASM(unsigned char* reference,
                                                    unsigned char* target,
                                                    unsigned char* reference_weight_ptr,
                                                    unsigned char* target_weight_ptr,
                                                    unsigned char* initial_ptr,
                                                    const char* jsonstring,
                                                    int debug)
{

  if (debug)
    std::cout << "_____ Beginning runWeightedNonLinearRegistrationJSON" << std::endl;
  
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  //  if(debug)
  //    params->print("from runWeightedNonLinearRegistrationJSON","_____");

  std::shared_ptr<bisSimpleImage<float> > reference_image(new bisSimpleImage<float>("reference_image_json"));
  if (!reference_image->linkIntoPointer(reference))
    return 0;
  
  std::shared_ptr<bisSimpleImage<float> > target_image(new bisSimpleImage<float>("target_image_json"));
  if (!target_image->linkIntoPointer(target))
    return 0;

  std::shared_ptr<bisSimpleImage<short> > reference_weight_image(new bisSimpleImage<short>("reference_weight_json"));
  if (!reference_weight_image->linkIntoPointer(reference_weight_ptr))
    return 0;



  std::unique_ptr<bisNonLinearImageRegistration> reg(new bisNonLinearImageRegistration("nonlinear"));
  reg->setReferenceImage(reference_image);
  reg->setTargetImage(target_image);
  reg->setReferenceWeightImage(reference_weight_image);
  if (target_weight_ptr!=0) {
    std::shared_ptr<bisSimpleImage<short> > target_weight_image(new bisSimpleImage<short>("target_weight_json"));
    if (!target_weight_image->linkIntoPointer(reference_weight_ptr))
      return 0;
    reg->setTargetWeightImage(target_weight_image);
  }

  if (initial_ptr) {
    std::shared_ptr<bisAbstractTransformation> initial_transformation=bisDataObjectFactory::deserializeTransformation(initial_ptr,"initialxform");
    reg->setInitialTransformation(initial_transformation);
  }
  reg->run(params.get());

  std::shared_ptr<bisComboTransformation> output(reg->getOutputTransformation());
  unsigned char* pointer=output->serialize();
  
 
  return pointer;
}

/** run Linear RPM Registration using \link bisLinearImageRegistration  \endlink
 * @param reference serialized reference points unsigned char array 
 * @param target    serialized target points as unsigned char array 
 * @param initial_xform serialized initial transformation as unsigned char array 
 * @param reference_labels serialized reference labels unsigned char array 
 * @param target_labels serialized target labels unsigned char array 
 * @param jsonstring the parameter string for the algorithm  { numLandmarks: 1000, initialTemperature: 10.0, finalTemperature: 1.0,annealRate : 0.93, prefSampling : 1, 
 *                                                             trnasformMode :2 , correspondenceMode :2 , useCentroids : 1 }
 * @param debug if > 0 print debug messages
 * @returns a pointer to a serialized 4x4 matrix
 */
unsigned char*  runLinearRPMRegistrationWASM(unsigned char* in_reference,
                                             unsigned char* in_target,
                                             unsigned char* initial_ptr,
                                             unsigned char* in_reference_labels,
                                             unsigned char* in_target_labels,
                                             const char* jsonstring,
                                             int debug)
{

  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  int numlandmarks=params->getIntValue("numLandmarks",1000);
  int transformMode=params->getIntValue("transformMode",2);
  int correspondenceMode=params->getIntValue("correspondenceMode",2);
  int useCentroids=params->getIntValue("useCentroids",1);
  float initialTemperature=params->getFloatValue("initialTemperature",10.0);
  float finalTemperature=params->getFloatValue("finalTemperature",10.0);
  int iterPerTemp=params->getIntValue("iterPerTemp",5);
  float annealRate=params->getFloatValue("annealRate",10.0);
  int prefSampling=params->getIntValue("prefSampling",10.0);

  if (debug) {
    std::cout << " Linear RPM Parameters " << std::endl;
    std::cout << "          numlandmarks=" << numlandmarks << " transformMode=" << transformMode << " corrMode=" << correspondenceMode << " useCent=" << useCentroids << std::endl;
    std::cout << "          initialT=" << initialTemperature << " finalT=" << finalTemperature << " annealRate=" << annealRate << " iterPerT=" << iterPerTemp << " prefSampling=" << prefSampling << std::endl;
  }

  std::unique_ptr<bisSimpleMatrix<float> > ref_points(new bisSimpleMatrix<float>("ref_points_json"));
  if (!ref_points->linkIntoPointer(in_reference))
    return 0;
  if (debug)
    std::cout << "___ Ref Points = " << ref_points->getNumRows() << "*" << ref_points->getNumCols() << std::endl;

  std::unique_ptr<bisSimpleMatrix<float> > target_points(new bisSimpleMatrix<float>("target_points_json"));
  if (!target_points->linkIntoPointer(in_target))
    return 0;
  if (debug)
    std::cout << "___ Target Points = " << target_points->getNumRows() << "*" << target_points->getNumCols() << std::endl;

  std::unique_ptr<bisMatrixTransformation> initial_transformation(new bisMatrixTransformation("parse_initial"));
  initial_transformation->identity();
  std::unique_ptr<bisSimpleMatrix<float> > initial_matrix(new bisSimpleMatrix<float>("initial_matrix_json"));
  if (initial_ptr!=0)
    {
      if (!initial_matrix->linkIntoPointer(initial_ptr))
	return 0;
      if (!initial_transformation->setSimpleMatrix(initial_matrix.get()))
	return 0;
    }
  else
    {
      initial_transformation=0;
    }

  std::unique_ptr<bisLinearRPMRegistration> RPM(new bisLinearRPMRegistration());

  if (in_reference_labels!=0 && in_target_labels!=0) {
    // Use labels
    std::unique_ptr<bisSimpleVector<int> > ref_labels(new bisSimpleVector<int>("ref_labels_json"));
    std::unique_ptr<bisSimpleVector<int> > targ_labels(new bisSimpleVector<int>("targ_labels_json"));
    if (!ref_labels->linkIntoPointer(in_reference_labels) || 
        !targ_labels->linkIntoPointer(in_target_labels) ) {
      std::cerr << "__ bad labels" << std::endl;
      return 0;
    }
    RPM->initialize(ref_points.get(),target_points.get(),numlandmarks,prefSampling,ref_labels.get(),targ_labels.get(),debug);
  } else {
    RPM->initialize(ref_points.get(),target_points.get(),numlandmarks,1,0,0,debug);
  }

  RPM->run(transformMode,
           correspondenceMode,
           initialTemperature,
           finalTemperature,
           iterPerTemp,
           annealRate,
           useCentroids,
           initial_transformation.get(),
           debug);

  std::unique_ptr<bisSimpleMatrix<float> > output(RPM->getOutputMatrix());
  bisUtil::mat44 m; output->exportMatrix(m);
  return output->releaseAndReturnRawArray();
}


/** run Non Linear RPM Registration using \link bisLinearImageRegistration  \endlink
 * @param reference serialized reference points unsigned char array 
 * @param target    serialized target points as unsigned char array 
 * @param initial_xform serialized initial transformation as unsigned char array 
 * @param reference_labels serialized reference labels unsigned char array 
 * @param target_labels serialized target labels unsigned char array 
 * @param jsonstring the parameter string for the algorithm  { numLandmarks: 1000, initialTemperature: 10.0, finalTemperature: 1.0,annealRate : 0.93, prefSampling : 1, 
 *                                                             cpsbegin: 40.0, cpsend:20, smoothnessbegin:0.01, smoothnessend:0.001   }
 * @param debug if > 0 print debug messages
 * @returns a pointer to a serialized combo transformation (bisComboTransformation)
 */
unsigned char*  runNonLinearRPMRegistrationWASM(unsigned char* in_reference,
                                                unsigned char* in_target,
                                                unsigned char* initial_ptr,
                                                unsigned char* in_reference_labels,
                                                unsigned char* in_target_labels,
                                                const char* jsonstring,
                                                int debug)
{

  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  if (!params->parseJSONString(jsonstring))
    return 0;

  int numlandmarks=params->getIntValue("numLandmarks",1000);
  int correspondenceMode=params->getIntValue("correspondenceMode",2);
  int useCentroids=params->getIntValue("useCentroids",1);
  float initialTemperature=params->getFloatValue("initialTemperature",10.0);
  float finalTemperature=params->getFloatValue("finalTemperature",10.0);
  int iterPerTemp=params->getIntValue("iterPerTemp",5);
  float annealRate=params->getFloatValue("annealRate",10.0);
  int prefSampling=params->getIntValue("prefSampling",10.0);

  float cpsBegin=params->getFloatValue("cpsbegin",40.0);
  float cpsEnd=params->getFloatValue("cpsend",20.0);
  float smoothnessBegin=params->getFloatValue("smoothnessbegin",40.0);
  float smoothnessEnd=params->getFloatValue("smoothnessend",20.0);

  
  
  if (debug) {
    std::cout << " NonLinear RPM Parameters " << std::endl;
    std::cout << "          numlandmarks=" << numlandmarks <<  " corrMode=" << correspondenceMode << " useCent=" << useCentroids << std::endl;
    std::cout << "          initialT=" << initialTemperature << " finalT=" << finalTemperature << " annealRate=" << annealRate << " iterPerT=" << iterPerTemp << " prefSampling=" << prefSampling << std::endl;
    std::cout << "          cps=" << cpsBegin << ":" << cpsEnd << " smoothness=" << smoothnessBegin << ":" << smoothnessEnd  << std::endl;
  }

  std::unique_ptr<bisSimpleMatrix<float> > ref_points(new bisSimpleMatrix<float>("ref_points_json"));
  if (!ref_points->linkIntoPointer(in_reference))
    return 0;
  if (debug)
    std::cout << "___ Ref Points = " << ref_points->getNumRows() << "*" << ref_points->getNumCols() << std::endl;

  std::unique_ptr<bisSimpleMatrix<float> > target_points(new bisSimpleMatrix<float>("target_points_json"));
  if (!target_points->linkIntoPointer(in_target))
    return 0;
  if (debug)
    std::cout << "___ Target Points = " << target_points->getNumRows() << "*" << target_points->getNumCols() << std::endl;

  std::unique_ptr<bisMatrixTransformation> initial_transformation(new bisMatrixTransformation("parse_initial"));
  initial_transformation->identity();
  std::unique_ptr<bisSimpleMatrix<float> > initial_matrix(new bisSimpleMatrix<float>("initial_matrix_json"));
  if (initial_ptr!=0)
    {
      if (!initial_matrix->linkIntoPointer(initial_ptr))
        return 0;
      if (!initial_transformation->setSimpleMatrix(initial_matrix.get()))
        return 0;
    }

  std::unique_ptr<bisNonLinearRPMRegistration> RPM(new bisNonLinearRPMRegistration());

  if (in_reference_labels!=0 && in_target_labels!=0) {
    // Use labels
    std::unique_ptr<bisSimpleVector<int> > ref_labels(new bisSimpleVector<int>("ref_labels_json"));
    std::unique_ptr<bisSimpleVector<int> > targ_labels(new bisSimpleVector<int>("targ_labels_json"));
    if (!ref_labels->linkIntoPointer(in_reference_labels) || 
        !targ_labels->linkIntoPointer(in_target_labels) ) {
      std::cerr << "__ bad labels" << std::endl;
      return 0;
    }
    RPM->initializeWithLinear(initial_transformation.get(),ref_points.get(),target_points.get(),numlandmarks,prefSampling,ref_labels.get(),targ_labels.get(),debug);
  } else {
    RPM->initializeWithLinear(initial_transformation.get(),ref_points.get(),target_points.get(),numlandmarks,1,0,0,debug);
  }
  
  RPM->run(correspondenceMode,
           cpsBegin,cpsEnd,
           smoothnessBegin,smoothnessEnd,
           initialTemperature,finalTemperature,
           iterPerTemp,
           annealRate,
           debug);

  std::shared_ptr<bisComboTransformation> output(RPM->getOutput());
  unsigned char* pointer=output->serialize();
  return pointer;

}

/*  License
 
 _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
 ----
     
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   See also  http: www.gnu.org/licenses/gpl.html
   
   If this software is modified please retain this statement and add a notice
   that it had been modified (and by whom).  
 
 Endlicense */

#include "bisNonLinearImageRegistration.h"
#include "bisApproximateDisplacementField.h"
#include "bisImageAlgorithms.h"
#include <sstream>
#include <time.h>

bisNonLinearImageRegistration::bisNonLinearImageRegistration(std::string s) : bisAbstractImageRegistration(s)
{
  std::shared_ptr<bisComboTransformation> tmpc(new bisComboTransformation(this->name+":combo"));
  this->internalTransformation=tmpc;
  this->internalTransformation->identity();
  this->class_name="bisNonLinearImageRegistration";
  this->hasInitialTransformation=0;
  this->append_mode=1;
}

bisNonLinearImageRegistration::~bisNonLinearImageRegistration()
{
  this->lastSmoothness=-1.0;
  this->lastSimilarity=-1.0;
}

void bisNonLinearImageRegistration::setInitialTransformation(std::shared_ptr<bisAbstractTransformation> tr) 
{
  this->initialTransformation=tr;
  this->hasInitialTransformation=1;
}
  

void bisNonLinearImageRegistration::generateFeedback(std::string input)
{
  if (this->enable_feedback)
    std::cout << input << "  (" << this->lastSimilarity << "," << this->lastSmoothness << ")" << std::endl;
}


void bisNonLinearImageRegistration::generateFeedback2(std::string input)
{
  if (this->enable_feedback)
    std::cout << input << std::endl;
}

// Optimizer Stuff
float bisNonLinearImageRegistration::computeValue(std::vector<float>& position)
{
  this->currentGridTransformation->setParameterVector(position);

  bisImageAlgorithms::resliceImage(this->level_target.get(),this->temp_target.get(),this->currentGridTransformation.get(),1,0.0);
  
  short* weight1_ptr=0,*weight2_ptr=0;
  if (this->use_weights>0)
    {
      weight1_ptr=this->level_reference_weight->getImageData();
      if (this->use_weights==2)
	{
	  bisImageAlgorithms::resliceImage(this->level_target_weight.get(),this->temp_target_weight.get(),this->currentGridTransformation.get(),1,0.0);
	  weight2_ptr=this->temp_target_weight->getImageData();
	}
    }

  this->internalHistogram->weightedFillHistogram(this->level_reference->getImageData(),
						 this->temp_target->getImageData(),
						 weight1_ptr,
						 weight2_ptr,
						 use_weights,
						 1.0,
						 1, // reset
						 this->level_dimensions,
						 this->level_bounds);


  
  float mv=(float)this->internalHistogram->computeMetric(this->metric);

  this->lastSimilarity=mv;
  
  if (this->lambda>0.0)
    {
      this->lastSmoothness=this->currentGridTransformation->getTotalBendingEnergy();
      mv+=this->lambda*this->lastSmoothness;
    }
  return mv;
}


float bisNonLinearImageRegistration::computeValueFunctionPiece(bisAbstractTransformation* tr,int bounds[6],int cp)
{

  
  short* weight1_ptr=0,*weight2_ptr=0;
  if (this->use_weights>0)
    weight1_ptr=this->level_reference_weight->getImageData();
  if (this->use_weights==2)
    weight2_ptr=this->temp_target_weight->getImageData();

  int level_dimensions[3]; level_target->getImageDimensions(level_dimensions);

  // Backup
  this->internalHistogram->backup();
  // Remove Part
    this->internalHistogram->weightedFillHistogram(this->level_reference->getImageData(),
						   this->temp_target->getImageData(),
						   weight1_ptr,
						   weight2_ptr,
						   use_weights,
						   -1.0, // factor
						   0, // reset
						   level_dimensions,
						   bounds);

  // Reslice into Part
  bisImageAlgorithms::resliceImageWithBounds(this->level_target.get(),this->part_temp_target.get(),tr,bounds,1,0.0);
  this->internalHistogram->weightedFillHistogram(this->level_reference->getImageData(),
						 this->part_temp_target->getImageData(),
						 weight1_ptr,
						 weight2_ptr,
						 use_weights,
						 1.0, // factor
						 0, // reset
						 level_dimensions,
						 bounds);
  
  // Compute Metric
  float mv=(float)this->internalHistogram->computeMetric(this->metric);

  // Restore histogram
  this->internalHistogram->restore();
  
  if (this->lambda>0.0)
    mv+=this->lambda*this->currentGridTransformation->getBendingEnergyAtControlPoint(cp);
  
  

  return mv;
}


float bisNonLinearImageRegistration::computeGradient(std::vector<float>& params,std::vector<float>& grad)
{
  int dim_ref[3]; level_reference->getImageDimensions(dim_ref);
  float spa_ref[3]; level_reference->getImageSpacing(spa_ref);
  float window_size=1.0;
  
  return this->currentGridTransformation->computeGradientForOptimization(params,grad,
                                                                         this->current_step_size,
                                                                         dim_ref,spa_ref,window_size,
                                                                         this);

}

  
int bisNonLinearImageRegistration::checkInputParameters(bisJSONParameterList* plist)
{

  bisAbstractImageRegistration::checkInputParameters(plist);
  this->internalParameters->setFloatValue("cps",bisUtil::frange(plist->getFloatValue("cps",20.0f),0.1f,50.0f));
  this->internalParameters->setFloatValue("cpsrate",bisUtil::frange(plist->getFloatValue("cpsrate",2.0f),1.0f,2.0f));
  this->internalParameters->setFloatValue("lambda",bisUtil::frange(plist->getFloatValue("lambda",0.0f),0.0f,1.0f));
  this->internalParameters->setFloatValue("windowsize",bisUtil::frange(plist->getFloatValue("windowsize",1.0f),1.0f,2.0f));
  this->internalParameters->setBooleanValue("appendmode",plist->getBooleanValue("appendmode",1));

  if (this->enable_feedback)
    this->internalParameters->print("Fixed Parameters prior to running Non Linear","+ + + ");

  this->lambda=this->internalParameters->getFloatValue("lambda",0.0f);
  this->windowsize=  this->internalParameters->getFloatValue("windowsize",1.0f);
  
  return 1;
}

// ------------------------------------------------------------------------------------------
bisSimpleImage<float>* bisNonLinearImageRegistration::computeDisplacementField(bisAbstractTransformation* xform)
{

  int dim_ref[3]; level_reference->getImageDimensions(dim_ref);
  float spa_ref[3]; level_reference->getImageSpacing(spa_ref);
  int newdim[3]; float newspa[3];
  for (int ia=0;ia<=2;ia++) {
    newspa[ia]=this->current_cps[ia]/3.0;
    newdim[ia]=int( ((dim_ref[ia]+1)*spa_ref[ia])/newspa[ia]+0.5)-1;
  }

  this->generateFeedback2("++  ");
  std::cout << "+ + Computing displacement field to fit. Dim=" <<newdim[0] << "," << newdim[1] << "," << newdim[2] <<
    ", spa=" << newspa[0] << "," << newspa[1] << "," << newspa[2] << std::endl;
  return xform->computeDisplacementField(newdim,newspa);
}

void bisNonLinearImageRegistration::approximateDisplacementField(bisSimpleImage<float>* dispfield,bisGridTransformation* newgrd,int fast)

{
  // Compute the displacement field from old
  float spa_ref[3]; level_reference->getImageSpacing(spa_ref);
  
  std::unique_ptr<bisJSONParameterList> params(new bisJSONParameterList());
  params->setFloatValue("lambda",0.1);
  params->setFloatValue("tolerance",spa_ref[0]*0.02);
  params->setIntValue("inverse",0);
  if (fast)
    {
      params->setIntValue("levels",1);
      params->setFloatValue("resolution",1.0);
      params->setIntValue("steps",2);
      params->setIntValue("iterations",5);
      params->setFloatValue("stepsize",0.125);
    }
  else
    {
      params->setIntValue("levels",2);
      params->setFloatValue("resolution",1.0);
      params->setIntValue("steps",3);
      params->setIntValue("iterations",10);
      params->setFloatValue("stepsize",0.125);
    }

  std::unique_ptr<bisApproximateDisplacementField> reg(new bisApproximateDisplacementField("approx"));
  reg->run(dispfield,newgrd,params.get());
}

// ------------------------------------------------------------------------------------------

void bisNonLinearImageRegistration::initializeLevelAndGrid(int lv,int numlevels)
{

  std::cout << "+ + I n i t i a l i z i n g  L e v e l " << lv << std::endl;

  if (lv==numlevels && this->hasInitialTransformation)
    {
      // If this is the lowest resolution we need to figure out how to handle internal
      
      int islinear=this->initialTransformation->isLinear();
      
      std::cout << "+ + \t we have an initial transformation, linear=" << islinear << std::endl;
      
      if (islinear==1) {
        // If it is linear, we are happy no big deal just copy its
        std::cout << "+ + \t this is a pure linear transformation " << std::endl;
        bisMatrixTransformation* linear=(bisMatrixTransformation*)(this->initialTransformation.get());
        bisUtil::mat44 m; linear->getMatrix(m);
        linear->printSelf();
        this->internalTransformation->setInitialTransformation(m);
      } else if (islinear == -1) {
        std::cout << "+ + \t this is a combo transformation " << std::endl;
        bisComboTransformation* in=(bisComboTransformation*)(this->initialTransformation.get());
        bisUtil::mat44 m; in->getInitialTransformation(m);
        bisUtil::printMatrix(m,"linear component");
        this->internalTransformation->setInitialTransformation(m);
      }
    }

  if (this->append_mode)
    {
      bisAbstractImageRegistration::initializeLevel(lv,this->internalTransformation.get());
    }
  else
    {
      bisUtil::mat44 m;
      this->internalTransformation->getInitialTransformation(m);
      std::unique_ptr<bisMatrixTransformation> temp_linear(new bisMatrixTransformation("temp_linear"));
      temp_linear->setMatrix(m);
      bisAbstractImageRegistration::initializeLevel(lv,temp_linear.get());
    }

  
  
  std::unique_ptr<bisSimpleImage<short> > tmp(new bisSimpleImage<short>(this->name+":part_temp_target_image"));
  this->part_temp_target=std::move(tmp);
  this->part_temp_target->copyStructure(this->level_reference.get());



  float cps=this->internalParameters->getFloatValue("cps",20.0);
  float rate=this->internalParameters->getFloatValue("cpsrate",2.0);
  cps=cps*powf(rate,lv-1.0f);

  int dim_ref[3]; level_reference->getImageDimensions(dim_ref);
  float spa_ref[3]; level_reference->getImageSpacing(spa_ref);

  float grid_ori[3] = { 0,0,0};
  this->current_dim[2]=1;
  this->current_cps[2]=1.0;

  int maxdim=2;
  if (dim_ref[2]<2)
    maxdim=1;
  
  for (int ia=0;ia<=maxdim;ia++)
    {
      float imagesize=(dim_ref[ia]-1)*spa_ref[ia]+1;
      int numcp=int(imagesize/cps+0.5);
      if (numcp<4)
        numcp=4;
      this->current_dim[ia]=numcp;
      this->current_cps[ia]=imagesize/(this->current_dim[ia]-1.05f);
      float outsz=(numcp-1)*this->current_cps[ia];
      float offset=outsz-imagesize;
      grid_ori[ia]=-0.5f*offset;
    }

  std::stringstream strss;
  strss << this->name << "_grid_" << lv;

  
  // Do we need to approximate the grid
  if (lv !=numlevels && append_mode==0)
    {
      // Fit the previous grid
      std::cout << "+ + ================================================" << std::endl;
      std::cout << "+ + Fitting previous grid" << std::endl;


      std::unique_ptr<bisSimpleImage<float> > dispfield(this->computeDisplacementField(this->currentGridTransformation.get()));
      this->currentGridTransformation->initializeGrid(this->current_dim,this->current_cps,grid_ori,1);
      this->approximateDisplacementField(dispfield.get(),this->currentGridTransformation.get(),1);
      std::cout << "+ + ================================================" << std::endl;
    }
  else
    {
      // First create a new grid
      std::shared_ptr<bisGridTransformation> tmp_g(new bisGridTransformation(strss.str()));
      this->currentGridTransformation=std::move(tmp_g);
      this->currentGridTransformation->initializeGrid(this->current_dim,this->current_cps,grid_ori,1);
      
      
      // Then check if need to fit it
      
      if (lv==numlevels && this->hasInitialTransformation)
        {
          int islinear=this->initialTransformation->isLinear();
          if (islinear == -1)
            {
              // We have a combo
              bisComboTransformation* initial=(bisComboTransformation*)(this->initialTransformation.get());
              
              // store this for now
              bisUtil::mat44 oldlinear; initial->getInitialTransformation(oldlinear);
              
              std::unique_ptr<bisMatrixTransformation> ident(new bisMatrixTransformation);
              ident->identity();
              initial->setInitialTransformation(ident.get());
              std::unique_ptr<bisSimpleImage<float> > dispfield(this->computeDisplacementField(initial));
              this->approximateDisplacementField(dispfield.get(),this->currentGridTransformation.get(),0);
              initial->setInitialTransformation(oldlinear);
            }
        }

      // Add the grid to the back of the internalTransformation Combo
      this->internalTransformation->addTransformation(this->currentGridTransformation);
    }
}


// Set Parameters and Run
void bisNonLinearImageRegistration::run(bisJSONParameterList* plist)
{
  this->checkInputParameters(plist);

  this->generateFeedback2("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");


  std::stringstream strss;
  strss.precision(5);

  int numlevels=  this->internalParameters->getIntValue("levels");
  int numsteps=   this->internalParameters->getIntValue("steps");
  float stepsize=   this->internalParameters->getFloatValue("stepsize");
  int optimization=this->internalParameters->getIntValue("optimization");
  int iterations=this->internalParameters->getIntValue("iterations");
  float tolerance=this->internalParameters->getFloatValue("tolerance",0.001f);
  this->append_mode=this->internalParameters->getBooleanValue("appendmode",1);
  
  // Also cps, cpsrate, windowsize, lambda ...

  if (this->enable_feedback)
    {
      std::cout << "+ +  Retrieved parameters: nlevels=" << numlevels << " numsteps=" << numsteps << " stepsize=" << stepsize << std::endl;
      std::cout << "+ +      optimization=" << optimization << " iterations=" << iterations << " tolerance=" << tolerance << std::endl;
      std::cout << "+ +      similarity metric=" << metric << ", append_mode=" << this->append_mode << std::endl; // TOADD cps, cpsrate, windowsize
    }

  time_t timer1,timer2;
  time(&timer1);
  for (int level=numlevels;level>=1;level=level-1)
    {
      strss.clear();
      std::stringstream strss2;
      strss2 << "+ +  Beginning to compute  n o n l i n e a r  registration at level=" << level << ", numsteps=" << numsteps << ", tolerance=" << tolerance;
      this->generateFeedback2(strss2.str());
      this->generateFeedback2("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");
      this->initializeLevelAndGrid(level,numlevels);

      this->generateFeedback2("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");
      float spa[3]; this->level_reference->getImageSpacing(spa);
      int numdof=this->currentGridTransformation->getNumberOfDOF();
      this->current_step_size=stepsize*powf(2.0f,float(numsteps-1))*spa[0];
      this->generateFeedback2("+ + ");
      std::stringstream strss3;
      strss3 << "+ +  \t\t Beginning level=" << level << " resolution=" << spa[0] << " numdof=" << numdof << " current_step=" << this->current_step_size;
      std::stringstream strss4;
      strss4 << "+ +  \t\t transformation: dim=(" << this->current_dim[0] << "*" << this->current_dim[1] << "*" << this->current_dim[2] << "), ";
      strss4 << "spa=(" << this->current_cps[0] << "," << this->current_cps[1] << "," << this->current_cps[2] << ") ";
      this->generateFeedback2(strss3.str());
      this->generateFeedback2(strss4.str());
      this->generateFeedback2("+ + ");
      // Set stepsize


      std::unique_ptr<bisOptimizer> optimizer(new bisOptimizer(this));

      std::vector<float> position(numdof);
  
      // Get current state ...
      this->currentGridTransformation->getParameterVector(position);
      this->totaltime=0.0;


      for (int step=numsteps;step>=1;step=step-1)
	{
	  if (this->enable_feedback)
	    std::cout << "+ +  In step = " << step << ". Iterations = " << iterations << ", optimization=" << optimization <<", current=" << this->current_step_size << "." << std::endl;
	  if (optimization==1)
	    optimizer->computeGradientDescent(position,iterations,tolerance);
	  else
	    optimizer->computeConjugateGradient(position,iterations,tolerance);
	  
	  this->current_step_size=this->current_step_size/2.0f;
	}
      this->generateFeedback2("+ + ");
      this->generateFeedback2("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");

    }
  time(&timer2);
  std::stringstream strss_final;
  this->totaltime=difftime(timer2,timer1);
  strss_final << "+ +  Stats : total_time " <<  this->totaltime;
  this->generateFeedback2(strss_final.str());
  this->generateFeedback2("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");

}




/*  License
 
 _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
 ----
     
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   See also  http: www.gnu.org/licenses/gpl.html
   
   If this software is modified please retain this statement and add a notice
   that it had been modified (and by whom).  
 
 Endlicense */


#include "bisNonLinearRPMRegistration.h"
#include "bisApproximateLandmarkDisplacementsWithGridTransform.h"
#include "bisJSONParameterList.h"
#include "bisUtil.h"

bisNonLinearRPMRegistration::bisNonLinearRPMRegistration(std::string n) : bisRPMCorrespondenceFinder(n) {

  std::shared_ptr<bisComboTransformation> tmp(new bisComboTransformation());
  this->Output=std::move(tmp);
  
  std::shared_ptr<bisGridTransformation> tmpgrid(new bisGridTransformation());
  this->Grid=std::move(tmpgrid);
  this->Output->addTransformation(this->Grid);
  
  tmpgrid=0;
  tmp=0;
}

bisNonLinearRPMRegistration::~bisNonLinearRPMRegistration()
{
  this->Output=0;
  this->Grid=0;
}


  // Description:
  // get Output Transformation  
std::shared_ptr<bisComboTransformation> bisNonLinearRPMRegistration::getOutput() {
  return this->Output;
}

// Description:
int bisNonLinearRPMRegistration::initializeWithLinear(bisMatrixTransformation* in_initialTransformation,
                                                      bisSimpleMatrix<float>* source,
                                                      bisSimpleMatrix<float>* target,
                                                      int maxnumlandmarks,
                                                      int samplingweight, // 1 = equal sampling, if  > 1 get extra points from points whose label > 0
                                                      bisSimpleVector<int>* source_labels,
                                                      bisSimpleVector<int>* target_labels,
                                                      int debug) {


  // Two parts
  // 1. Set the linear component of Output to in_initialTransformation
  // 2. Map target points by Inverse of in_initialTransformation and use these to initialize the locator
  this->Output->setInitialTransformation(in_initialTransformation);

  // Compute inverse
  std::unique_ptr<bisMatrixTransformation> tmp(new bisMatrixTransformation());
  bisUtil::mat44 m; in_initialTransformation->getMatrix(m);

  Eigen::MatrixXf eigen=Eigen::MatrixXf::Zero(4,4);
  for (int ia=0;ia<=3;ia++)
    for (int ib=0;ib<=3;ib++)
      eigen(ia,ib)=m[ia][ib];

  Eigen::MatrixXf inverse=eigen.inverse();
  for (int ia=0;ia<=3;ia++)
    for (int ib=0;ib<=3;ib++)
      m[ia][ib]=inverse(ia,ib);
  tmp->setMatrix(m);

  bisSimpleMatrix<float>* mappedPoints=bisPointRegistrationUtils::transformPoints(target,tmp.get(),debug);
  return bisRPMCorrespondenceFinder::initialize(source,mappedPoints,maxnumlandmarks,samplingweight,source_labels,target_labels,debug);
  
  
}

int bisNonLinearRPMRegistration::initializeGrid(float spacing,float cps_begin,float cps_end,bisSimpleMatrix<float>* RefLandmarks) {

  float current_spa[3]; this->Grid->getGridSpacing(current_spa);
  int current_dim[3]; this->Grid->getGridDimensions(current_dim);

  if (current_dim[0]>0) {
    // Do we need to reshape the grid, may be it is close enough
    float gap=0.1*fabs(cps_begin-cps_end);
    float dg=fabs(spacing-current_spa[0]);
    if (dg<gap)
      return 0;
  }

  // Find bounds
  float minc[3],maxc[3];
  float* pts=RefLandmarks->getData();
  int numpoints=RefLandmarks->getNumRows();

  // Find min and max and create bounds
  for (int ia=0;ia<=2;ia++) {
    minc[ia]=pts[ia];
    maxc[ia]=pts[ia];
  }

  for (int index=1;index<numpoints;index++) {
    int offset=index*3;
    for (int ia=0;ia<=2;ia++) {
      float p=pts[offset+ia];
      if (minc[ia]>p) minc[ia]=p;
      if (maxc[ia]<p) maxc[ia]=p;
    }
  }

  // Compute Grid Dimensions, origin and spacing
  int dim[3];
  float ori[3],spa[3];
  
  for (int ia=0;ia<=2;ia++) {
    float l=maxc[ia]-minc[ia];
    dim[ia]=int(l/spacing)+1;
    float l2=(dim[ia]-1)*spacing;
    ori[ia]=minc[ia]-(l2-l)*0.5;
    spa[ia]=spacing;
  }

  // Initialize the grid
  Grid->initializeGrid(dim,spa,ori,1);
  return 1;

}

int bisNonLinearRPMRegistration::approximateGrid(bisSimpleMatrix<float>* sourcePts,
                                                 bisSimpleMatrix<float>* targetPts,
                                                 bisSimpleVector<float>* weights,
                                                 float Smoothness,
                                                 int accurate,int debug) {


  int iterations=20;
  int steps=1;
  float stepsize=1.0;
  float tolerance=0.2;
  
  if (accurate) {
    steps=2;
    tolerance=0.05;
    stepsize=0.5;
  }

  std::unique_ptr<bisJSONParameterList> plist(new bisJSONParameterList());
  plist->setFloatValue("lambda",Smoothness);
  plist->setFloatValue("stepsize",stepsize);
  plist->setFloatValue("tolerance",tolerance);
  plist->setIntValue("steps",steps);
  plist->setIntValue("iterations",iterations);
  
  std::unique_ptr<bisApproximateLandmarkDisplacementsWithGridTransform> landmarkFit(new bisApproximateLandmarkDisplacementsWithGridTransform());
  return landmarkFit->run(sourcePts,targetPts,weights,this->Grid.get(),plist.get(),debug);
}
  
int bisNonLinearRPMRegistration::run(int in_correspondenceMode,
                                     float in_cps_begin,
                                     float in_cps_end,
                                     float in_smoothness_begin,
                                     float in_smoothness_end,
                                     float in_initialTemperature,
                                     float in_finalTemperature,
                                     int   in_iterationPerTemperature,
                                     float in_annealRate,
                                     int in_debug) {


  if (this->locator==NULL) {
    std::cerr << "___ bisNonLinearRPMRegistration not initialized" << std::endl;
    return 0;
  }

  float CPSBegin=bisUtil::frange(in_cps_begin,1.0,100.0);
  float CPSEnd=bisUtil::frange(in_cps_end,0.2,CPSBegin);
  float SmoothnessBegin=bisUtil::frange(in_smoothness_begin,0.001,10.0);
  float SmoothnessEnd=bisUtil::frange(in_smoothness_end,0.0001,SmoothnessBegin);

  
  int IterationPerTemperature = bisUtil::irange(in_iterationPerTemperature,1,10);
  int CorrespondenceMode=bisUtil::irange(in_correspondenceMode,0,2);
  float FinalTemperature=bisUtil::frange(in_finalTemperature,0.01,1000.0);
  float InitialTemperature=bisUtil::frange(in_initialTemperature,FinalTemperature,1000.0);
  float AnnealRate=bisUtil::frange(in_annealRate,0.5,0.999);
  int debug=in_debug;
  
  bisSimpleMatrix<float>* OutputRefLandmarks=new bisSimpleMatrix<float>();
  bisSimpleMatrix<float>* OutputTargetLandmarks=new bisSimpleMatrix<float>();
  bisSimpleVector<float>* OutputWeights=new bisSimpleVector<float>();
  
  
  float Temperature=InitialTemperature;
  float CPS=CPSBegin;
  float Smoothness=SmoothnessBegin;
  int numpoints=this->SampledReferencePoints->getNumRows();
  int numpoints2=this->SampledTargetPoints->getNumRows();

  int totaliter=int(fabs(log(InitialTemperature/FinalTemperature)/log(AnnealRate))+1.0);
  float cps_annealrate=exp(-fabs(log(CPSBegin/CPSEnd)/float(totaliter-1.0)));
  float smooth_annealrate=exp(-fabs(log(SmoothnessBegin/SmoothnessEnd)/float(totaliter-1.0)));
  
  if (debug) {
    std::cout << "___ Beginning  NonLinear RPM Registration tmode=" << " cmode=" << CorrespondenceMode << std::endl;
    std::cout << "___            CPS= " << CPSBegin << ":" << CPSEnd << " , smoothnesss=" << SmoothnessBegin << ":" << SmoothnessEnd << std::endl;
    std::cout << "___            NumPoints= " << numpoints << " vs " << numpoints2 << " temperatures=" << InitialTemperature << ":" << AnnealRate << ":" << FinalTemperature << std::endl;
  }
  
  int iteration_count=0;
  totaliter*=IterationPerTemperature;
  int incr=int(numpoints/5);
  while (Temperature > FinalTemperature)
    {
      for (int it=1;it<=IterationPerTemperature;it++) {
        iteration_count=iteration_count+1;
        if (debug) 
          std::cout << "Beginning iteration " << iteration_count << "/" << totaliter << ". Temp=" << Temperature << "  CPS=" << CPS << " Smooth=" << Smoothness << std::endl;
        
        
        this->estimateCorrespondence(this->Output.get(),
                                     Temperature,
                                     CorrespondenceMode,
                                     OutputRefLandmarks,
                                     OutputTargetLandmarks,
                                     OutputWeights,
                                     debug);
        
        if (debug) {
          bisPointRegistrationUtils::printJointPoints(OutputRefLandmarks,OutputTargetLandmarks,OutputWeights,"out_ref->targ",incr);
        }

        this->initializeGrid(CPS,CPSBegin,CPSEnd,OutputRefLandmarks);
        int accurate=0;
        // Do accurate at last step
        if (it==IterationPerTemperature && Temperature*AnnealRate< FinalTemperature)
          accurate=1;
        this->approximateGrid(OutputRefLandmarks,
                              OutputTargetLandmarks,
                              OutputWeights,
                              Smoothness,
                              accurate,debug);
        
      }
      Temperature*=AnnealRate;
      CPS*=cps_annealrate;
      Smoothness*=smooth_annealrate;
    }
  
  delete OutputRefLandmarks;
  delete OutputTargetLandmarks;
  delete OutputWeights;

  return iteration_count;
}


/*  License
 
 _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
 ----
     
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   See also  http: www.gnu.org/licenses/gpl.html
   
   If this software is modified please retain this statement and add a notice
   that it had been modified (and by whom).  
 
 Endlicense */

#include "bisApproximateDisplacementField.h"
#include "bisImageAlgorithms.h"
#include <sstream>
#include <iomanip>
#include <time.h>

bisApproximateDisplacementField::bisApproximateDisplacementField(std::string s) : bisOptimizableAlgorithm(s)
{
  this->class_name="bisApproximateDisplacementField";
  this->enable_feedback=0;
}

bisApproximateDisplacementField::~bisApproximateDisplacementField()
{
  this->lastSmoothness=-1.0;
  this->lastSimilarity=-1.0;
}


void bisApproximateDisplacementField::generateFeedback(std::string input)
{

  std::cout << input << "  (" << std::fixed << std::setw(5) << this->lastSimilarity << "," << std::setw(5) << this->lastSmoothness << ")" << std::endl;
}


void bisApproximateDisplacementField::generateFeedback2(std::string input)
{
   std::cout << input << std::endl;
}

float bisApproximateDisplacementField::getCurrentStepSize() {
  return this->current_step_size;
}


// Optimizer Stuff
float bisApproximateDisplacementField::computeValue(std::vector<float>& position)
{
  this->currentGridTransformation->setParameterVector(position);
  this->currentGridTransformation->inPlaceComputeDisplacementField(this->temp_displacement_field.get(),this->level_bounds);

  float v=0;

  /*  for (int ia=0;ia<=5;ia++)
    {
      std::cout << "Original = " << this->level_reference->getImageData()[ia] << " vs " << this->temp_displacement_field->getImageData()[ia] << std::endl;
      }*/
  
  
  if (!this->inverse)
    {
      v=bisAbstractTransformation::computeDisplacementFieldSSD(this->temp_displacement_field.get(),
							       this->level_reference.get(),
							       this->level_bounds);
    }
  else
    {
      v=bisImageAlgorithms::computeDisplacementFieldRoundTripError(this->level_reference.get(),
								   this->temp_displacement_field.get(),
								   this->level_bounds);
    }
	
  

  this->lastSimilarity=v;
  

  if (this->lambda>0.0)
    {
      this->lastSmoothness=this->currentGridTransformation->getTotalBendingEnergy();
      v+=this->lambda*this->lastSmoothness;
    }

  return v;
}


float bisApproximateDisplacementField::computeValueFunctionPiece(bisAbstractTransformation* tr,int bounds[6],int cp)
{

  int debug=0;

  tr->inPlaceComputeDisplacementField(this->temp_displacement_field.get(),bounds);
  
  float v=0;
  if (!this->inverse)
    {
      v=bisAbstractTransformation::computeDisplacementFieldSSD(this->temp_displacement_field.get(),
							       this->level_reference.get(),
							       bounds,debug);
    }
  else
    {
      v=bisImageAlgorithms::computeDisplacementFieldRoundTripError(this->level_reference.get(),
								   this->temp_displacement_field.get(),
								   bounds,debug);
    }


  if (debug)
    {
      int i=(bounds[1]-bounds[0])/2;
      int j=(bounds[3]-bounds[2])/2;
      int k=(bounds[5]-bounds[4])/2;
      int dim[3]; temp_displacement_field->getImageDimensions(dim);
      int index=k*dim[0]*dim[1]+j*dim[0]+i;
      std::cout << " Target=" << this->level_reference->getImageData()[index] << " vs Gen=" <<  this->temp_displacement_field->getImageData()[index] << std::endl;
    }
  if (this->lambda>0.0)
    v+=this->lambda*this->currentGridTransformation->getBendingEnergyAtControlPoint(cp);
  
  return v;
}


float bisApproximateDisplacementField::computeGradient(std::vector<float>& params,std::vector<float>& grad)
{
  int dim_ref[3]; level_reference->getImageDimensions(dim_ref);
  float spa_ref[3]; level_reference->getImageSpacing(spa_ref);

  return this->currentGridTransformation->computeGradientForOptimization(params,grad,
                                                                         this->current_step_size,
                                                                         dim_ref,spa_ref,this->windowsize,
                                                                         this);
}

  
int bisApproximateDisplacementField::checkInputParameters(bisJSONParameterList* plist)
{
  std::unique_ptr<bisJSONParameterList> tmp(new bisJSONParameterList(this->name+":plist"));
  this->internalParameters=std::move(tmp);

  
  this->internalParameters->setFloatValue("lambda",bisUtil::frange(plist->getFloatValue("lambda",0.0f),0.0f,1.0f));
  this->internalParameters->setFloatValue("windowsize",bisUtil::frange(plist->getFloatValue("windowsize",1.0f),1.0f,2.0f));
  this->internalParameters->setFloatValue("resolution",bisUtil::frange(plist->getFloatValue("resolution",1.5f),0.5f,10.0f));
  this->internalParameters->setFloatValue("resolutionrate",bisUtil::frange(plist->getFloatValue("resolutionrate",2.0f),1.5f,3.0f));
  this->internalParameters->setFloatValue("tolerance",bisUtil::frange(plist->getFloatValue("tolerance",0.001f),0.0f,0.5f));
  this->internalParameters->setIntValue("levels",bisUtil::irange(plist->getIntValue("levels",3),1,4));
  this->internalParameters->setIntValue("steps",bisUtil::irange(plist->getIntValue("steps",1),1,4));
  this->internalParameters->setFloatValue("stepsize",bisUtil::frange(plist->getFloatValue("stepsize",1.0f),0.05f,4.0f));
  this->internalParameters->setIntValue("iterations",bisUtil::irange(plist->getIntValue("iterations",15),1,100));
  this->internalParameters->setIntValue("inverse",plist->getBooleanValue("inverse",0));
  this->lambda=this->internalParameters->getFloatValue("lambda",0.0f);
  this->windowsize=  this->internalParameters->getFloatValue("windowsize",1.0f);
  this->inverse=this->internalParameters->getIntValue("inverse");
  if (this->enable_feedback)
    this->internalParameters->print("Approximate Displacement Field");
  return 1;
}

void bisApproximateDisplacementField::initializeLevel(int lv)
{
  float rsc=this->internalParameters->getFloatValue("resolution",1.5f);
  float rate=this->internalParameters->getFloatValue("resolutionrate",2.0f);
  float resolution=rsc*powf(rate,lv-1.0f);

  float ospa[5]; currentDisplacementField->getSpacing(ospa);
  float target_spa[3];
  
  for (int ia=0;ia<=2;ia++)
    {
      target_spa[ia]=resolution*ospa[ia];

    }

  // Create resample disp field
  std::unique_ptr<bisSimpleImage<float> > tmp(bisImageAlgorithms::resampleImage<float>(currentDisplacementField,target_spa));
  this->level_reference=std::move(tmp);

  // Create empty disp field
  std::unique_ptr<bisSimpleImage<float> > tmp2(new bisSimpleImage<float>("temp_dispfield"));
  tmp2->copyStructure(this->level_reference.get());
  this->temp_displacement_field=std::move(tmp2);

  int dim[3]; this->temp_displacement_field->getImageDimensions(dim);
  for (int ia=0;ia<=2;ia++)
    {
      this->level_bounds[2*ia]=0;
      this->level_bounds[2*ia+1]=dim[ia]-1;
    }
      
}


// Set Parameters and Run
float bisApproximateDisplacementField::run(bisSimpleImage<float>* displacementGrid, bisGridTransformation* transformation,bisJSONParameterList* plist)
{

  this->currentGridTransformation=transformation;
  this->currentDisplacementField=displacementGrid;

  if (this->enable_feedback)
    this->generateFeedback2("++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ +");
  this->checkInputParameters(plist);

  std::stringstream strss;
  strss.precision(5);

  int numlevels=  this->internalParameters->getIntValue("levels");
  int numsteps=   this->internalParameters->getIntValue("steps");
  float stepsize=   this->internalParameters->getFloatValue("stepsize");
  int iterations=this->internalParameters->getIntValue("iterations");
  float tolerance=this->internalParameters->getFloatValue("tolerance",0.001f);

  // Also cps, cpsrate, windowsize, lambda ...
  

  float last=0.0;

  for (int level=numlevels;level>=1;level=level-1)
    {
      strss.clear();
      std::stringstream strss2;
      if (!this->inverse)
	strss2 << "++   Beginning to appproximate FORWARD displacement field at level=" << level << ", numsteps=" << numsteps << ", tolerance=" << tolerance;
      else
      	strss2 << "++   Beginning to appproximate INVERSE displacement field at level=" << level << ", numsteps=" << numsteps << ", tolerance=" << tolerance;
      this->generateFeedback2(strss2.str());

      this->initializeLevel(level);

      float spa[3]; this->level_reference->getImageSpacing(spa);
      int numdof=this->currentGridTransformation->getNumberOfDOF();
      this->current_step_size=stepsize*powf(2.0,float(numsteps-1))*spa[0];
      this->generateFeedback2("++  ");
      std::stringstream strss3;
      strss3 << "++   Approx Level=" << level << " resolution=" << spa[0] << " numdof=" << numdof << " current_step=" << this->current_step_size << " ( step=" << stepsize << ", spa[0]=" << spa[0] << ")";
      this->generateFeedback2(strss3.str());
      this->generateFeedback2("++  ");
      // Set stepsize

      std::unique_ptr<bisOptimizer> optimizer(new bisOptimizer(this));

      std::vector<float> position(numdof);
      
      // Get current state ...
      this->currentGridTransformation->getParameterVector(position);
      
      for (int step=numsteps;step>=1;step=step-1)
	{
	  std::cout << "~~~~ In step = " << step << ", iterations = " << iterations << " cur=" << this->current_step_size;

	  strss.clear();
	  this->generateFeedback2(strss.str());
	  last=optimizer->computeConjugateGradient(position,iterations,tolerance);
	  this->current_step_size=this->current_step_size/2.0f;
	}
      this->generateFeedback2("++  ");
    }



  return last;
}




/*  License
 
 _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
 ----
     
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   See also  http: www.gnu.org/licenses/gpl.html
   
   If this software is modified please retain this statement and add a notice
   that it had been modified (and by whom).  
 
 Endlicense */


#include "bisDTIAlgorithms.h"
#include "bisEigenUtil.h"
#include <Eigen/Dense>
#include "bisImageAlgorithms.h"
#include <vector>

namespace bisDTIAlgorithms {


  
  int computeTensorFit(bisSimpleImage<short>* input,
		       bisSimpleImage<short>* t2image,
		       bisSimpleImage<unsigned char>* mask,
		       Eigen::MatrixXf& gradients,
		       float bValue,
		       bisSimpleImage<float>* tensor)
  {

    if (bisImageAlgorithms::doImagesHaveSameSize<short,short>(input,t2image,0)==0)
      {
	std::cerr << "Bad T2 Image " << std::endl;
	return 0;
      }

    int dim[5]; input->getDimensions(dim);
    float spa[5]; input->getSpacing(spa);
    std::cout << "dim=" << dim[0] << "," << dim[1] << "," << dim[2] << "," << dim[3] << "," << dim[4] << std::endl;

    if (mask!=0)
      {
	if (bisImageAlgorithms::doImagesHaveSameSize<short,unsigned char>(input,mask,0)==0)
	  {
	    std::cerr << "Bad Mask Image " << std::endl;
	    int dmask[5]; mask->getDimensions(dmask);
	    std::cout << "dmask=" << dmask[0] << "," << dmask[1] << "," << dmask[2] << "," << dmask[3] << "," << dmask[4] << std::endl;
	    return 0;
	  }
      }

    
    
    int numdirections=dim[3];
    if (numdirections!=gradients.rows())
      {
	std::cout << "Bad Directions Matrix " << std::endl;
	return 0;
      }


    
    // Allocate Output
    spa[3]=1;spa[4]=1;
    int t_dim[5]= { dim[0],dim[1],dim[2],6,1};
    tensor->allocateIfDifferent(t_dim,spa);
    tensor->fill(0.0f);

    // Create Matrix
    Eigen::MatrixXf alpha=Eigen::MatrixXf::Zero(numdirections,6);
    for (int i=0; i< numdirections; i++) {
      float gx = gradients(i, 0);
      float gy = gradients(i, 1);
      float gz = gradients(i, 2);
      alpha(i,0) = gx*gx;
      alpha(i,1) = 2*gx*gy;
      alpha(i,2) = 2*gx*gz;
      alpha(i,3) = gy*gy;
      alpha(i,4) = 2*gy*gz;
      alpha(i,5) = gz*gz;
    }

    //    std::cout << "Alpha Matrix=" << std::endl << alpha << std::endl << std::endl;

    short* baseline=t2image->getImageData();
    unsigned char* maskdata=0;
    if (mask!=0)
      maskdata=mask->getImageData();
    short* inpdata=input->getImageData();
    float* tensordata=tensor->getImageData();
    
    int volsize=dim[2]*dim[1]*dim[0];
    float shift=0.0;
    Eigen::VectorXf adc =Eigen::VectorXf::Zero(6);
    Eigen::VectorXf t =Eigen::VectorXf::Zero(6);
    Eigen::MatrixXf LSQ=bisEigenUtil::createLSQMatrix(alpha);

    //    std::cout << "LSQ Matrix=" << std::endl << LSQ << std::endl << std::endl;

    for (int index=0;index<volsize;index++)
      {    
	float baseln = float(baseline[index])+shift;
	
	int inmask = 1;
	if (maskdata!=0)
	  inmask=maskdata[index];
	
	if (inmask)
	  {
	    // Calculate ADCs
	    for(int n=0; n< numdirections;n++)
	      {
		
		int i_index=index+n*volsize;
		float value = float(inpdata[i_index])+shift;
		
		adc(n)=0.0;
		if (value>0.0)
		  {
		    if (baseln/value > 1.0)
		      adc(n) = (float)(log(baseln / value) / bValue);
		  }
	      }
	    
	    bisEigenUtil::inPlaceMultiplyMV(LSQ,adc,t);
	    for (int ia=0;ia<=5;ia++)
	      tensordata[index+ia*volsize]=t(ia);
	  }
      }
    return 1;
  }

  // output is 4 components x 3 frames
  // component 0 = eigenvalues
  // components 1-3 eigenvectors
  // frames are x,y,z
  int computeTensorEigenSystem(bisSimpleImage<float>* tensor,
			       bisSimpleImage<unsigned char>* mask,
			       bisSimpleImage<float>* eigenSystem)

  {
    int dim[5]; tensor->getDimensions(dim);
    float spa[5]; tensor->getSpacing(spa);
    std::cout << "dim=" << dim[0] << "," << dim[1] << "," << dim[2] << "," << dim[3] << "," << dim[4] << std::endl;
    if (dim[3]!=6 || dim[4]!=1)
      {
	std::cerr << "Bad Tensor it must have 6 frames and 1 component" << std::endl;
	return 0;
      }
    
    if (mask!=0)
      {
	if (bisImageAlgorithms::doImagesHaveSameSize<float,unsigned char>(tensor,mask,0)==0)
	  {
	    std::cerr << "Bad Mask Image " << std::endl;
	    int dmask[5]; mask->getDimensions(dmask);
	    std::cout << "dmask=" << dmask[0] << "," << dmask[1] << "," << dmask[2] << "," << dmask[3] << "," << dmask[4] << std::endl;
	    return 0;
	  }
      }


    
        // Allocate Output
    spa[3]=1;spa[4]=1;
    int t_dim[5]= { dim[0],dim[1],dim[2],3,4};
    eigenSystem->allocateIfDifferent(t_dim,spa);
    eigenSystem->fill(0.0f);

    unsigned char* maskdata=0;
    if (mask!=0)
      maskdata=mask->getImageData();
    float* tensordata=tensor->getImageData();
    float* outputdata=eigenSystem->getImageData();
    
    int volsize=dim[2]*dim[1]*dim[0];
    int volframesize=volsize*3;
    Eigen::Matrix3f tensorMatrix =Eigen::Matrix3f::Zero(3,3);

    for(int index=0;index<volsize;index++)
      {
	int inmask = 1;
	if (maskdata!=0)
	  inmask=maskdata[index];
	
	if (inmask)
	  {
	    tensorMatrix(0,0)=tensordata[index];
	    tensorMatrix(0,1)=tensordata[index+volsize];
	    tensorMatrix(0,2)=tensordata[index+2*volsize];
	    tensorMatrix(1,0)=tensorMatrix(0,1);
	    tensorMatrix(1,1)=tensordata[index+3*volsize];
	    tensorMatrix(1,2)=tensordata[index+4*volsize];
	    tensorMatrix(2,0)=tensorMatrix(0,2);
	    tensorMatrix(2,1)=tensorMatrix(1,2);
	    tensorMatrix(1,2)=tensordata[index+5*volsize];
	    
	    Eigen::SelfAdjointEigenSolver<Eigen::Matrix3f> solver(tensorMatrix);
	    
	    for (int frame=0;frame<=2;frame++)
	      {
		// Eigen values component = 0;
		outputdata[frame*volsize+index]=solver.eigenvalues()(0);
		for (int v=0;v<=2;v++)
		  outputdata[(v+1)*volframesize+frame*volsize+index]=solver.eigenvectors()(v,frame);
	      }
	  }
      }
    return 1;
  }


  int computeTensorInvariants(bisSimpleImage<float>* eigenSystem,
			      bisSimpleImage<unsigned char>* mask,
			      int mode,
			      bisSimpleImage<float>* output)
  {
    int dim[5]; eigenSystem->getDimensions(dim);
    float spa[5]; eigenSystem->getSpacing(spa);
    std::cout << "dim=" << dim[0] << "," << dim[1] << "," << dim[2] << "," << dim[3] << "," << dim[4] << std::endl;
    if (dim[3]!=3 && dim[4]!=4)
      {
	std::cerr << "Bad EigenSystem it must have 3 frames and 4 components" << std::endl;
	return 0;
      }
    
    if (mask!=0)
      {
	if (bisImageAlgorithms::doImagesHaveSameSize<float,unsigned char>(eigenSystem,mask,0)==0)
	  {
	    std::cerr << "Bad Mask Image " << std::endl;
	    int dmask[5]; mask->getDimensions(dmask);
	    std::cout << "dmask=" << dmask[0] << "," << dmask[1] << "," << dmask[2] << "," << dmask[3] << "," << dmask[4] << std::endl;
	    return 0;
	  }
      }

    mode=bisUtil::irange(mode,0,5);
    int outframes=1;
    if (mode==5)
      outframes=5;
    // Allocate Output
    spa[3]=1;spa[4]=1;
    int t_dim[5]= { dim[0],dim[1],dim[2],3,4};
    output->allocateIfDifferent(t_dim,spa);
    output->fill(0.0f);

    unsigned char* maskdata=0;
    if (mask!=0)
      maskdata=mask->getImageData();
    float* eigenSystemData=eigenSystem->getImageData();
    float* outputdata=output->getImageData();
    
    int volsize=dim[2]*dim[1]*dim[0];

    for (int index=0;index<volsize;index++)
      {
	int inmask = 1;
	if (maskdata!=0)
	  inmask=maskdata[index];
	
	if (inmask)
	  {
	    float l1=eigenSystemData[index];
	    float l2=eigenSystemData[index+volsize];
	    float l3=eigenSystemData[index+2*volsize];
	    float ml = (l1 + l2 + l3) / 3.0;
	    float l1m = l1 - ml;
	    float l2m = l2 - ml;
	    float l3m = l3 - ml;
	    
	    float FA = sqrt(3*(l1m*l1m + l2m*l2m + l3m*l3m)) / 
	      sqrt(2*(l1*l1 + l2*l2 + l3*l3));	    
	    float RA = sqrt(l1m*l1m + l2m*l2m + l3m*l3m) / (sqrt(double(3.0))*ml);
	    float VR = 1.0 - ((l1*l2*l3) / (ml*ml*ml));
	    float SK = (l1m*l1m*l1m + l2m*l2m*l2m + l3m*l3m*l3m) / (l1+l2+l3);
	    float MD = ml;
	    
	    for (int i=0;i<outframes;outframes++)
	      {
		int computemode=i;
		if (mode!=5)
		  computemode=mode;
		
		switch (computemode)
		  {
		  case 0:
		    outputdata[index+volsize*i]=FA;
		    break;
		  case 1:
		    outputdata[index+volsize*i]=RA;
		    break;
		  case 2:
		    outputdata[index+volsize*i]=VR;
		    break;
		  case 3:
		    outputdata[index+volsize*i]=MD;
		    break;
		  case 4:
		    outputdata[index+volsize*i]=SK;
		    break;
		  }
	      }
	  }
      }
    return 1;
  }


  int computeTensorColormap(bisSimpleImage<float>* eigenSystem,
			    bisSimpleImage<unsigned char>* mask,
			    bisSimpleImage<float>* magnitude,
			    float scaling,
			    bisSimpleImage<unsigned char>* outputImage)
  {
    if (mask!=0)
      {
	if (bisImageAlgorithms::doImagesHaveSameSize<float,unsigned char>(eigenSystem,mask,0)==0)
	  {
	    std::cerr << "Bad mask for computeTensorColormap" << std::endl;
	    return 0;
	  }
      }

    if (magnitude!=0)
      {
	if (bisImageAlgorithms::doImagesHaveSameSize<float,float>(eigenSystem,magnitude,0)==0)
	  {
	    std::cerr << "Bad magnitude for computeTensorColormap" << std::endl;
	    return 0;
	  }
      }
    

    float* in_data =eigenSystem->getImageData();
    int dim[5];  eigenSystem->getDimensions(dim);
    std::cout << "dim=" << dim[0] << "," << dim[1] << "," << dim[2] << "," << dim[3] << "," << dim[4] << std::endl;
    if (dim[3]!=3 && dim[4]!=4)
      {
	std::cerr << "Bad EigenSystem it must have 3 frames and 4 components" << std::endl;
	return 0;
      }

    outputImage->fill(0);
    unsigned char* odata=outputImage->getImageData();
    unsigned char* mask_data=0;
    if (mask != 0)
      mask_data= mask->getImageData();
    
    float* mag_data=0;
    double mrange[2];
    if (magnitude != 0)
      {
	mag_data= magnitude->getImageData();
	magnitude->getRange(mrange);
      }
    
    double v[3], rgb[3], nrgb[3];
    int volsize=dim[0]*dim[1]*dim[2];
    // Principal Eigenvector is last one so components 9,10,11
    int offset=9*volsize;
    
    for (int index=0;index<volsize;index++)
      {	
	rgb[0] = rgb[1] = rgb[2] = 0;

	int compute=1;
	if (mask_data!=0)
	  compute=mask_data[index];
	
	if (compute)
	  {
	    for (int ia=0;ia<=2;ia++)
	      v[ia]= in_data[index+ia*volsize+offset];
	    bisUtil::normalize(v);
	    
	    /* compute color */
	    double mgn = 1.0;
	    if (mag_data!=0)
	      mgn=(mag_data[index] - mrange[0]) / mrange[1];

	    for (int ia=0;ia<=2;ia++)
	      rgb[ia] = fabs(v[ia])*mgn;

	    for (int ia=0;ia<=2;ia++)
	      {
		nrgb[ia] = rgb[ia]*255*scaling;
		odata[ia*volsize+index]=( nrgb[ia] < 256 ? nrgb[ia] : 255);
	      }
	  }
      }
    return 1;
  }
  
  // End of namespace
}


/*  License
 
 _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
 ----
     
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   See also  http: www.gnu.org/licenses/gpl.html
   
   If this software is modified please retain this statement and add a notice
   that it had been modified (and by whom).  
 
 Endlicense */

#include "bisOptimizer.h"
#include "sstream"
#include "math.h"


// This is defined here to keep Doxygen happy
void bisOptimizableAlgorithm::beginIteration(std::vector<float>&  ,int )
{

}


// --------------- 

bisOptimizer::bisOptimizer(bisOptimizableAlgorithm* algorithm,std::string n) : bisObject(n)
{
  this->algorithm=algorithm;
  this->NumDOF=0;
  this->resetStatistics();
  this->class_name="bisOptimizer";
}

bisOptimizer::~bisOptimizer()
{
}



void bisOptimizer::allocateTempArrays(unsigned int sz)
{
  if (sz==this->NumDOF)
    return;

  this->pcom.resize(sz);
  this->xicom.resize(sz);
  this->xtemp.resize(sz);
  this->gradient.resize(sz);
  
  for (unsigned int ia=0;ia<sz;ia++)
    {
      this->pcom[ia]=0.0;
      this->xicom[ia]=0.0;
      this->xtemp[ia]=0.0;
      this->gradient[ia]=0.0;
    }
  
  this->resetStatistics();
  this->NumDOF=sz;
}

void bisOptimizer::resetStatistics()
{
  this->NumEvaluations=0;
  this->NumGradients=0;
}

// Print basically
void bisOptimizer::generateOutput(std::string prefix1,std::string prefix2,std::vector<float>& position,float measure,int iter)
{
  std::stringstream output;
  output.precision(5);

  output << "~~~~ " << prefix1 << ":" << prefix2 << " " << iter << " " << std::fixed;
  if (this->NumDOF<=12) {
    output << ": (";
    for (unsigned int ii=0; ii<this->NumDOF; ii++) 
      output << position[ii] << " ";
    
    output << " ) " << measure;
  } else {
    output << this->NumDOF << ":" << "( range=";

    float maxp=position[0];
    float minp=position[0];
    float sum=position[0];
    for (unsigned int ii=1; ii<this->NumDOF; ii++) {
      float v=position[ii];
      sum+=fabs(v);
      if (maxp<v)
        maxp=v;
      else if (minp>v)
        minp=v;
    }
    output << minp << ":" << maxp << ", meanabs=" << sum/float(this->NumDOF) <<" ) " << measure;
  }
  this->algorithm->generateFeedback(output.str());
}
	
void bisOptimizer::generateStatistics(std::string method,std::vector<float>& position)
{
  
  this->NumEvaluations+=1;
  float v=this->algorithm->computeValue(position);

  std::stringstream output;
  output.precision(5);
  output << std::fixed;
  output << "~~~~ " << method << " Stats: Nfunc=" << this->NumEvaluations << ", Ngrad=" << this->NumGradients << ", v=" << v;
  this->algorithm->generateFeedback(output.str());
}

float bisOptimizer::lineFunction(float x)
{
  for (unsigned int ia=0;ia<this->xtemp.size();ia++)
    this->xtemp[ia]=this->pcom[ia]+x*this->xicom[ia];

  this->NumEvaluations+=1;
  float v= this->algorithm->computeValue(this->xtemp);
  return v;

}


#define GOLD 1.618034
#define GLIMIT 100.0
#define TINY 1.0e-20
#define ITMAX 100

void  bisOptimizer::bracketMinimum(optParams& params)
{
  float ulim,u,r,q,fu,temp;
	    
  params.fa=this->lineFunction(params.ax);
  params.fb=this->lineFunction(params.bx);
  if (params.fb > params.fa) {
    temp=params.bx; params.bx=params.ax; params.ax=temp;
    temp=params.fb; params.fb=params.fa; params.fa=temp;
  }

  params.cx=(float)((params.bx)+GOLD*(params.bx-params.ax));
  params.fc=this->lineFunction(params.cx);
  while (params.fb > params.fc) {
    r=(params.bx-params.ax)*(params.fb-params.fc);
    q=(params.bx-params.cx)*(params.fb-params.fa);
    double dq = q-r;
    if (fabs(dq) < TINY)
      {
	float sgn=0.0;
	if (dq<0.0) sgn=-1.0;
	if (dq>0.0) sgn=1.0;
	dq = sgn * TINY;
      }
    u=(float)((params.bx)-((params.bx-params.cx)*q-(params.bx-params.ax)*r)/(2.0*dq));
    ulim=(float)((params.bx)+GLIMIT*(params.cx-params.bx));
    if ((params.bx-u)*(u-params.cx) > 0.0) {
      fu=this->lineFunction(u);
      if (fu < params.fc) {
	params.ax=params.bx;
	params.bx=u;
	params.fa=params.fb;
	params.fb=fu;
	return;
      } else if (fu > params.fb) {
	params.cx=u;
	params.fc=fu;
	return;
      }
      u=(float)((params.cx)+GOLD*(params.cx-params.bx));
      fu=this->lineFunction(u);
    } else if ((params.cx-u)*(u-ulim) > 0.0) {
      fu=this->lineFunction(u);
      if (fu < params.fc) {
	//ShiftValues(bx,cx,&u,u+GOLD*(u-params.cx));
	temp=(float)(u+GOLD*(u-params.cx));
	params.bx=params.cx; params.cx=u; u=temp;
	// ShiftValues(fb,fc,&fu,this->lineFunction(u));
	temp=this->lineFunction(u);
	params.fb=params.fc; params.fc=fu; fu=temp;
      }
    } else if ((u-ulim)*(ulim-params.cx) >= 0.0) {
      u=ulim;
      fu=this->lineFunction(u);
    } else {
      u=(float)((params.cx)+GOLD*(params.cx-params.bx));
      fu=this->lineFunction(u);
    }
    
    //ShiftValues(ax,bx,cx,u);
    params.ax=params.bx; params.bx=params.cx; params.cx=u;
    //   ShiftValues(fa,fb,fc,fu);
    params.fa=params.fb; params.fb=params.fc; params.fc=fu;
  }
}
	
	
float bisOptimizer::minimizeGivenBounds(optParams& params,float tol)
{
// Replacement code from ITK 3.4 (vnl_brent)
// This code has been removed after it was pointed out
// to ITK developers that it was a copy of code from
// Numerical Recipies. January 23 2007
// The distribution license of numerical recipies is not
// compatible with the BSD-License used by ITK.
// 
// ---------------------------------------------
// The following implementation was based on the description
// of the Brent's method presented in the Wikipedia:
//    http://en.wikipedia.org/wiki/Brent%27s_method
  
  float a = params.ax;
  float b = params.cx;
  float ZEPS = tol;
  int mflag=0;
	    
  if( params.ax > params.cx ) {
    a = params.cx;
    b = params.ax;
  }
  
  float x = params.bx;
  float fa = this->lineFunction(a);
  float fb = this->lineFunction(b);
  float fx = this->lineFunction(x);
	    
  if( fa * fb >= 0.0 ) {
    params.xmin = x;
    return fx;
  }
	    
  if( fabs(fa) < fabs(fb) ) {
    float t= a;
    a = b;
    b = t;
    float ft = fa;
    fa = fb;
    fb = ft;
  }
  
  float c = a;
  float d = a;   // it is not clear how to initialize d
  float fc = fa;
  
  float s;
  
  for( int iteration = 1; iteration <= ITMAX; iteration++) {
    if( fabs(fb) <= ZEPS || fabs( a - b ) <= ZEPS ) {
      params.xmin=b;
      return fb;
    }
    
    float fac = fa - fc;
    float fbc = fb - fc;
    float fab = fa - fb;
    
    if( fabs( fac ) < ZEPS || fabs(fbc) < ZEPS ) {
      // Apply secant rule
      s = b - fb * (b - a) / ( fb - fa );
    } else {
      // Inverse quadratic interpolation
      float afbfc = ( a * fb * fc ) / ( fab * fac );
      float bfafc = ( b * fa * fc ) / ( fab * fbc );
      float cfafb = ( c * fa * fb ) / ( fac * fbc );
      s = afbfc - bfafc + cfafb;
    }
    
    if( !( s > ( 3 * a + b ) / 4.0 && s < b ) ||
	(  mflag && ( fabs( s - b ) >= fabs( b - c ) / 2.0 ) ) ||
	( !mflag && ( fabs( s - b ) >= fabs( c - d ) / 2.0 ) )    ) {
      s = ( a + b ) / 2;
      mflag = 1;
    }  else {
      mflag = 0;
    }
    
    float fs = this->lineFunction(s);
    d = c;	c = b;
    
    if( fa * fs < 0.0 ) {
      b = s;
      fb = fs;
    }  else {
      a = s;
      fa = fs;
    }
    
    if( fabs( fa ) < fabs( fb ) ) {
      float temp = a;
      a = b;
      b = temp;
    }
  }
  
  params.xmin = b;
  return fb;
}

#undef ITMAX
#undef CGOLD
#undef ZEPS

float bisOptimizer::lineMinimization(std::vector<float>& p,std::vector<float>& xi,int iterno,float tolerance,std::string method)
{
  if (method=="")
    method = "Some";

  for (unsigned int ia=0;ia<p.size();ia++) {
    this->pcom[ia]=p[ia];
    this->xicom[ia]=xi[ia];
  }
	    
  optParams params;
  params.ax=0.0;
  params.bx=1.0;
  params.cx=1.0;
  params.fa=0.0;
  params.fb=0.0;
  params.fc=0.0;
  params.xmin=0.0;
	    
  this->bracketMinimum(params);
  float fret=this->minimizeGivenBounds(params,tolerance);

  for (unsigned int ia=0;ia<xi.size();ia++)
    p[ia]=p[ia]+params.xmin*xi[ia];
    
  if (iterno>=0)
    this->generateOutput(method, "Lmin",p,fret,iterno);
	    
  return fret;
}


    
float bisOptimizer::computeGradientDescent(std::vector<float>& position,int iterations,float tolerance)
{
  unsigned int numdof=position.size();
  this->allocateTempArrays(numdof);
  this->algorithm->beginIteration(position,0);
  
  this->NumEvaluations+=1;
  float old_similarity=this->algorithm->computeValue(position);
  this->generateOutput("GD", "Beginning",position,old_similarity,0);

  this->algorithm->computeGradient(position,this->gradient);
  this->NumGradients+=1;
  
  float best=old_similarity;
  int done=0;
  int iter=1;
		
  while (done==0 && iter<iterations) {  
    this->algorithm->beginIteration(position,iter);
    best=this->lineMinimization(position,this->gradient,iter,tolerance,"\t GD");
    if (fabs(best-old_similarity)<tolerance) {
      done=1;
    } else {
      this->NumEvaluations+=1;
      old_similarity=this->algorithm->computeValue(position);
      this->NumGradients+=1;
      this->algorithm->computeGradient(position,this->gradient);
      iter=iter+1;
    }
  }
  
  this->generateOutput("\t GD", "Done",position,best,iter);
  this->generateStatistics("\t GD",position);


  return best;
}

float bisOptimizer::computeSlowClimb(std::vector<float>& position,float step,int iterations)
{
  this->NumDOF=position.size();
  this->algorithm->beginIteration(position,0);
  this->NumEvaluations+=1;
  float old_similarity=this->algorithm->computeValue(position);
  float similarity=old_similarity;


  std::stringstream line;
  line << "SC " << step;
  this->generateOutput(line.str(), "Beginning",position,old_similarity,0);

  std::stringstream line2;
  line2 << "\t SC " << step;

  
  for (int iter=1;iter<=iterations;iter++)
    {
      int j = 0,k = 0;
      float best_similarity=old_similarity;
      this->algorithm->beginIteration(position,iter);
      
      for (unsigned int i = 0; i < this->NumDOF; i++)
	{
	  float orig=position[i];
	  position[i]=orig + step;
	  this->NumEvaluations+=2;
	  similarity=this->algorithm->computeValue(position);
	  if (similarity < best_similarity)
	    {
	      best_similarity = similarity;
	      j =  i;
	      k =  1;
	    }
	  position[i]=orig-step;
	  similarity=this->algorithm->computeValue(position);
	  if (similarity < best_similarity)
	    {
	      best_similarity = similarity;
	      j =  i;
	      k = -1; 
	    }
	  position[i]=orig;
	}
      
      if (best_similarity < old_similarity)
	{
	  float oldv=position[j];
	  float updatedv=oldv+k*step;
	  position[j]=updatedv;
	  old_similarity=best_similarity;
	}
      else
	iter=iterations+1; // Break Out	

      this->generateOutput(line2.str(), "It",position,old_similarity,iter);
    }

  this->generateStatistics(line2.str(),position);
  return old_similarity;
}
 
float bisOptimizer::computeConjugateGradient(std::vector<float>& position,int iterations,float tolerance)
{
  unsigned int numdof=position.size();
  
  this->allocateTempArrays(numdof);
  if (gradient.size()<numdof)
    gradient.resize(numdof);
		
  std::stringstream line;
  line << "CG: Beginning (it=" << iterations << "), tol=" <<  tolerance << ", stepsize=" << this->algorithm->getCurrentStepSize();
  std::stringstream line2;
  line2 << std::endl << "~~~~ \t CG:Init";
		
  this->algorithm->beginIteration(position,0);
  this->NumEvaluations+=1;
  float funcval=this->algorithm->computeValue(position);
  this->generateOutput(line.str(),line2.str(),position,funcval);

  this->NumGradients+=1;
  float norm=this->algorithm->computeGradient(position,this->gradient);

  if (norm<tolerance) {
    std::stringstream line;
    line << "\t\t norm " << norm << " tolerance " << tolerance << std::endl;
    this->algorithm->generateFeedback(line.str());
    this->generateOutput("\t CG", "Done",position,funcval,0);  
    this->generateStatistics("\t CG",position);
    return funcval;
  }

  std::vector<float> g(numdof);
  std::vector<float> h(numdof);

  for (unsigned int ia=0;ia<numdof;ia++) {
    g[ia]=-1.0f*this->gradient[ia];
    h[ia]=g[ia];
    this->gradient[ia]=h[ia];
  }
		
  int iter=1;
  int done=0;
		
  while (iter<=iterations && done == 0 ) {
    
    this->algorithm->beginIteration(position,iter);
    float updatedval=this->lineMinimization(position,this->gradient,iter,tolerance,"\t CG");
    done=1;
    if (fabs(funcval-updatedval)>tolerance)
      {
	this->NumEvaluations+=1;
	funcval=this->algorithm->computeValue(position);
	this->NumGradients+=1;
	this->algorithm->computeGradient(position,this->gradient);
	float dgg=0.0,gg=0.0;
	for (unsigned int j=0;j<numdof;j++) {
	gg += g[j]*g[j];
	dgg += (this->gradient[j]+g[j])*this->gradient[j];
      }
      if (gg > 0.000001)  {
	float gam=dgg/gg;
	for (unsigned int ia=0;ia<numdof;ia++)
	  {
	    g[ia]=-1.0f*this->gradient[ia];
	    h[ia]=h[ia]*gam+g[ia];
	    this->gradient[ia]=h[ia];
	  }
	done=0;
      }
    }
    //    this->generateOutput("\t CG", "Done",position,funcval,iter);  
    ++iter;
  }
  
  this->generateOutput("\t CG", "Done",position,funcval,iter);  
  this->generateStatistics("\t CG",position);
  
  return funcval;
}
/*  License
 
    _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
    ----
     
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
   
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    See also  http: www.gnu.org/licenses/gpl.html
   
    If this software is modified please retain this statement and add a notice
    that it had been modified (and by whom).  
 
    Endlicense */

#include "bisLinearImageRegistration.h"
#include "bisImageAlgorithms.h"
#include "sstream"
#include <time.h>

bisLinearImageRegistration::bisLinearImageRegistration(std::string s) : bisAbstractImageRegistration(s)
{
  this->class_name="bisLinearImageRegistration";
  
  std::string n=this->name+":internal";
  
  std::unique_ptr<bisLinearTransformation> tmp(new bisLinearTransformation(n));
  this->internalTransformation=std::move(tmp);
  this->internalTransformation->identity();

  std::string n2=this->name+":initial";
  std::unique_ptr<bisMatrixTransformation> tmpM(new bisMatrixTransformation(n2));
  this->initialTransformation=std::move(tmpM);
  this->initialTransformation->identity();

}

bisLinearImageRegistration::~bisLinearImageRegistration()
{
}


  
bisSimpleMatrix<float>* bisLinearImageRegistration::getOutputMatrix()
{
  return this->internalTransformation->getSimpleMatrix("lin_reg_matrix");
}


bisSimpleVector<float>* bisLinearImageRegistration::getTransformationParameterVector()
{
  bisSimpleVector<float>* output=new bisSimpleVector<float>("lin_reg_vector");
  output->allocate(29);

  bisUtil::mat44 m;
  this->internalTransformation->getMatrix(m);
  int index=0;
  for (int ia=0;ia<=3;ia++) {
    for (int ib=0;ib<=3;ib++) {
      output->getData()[index]=m[ia][ib];
      index=index+1;
    }
  }

  std::vector<float> p(12);
  this->internalTransformation->storeParameterVector(p,1);
  for (int ia=0;ia<=11;ia++) 
    output->getData()[ia+16]=p[ia];

  output->getData()[28]=(float)this->internalTransformation->getMode();

  return output;
}


void bisLinearImageRegistration::setInitialTransformation(bisMatrixTransformation* initial)
{
  bisUtil::mat44 m; initial->getMatrix(m);
  this->initialTransformation->setMatrix(m);
}
  

// Optimizer Stuff
float bisLinearImageRegistration::computeValue(std::vector<float>& position)
{
  this->internalTransformation->setParameterVector(position,1);
  bisImageAlgorithms::resliceImage(this->level_target.get(),this->temp_target.get(),this->internalTransformation.get(),1,0.0);


  
  short* weight1_ptr=0,*weight2_ptr=0;
  if (this->use_weights>0)
    {
      weight1_ptr=this->level_reference_weight->getImageData();
      if (this->use_weights==2)
        {
          bisImageAlgorithms::resliceImage(this->level_target_weight.get(),this->temp_target_weight.get(),this->internalTransformation.get(),1,0.0);
          weight2_ptr=this->temp_target_weight->getImageData();
        }
    }

  this->internalHistogram->weightedFillHistogram(this->level_reference->getImageData(),
                                                 this->temp_target->getImageData(),
                                                 weight1_ptr,
                                                 weight2_ptr,
                                                 use_weights,
                                                 1.0,
                                                 1, // reset
                                                 this->level_dimensions,
                                                 this->level_bounds);


  float mv=(float)this->internalHistogram->computeMetric(this->metric);

  /*  count=count+1;
      if (count>=13 && count<=20)
      {
      std::vector<float> p(12);
      this->internalTransformation->storeParameterVector(p,1);
      bisUtil::mat44 m; this->internalTransformation->getMatrix(m);
      std::cout << count << " [";
      for (int j=0;j<p.size();j++)
      std::cout << p[j] << " ";
      std::cout << "] [";
      for (int row=0;row<=2;row++) {
	  for (int col=0;col<=3;col++) {
      std::cout << m[row][col] << " ";
	  }
      }
      std::cout << "] = " << mv << std::endl;
      }*/


  return mv;
}


float bisLinearImageRegistration::computeGradient(std::vector<float>& params,std::vector<float>& grad)
{
  
  int numdof=this->internalTransformation->getNumberOfDOF();

  //  std::cout << "sizes=" << params.size() << " " << grad.size() << " dof=" << numdof << std::endl;
  
  for (int i=0;i<numdof;i++)
    grad[i]=0.0;
		
  float GradientNorm = 0.000001f;

  
  for (int i=0;i<numdof;i++)
    {
      float orig=params[i];
      params[i]=orig+this->current_step_size;
      float a=this->computeValue(params);
		    
      params[i]=orig-this->current_step_size;
      float b=this->computeValue(params);
		    
      params[i]=orig;
      float g=-0.5f*(b-a)/this->current_step_size;
      grad[i]=g;
      GradientNorm+=g*g;
    }

  GradientNorm = (float)sqrt(GradientNorm);
  //  std::cout << "\t grad=";
  for (int i=0;i<numdof; i++) {
    grad[i]=grad[i]/GradientNorm;
    //std::cout << grad[i] << " ";
  }
  //  std::cout << std::endl;
  return GradientNorm;
}

  
int bisLinearImageRegistration::checkInputParameters(bisJSONParameterList* plist)
{

  bisAbstractImageRegistration::checkInputParameters(plist);

  int mode=bisUtil::irange(plist->getIntValue("mode",0),0,6);
  

  int dim[3];
  this->reference->getImageDimensions(dim);
  if (dim[2]<2) {
    // Force use of 2D mode
    if (mode==0)
      mode=4;
    if (mode==1 || mode==2)
      mode=5;
    if (mode==3)
      mode=6;
  }

  this->internalParameters->setIntValue("mode",mode);

  this->internalParameters->setBooleanValue("centeronrefonly",plist->getBooleanValue("centeronrefonly",0));
  if (this->enable_feedback)
    this->internalParameters->print("Fixed Parameters prior to running Linear","+ + + ");
  return 1;
}



// Set Parameters and Run
void bisLinearImageRegistration::run(bisJSONParameterList* plist)
{

  //  plist->print("Unfixd Parameters","+ + + ");
  
  this->checkInputParameters(plist);

  this->generateFeedback("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");


  std::stringstream strss;
  strss.precision(5);

  int numlevels=  this->internalParameters->getIntValue("levels");
  int numsteps=   this->internalParameters->getIntValue("steps");
  float stepsize=   this->internalParameters->getFloatValue("stepsize");
  int optimization=this->internalParameters->getIntValue("optimization");
  int iterations=this->internalParameters->getIntValue("iterations");
  float tolerance=this->internalParameters->getFloatValue("tolerance",0.001f);
  int centeronrefonly=this->internalParameters->getBooleanValue("centeronrefonly",0);
  int mode=this->internalParameters->getIntValue("mode",0);
  int initial_mode=0;
  if (mode>3)
    initial_mode=4;

  if (enable_feedback) {
    std::cout << "+ +  Retrieved parameters: nlevels=" << numlevels << " numsteps=" << numsteps << " stepsize=" << stepsize << std::endl;
    std::cout << "+ +      optimization=" << optimization << " iterations=" << iterations << " tolerance=" << tolerance << std::endl;
    std::cout << "+ +      mode=" << mode << ", initial=" << initial_mode << ", similarity metric=" << metric << std::endl;
  }
  // Initialize Transformation 
  this->internalTransformation->setMode(initial_mode);
  this->internalTransformation->identity();
  this->internalTransformation->setPreMatrixTransformation(this->initialTransformation.get());

  time_t timer1,timer2;
  time(&timer1);
  for (int level=numlevels;level>=1;level=level-1)
    {
      strss.clear();
      std::stringstream strss2;
      strss2 << "+ +  Beginning to compute  l i n e a r  registration at level=" << level << ", numsteps=" << numsteps << ", tolerance=" << tolerance << " centeronrefonly=" << centeronrefonly;
      this->generateFeedback(strss2.str());
      this->generateFeedback("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");
      this->initializeLevel(level);
      if (level==numlevels)
        {
          // Set Shifts now that the first level is initialized ...
          int dim_ref[3]; level_reference->getImageDimensions(dim_ref);
          float spa_ref[3]; level_reference->getImageSpacing(spa_ref);
          int dim_trg[3]; level_target->getImageDimensions(dim_trg);
          float spa_trg[3]; level_target->getImageSpacing(spa_trg);
          if (centeronrefonly) {
            this->generateFeedback("+ + + + +");
            this->generateFeedback("+ + + + + Shifting Based on reference only ");
            this->generateFeedback("+ + + + +");
            this->internalTransformation->setShifts(dim_ref,spa_ref,dim_ref,spa_ref);
          }
          else {
            this->internalTransformation->setShifts(dim_ref,spa_ref,dim_trg,spa_trg);
          }
        }

      this->generateFeedback("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");
      float spa[3]; this->level_reference->getImageSpacing(spa);
      int numdof=this->internalTransformation->getNumberOfDOF();
      std::stringstream strss3;
      this->current_step_size=stepsize*powf(2.0f,float(numsteps-1))*spa[0];
      strss3 << "+ +  \t\t Beginning level=" << level << " resolution=" << spa[0] << " numdof=" << numdof << " current_step=" << this->current_step_size;
      this->generateFeedback("+ + ");
      this->generateFeedback(strss3.str());
      this->generateFeedback("+ + ");
      // Set stepsize


      std::unique_ptr<bisOptimizer> optimizer(new bisOptimizer(this));

      std::vector<float> position(numdof);
  
      // true here refers to scale*100.0. Get Initial Parameters from transformation
      this->internalTransformation->storeParameterVector(position,1);

      this->totaltime=0.0;


      for (int step=numsteps;step>=1;step=step-1)
        {
          if (enable_feedback)
            std::cout << "+ +  In step = " << step << ". Iterations = " << iterations << ", optimization=" << optimization <<", current=" << this->current_step_size << "." << std::endl;
          if (optimization==0)
            optimizer->computeSlowClimb(position,this->current_step_size,iterations);
          else if (optimization==1)
            optimizer->computeGradientDescent(position,iterations,tolerance);
          else
            optimizer->computeConjugateGradient(position,iterations,tolerance);
	  
          this->current_step_size=this->current_step_size/2.0f;
        }
      if (level==2)
        this->internalTransformation->setMode(mode);
      this->generateFeedback("+ + ");
      this->generateFeedback("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");
    }
  time(&timer2);
  std::stringstream strss_final;
  this->totaltime=difftime(timer2,timer1);
  strss_final << "+ +  Stats : total_time " <<  this->totaltime;
  this->generateFeedback(strss_final.str());
  this->generateFeedback("+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +");

}



/*  License
 
    _This file is Copyright 2018 by the Image Processing and Analysis Group (BioImage Suite Team). Dept. of Radiology & Biomedical Imaging, Yale School of Medicine._ It is released under the terms of the GPL v2.
 
    ----
     
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
   
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    See also  http: www.gnu.org/licenses/gpl.html
   
    If this software is modified please retain this statement and add a notice
    that it had been modified (and by whom).  
 
    Endlicense */

#include "bisRPMCorrespondenceFinder.h"
#include "bisPointLocator.h"
#include "bisPointRegistrationUtils.h"


bisRPMCorrespondenceFinder::bisRPMCorrespondenceFinder(std::string n) : bisObject(n) {

  this->locator=NULL;
  this->SampledReferencePoints=0;
  this->SampledTargetPoints=0;
  this->SampledReferenceLabels=NULL;
  this->SampledTargetLabels=NULL;
  this->class_name="bisRPMCorrespondenceFinder";
}

bisRPMCorrespondenceFinder::~bisRPMCorrespondenceFinder() {
  this->cleanup();
}

void bisRPMCorrespondenceFinder::cleanup() {
  
  if (this->locator)
    delete this->locator;

  this->SampledReferencePoints=0;
  this->SampledTargetPoints=0;
  
  if (this->SampledReferenceLabels)
    delete this->SampledReferenceLabels;
  
  if (this->SampledTargetLabels)
    delete this->SampledTargetLabels;

  
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------
int bisRPMCorrespondenceFinder::samplePoints(bisSimpleMatrix<float>* inputPoints,
                                             bisSimpleVector<int>* inputLabels,
                                             int maxnumpoints,
                                             int samplingweight,
                                             bisSimpleMatrix<float>* outputPoints,
                                             bisSimpleVector<int>* outputLabels,
                                             int debug)
{
  samplingweight=bisUtil::irange(samplingweight,1,5);
  int uselabels=0;
  if (inputLabels)
    uselabels=1;

  int numrows=inputPoints->getNumRows();
  int numcols=inputPoints->getNumCols();
  int numrows2=numrows;
  if (uselabels) {
    numrows2=inputLabels->getLength();
  }

  if (numrows<4 || numcols!=3 || numrows2 != numrows) {
    std::cerr << "___ Failed to sample " << numrows << "*" << numcols << std::endl;
    if (uselabels)
      std::cerr << "___      uselabels=" << uselabels << " numrows=" << numrows2 << std::endl;
  }
  
  if (!uselabels || samplingweight<=1) {
    
    int step=1;
    if (maxnumpoints < numrows) {
      step=int(numrows/maxnumpoints);
    }
    int actualnumpoints=numrows/step;
    outputPoints->zero(actualnumpoints,3);
    outputLabels->zero(actualnumpoints);
    float* outpts=outputPoints->getData();

    if (debug) {
      std::cout << "___ Sampling from " << numrows << " points to " << actualnumpoints << " (step=" << step << ")" << std::endl;
      std::cout << "___ Actual Num Points=" << actualnumpoints << std::endl;
    }
    float* pts=inputPoints->getData();
    
    for (int i=0;i<actualnumpoints;i++) {
      int index=i*step*3;
      for (int ia=0;ia<=2;ia++)
        outpts[i*3+ia]=pts[index+ia];
    }
    return actualnumpoints;
  }

  // Preferential sampling ... harder
  int count[2]={0,0};
  float* pts=inputPoints->getData();
  int* labels=inputLabels->getData();
  
  for (int i=0;i<numrows;i++) {
    if (labels[i]>0)
      count[1]=count[1]+1;
  }
  count[0]=numrows-count[1];

  int nominaltotal=count[0]+count[1]*samplingweight;
  int step[2]={1,1};
  if (maxnumpoints < nominaltotal) {
    float fraction=float(count[0])/float(nominaltotal);
    step[0]=int(count[0]/(fraction*maxnumpoints));
    step[1]=int(count[1]/((1.0-fraction)*maxnumpoints));
  }

  
  int actual[2]= { count[0]/step[0], count[1]/step[1]};
  
  int actualnumpoints=actual[0]+actual[1];
  if (debug) {
    std::cout << "___ Pref Sampling from " << numrows << "(" << count[0] << "," << count[1] << ") points to " << actualnumpoints;
    std::cout << "(" << actual[0] << "," << actual[1] << ") ( step= " << step[0] << "," << step[1] << ")" << std::endl;
  }
  

  outputPoints->zero(actualnumpoints,3);
  outputLabels->zero(actualnumpoints);
  float* outpts=outputPoints->getData();
  int* outlabels=outputLabels->getData();

  int out_index=0;

  int added[2] = { 0,0 };
  
  for (int pass=0;pass<=1;pass++) {
    int count=0;
    for (int i=0;i<numrows;i++) {
      int add=0;
      if ( count==0 && ( ( labels[i]==0 && pass==0 ) || (labels[i]>0 && pass==1)))
        add=1;
      
      if (add) {
        for (int ia=0;ia<=2;ia++)
          outpts[out_index*3+ia]=pts[i*3+ia];
        outlabels[out_index]=labels[i];
        out_index=out_index+1;
        added[pass]=added[pass]+1;
        if (added[pass] >=  actual[pass])
          i=numrows;
      }
      if ( (labels[i]==0 && pass==0) || (labels[i]>0 && pass==1)) {
        count=count+1;
        if (count==step[pass])
          count=0;
      }
    }
  }

  return actualnumpoints;
}
                 
// ----------------------------------------------------------------------------------------------------------------------------------------------------------
// Description:
// Specify the ref and target data sets.
int bisRPMCorrespondenceFinder::initialize(bisSimpleMatrix<float>* ref,
                                           bisSimpleMatrix<float>* target,
                                           int maxnumlandmarks,
                                           int samplingweight, // 1 = equal sampling, if  > 1 get extra points from points whose label > 0
                                           bisSimpleVector<int>* ref_labels,
                                           bisSimpleVector<int>* target_labels,
                                           int debug) {

  this->cleanup();
  int ok[2];
  
  std::shared_ptr<bisSimpleMatrix<float> > reft(new bisSimpleMatrix<float>());
  this->SampledReferencePoints=std::move(reft);

  std::shared_ptr<bisSimpleMatrix<float> > targt(new bisSimpleMatrix<float>());
  this->SampledTargetPoints=std::move(targt);
  
  this->SampledTargetLabels=new bisSimpleVector<int>();
  this->SampledReferenceLabels=new bisSimpleVector<int>();
  
  ok[0]=this->samplePoints(ref,ref_labels,maxnumlandmarks,samplingweight,this->SampledReferencePoints.get(),this->SampledReferenceLabels,debug);
  ok[1]=this->samplePoints(target,target_labels,int(maxnumlandmarks*1.5),samplingweight,this->SampledTargetPoints.get(),this->SampledTargetLabels,debug);

  if (ok[0] == 0 || ok[1] ==0) {
    std::cerr << "Failed to sample points " << std::endl;
    this->cleanup();
    return 0;
  }

  this->locator=new bisPointLocator();
  this->locator->initialize(this->SampledTargetPoints,0.1,0);
  return 1;
   
  
}
// ----------------------------------------------------------------------------------------------------------------------------------------------------------

int bisRPMCorrespondenceFinder::estimateCorrespondence(bisAbstractTransformation* Transformation,
                                                       float temperature,
                                                       int mode,
                                                       bisSimpleMatrix<float>* OutputRefLandmarks,
                                                       bisSimpleMatrix<float>* OutputTargetLandmarks,
                                                       bisSimpleVector<float>* OutputWeights,
                                                       int debug)
{
  int numref=this->SampledReferencePoints->getNumRows();
  int numtarget=this->SampledTargetPoints->getNumRows();
  if (OutputRefLandmarks->getNumRows()!=numref || OutputRefLandmarks->getNumCols()!=3) 
    OutputRefLandmarks->zero(numref,3);
  
  if (OutputTargetLandmarks->getNumRows()!=numref || OutputTargetLandmarks->getNumCols()!=3) 
    OutputTargetLandmarks->zero(numref,3);
  
  if (OutputWeights->getLength()!=numref)
    OutputWeights->zero(numref);
  
  float* reference_pts=this->SampledReferencePoints->getData();
  
  float* out_ref=OutputRefLandmarks->getData();
  float* out_target=OutputTargetLandmarks->getData();
  float* out_weights=OutputWeights->getData();
  
  if (mode==0) {
    return bisRPMCorrespondenceFinder::computeCorrespodnencesICP(Transformation,
                                                                 locator,
                                                                 reference_pts,
                                                                 out_ref,
                                                                 out_target,
                                                                 out_weights,
                                                                 numref,
                                                                 debug);
  }
  
  float* target_pts=this->SampledTargetPoints->getData();
  int* reference_labels=this->SampledReferenceLabels->getData();
  int* target_labels=this->SampledTargetLabels->getData();
  
  bisRPMCorrespondenceFinder::computeCorrespondencesRPM(Transformation,locator,
                                                        mode,
                                                        reference_pts,reference_labels,
                                                        target_pts,target_labels,
                                                        out_ref,out_target,out_weights,
                                                        temperature,numref,numtarget,debug);

  
  


  return 1;
}
// ----------------------------------------------------------------------------------------------------------------------------------------------------------

int bisRPMCorrespondenceFinder::computeCorrespodnencesICP(bisAbstractTransformation* Transformation,
                                                          bisPointLocator* locator,
                                                          float* reference_pts,
                                                          float* out_ref,
                                                          float* out_target,
                                                          float* out_weights,
                                                          int numref,
                                                          int debug) {

  if (debug)
    std::cout << "___ Computing ICP correspondences for " << numref << " points" << std::endl;

  int half=int(numref/2);
  
  for (int i=0;i<numref;i++) {
    float x[3],y[3],tx[3];
    for (int ia=0;ia<=2;ia++)
      x[ia]=reference_pts[i*3+ia];
    Transformation->transformPoint(x,tx);
    
    locator->getNearestPoint(tx,y,0);
    for (int ia=0;ia<=2;ia++) {
      out_ref[i*3+ia]=x[ia];
      out_target[i*3+ia]=y[ia];
      out_weights[i]=1.0;
    }

    if  ( (i==0 || i==half) && debug>0) {
        std::cout << "Point = " << i << " x=" << x[0] << "," << x[1] << " " << x[2] << " --> ";
        std::cout << "tx=" << tx[0] << "," << tx[1] << " " << tx[2] << " --> ";
        std::cout << "y=" << y[0] << "," << y[1] << " " << y[2] << std::endl;
    }
    
  }
  return 1;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------
// RPM
// ----------------------------------------------------------------------------------------------------------------------------------------------------------

int bisRPMCorrespondenceFinder::normalizeMatrixMixture(Eigen::SparseMatrix<float,Eigen::RowMajor> M) {

  // Compute Sums
  for (int k=0; k<M.outerSize(); ++k) {

    float sum=0.01;
    
    for (Eigen::SparseMatrix<float,Eigen::RowMajor>::InnerIterator it(M,k); it ; ++it)
      sum+=it.value();

    //if (k==468 || k==117)
    //std::cout << "Sum for row=" << k << "=" << sum << std::endl;
    
    for (Eigen::SparseMatrix<float,Eigen::RowMajor>::InnerIterator it(M,k); it ; ++it) 
      M.coeffRef(it.row(),it.col())=it.value()/sum;
  }

  return 1;
}

int bisRPMCorrespondenceFinder::normalizeMatrixRPM(Eigen::SparseMatrix<float,Eigen::RowMajor> M) {

  int numrefpts=M.rows();
  std::vector<float> outlier_ref(numrefpts);
  for (int i=0;i<numrefpts;i++) 
    outlier_ref[i]=0.01;

  int numtargetpts=M.cols();
  std::vector<float> outlier_targ(numtargetpts);
  for (int i=0;i<numtargetpts;i++)
    outlier_targ[i]=0.01;

  std::vector<float> sumcols(numtargetpts);
  for (int sinkolhm_iteration=0;sinkolhm_iteration<=4;sinkolhm_iteration++)
    {
      // Sum Rows
      // Compute Sums
      for (int k=0; k<M.outerSize(); ++k) {
        float sum=outlier_ref[k];
        
        for (Eigen::SparseMatrix<float,Eigen::RowMajor>::InnerIterator it(M,k); it ; ++it)
          sum+=it.value();

        for (Eigen::SparseMatrix<float,Eigen::RowMajor>::InnerIterator it(M,k); it; ++it)
          M.coeffRef(it.row(),it.col())=it.value()/sum;
        outlier_ref[k]/=sum;
      }

      // Sum Columns now (a little messier as this is the inner loop
      for (int column=0;column<numtargetpts;column++)
        sumcols[column]=outlier_targ[column];
      
      // Now Columns Sum
      for (int k=0; k<M.outerSize(); ++k) {
        for (Eigen::SparseMatrix<float,Eigen::RowMajor>::InnerIterator it(M,k); it ; ++it)  {
          sumcols[it.col()]+=it.value();
        }
      }
      
      for (int column=0;column<numtargetpts;column++)
        outlier_targ[column]/=sumcols[column];

      for (int k=0; k<M.outerSize(); ++k) {
        for (Eigen::SparseMatrix<float,Eigen::RowMajor>::InnerIterator it(M,k); it ; ++it) {
          M.coeffRef(it.row(),it.col())=it.value()/sumcols[it.col()];
        }
      }
    }
  return 1;
}
// ----------------------------------------------------------------------------------------------------------------------------------------------------------
int bisRPMCorrespondenceFinder::computeCorrespondencesRPM(bisAbstractTransformation* Transformation,bisPointLocator* locator,
                                                          int mode,
                                                          float* reference_pts,int* reference_labels,
                                                          float* target_pts,int* target_labels,
                                                          float* out_ref, float* out_target,float* out_weights,
                                                          float temperature,int numrefpts,int numtargetpts,int debug) {

  // Create extra columns and rows
  Eigen::SparseMatrix<float,Eigen::RowMajor> M(numrefpts,numtargetpts);
  Eigen::VectorXf outlier_ref=Eigen::VectorXf::Zero(numrefpts);
  Eigen::VectorXf sum_ref=Eigen::VectorXf::Zero(numrefpts);
  Eigen::VectorXf outlier_targ=Eigen::VectorXf::Zero(numtargetpts);
  Eigen::VectorXf sum_targ=Eigen::VectorXf::Zero(numtargetpts);

  // Initialize outliers
  for (int i=0;i<numrefpts;i++)
    outlier_ref(i)=0.01;
  for (int i=0;i<numtargetpts;i++)
    outlier_targ(i)=0.01;
  
  std::cout << "_____ Computing RPM Correspondences mode=" << mode << " Points=" << numrefpts << "*" << numtargetpts << " temperature=" << temperature << std::endl;
  float threshold=3*temperature;
  float T2=2.0*temperature*temperature;
  std::vector<int> pointlist;
  
  //std::cout << "___ nums=" << numrefpts << "*" << numtargetpts << " M=" <<  M.outerSize() << "*" << M.innerSize() << std::endl;
    
  for (int row=0;row<numrefpts;row++)
    {
      float x[3],tx[3];
      for (int ia=0;ia<=2;ia++) {
        x[ia]=reference_pts[row*3+ia];
        out_ref[row*3+ia]=x[ia];
      }

      Transformation->transformPoint(x,tx);
      int nump=locator->getPointsWithinRadius(tx,threshold,pointlist,0);
      if (nump<3) {
        pointlist.clear();
        locator->getPointsWithinRadius(tx,threshold*2.0,pointlist,0);
      }

      float sum=0.0;

      //if (row==468 || row==117)  {
      //        std::cout << "___ row=" << row << " nump=" << nump << std::endl;
      //      }
      
      for (int i=0;i<nump;i++) {
        int col=pointlist[i];
        if (reference_labels[row] == target_labels[col]) {
          float y[3];
          for (int ia=0;ia<=2;ia++) 
            y[ia]=target_pts[col*3+ia];

          float dist2=bisPointRegistrationUtils::distance2(tx,y);
          float d=exp(-dist2/T2);
          sum+=d;
          M.coeffRef(row,col)=d;
          /*if (row==468 || row==117)  {
            std::cout << "row=" << row << "," << col << " (nump=" << nump << ")=" << d << "(dist2=" << dist2 << "," << T2 << ") sum=" << sum << " x=" << x[0] << "," << x[1] << "," << x[2];
            std::cout << " -> tx=" << tx[0] << "," << tx[1] << "," << tx[2];
            std::cout << " -> y=" << y[0] << "," << y[1] << "," << y[2] << std::endl;
            }*/
          
        }
      }

      // If total sum is too low < 0.001, then stablize using closest point and set its weight to 0.001
      if (sum<0.1) {
        float y[3];
        int nearest=locator->getNearestPoint(tx,y,0);
        M.coeffRef(row,nearest)=0.001;
        sum=0.001;
        /*if (row==468 || row==117)  {
          std::cout << "SMALL SUM row=" << row << "," << nearest << " sum=" << sum << " x=" << x[0] << "," << x[1] << "," << x[2];
          std::cout << " -> tx=" << tx[0] << "," << tx[1] << "," << tx[2];
          std::cout << " -> y=" << y[0] << "," << y[1] << "," << y[2] << std::endl;
          }*/
      }
    }

  if (mode==1)  {
    if (debug)
      std::cout << "__ Normalizing Matrix as Mixture" << std::endl;
    bisRPMCorrespondenceFinder::normalizeMatrixMixture(M);
  } else {
    std::cout << "__ Normalizing Matrix as Full RPM" << std::endl;
    bisRPMCorrespondenceFinder::normalizeMatrixRPM(M);
  }
  
  for (int i=0;i<numrefpts;i++) {
    out_weights[i]=0.0;
    out_target[i*3]=0.0;
    out_target[i*3+1]=0.0;
    out_target[i*3+2]=0.0;
  }
    
  for (int k=0; k<M.outerSize(); ++k) {
    for (Eigen::SparseMatrix<float,Eigen::RowMajor>::InnerIterator it(M,k); it; ++it) {
      float v=it.value();
      int row=it.row();   // row index
      int col=it.col();   // col index (here it is equal to k)
      out_weights[row]+=v;
      for (int ia=0;ia<=2;ia++) 
        out_target[row*3+ia]+=v*target_pts[col*3+ia];
    }
  }

  /*if (debug) {
    int row=117;
    std::cout << "weighted_out_target=  for row=" << row << "= " 
              <<  out_target[row*3] << "," 
              <<  out_target[row*3+1] << "," 
              <<  out_target[row*3+2] 
              <<  " wgt=" << out_weights[row] << std::endl;
    row=468;
    std::cout << "weighted_out_target=  for row=" << row << "= " 
              <<  out_target[row*3] << "," 
              <<  out_target[row*3+1] << "," 
              <<  out_target[row*3+2] 
              <<  " wgt=" << out_weights[row] << std::endl;
              }*/
      
  for (int i=0;i<numrefpts;i++) {
    for (int ia=0;ia<=2;ia++)  {
      out_target[i*3+ia]/=out_weights[i];
    }
  }

  /*if (debug) {
    int row=117;
    std::cout << "out_target=  for row=" << row << "= "
              <<  out_target[row*3] << "," 
              <<  out_target[row*3+1] << "," 
              <<  out_target[row*3+2] 
              <<  " wgt=" << out_weights[row] << std::endl;
    row=468;
    std::cout << "out_target=  for row=" << row << "= "
              <<  out_target[row*3] << "," 
              <<  out_target[row*3+1] << "," 
              <<  out_target[row*3+2] 
              <<  " wgt=" << out_weights[row] << std::endl;
              }*/

  
  return 1;
}

                 
