
module OOL
  module Conmin
    class Pgrad_parameters < Array
      attr_accessor :fmin, :tol, :alpha, :sigma1, :sigma2
    end
    class Spg_parameters < Array
      attr_accessor :fmin, :tol, :M, :alphamin, :alphamax, :gamma
      attr_accessor :sigma1, :sigma2
    end
    class Gencan_parameters < Array
      attr_accessor :epsgpen, :epsgpsn, :fmin, :udelta0
      attr_accessor :ucgmia, :ucgmib
      attr_accessor :cg_scre, :cg_gpnf, :cg_epsi, :cg_epsf
      attr_accessor :cg_epsnqmp, :cg_maxitnqmp, :nearlyq
      attr_accessor :nint, :next, :mininterp, :maxextrap
      attr_accessor :trtype, :eta, :deltamin, :lspgmi, :lspgma
      attr_accessor :theta, :gamma, :beta, :sigma1, :sigma2
      attr_accessor :epsrel, :epsabs, :infrel, :infabs
    end    
  end
end
begin
  require 'narray' if ENV['NARRAY']
rescue LoadError
end

begin
  require 'nmatrix/nmatrix' if ENV['NMATRIX']
rescue LoadError
end

require 'gsl_native'
require 'gsl/version'
require 'gsl/oper'
require 'gsl/interp2d_fix' if GSL::GSL_VERSION >= '2.0'require 'gsl'

module OOL
  module Conmin
    class Minimizer
      class Pgrad
        class Parameters
          attr_accessor :fmin, :tol, :alpha, :sigma1, :sigma2
        end
      end
      class Spg
        class Parameters
          attr_accessor :fmin, :tol, :M, :alphamin, :alphamax, :gamma
          attr_accessor :sigma1, :sigma2
        end
      end
      class Gencan
        class Parameters
          attr_accessor :epsgpen, :epsgpsn, :fmin, :udelta0
          attr_accessor :ucgmia, :ucgmib
          attr_accessor :cg_scre, :cg_gpnf, :cg_epsi, :cg_epsf
          attr_accessor :cg_epsnqmp, :cg_maxitnqmp, :nearlyq
          attr_accessor :nint, :next, :mininterp, :maxextrap
          attr_accessor :trtype, :eta, :deltamin, :lspgmi, :lspgma
          attr_accessor :theta, :gamma, :beta, :sigma1, :sigma2
          attr_accessor :epsrel, :epsabs, :infrel, :infabs
        end    
      end
    end
  end
end
module GSL::Oper

  def self.included(base)
    base.class_eval {
      alias_method :_gsl_oper_original_mul, :*
      alias_method :_gsl_oper_original_div, :/

      def *(other)
        case other
          when Numeric
            _gsl_oper_original_mul(other)
          when GSL::Matrix,          GSL::Vector,
               GSL::Matrix::Int,     GSL::Vector::Int,
               GSL::Vector::Complex, GSL::Matrix::Complex,
               *GSL.have_tensor? ? [GSL::Tensor, GSL::Tensor::Int] : []
            other.scale(self)
          else
            _gsl_oper_original_mul(other)
        end
      end

      def /(other)
        case other
          when Numeric
            _gsl_oper_original_div(other)
          when GSL::Poly, GSL::Poly::Int
            a = GSL::Poly[1]; a[0] = self
            GSL::Rational.new(a, other)
          when GSL::Vector::Col
            other.scale(self / GSL.pow_2(other.dnrm2))
          when GSL::Vector::Int::Col
            v = other.to_f
            v.scale(self / GSL.pow_2(v.dnrm2))
          else
            _gsl_oper_original_div(other)
        end
      end
    }
  end

end

[RUBY_VERSION > "2.4" ? Integer : Fixnum, Float].each { |klass| klass.send(:include, GSL::Oper) }
# Reasons for existence of this code:
#
# It so happens that GSL's 2D interpolation methods are somehow swapping X and
# Y co-ordinates and returning a wrong result. This is a bug in GSL, and in order
# to make up for that, we swap the x and y points before passing them to GSL.
# The detect_gsl_interp2d_swapping_bug method tests the inter2d eval function
# to see if the bug exists so that in case a future GSL update fixes the bug,
# this Ruby wrapper will remain unaffected.
#
# For testing whether the bug exists, the eval method is run and tested against
# what is known to be corrent output (ans_expected), and the @@swapped class
# variable is set to true if the result is not consistent with the expected
# output. If @swapped is true, the x and y values are internally swapped by
# the Ruby wrapper before passing them to GSL for processing.
module GSL
  class Interp2d
    module BugDetectHelper
      class << self
        def asymmetric_function(x, y)
          x - 2*y
        end
      end
    end

    def self.detect_gsl_interp2d_swapping_bug
      @@swapped = nil
      x = GSL::Vector.alloc((-4..4).to_a)
      y = GSL::Vector.alloc((-4..4).to_a)

      z = []
      x.each do |xi|
        y.each do |yi|
          z << BugDetectHelper.asymmetric_function(xi, yi)
        end
      end
      z = GSL::Vector.alloc(z)
      i2d = GSL::Interp2d.alloc(GSL::Interp2d::BICUBIC, x, y, z)

      test_x = x[1]
      test_y = y[1]

      ans_normal = i2d.eval(x,y,z,test_x, test_y)
      ans_swapped = i2d.eval(x,y,z,test_y, test_x)
      ans_expected = BugDetectHelper.asymmetric_function(test_x, test_y)
      @@swapped = ans_expected == ans_normal

      @@swapped
    end

    def self.swapped
      @@swapped
    end
  end

  class Spline2d
    @@swapped = GSL::Interp2d.detect_gsl_interp2d_swapping_bug

    def self.swapped
      @@swapped
    end
  end
end

GSL::Interp2d.detect_gsl_interp2d_swapping_bugrequire 'gnuplot'

class Array
  def to_gplot
    if ( self[0].kind_of? Array ) then
      tmp = self[0].zip( *self[1..-1] )
      tmp.collect { |a| a.join(" ") }.join("\n") + "\ne"
    elsif ( self[0].kind_of? Numeric ) then
      s = ""
      self.length.times { |i| s << "#{self[i]}\n" }
      s
    elsif ( self[0].kind_of? GSL::Vector ) then
      tmp = self[0].zip( *self[1..-1] )
      tmp.collect { |a| a.join(" ") }.join("\n") + "\ne"
    else
      self[0].zip( *self[1..-1] ).to_gplot
    end
  end
  def to_gsplot
    f = ""

    if ( self[0].kind_of? Array ) then
      x = self[0]
      y = self[1]
      d = self[2]

      x.each_with_index do |xv, i|
        y.each_with_index do |yv, j|
          f << [ xv, yv, d[i][j] ].join(" ") << "\n"
        end
        # f << "\n"
      end
    elsif ( self[0].kind_of? Numeric ) then
      self.length.times do |i| f << "#{self[i]}\n" end
    else
      self[0].zip( *self[1..-1] ).to_gsplot
    end

    f
  end
end
module GSL
  RUBY_GSL_VERSION = RB_GSL_VERSION = '2.1.0.3'
end
#!/usr/bin/env ruby
require("gsl")
include Math

N = 20
Zeta2 = PI*PI/6.0

v = GSL::Vector.alloc(N)
sum = 0.0
for n in 0...N do
  np1 = n.to_f + 1.0
  v[n] = 1.0/(np1 * np1)
  sum += v[n]
end

#sum_accel, err, sum_plain, terms_used = v.accel_sum
#sum_accel, err, sum_plain, terms_used = v.sum_accel
sum_accel, err, sum_plain, terms_used = v.accel

printf("term-by-term sum = %.16f using %d terms\n", sum, N)
printf("term-by-term sum = %.16f using %d terms\n", sum_plain, terms_used)
printf("exact value      = %.16f\n", Zeta2)
printf("accelerated sum  = %.16f using %d terms\n", sum_accel, terms_used)
printf("Estimated error  = %.16f\n", err)
printf("Actual error     = %.16f\n", sum_accel - Zeta2)

p GSL::Sum::Levin_u.accel(v)
p GSL::Sum::Levin_utrunc.accel(v)

lu = GSL::Sum::Levin_u.alloc(N)
p lu.accel(v)

lutrunc = GSL::Sum::Levin_utrunc.alloc(N)
p lutrunc.accel(v)
#!/usr/bin/env ruby
require("gsl")
include GSL
include GSL::Siman

N_TRIES = 200
ITERS_FIXED_T = 10
STEP_SIZE = 10
K = 1.0
T_INITIAL = 0.002
MU_T = 1.005
T_MIN = 2.0e-6

params = Siman::Params.alloc(N_TRIES, ITERS_FIXED_T, STEP_SIZE, K, T_INITIAL,
                           MU_T, T_MIN)

efunc = Efunc.alloc { |vx|
  x = vx[0]
  s = (x - 1.0)
  Math::exp(-s*s)*Math::sin(8*x)
}

metric = Metric.alloc { |vx, vy|
  (x[0] - y[0]).abs
}

step = Step.alloc { |rng, vx, step_size|
  r = rng.uniform
  old_x = vx[0]
  a =  r * 2 * step_size - step_size + old_x
  vx[0] = a
}

simanprint = Print.alloc { |vx|
  printf("%12g", vx[0])
}

x = GSL::Vector.alloc([15.5])
GSL::Rng.env_setup()
r = GSL::Rng.alloc()

Siman::solve(r, x, efunc, step, metric, simanprint, params)
#Siman::solve(r, x, efunc, step, metric, nil, params)
p x
#!/usr/bin/env ruby
require("gsl")

f = GSL::Function.alloc { |x|
  if x < 0.5
    0.25
  else
    0.75
  end
}

n = 1000
order = 40
cs = GSL::Cheb.alloc(order)

x = GSL::Vector.linspace(0, 1, n)
ff = f.eval(x)
cs.init(f, 0, 1)
r10 = cs.eval_n(10, x)
r40 = cs.eval(x)
GSL::graph(x, ff, r10, r40)
#!/usr/bin/env ruby
require("gsl")
include Math

# Function to be expanded
G = GSL::Function.alloc { |x| exp(-x*x) }
#G = Function.alloc { |x| sin(-x*x) }

# Sampling points
XMIN = 0.0
XMAX = 3.0
SIZE = 20

x = GSL::Vector.linspace(XMIN, XMAX, SIZE)
sample = G.eval(x)

# Discrete Hankel transform with the Bessel function J0
dht = GSL::Dht.alloc(SIZE, 0, XMAX)
g = dht.apply(sample)

num = dht.num
den = dht.den
coef = dht.coef

# Reconstruction
y = GSL::Vector[SIZE]
for n in 0...SIZE do
  val = 0.0
  for m in 0...SIZE do
    a = GSL::Sf::bessel_J0(dht.sample(n, m))
    val += (2.0/XMAX/XMAX)*a/den[m]*g[m]
#    val += (2.0/XMAX/XMAX)*num[n][m]/den[m]*g[m]
#    val += coef[n][m]*g[m]
  end
  y[n] = val
end

x0 = GSL::Vector.linspace(XMIN, XMAX, 100)
y0 = G.eval(x0)

GSL::graph([x0, y0], [x, sample], [x, y], "-T X -C -g 3 -X t -Y 'f(t)' --toggle-rotate-y-label -L 'Red: f(t), Green: sample, Blue: DHT of size #{SIZE}'")

#!/usr/bin/env ruby
require("gsl")
include GSL::Dirac

I = GSL::Complex[0, 1]

p Pauli1
p Pauli2
p Pauli3

p (Pauli1*Pauli2 - Pauli2*Pauli1)/I/2

p Dirac.anticommute(Pauli1, Pauli1)
p Dirac.anticommute(Pauli1, Pauli2)

#p Eye2
#p Eye4

p Beta

p Alpha1
p Alpha2
p Alpha3

p Alpha1*Alpha1
p Alpha2*Alpha2
p Alpha3*Alpha3

p GSL::Dirac.anticommute(Alpha1, Alpha1)
p GSL::Dirac.anticommute(Alpha1, Alpha2)

p GSL::Dirac.anticommute(Gamma0, Gamma0)
p GSL::Dirac.anticommute(Gamma1, Gamma1)
p GSL::Dirac.anticommute(Gamma2, Gamma2)
p GSL::Dirac.anticommute(Gamma3, Gamma3)
p GSL::Dirac.anticommute(Gamma3, Gamma0)

p IEye4*Gamma0*Gamma1*Gamma2*Gamma3

p Pauli2
p Pauli2.conjugate
p Pauli2
p Pauli3
p Pauli3.dagger

p Lambda1
p Lambda2
p Lambda3
p Lambda4
p Lambda5
p Lambda6
p Lambda7
p Lambda8



#!/usr/bin/env ruby
require("gsl")

c = 0
printf("All subsets of {0,1,2,3} by size:\n") ;
for i in 0...4 do
  c = GSL::Combination.calloc(4, i);
  begin
    printf("{");
    c.fprintf(STDOUT, " %u");
    printf(" }\n");
  end while c.next == GSL::SUCCESS
end

p c
c2 = c.clone
p c2

a = c.data
p a.class
p a
p a.print

#!/usr/bin/env ruby
require("gsl")
fn1 = GSL::Function.alloc { |x| Math::cos(x) + 1.0 }
iter = 0;  max_iter = 500
m = 2.0             # initial guess
m_expected = Math::PI
a = 0.0; b = 6.0
gmf = GSL::Min::FMinimizer.alloc(GSL::Min::FMinimizer::BRENT)
gmf.set(fn1, m, a, b)
printf("Using %s method\n", gmf.name)
printf("%5s [%9s, %9s] %9s %10s %9s\n", "iter", "lower", "upper", "min",
       "err", "err(est)")
printf("%5d [%.7f, %.7f] %.7f %+.7f %.7f\n",
       iter, a, b, m, m - m_expected, b - a)
begin
  iter += 1
  status = gmf.iterate
  status = gmf.test_interval(0.001, 0.0)
  puts("Converged:") if status == GSL::SUCCESS
  a = gmf.x_lower;  b = gmf.x_upper
  m = gmf.x_minimum
  printf("%5d [%.7f, %.7f] %.7f %+.7f %.7f\n",
         iter, a, b, m, m - m_expected, b - a);
end while status == GSL::CONTINUE and iter < max_iter

x = GSL::Vector.linspace(0, 6, 50)
mx = gmf.x_minimum
min = fn1.eval(mx)
GSL::graph([x, fn1.eval(x)], [GSL::Vector[mx], GSL::Vector[min]], "-C -g 3 -S 4 -m -1")
#!/usr/bin/env ruby
require("gsl")

data = GSL::Vector[88.60,73.20,91.40,68.00,75.20,63.00,53.90,69.20,
50.10,71.50,44.90,59.50,40.20,56.30,38.70,31.00,
39.60,45.30,25.20,22.70]
factor = GSL::Vector::Int[1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4]

table = GSL::TAMU_ANOVA::Table.oneway(data, factor, 4)
table.print

data = GSL::Vector[45.50,45.30,45.40,44.40,44.60,43.90,44.60,44.00,44.20,
43.90,44.70,44.20,44.00,43.80,44.60,43.10,46.00,45.90,
44.80,46.20,45.10,45.50]
factor = GSL::Vector::Int[1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3]

table = GSL::TAMU_ANOVA::Table.oneway(data, factor, 3)
table.print
#!/usr/bin/env ruby
require("gsl")

# Abramovitz & Stegun
fc01 = 0.0999975
fs01 = 0.0005236

printf("fresnel_c(0.1):\n")
printf("Expect: %2.7f \t Calculated: %2.7f \n ", fc01, GSL::fresnel_c(0.1))
printf("fresnel_s(0.1):\n")
printf("Expect: %2.7f \t Calculated: %2.7f \n ", fs01, GSL::fresnel_s(0.1))
#!/usr/bin/env ruby
require("gsl")

x = 2.0

P = GSL::Cdf::ugaussian_P(x);
printf("prob(x < %f) = %f\n", x, P);

Q = GSL::Cdf::ugaussian_Q(x);
printf("prob(x > %f) = %f\n", x, Q);

x = GSL::Cdf::ugaussian_Pinv(P);
printf("Pinv(%f) = %f\n", P, x);

x = GSL::Cdf::ugaussian_Qinv(Q);
printf("Qinv(%f) = %f\n", Q, x);
#!/usr/bin/env ruby
require("gsl")

N = 200
NCOEFFS = 8
NBREAK = NCOEFFS - 2

GSL::Rng::env_setup()
r = GSL::Rng.alloc()

bw = GSL::BSpline.alloc(4, NBREAK)
B = GSL::Vector.alloc(NCOEFFS)
x = GSL::Vector.alloc(N)
y = GSL::Vector.alloc(N)
xx = GSL::Matrix.alloc(N, NCOEFFS)
w = GSL::Vector.alloc(N)

#printf("#m=0,S=0\n")
for i in 0...N do
  xi = (15.0/(N-1)/1)*i
  yi = Math::cos(xi)*Math::exp(-0.1*xi)

  sigma = 0.1
  dy = GSL::Ran.gaussian(r, sigma)
  yi += dy

  x[i] = xi
  y[i] = yi
  w[i] = sigma

#  printf("%f %f\n", xi, yi)
end

bw.knots_uniform(0.0, 15.0)

for i in 0...N do
  xi = x[i]
  bw.eval(xi, B)
  for j in 0...NCOEFFS do
    xx[i,j] = B[j]
  end
end

c, cov, chisq = GSL::MultiFit.wlinear(xx, w, y)

#printf("#m=0,S=0\n")

x2 = GSL::Vector.linspace(0, 15, 150)
y2 = GSL::Vector.alloc(150)
x2.each_index do |i|
  bw.eval(x2[i], B)
  yi, yerr = GSL::MultiFit::linear_est(B, c, cov)
  y2[i] = yi
#  printf("%f %f\n", xi, yi)
end

GSL::graph([x, y], [x2, y2], "-T X -C -X x -Y y -x 0 15 -y -1 1.3")
#!/usr/bin/env ruby
require("gsl")

m = NMatrix[[1.0, 1/2.0, 1/3.0, 1/4.0], [1/2.0, 1/3.0, 1/4.0, 1/5.0],
            [1/3.0, 1/4.0, 1/5.0, 1/6.0], [1/4.0, 1/5.0, 1/6.0, 1/7.0]]

p GSL::Eigen.symm(m)
p GSL::Eigen.symmv(m)

#!/usr/bin/env ruby
require("gsl")

m = GSL::Matrix[[1.0, 1/2.0, 1/3.0, 1/4.0], [1/2.0, 1/3.0, 1/4.0, 1/5.0],
           [1/3.0, 1/4.0, 1/5.0, 1/6.0], [1/4.0, 1/5.0, 1/6.0, 1/7.0]]

eigval = m.eigen_symm
p eigval

eigval, eigvec = m.eigen_symmv

p eigval == GSL::Eigen.symm(m)
val, vec = GSL::Eigen.symmv(m)
p vec

i = 0
vec.each_col do |v|
  a = (m*v)/v
  if a != val[i]
    puts("error")
  end
  i += 1
end

# Diagonalization
b = eigvec.inv*m*eigvec
b.clean!(1e-10)
p b
d = b.diagonal
p d == eigval

prod = eigval.prod
p GSL.equal?(prod, m.det, 1e-10)

#!/usr/bin/env ruby
#  Harmonic oscillator in quantum mechanics
#
#  This example is taken from "eigen1.cpp"
#  in "Numerische Physik" p214-216 (Springer).
#
#  Reference:
#    "Numerische Physik", by Harald Wiedemann, Springer (2004)
#    ISBN: 3-540-40774-X
#    http://www.springeronline.com/sgw/cda/frontpage/0,10735,1-102-22-22345455-0,00.html
require("gsl")

STDERR.puts("Harmonic oscillator in quantum mechanics:")

# Values used in the book:
#NMAX = 512
#dx = 0.02

# These are much faster:
NMAX = 64
dx = 0.16

# Potential
V = GSL::Vector[NMAX]
for n in 0...NMAX do
  x = (n - NMAX/2)*dx
  V[n] = 0.5*x*x
end

# Hamiltonian
H = GSL::Matrix.calloc(NMAX, NMAX)
H.set_diagonal(1.0/dx/dx + V)
tmp = -0.5/dx/dx
for n1 in 1...NMAX do
  H[n1-1,n1] = tmp
  H[n1,n1-1] = tmp
end
for n1 in 0...(NMAX-1) do
  H[n1+1,n1] = tmp
  H[n1,n1+1] = tmp
end

# Calculate eigen values and eigen vectors
STDERR.print("  Solving the eigen system of #{NMAX}X#{NMAX} dimensions...")
STDERR.flush
eval, evec = H.eigen_symmv
GSL::Eigen.symmv_sort(eval, evec, GSL::Eigen::SORT_VAL_ASC)
STDERR.puts("OK")
STDERR.flush

x2 = GSL::Vector[NMAX]
for n1 in 0...NMAX do
  x2[n1] = 0
  for n2 in 0...NMAX do
    x = (n2 - NMAX/2)*dx
    x2[n1] += GSL::pow_2(evec[n2,n1]*x)
  end
end

# Energy eigen values, see p217 "Tabelle 5.1"
# The differences with Tabelle 5.1 are from NMAX and dx.
# If we use NMAX=512 and dx=0.02, we obtain the same results (but much slower).
STDERR.puts("  Eigen values:")
STDERR.printf("  %2s Exact %5s %10s | %2s Exact %5s %10s\n",
              "n", "E", "err\(\%\)", "n", "E", "err\(\%\)")
STDERR.print("  -----------------------------------------------------\n")
for n1 in 0..6 do
  exact1 = n1 + 0.5
  exact2 = n1 + 7 + 0.5
  STDERR.printf("  %2d %4.1f %8.5f %+7.5f | %2d %4.1f %8.5f %+7.5f\n",
                n1, exact1, eval[n1], (exact1 - eval[n1])/exact1*100,
                n1+7, exact2, eval[n1+7], (exact2-eval[n1+7])/exact2*100)
end
STDERR.flush

# Eigen vectors of n = 0, 1, 2, 10. See p217 "Abb 5.3"
c = Math::sqrt(1.0/dx)
vec0 = evec.col(0).scale(c)
vec1 = evec.col(1).scale(c)
vec2 = evec.col(2).scale(c)
vec10 = evec.col(10).scale(c)
File.open("qhoscillator.dat", "w") do |fp|
  for i in 0...NMAX do
    x = (i - NMAX/2)*dx
    fp.printf("%e %e %e %e %e\n", x, -vec0[i], vec1[i], -vec2[i], -vec10[i])
  end
end
system("gnuplot -persist qhoscillator.gp")
File.delete("qhoscillator.dat")

#!/usr/bin/env ruby
require("gsl")

include GSL::Eigen

m = GSL::Matrix::Complex.alloc(2, 2)
m.set(0, 1, [0, -1])
m.set(1, 0, [0, 1])
p m

val, vec = m.eigen_hermv
p val
p vec.unpack

m2 = GSL::Matrix.alloc([1, 0, 0], [0, 0, 1], [0, 1, 0])
val, vec = m2.eigen_symmv
p val
p vec.unpack




#!/usr/bin/env ruby
require("gsl")

m = GSL::Matrix[[1, 2], [3, 4]]

w = GSL::Eigen::Nonsymm::Workspace.alloc(2)
v = GSL::Vector::Complex.alloc(2)

#w.params(0, 1)

#p GSL::Eigen.nonsymm(m)
#p GSL::Eigen.nonsymm(m, v, w)

p m.eigen_nonsymm
#p m.eigen_nonsymm(v, w)

#p m.eigen_nonsymm_Z
#p m


=begin
Octave result:

octave:1> m = [1 2; 3 4]
m =

  1  2
  3  4

octave:2> eig(m)
ans =

  -0.37228
   5.37228


=end
#!/usr/bin/env ruby
require("gsl")

m = GSL::Matrix[[1, 2, 3], [4, 5, 0], [6, 0, 0]]
evec, eval = m.eigen_nonsymmv
p evec
p eval

m = GSL::Matrix.vandermonde([-1, -2, 3, 4])
w = GSL::Eigen::Nonsymmv.alloc(4)
eval, evec = GSL::Eigen::nonsymmv(m, w)
p eval
p evec

=begin
This can be compared with the corresponding output from GNU OCTAVE,

  octave> [v,d] = eig(vander([-1 -2 3 4]));
octave> diag(d)
ans =

  -6.4139 + 0.0000i
   5.5456 + 3.0854i
   5.5456 - 3.0854i
   2.3228 + 0.0000i

octave> v
v =

 Columns 1 through 3:

  -0.09988 + 0.00000i  -0.04350 - 0.00755i  -0.04350 + 0.00755i
  -0.11125 + 0.00000i   0.06399 - 0.14224i   0.06399 + 0.14224i
   0.29250 + 0.00000i  -0.51518 + 0.04142i  -0.51518 - 0.04142i
   0.94451 + 0.00000i  -0.84059 + 0.00000i  -0.84059 - 0.00000i

 Column 4:

  -0.14493 + 0.00000i
   0.35660 + 0.00000i
   0.91937 + 0.00000i
   0.08118 + 0.00000i
=end
#!/usr/bin/env ruby
require("gsl")

m = GSL::Matrix.vandermonde([1, 2, 3, 4])
p m
eval, evec = m.eigen_nonsymmv

p eval.real
p evec.real

GSL::Eigen::nonsymmv_sort(eval, evec, GSL::Eigen::SORT_ABS_ASC)
p eval.real
p evec.real


=begin
Octave result:

octave:1> m = vander([1 2 3 4])
m =

   1   1   1   1
   8   4   2   1
  27   9   3   1
  64  16   4   1

octave:2> [v, d] = eig(m)
v =

   0.106363   0.137820  -0.129196   0.052254
   0.228569   0.036136   0.407586  -0.375568
   0.462688  -0.289537   0.376326   0.794157
   0.849919  -0.946503  -0.821925  -0.474902

d =

   15.48974    0.00000    0.00000    0.00000
    0.00000   -7.70629    0.00000    0.00000
    0.00000    0.00000    1.29422    0.00000
    0.00000    0.00000    0.00000   -0.07768
=end
#!/usr/bin/env ruby
# Calculate the redshift-distance relation
# for Friedmann universe
require("./cosmology")
include Cosmology

# Matter = 1, Lambda = 0, Radiation = 0
u10 = Universe.new(1.0, 0.0, 0.0)

# Matter = 0.27, Lambda = 0.73, Radiation = 0
u37 = Universe.new(0.27, 0.73, 0.0)

# Matter = 0.0, Lambda = 1.0, Radiation = 0
u01 = Universe.new(0.0, 1.0, 0.0)

begin
  file = File.open("friedmann.dat", "w")
  z = 0.01
  while z <= 3
    # comoving distance, luminosity distance
    chi10, ldist10 = u10.luminosity_distance(z)
    chi37, ldist37 = u37.luminosity_distance(z)
    chi01, ldist01 = u01.luminosity_distance(z)
    file.printf("%e %e %e %e %e %e %e\n",
                z, chi10, ldist10, chi37, ldist37, chi01, ldist01)
    z += 0.1
  end
ensure
  file.close
end

#puts("Data file \"friedmann.dat\" created.")
#puts("Try \"gnuplot -persist friedmann.gp\"")
system("gnuplot -persist friedmann.gp")
File.delete("friedmann.dat")
#!/usr/bin/env ruby
require 'gsl'
include GSL
include Math

f458 = Function.alloc { |x|
  if x.zero?
    val = 0.0
  else
    u = log(x)
    v = 1.0 + u*u
    val = 1.0/(v*v)
  end
  val
}

exp_result = -1.892751853489401670E-01
exp_abserr =  1.129133712015747658E-08

table = [0.0, 0.0, 1, 0]
result = f458.qaws([0.0, 1.0], table, [0.0, 1e-7])
p result
puts("exp_result: #{exp_result}")
puts("exp_abserr: #{exp_abserr}")

table = Integration::QAWS_Table.alloc(0.0, 0.0, 1, 0)
result = f458.qaws([0.0, 1.0], table, [0.0, 1e-7])
p result

p Integration.qaws(f458, [0.0, 1.0], table)
#!/usr/bin/env ruby
require 'gsl'
include GSL
include Math

f459 = Function.alloc { |x|
  1.0/(5.0*x*x*x + 6.0)
}

exp_result = -8.994400695837000137E-02
exp_abserr = 1.185290176227023727E-06

result = f459.qawc([-1.0, 5.0], 0, [0.0, 1e-3])
p result
puts("exp_result: #{exp_result}")
puts("exp_abserr: #{exp_abserr}")

p Integration.qawc(f459, [-1.0, 5.0], 0)
#!/usr/bin/env ruby
require("gsl")
include Math

f = GSL::Function.alloc { |x| x*sin(1.0/x)*sqrt((1 - x).abs) }
w = GSL::Integration::Workspace.alloc(1000)

p f.qag(0, 3, w)
#!/usr/bin/env ruby
require("gsl")
include GSL
include Math

f = Function.alloc { |x| Math::sin(x)/x }

p f.qng(0, 2.0*Math::PI)

# Singular at x = 0
f2 = Function.alloc { |x| exp(-x)/sqrt(x) }

# This will fail...
#p f2.qng(0, 1)

p Integration.qng(f, [0, 2*Math::PI])

#!/usr/bin/env ruby
require("gsl")
include GSL
include Math

printf("QAGIU (integrate [0:+infty])\n\n")

w = Integration::Workspace.alloc(1000)
xmin = 0.0

f1 = Function.alloc{ |x, a|
  1.0/(pow_4(x) + pow_4(a))
}

printf("Case 1: f(x; a) = 1/(x^4 + a^4), I(a) = pi/2sqrt2/a^3\n")
a = 1.0
printf("        Expected: I(1) = %10.9f\n", M_PI/2/M_SQRT2)
f1.set_params(a)
printf("        QAGIU Result:    %10.9f\n\n", f1.qagiu(xmin, w)[0])

f2 = Function.alloc{ |x, a|
  x*x/(pow_4(x) + pow_4(a))
}

printf("Case 2: f(x; a) = 1/(x^4 + a^4), I(a) = pi/2sqrt2/a\n")
a = 2.0
printf("        Expected: I(2) = %10.9f\n", M_PI/2/M_SQRT2/a)
f2.set_params(a)
printf("        QAGIU Result:    %10.9f\n\n", f2.qagiu(xmin, w)[0])
#!/usr/bin/env ruby
require("gsl")
include Math

proc = Proc.new{ |x, alpha|
  log(alpha*x)/sqrt(x)
}

f = GSL::Function.alloc(proc)
f.set_params(1.0)

expected = -4.0

#result, error, neval = f.integration_qags([0.0, 1.0], 0.0, 1.0e-7, 1000)
#result, error, neval = f.integration_qags([0.0, 1.0])
result, error, neval = f.qags([0.0, 1.0])

printf("result          = %.18f\n", result);
printf("exact result    = %.18f\n", expected);
printf("estimated error = %.18f\n", error);
printf("actual error    = %.18f\n", result - expected);
printf("intervals =  %d\n", neval);
#!/usr/bin/env ruby
require 'gsl'
include GSL
include Math

f454 = Function.alloc{ |x|
  x2 = x*x
  x3 = x2*x
  x3*log(((x2-1)*(x2-2)).abs)
}
exp_result = 5.274080611672716401E+01
exp_abserr = 1.755703848687062418E-04
pts = [0, 1, sqrt(2), 3]
result = f454.qagp(pts, 0.0, 1e-3)
p result

puts("exp_result: #{exp_result}")
puts("exp_abserr: #{exp_abserr}")

p Integration.qagp(f454, pts, [0.0, 1e-3])
#!/usr/bin/env ruby
require("gsl")

# Singular at x = 0

f = GSL::Function.alloc { |x| 1.0/Math::sqrt(x) }

puts("QAG")
p f.qag(0, 1)
p f.qag([0, 1])

p GSL::Integration.qag(f, 0, 1)
p GSL::Integration.qag(f, [0, 1])

#!/usr/bin/env ruby
require("gsl")
include GSL
include Math

w = Integration::Workspace.alloc(1000)
xmin = 0.0

f = Function.alloc{ |x, n|
  pow(x, n-1)/(exp(x) - 1.0)
}

nv = Vector[2..5]
y1 = Sf::gamma(nv)*Sf::zeta(nv)

y2 = Vector[10]
begin
  file1 = File.open("y1.dat", "w")
  file2 = File.open("y2.dat", "w")
  nv.each do |n|
    f.set_params(n)
    y2[n.to_i-2] = f.qagiu(xmin, w)[0]
    file1.printf("%e %e\n", n, y1[n.to_i-2])
    file2.printf("%e %e\n", n, y2[n.to_i-2])
  end
ensure
  file1.close
  file2.close
end

system("graph -T X -C -g 3 -m 1 'y2.dat' -m -2 -S 4 'y1.dat' ")
File.delete("y1.dat")
File.delete("y2.dat")


#!/usr/bin/env ruby
require 'gsl'
include GSL
include Math

f457 = Function.alloc { |x|
  if x.zero?
    val = 0.0
  else
    val = 1.0/sqrt(x)
  end
  val
}

exp_result =  9.999999999279802765E-01
exp_abserr =  1.556289974669056164E-08

table = [PI/2.0, 1.0, GSL::Integration::COSINE, 1000]
result = f457.qawf(0.0, 1e-7, table)
p result
puts("exp_result: #{exp_result}")
puts("exp_abserr: #{exp_abserr}")

w = Integration::Workspace.alloc
wc = Integration::Workspace.alloc

limit = 1000
table = Integration::QAWO_Table.alloc(PI/2.0, 1.0, GSL::Integration::COSINE, 1000)
p f457.qawf(0.0, table)
p f457.qawf(0.0, 1e-7, table)
p f457.qawf(0.0, 1e-7, limit, table)
p f457.qawf(0.0, limit, table)
p f457.qawf(0.0, 1e-7, limit, w, wc, table)
p f457.qawf(0.0, w, wc, table)
p f457.qawf(0.0, limit, w, wc, table)
#p f457.qawf(0.0, limit, w, table)

p Integration.qawf(f457, 0.0, table)
p Integration.qawf(f457, 0.0, 1e-7, table)
p Integration.qawf(f457, 0.0, 1e-7, limit, table)
p Integration.qawf(f457, 0.0, limit, w, wc, table)

require("gsl")
include GSL
include GSL::CONST
include GSL::CONST::CGSM
include Math

module Cosmology

  # Inverse of H(z), H(z): Hubble parameter determined by Friedmann equation
  InvHz = Function.alloc { |z, unv|
    matter = unv.matter
    radiation = unv.radiation
    lambda = unv.lambda         # Cosmological constant
    k = unv.k                   # Curvature
    zplus1 = z + 1.0
    z12 = zplus1*zplus1
    1.0/sqrt(k*z12 + lambda + matter*z12*zplus1 + radiation*z12*z12)
  }
  WSpace = GSL::Integration::Workspace.alloc(1000)

  class Universe
    H2H0 = 3.24e-18
    G = GRAVITATIONAL_CONSTANT
    RAD_DENSITY = 8.0*pow_5(PI)*pow_4(BOLTZMANN)/15.0/pow_3(PLANCKS_CONSTANT_H*SPEED_OF_LIGHT)
    #  p SPEED_OF_LIGHT/(0.71*100*1e5*1e3)*13

    def initialize(matter = 0.3, lambda = 0.7, cmbT = 2.7, h = 0.7)
      # Hubble parameter at present
      @h = h
      @H0 = H2H0*h

      # Density parameters
      @matter = matter
      @lambda = lambda
      rad = RAD_DENSITY*pow_4(cmbT)
      @radiation = rad*8*PI*G/3/@H0/@H0/SPEED_OF_LIGHT/SPEED_OF_LIGHT
      @Omega = @matter + @lambda + @radiation
      @k = 1.0 - @Omega
      @q = @matter/2.0 + @radiation - @lambda  # Decceleration parameter
    end

    def comoving_distance(z)
      InvHz.set_params(self)
      InvHz.integration_qags([0.0, z], WSpace)[0]
    end

    # r: comoving distance
    def conformal_factor(r)
      tmp = sqrt(@k)
      if @Omega > 1.0
        sin(tmp*r)/tmp
      elsif @Omega < 1.0
        sinh(tmp*r)/tmp
      else
        r
      end
    end

    def luminosity_distance(z)
      r = self.comoving_distance(z)
      s = self.conformal_factor(r)
      [r, (1.0 + z)*s]  # comoving distance, luminosity distance
    end

    attr_reader :h
    attr_reader :H0
    attr_reader :matter
    attr_reader :lambda
    attr_reader :radiation
    attr_reader :Omega
    attr_reader :k
    attr_reader :q
  end
end
#!/usr/bin/env ruby
require 'gsl'
include GSL
include Math

f456 = Function.alloc { |x|
  if x.zero?
    val = 0.0
  else
    val = log(x)
  end
  val
}

exp_result = -1.281368483991674190E-01
exp_abserr =  6.875028324415666248E-12

table = [10.0*PI, 1.0, GSL::Integration::SINE, 1000]
result = f456.qawo(0.0, [0.0, 1e-7], table)
p result
puts("exp_result: #{exp_result}")
puts("exp_abserr: #{exp_abserr}")

table = Integration::QAWO_Table.alloc(10.0*PI, 1.0, GSL::Integration::SINE, 1000)
p f456.qawo(0.0, [0.0, 1e-7], table)
p f456.qawo(0.0, table)

p Integration.qawo(f456, 0.0, table)
p Integration.qawo(f456, 0.0, [0.0, 1e-7], table)
#!/usr/bin/env ruby
require 'gsl'
include GSL
include Math

f = Function.alloc{ |x|
  exp(-x*x)
}

exact = sqrt(PI)

result, = f.qagi
puts("QAGI")
puts("exp(-x*x), x = -infty --- +infty")
printf("exact  = %.18f\n", exact)
printf("result = %.18f\n\n", result)

p Integration.qagi(f)

w = Integration::Workspace.alloc(1000)
xmin = 0.0

puts("QAGIU")
result, = f.integration_qagiu(xmin, [0, 1e-6], w)
puts("exp(-x*x), x = 0 --- +infty")
printf("exact  = %.18f\n", exact/2)
printf("result = %.18f\n", result)
p w.to_a

p Integration.qagiu(f, xmin)

puts("QAGIL")
result, = f.integration_qagil(0.0, 0.0, 1e-7, 1000, w)
puts("exp(-x*x), x = -infty --- 0")
printf("exact  = %.18f\n", exact/2)
printf("result = %.18f\n\n", result)

f455 = Function.alloc { |x|
  log(x)/(1.0 + 100.0*x*x)
}

exp_result = -3.616892186127022568E-01
exp_abserr = 3.016716913328831851E-06

result = f455.qagiu(0.0, [0.0, 1e-3])
p result
puts("exp_result: #{exp_result}")
puts("exp_abserr: #{exp_abserr}")

#!/usr/bin/env ruby
# Ahmed's Integral
# See e.g. http://mathworld.wolfram.com/AhmedsIntegral.html
#
require("gsl")
include GSL
include Math

f = Function.alloc { |x|
  sqrtx22 = sqrt(x*x + 2)
  atan(sqrtx22)/(sqrtx22*(x*x + 1))
}

val = f.qng(0, 1)[0]

puts("Ahmed's integral")
puts("Expect: 5pi^2/96 = #{5.0*M_PI*M_PI/96}")
puts("QNG result:        #{val}")



#!/usr/bin/env ruby
require("gsl")
include Math

f = GSL::Function.alloc { |x| x*sin(1.0/x) }
w = GSL::Integration::Workspace.alloc(1000)

p f.qag(0, 3, w)
#!/usr/bin/env ruby
require("gsl")
include GSL

# Singular at x = 0
f = Function.alloc { |x| 1.0/Math::sqrt(x) }

puts("QAGS")
p f.qags(0, 1)
p f.qags([0, 1])

p Integration.qags(f, 0, 1)
p Integration.qags(f, [0, 1])

#!/usr/bin/env ruby
require("gsl")
include GSL
include Math

printf("QAGI (integrate [-infty:+infty])\n\n")

w = Integration::Workspace.alloc(1000)

f = Function.alloc{ |x, a|
  cos(x)/(x*x + a*a)
}

a = 1.0
f.set_params(a)
printf("Case 1: f(x; a) = cos(x)/(x^2 + a^2), I(a) = pi/a e^(-a)\n")
printf("        Expected: I(1) = %10.9f\n", M_PI*exp(-a))
printf("        QAGI Result:     %10.9f\n", f.qagi([0, 1e-4], w)[0])

f = Function.alloc{ |x, a|
  exp(a*x)/(1 + exp(x))
}

a = 0.3
f.set_params(a)
printf("Case 2: f(x; a) = e^{ax}/(1 + e^x), I(a) = pi/sin(a pi)\n")
printf("        Expected: I(0.3) = %10.9f\n", M_PI/sin(a*M_PI))
printf("        QAGI Result:       %10.9f\n", f.qagi([0, 1e-2], w)[0])
#!/usr/bin/env ruby
require("gsl")
phi = GSL::Vector.linspace(0, 12*Math::PI, 800)
r = GSL::Sf::exp(GSL::Sf::cos(phi)) - 2*GSL::Sf::cos(4*phi) + GSL::pow_5(GSL::Sf::sin(phi/12))
x = r*GSL::Sf::cos(phi)
y = r*GSL::Sf::sin(phi)
GSL::graph(x, y)
#!/usr/bin/env ruby
require("gsl")

t = GSL::Vector.linspace(0, 2*Math::PI, 100)

a = 2
b = 3

cost = GSL::Sf::cos(t)
r = b*GSL::Sf::cos(2*t) - a*cost

x = r*cost
y = r*GSL::Sf::sin(t)
GSL::graph(x, y, "-T X -C")
#!/usr/bin/env ruby
require("gsl")

phi = GSL::Vector.linspace(0, 2*Math::PI, 200)
r1 = GSL::Sf::sin(4*phi)
x1 = r1*GSL::Sf::cos(phi)
y1 = r1*GSL::Sf::sin(phi)
r2 = GSL::Sf::cos(4*phi)
x2 = r2*GSL::Sf::cos(phi)
y2 = r2*GSL::Sf::sin(phi)
GSL::Vector.graph([x1, y1], [x2, y2])
#!/usr/bin/env ruby
# Koch curve

require("gsl")
include Math

ONE_UNIT = 3

def koch(x, y, theta, size, order, file)
  if order == 0
    x += cos(theta)*size
    y += sin(theta)*size
    file.printf("%e %e\n", x, y)
  else
    x, y = koch(x, y, theta, size/3, order-1, file)
    theta += Math::PI/3
    x, y = koch(x, y, theta, size/3, order-1, file)
    theta -= 2.0*Math::PI/3
    x, y = koch(x, y, theta, size/3, order-1, file)
    theta += Math::PI/3
    x, y = koch(x, y, theta, size/3, order-1, file)
  end
  return [x, y]
end

SIZE = 243
ORDER = 4

x = 0.0
y = 0.0
theta = 0.0
IO.popen("graph -T X -C -N x -N y", "w") do |io|
  io.printf("%e %e\n", x, y)
  x, y = koch(x, y, theta, SIZE, ORDER, io)
  theta -= 2.0*Math::PI/3
  x, y = koch(x, y, theta, SIZE, ORDER, io)
  theta -= 2.0*Math::PI/3
  x, y = koch(x, y, theta, SIZE, ORDER, io)
  theta -= 2.0*Math::PI/3
end
#!/usr/bin/env ruby
require("gsl")

a = 1
t = GSL::Vector.linspace(0, 2*Math::PI, 100)
cost = GSL::Sf::cos(t)
sint = GSL::Sf::sin(t)
x = a*sint
y = a*sint*cost

GSL::graph(x, y, "-T X -C")
#!/usr/bin/env ruby
require("gsl")
include Math

sint2 = GSL::Function.alloc { |t| Math::sin(Math::PI/2*t*t) }
cost2 = GSL::Function.alloc { |t| Math::cos(Math::PI/2*t*t) }
w = GSL::Integration::Workspace.alloc(1000)

t = 0
STDOUT.print("Computing... ")
STDOUT.flush
IO.popen("graph -T X -C -g 3 -X 'C(t)' -Y 'S(t)' --toggle-rotate-y-label -L 'Cornu spiral'", "w") do |io|
  t = -4
  while t < 4
    c = cost2.qag([0, t], w)[0]
    s = sint2.qag([0, t], w)[0]
    io.printf("%e %e\n", c, s)
    t += 0.01
  end
  STDOUT.print("done\n")
  STDOUT.flush
  io.flush
end
#!/usr/bin/env ruby
require("gsl")

a = 1
t = GSL::Vector.linspace(0, 3*Math::PI, 100)
cost = GSL::Sf::cos(t/3)
cost3 = cost*cost*cost
r = 4*a*cost3
x = r*GSL::Sf::cos(t)
y = r*GSL::Sf::sin(t)

GSL::graph(x, y, "-T X -C")
#!/usr/bin/env ruby
require("gsl")

dim = 3
roesller = Proc.new { |t, v, dvdt, params|
  a = params[0]; b = params[1]; c = params[2]
  x = v[0]; y = v[1]; z = v[2]
  dvdt[0] = - y - z
  dvdt[1] = x + a*y
  dvdt[2] = b*x - (c - x)*z
}

a = 0.344
b = 0.4
c = 4.5
solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RKF45, [1e-6, 0.0], roesller, dim)
solver.set_params(a, b, c)

t = 0.0; tend = 100.0
h = 1e-6
v = GSL::Vector.alloc(1, 0, 0)

GSL::ieee_env_setup()

IO.popen("gnuplot -persist", "w") do |io|
  io.print("set title 'Roesller equation'\n")
  io.print("set xlabel 'X'\n")
  io.print("set ylabel 'Y'\n")
  io.print("set zlabel 'Z'\n")
  io.printf("splot '-' u 2:3:4 w l\n")
  while t < tend
    t, h, status = solver.apply(t, tend, h, v)
    io.printf("%e %e %e %e\n", t, v[0], v[1], v[2])
    break if status != GSL::SUCCESS
  end
  io.printf("e\n")
  io.flush
end

#!/usr/bin/env ruby
require("gsl")

a = 1
t = GSL::Vector.linspace(0, 2*Math::PI, 100)
cost = GSL::Sf::cos(t)
sint = GSL::Sf::sin(t)
x = a*cost
y = a*sint*cost/(1 + sint*sint)

GSL::graph(x, y, "-T X -C")
#!/usr/bin/env ruby
#begin
#  require 'rubygems'
#  require_gem "gnuplot"         # Try using rubygem
#ensure
  require 'gnuplot'             # No gem, use traditional require
#end

require "gsl"

# Add the to_gplot method to Vector since its not already built in.  This
# might be worthwhile adding to the core GSL stuff.

x = GSL::Vector.linspace(0, 2*M_PI, 100)
s = Sf::sin(x)
c = Sf::cos(x)

# Now generate the actual plot
Gnuplot::open do |gp|
  Gnuplot::Plot.new( gp ) do |plot|

    plot.title "GSL plotting example"
    plot.data = [
      Gnuplot::DataSet.new( [x, c] ) { |ds|
        ds.title = "cos(x)"
        ds.with = "lines"
      },
      Gnuplot::DataSet.new( [x, s] ) { |ds|
        ds.title = "sin(x)"
        ds.with = "lines"
      }
    ]
  end
end

#!/usr/bin/env ruby
require("gnuplot")
require("gsl")

dim = 3
roesller = Proc.new { |t, v, dvdt, params|
  a = params[0]; b = params[1]; c = params[2]
  x = v[0]; y = v[1]; z = v[2]
  dvdt[0] = - y - z
  dvdt[1] = x + a*y
  dvdt[2] = b*x - (c - x)*z
}

a = 0.344
b = 0.4
c = 4.5
solver = GSL::Odeiv::Solver.new(GSL::Odeiv::Step::RKF45, [1e-6, 0.0], roesller, dim)
solver.set_params(a, b, c)

t = 0.0; tend = 100.0
h = 1e-6
v = GSL::Vector[1, 0, 0]

GSL::ieee_env_setup()

N = 1000
x = GSL::Vector[N]
y = GSL::Vector[N]
z = GSL::Vector[N]

i = 0
while t < tend
  t, h, status = solver.apply(t, tend, h, v)
  x[i] = v[0]
  y[i] = v[1]
  z[i] = v[2]
  i += 1
  break if status != GSL::SUCCESS
end

Gnuplot::open do |gp|
  Gnuplot::SPlot.new( gp ) do |plot|

    plot.title "Roesller equation"

    plot.data = [
      Gnuplot::DataSet.new( [x.subvector(i), y.subvector(i), z.subvector(i)] ) { |ds|
        ds.title = ""
        ds.with = "lines"
      }
    ]
  end
end


#!/usr/bin/env ruby
require("gsl")

na = NArray[1.0, 2, 3, 4, 5, 6, 7 ,8 ,9]
p na
v = GSL::Vector.alloc(na)
p v

v[3] = 99.9
p v
p na

na2 = NArray[12.3, 45.6, 78.9, 1.23, 4.56, 7.89]
p na2
vref = na2.to_gv_view
p vref
vref[1] = 0.00
p na2

m = NMatrix[[1.0, 2],[3, 4]]
p m

gm = GSL::Matrix.alloc(m)
p gm

gm.set(1, 1, 99.9)
p gm
p m

gm2 = m.to_gm_view

gm2.set(1, 1, 99.9)
p gm2
p m

m = NMatrix[[0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
            [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85]]
mref = GSL::Matrix.to_gm_view(m)
mref[1,1] = 123
p m

mm = GSL::Matrix.to_gm(m)
mm[1,1] = 456
p m
#!/usr/bin/env ruby
require("gsl")

puts("\nGSL::Vector")
v = GSL::Vector.alloc(1..9)
p v

puts("\nGSL::Vector ---> NArray")
vna = v.to_na
p vna

puts("\nNArray ---> GSL::Vector")
v2 = GSL::Vector.to_gv(vna)
p v2

puts("\nGSL::Matrix")
m = GSL::Matrix.alloc(1..9, 3, 3)
p m

puts("\nGSL::Matrix ---> NArray")
mna = m.to_na
p mna

puts("\nNArray ---> GSL::Matrix")
m2 = GSL::Matrix.to_gm(mna)
p m2


#!/usr/bin/env ruby
require("gsl")

na = NArray[0.1, 0.2, 0.3, 0.4]
p GSL::Sf::legendre_Pl(2, na)

v = GSL::Vector[0.1, 0.2, 0.3, 0.4]
p GSL::Sf::legendre_Pl(2, v)

na = NArray[[1.0, 2, 3, 4], [2, 3, 4, 5]]
p GSL::Sf::sin(na)

m = GSL::Matrix[[1.0, 2, 3, 4], [2, 3, 4, 5]]
p GSL::Sf::sin(m)

n = 50
x = GSL::Vector.linspace(0.01, 1, n).to_na
y1 = GSL::Sf::beta_inc(0.5, 5.0, x)
y2 = GSL::Sf::beta_inc(1.0, 3.0, x)
y3 = GSL::Sf::beta_inc(8.0, 10.0, x)
y4 = GSL::Sf::beta_inc(5.0, 0.5, x)
p y1.class
p y2.class
p y3.class
p y4.class
GSL::Vector.graph([x, y1], [x.to_gv, y2], [x, y3.to_gv], [x, y4], "-T X -C -g 3 -y 0 1.1 -X x -L 'Incomplete beta functions'")
#!/usr/bin/env ruby
require("gsl")

N = 10000
r = GSL::Rng.alloc
na = r.gaussian(1.0, N).to_na    # Generate N random numbers
p na.class
p na.rank
p na.size
p na.min
p na.max
h = GSL::Histogram.alloc(50, [-4, 4])
h.fill(na)
h.graph("-T X -C -g 3")
#!/usr/bin/env ruby
require("gsl")
require("nimage")

def mandel(w, h)
  zoom = 3.5
  z = (GSL::Matrix::Complex[w, 1].indgen!/w - 0.65)*zoom + (GSL::Matrix::Complex[1, h].indgen!/h - 0.5)*zoom*GSL::Complex[0, 1]
  c = z.clone
  a = GSL::Vector::Int[w, h]
  idx = GSL::Vector::Int[h, w].indgen!

  for i in 1..30
    z = z*z + c
    idx_t,idx_f = (z.abs>2).where2
    a[idx[idx_t]] = i
    break if idx_f.size==0
    idx = idx[idx_f]
    z = z[idx_f]
    c = c[idx_f]
  end
  a
end

NImage.show mandel(400,400).to_na_ref

print "Hit return key..."
STDIN.getc
#!/usr/bin/env ruby
require("gsl")

demyanov_f = Proc.new { |x, params|
  GSL::MAX_DBL(5.0*x[0]+x[1], GSL::MAX_DBL(x[0]*x[0]+x[1]*x[1]+4.0*x[1], -5.0*x[0] + x[1]))
}

demyanov_sdf = Proc.new { |x, sdf|
  f = 5.0*x[0] + x[1]
  ff = x[0]*x[0] + x[1]*x[1] + 4.0*x[1]
  i_max = 1
  if f < ff
    f = ff
    i_max = 2
  end
  if f < -5.0*x[0] + x[1]
    i_max = 3
  end
  case i_max
  when 1
    sdf[0] = 5.0
    sdf[1] = 1.0
  when 2
    sdf[0] = 2.0*x[0]
    sdf[1] = 2.0*x[1] + 4.0
  when 3
    sdf[0] = -5.0
    sdf[1] = 1.0
  end
}

max_iter = 1000
n = 2
function = GSL::MultiMin::Function_fsdf.alloc(demyanov_f, demyanov_sdf, n)

start_point = GSL::Vector.alloc(n)
start_point.set_all(1.0)
bundle_size_max = n + 3

s = GSL::MultiMin::FsdfMinimizer.alloc("bundle_method", n)
s.set(function, start_point, bundle_size_max)

printf("********************  %s  ********************\n\n","Demyanov function")

printf("== k ===== f(x) ===== ||sgr_f(x)|| ======= eps ======  \n");

subgradient = s.subgradient

iter = 0;
printf("%4d  %14.7f  %13.8e  %13.8e\n", iter, s.f, subgradient.dnrm2, s.eps)

begin
  iter += 1
  status = s.iterate
  status = s.test_convergence(1e-5)
  printf("%4d  %14.7f  %13.8e  %13.8e\n", iter, s.f, subgradient.dnrm2, s.eps)
  if status == GSL::SUCCESS
    printf("\nMinimum is found at\n")
    x = s.x
    for j in 0...x.size do
      printf("%9.6f ", x[j])
    end
    printf("\n\n")
  end
end while status == GSL::CONTINUE and iter <= max_iter

#!/usr/bin/env ruby
require("gsl")
include GSL::MultiMin

my_f = Proc.new { |v, params|
  x = v[0]; y = v[1]
  p0 = params[0]; p1 = params[1]
  10.0*(x - p0)*(x - p0) + 20.0*(y - p1)*(y - p1) + 30.0
}

my_df = Proc.new { |v, params, df|
  x = v[0]; y = v[1]
  p0 = params[0]; p1 = params[1]
  df[0] = 20.0*(x-p0)
  df[1] = 40.0*(y-p1)
}

my_func = GSL::MultiMin::Function_fdf.alloc(my_f, my_df, 2)
my_func.set_params([1.0, 2.0])      # parameters

x = GSL::Vector.alloc([5.0, 7.0])          # starting point

#minimizer = GSL::MultiMin::FdfMinimizer.alloc("conjugate_fr", 2)
minimizer = GSL::MultiMin::FdfMinimizer.alloc(GSL::MultiMin::FdfMinimizer::VECTOR_BFGS, 2)
#minimizer = GSL::MultiMin::FdfMinimizer.alloc(GSL::MultiMin::FdfMinimizer::VECTOR_BFGS2, 2)
minimizer.set(my_func, x, 0.01, 1e-4)

iter = 0
begin
  iter += 1
  status = minimizer.iterate()
  status = minimizer.test_gradient(1e-3)
  if status == GSL::SUCCESS
    puts("Minimum found at")
  end
  x = minimizer.x
  f = minimizer.f
  printf("%5d %.5f %.5f %10.5f\n", iter, x[0], x[1], f)

end while status == GSL::CONTINUE and iter < 100
#!/usr/bin/env ruby
require("gsl")
include GSL
include GSL::MultiMin

np = 2

my_f = Proc.new { |v, params|
  x = v[0]; y = v[1]
  p0 = params[0]; p1 = params[1]
  10.0*(x - p0)*(x - p0) + 20.0*(y - p1)*(y - p1) + 30.0
}

my_func = MultiMin::Function.alloc(my_f, np)
my_func.set_params([1.0, 2.0])      # parameters

x = Vector.alloc([5, 7])
ss = Vector.alloc(np)
ss.set_all(1.0)

#minimizer = FMinimizer.alloc("nmsimplex", np)
minimizer = FMinimizer.alloc(MultiMin::FMinimizer::NMSIMPLEX, np)

minimizer.set(my_func, x, ss)

iter = 0
begin
  iter += 1
  status = minimizer.iterate()
  status = minimizer.test_size(1e-2)
  if status == GSL::SUCCESS
    puts("converged to minimum at")
  end
  x = minimizer.x
  printf("%5d ", iter);
  for i in 0...np do
    printf("%10.3e ", x[i])
  end
  printf("f() = %7.3f size = %.3f\n", minimizer.fval, minimizer.size);
end while status == GSL::CONTINUE and iter < 100

#!/usr/bin/env ruby
require("gsl")

module GSL::CQP
  class Test_Problem
    def Test_Problem.gould()
      cqp_data = GSL::CQP::Data.alloc()
      cqp_data.Q = GSL::Matrix.eye(2, 2)
      cqp_data.q = GSL::Vector[-2.0, -1.0]
      cqp_data.A = GSL::Matrix[[3, 1], 1, 2]
      cqp_data.b = GSL::Vector.alloc(1); cqp_data.b[0] = 1.5
      cqp_data.C = GSL::Matrix[[1, 0, 0, 1], 2, 2]
      cqp_data.d = GSL::Vector.calloc(2)

      Test_Problem.new("Goulds's problem", 2, 1, 2, cqp_data, 0.0)
    end
    def Test_Problem.betts()
      cqp_data = GSL::CQP::Data.alloc()
      cqp_data.Q = GSL::Matrix[[0.02, 0, 0, 2], 2, 2]
      cqp_data.q = GSL::Vector.calloc(2)
      cqp_data.A = GSL::Matrix[[10, -1.0], 1, 2]
      cqp_data.b = GSL::Vector.alloc(1); cqp_data.b[0] = 20
      cqp_data.C = GSL::Matrix.calloc(4, 2)
      cqp_data.C[0,0] = 1.0; cqp_data.C[1,1] = 1.0
      cqp_data.C[2,0] = -1.0; cqp_data.C[3,1] = -11.0
      cqp_data.d = GSL::Vector[2.0, -50, -50, -50]


      Test_Problem.new("Betts's problem", 2, 1, 4, cqp_data, 0.04)
    end
    def Test_Problem.beale()
      cqp_data = GSL::CQP::Data.alloc()
      cqp_data.Q = GSL::Matrix[[4, 2, 2, 2, 4, 0, 2, 0, 2], 3, 3]
      cqp_data.q = GSL::Vector[-8, -6, -4]
      cqp_data.A = GSL::Matrix[[-1, -1, -2], 1, 3]
      cqp_data.b = GSL::Vector.alloc(1); cqp_data.b[0] = -3.0
      cqp_data.C = GSL::Matrix.eye(3, 3)
      cqp_data.d = GSL::Vector.calloc(3)

      cqp_data.Q[0,0] = 4.0; cqp_data.Q[0,1] = 2.0
      cqp_data.Q[1,0] = 2.0; cqp_data.Q[1,1] = 4.0
      cqp_data.Q[2,0] = 2.0; cqp_data.Q[2,2] = 2.0
      Test_Problem.new("Beale's problem", 3, 1, 3, cqp_data, 9.0+1.0/9.0)
    end

    def initialize(name, n, me, mi, cqp, opt_value)
      @name = name
      @n = n
      @me = me
      @mi = mi
      @cqp = cqp
      @opt_value = opt_value
    end

    def solve()
      max_iter = 1000
      iter = 1
      status = GSL::CONTINUE
      s = GSL::CQP::Minimizer.alloc("mg_pdip", @n, @me, @mi)
      s.set(@cqp)
      printf("********************  %s  ********************\n\n", @name)

      printf("== Itn ======= f ======== ||gap|| ==== ||residual||\n\n")

      begin
        status = s.iterate
        status = s.test_convergence(1e-10, 1e-10)
        printf("%4d   %14.8f  %13.6e  %13.6e\n", iter, s.f, s.gap, s.residuals_norm)
        if status == GSL::SUCCESS
          printf("\nMinimum is found at\n");
          x = s.x
          lm_eq = s.lm_eq
          lm_ineq = s.lm_ineq
          for j in 0...x.size do
            printf("%9.6f ", x[j])
          end
          printf("\n\n")
          printf("\nLagrange-multipliers for Ax=b\n")
          for j in 0...lm_eq.size do
            printf("%9.6f ", lm_eq[j])
          end
          printf("\n\n")
          printf("\nLagrange-multipliers for Cx>=d\n");
          for j in 0...lm_ineq.size do
            printf("%9.6f ", lm_ineq[j])
          end
          printf("\n\n")
        else
          iter += 1
        end
     end while status == GSL::CONTINUE and iter <= max_iter
      GSL::SUCCESS
    end

    attr_accessor :name, :n, :me, :mi
    attr_accessor :cqp, :opt_value
  end

end

tp = Array.new(3)
tp[0] = GSL::CQP::Test_Problem.gould()
tp[1] = GSL::CQP::Test_Problem.betts()
tp[2] = GSL::CQP::Test_Problem.beale()

tp.each do |t|
  t.solve()
end

#!/usr/bin/env ruby
require("gsl")

N = 100

y0 = 0.1
A = 2
rr = -1.5

r = GSL::Rng.alloc()
x = GSL::Vector.linspace(0.1, 1, N)
y =  y0 + A*GSL::pow(x, rr) + 0.1*r.gaussian(1, N)

coef, err, chi2, dof = GSL::MultiFit::FdfSolver.fit(x, y, "power")
y0 = coef[0]
amp = coef[1]
rr = coef[2]
p coef
p err

GSL::graph(x, y, y0+amp*GSL::pow(x, rr), "-T X -C -g 3 -l x -l y")
#!/usr/bin/env ruby
require("gsl")
include GSL::MultiFit

N = 100

y0 = 1
m = 2.0
xhalf = 5
rr = 4

r = GSL::Rng.alloc()
x = GSL::Vector.linspace(0.001, 10, N)
y =  y0 + (m-y0)/(1.0 + GSL::pow(xhalf/x, rr)) + 0.02*r.gaussian(1, N)

coef, err, chi2, dof = GSL::MultiFit::FdfSolver.fit(x, y, "hill")
y0 = coef[0]
m = coef[1]
xhalf = coef[2]
rr = coef[3]
p coef
p err
GSL::graph(x, y, y0+(m-y0)/(1+GSL::pow(xhalf/x, rr)))

=begin
Result:
GSL::Vector
[ 9.959e-01 1.995e+00 4.936e+00 4.035e+00 ]
GSL::Vector
[ 4.676e-03 1.035e-02 3.779e-02 1.125e-01 ]

GNUPLOT result:
Final set of parameters            Asymptotic Standard Error
=======================            ==========================

y0              = 0.995858         +/- 0.004676     (0.4695%)
m               = 1.99465          +/- 0.01034      (0.5184%)
xhalf           = 4.93605          +/- 0.0378       (0.7658%)
r               = 4.0346           +/- 0.1124       (2.787%)
=end
#!/usr/bin/env ruby
require("gsl")

N = 100

y0 = 1.0
A = 2.0
x0 = 3.0
B = 4.0

r = GSL::Rng.alloc()
x = GSL::Vector.linspace(-10, 20, N)
y =  y0 + A/(GSL::pow_2(x-x0)+B) + 0.03*GSL::Ran::gaussian(r, 1, N)

coef, err, chi2, dof = GSL::MultiFit::FdfSolver.fit(x, y, "lorentzian")
y0 = coef[0]
amp = coef[1]
x0 = coef[2]
b = coef[3]
p coef
p err
GSL::graph(x, y, y0+amp/(GSL::pow_2(x-x0)+b))
#!/usr/bin/env ruby
require("gsl")

N = 40

amp0 = 5.0
b0 = 0.1
y0 = 1.0

r = GSL::Rng.alloc()
x = GSL::Vector[0...N]
sigma = GSL::Vector[N]
sigma.set_all(0.1)
y = y0 + amp0*GSL::Sf::exp(-b0*x) + 0.1*r.gaussian(1, N)

coef, err, chi2, dof = GSL::MultiFit::FdfSolver.fit(x, sigma, y, "exponential")
y0 = coef[0]
amp = coef[1]
b = coef[2]
p coef
p err
GSL::graph(x, y, y0+amp*GSL::Sf::exp(-b*x))

# This will result in
# [ 1.019e+00 5.045e+00 1.040e-01 ]
# [ 3.385e-02 5.395e-02 2.826e-03 ]

# GNUPLOT results:
# y0              = 1.01925          +/- 0.03383      (3.319%)
# A               = 5.04536          +/- 0.05396      (1.069%)
# b               = 0.104049         +/- 0.002826     (2.716%)
#!/usr/bin/env ruby
require("gsl")

n = 4
x = GSL::Vector[1970.0, 1980, 1990, 2000]
y = GSL::Vector[12.0, 11, 14, 13]
w = GSL::Vector[0.1, 0.2, 0.3, 0.4]

c0, c1, cov00, cov01, cov11, chisq = GSL::Fit::wlinear(x, w, y)

printf("# best fit: Y = %g + %g X\n", c0, c1);
printf("# covariance matrix:\n");
printf("# [ %g, %g\n#   %g, %g]\n",
        cov00, cov01, cov01, cov11);
printf("# chisq = %g\n", chisq);

File.open("data.dat", "w") do |f|
  for i in 0...n do
    f.printf("%e %e %e\n", x[i], y[i], 1.0/Math::sqrt(w[i]))
  end
end

begin
  ffit = File.open("fit.dat", "w")
  fhi = File.open("hi.dat", "w")
  flo = File.open("lo.dat", "w")
  for i in -30...130 do
    xf = x[0] + (i/100.0) * (x[n-1] - x[0])

    yf, yf_err = GSL::Fit::linear_est(xf, c0, c1, cov00, cov01, cov11)

    ffit.printf("%g %g\n", xf, yf)
    fhi.printf("%g %g\n", xf, yf + yf_err)
    flo.printf("%g %g\n", xf, yf - yf_err)
  end
ensure
  ffit.close
  fhi.close
  flo.close
end

system("graph -T X -C -g 3 -X x -Y y -x 1960 2010 -y 0 20 -m 0 -S 2 -Ie data.dat -S 0 -I a -m 1 fit.dat -m 2 hi.dat -m 2 lo.dat")
File.delete("data.dat")
File.delete("fit.dat")
File.delete("hi.dat")
File.delete("lo.dat")
#!/usr/bin/env ruby
require("gsl")

# Create data
r = GSL::Rng.alloc("knuthran")
amp1 = 5.0
x01 = 1.0
sigma1 = 1.5

amp2 = 2.0
x02 = 5.0
sigma2 = 0.5

y0 = 2.0
N = 300
x = GSL::Vector.linspace(-4, 9, N)
y = y0 + amp1*GSL::Ran::gaussian_pdf(x - x01, sigma1) + amp2*GSL::Ran::gaussian_pdf(x - x02, sigma2) + 0.05*GSL::Ran::gaussian(r, 1.0, N)

coef, err, chi2, dof =  GSL::MultiFit::FdfSolver.fit(x, y, "gaussian_2peak", [2, 4, 0.9, 1, 1, 4, 1])

p coef
y01 = coef[0]

amp1 = coef[1]*Math::sqrt(2*Math::PI)*sigma1
x01 = coef[2]
sigma1 = Math::sqrt(coef[3])

amp2 = coef[4]*Math::sqrt(2*Math::PI)*sigma2
x02 = coef[5]
sigma2 = Math::sqrt(coef[6])

y2 = y01 + amp1*GSL::Ran::gaussian_pdf(x - x01, sigma1) + amp2*GSL::Ran::gaussian_pdf(x - x02, sigma2)

GSL::graph(x, y, y2, "-C -g 3")
#!/usr/bin/env ruby
require("gsl")

N = 100

y0 = 1
A = 1.5
fc = 0.7
phi = 0.2

r = GSL::Rng.alloc()
x = GSL::Vector.linspace(0, 12, N)
y =  y0 + A*GSL::Sf::sin(fc*x+phi) + 0.1*r.gaussian(1, N)

coef, err, chi2, dof = GSL::MultiFit::FdfSolver.fit(x, y, "sin")
y0 = coef[0]
amp = coef[1]
fc = coef[2]
phi = coef[3]
p coef
p err
GSL::graph(x, y, y0+amp*GSL::Sf::sin(fc*x+phi))
#!/usr/bin/env ruby
require("gsl")

x = GSL::Vector[0.0, 0.3, 0.8, 1.1, 1.6, 2.3]
y = GSL::Vector[0.5, 0.82, 1.14, 1.25, 1.35, 1.40]
coef, cov, chisq, status = GSL::MultiFit.polyfit(x, y, 2)
p coef
x2 = GSL::Vector.linspace(0, 2.5, 20)
GSL::graph([x, y], [x2, coef.eval(x2)], "-C -g 3 -S 4 -X X -Y Y")
#!/usr/bin/env ruby
require("gsl")

unless GSL::MultiFit.const_defined?("Ndlinear")
  puts("The extension library NDLINEAR is not installed.")
  exit()
end

N_DIM = 3
N_SUM_R = 10
N_SUM_THETA = 11
N_SUM_PHI = 9
R_MAX = 3.0

def psi_real_exact(k, l, m, r, theta, phi)
  rr = GSL::pow(r, l)*Math::exp(-r*r)*GSL::Sf::laguerre_n(k, l + 0.5, 2 * r * r)

  tt = GSL::Sf::legendre_sphPlm(l, m, Math::cos(theta))

  pp = Math::cos(m*phi)

  rr*tt*pp
end

basis_r = Proc.new { |r, y, params|
  params.eval(r, y)
}

basis_theta = Proc.new { |theta, y, params|
  for i in 0...N_SUM_THETA do
    y[i] = GSL::Sf::legendre_Pl(i, Math::cos(theta));
  end
}

basis_phi = Proc.new { |phi, y, params|
  for i in 0...N_SUM_PHI do
    if i%2 == 0
      y[i] = Math::cos(i*0.5*phi)
    else
      y[i] = Math::sin((i+1.0)*0.5*phi)
    end
  end
}


GSL::Rng::env_setup()

k = 5
l = 4
m = 2

NDATA = 3000

N = [N_SUM_R, N_SUM_THETA, N_SUM_PHI]
u = [basis_r, basis_theta, basis_phi]

rng = GSL::Rng.alloc()

bspline = GSL::BSpline.alloc(4, N_SUM_R - 2)
bspline.knots_uniform(0.0, R_MAX)

ndlinear = GSL::MultiFit::Ndlinear.alloc(N_DIM, N, u, bspline)
multifit = GSL::MultiFit.alloc(NDATA, ndlinear.n_coeffs)
vars = GSL::Matrix.alloc(NDATA, N_DIM)
data = GSL::Vector.alloc(NDATA)


for i in 0...NDATA do

  r = rng.uniform()*R_MAX
  theta = rng.uniform()*Math::PI
  phi = rng.uniform()*2*Math::PI

  psi = psi_real_exact(k, l, m, r, theta, phi)

  dpsi = rng.gaussian(0.05*psi)

  vars[i,0] = r
  vars[i,1] = theta
  vars[i,2] = phi

  data[i] = psi + dpsi
end

#GSL::MultiFit::Ndlinear::design(vars, X, ndlinear)
X = GSL::MultiFit::Ndlinear::design(vars, ndlinear)

coeffs, cov, chisq, = GSL::MultiFit::linear(X, data, multifit)

rsq = GSL::MultiFit::linear_Rsq(data, chisq)
STDERR.printf("chisq = %e, Rsq = %f\n", chisq, rsq)

eps_rms = 0.0
volume = 0.0
dr = 0.05;
dtheta = 5.0 * Math::PI / 180.0
dphi = 5.0 * Math::PI / 180.0
x = GSL::Vector.alloc(N_DIM)

r = 0.01
while r < R_MAX do
  theta = 0.0
  while theta < Math::PI do
    phi = 0.0
    while phi < 2*Math::PI do
      dV = r*r*Math::sin(theta)*dr*dtheta*dphi
      x[0] = r
      x[1] = theta
      x[2] = phi

      psi_model, err = GSL::MultiFit::Ndlinear.calc(x, coeffs, cov, ndlinear)
      psi = psi_real_exact(k, l, m, r, theta, phi)
      err = psi_model - psi
      eps_rms += err * err * dV;
      volume += dV;

      if phi == 0.0
         printf("%e %e %e %e\n", r, theta, psi, psi_model)
      end

      phi += dphi
    end
    theta += dtheta
  end
  printf("\n");

  r += dr
end

eps_rms /= volume
eps_rms = Math::sqrt(eps_rms)
STDERR.printf("rms error over all parameter space = %e\n", eps_rms)

#!/usr/bin/env ruby
require("gsl")

N = 100

y0 = 0.5
m = 1.0
x0 = 1
rr = 0.2

r = GSL::Rng.alloc()
x = GSL::Vector.linspace(0, 2, N)
y =  y0 + m/(1.0 + GSL::Sf::exp((x0-x)/rr)) + 0.02*r.gaussian(1, N)

coef, err, chi2, dof = GSL::MultiFit::FdfSolver.fit(x, y, "sigmoid")
y0 = coef[0]
m = coef[1]
x0 = coef[2]
rr = coef[3]
p coef
p err
GSL::graph(x, y, y0+m/(1+GSL::Sf::exp((x0-x)/rr)))

=begin
Result:
GSL::Vector
[ 4.954e-01 1.004e+00 9.916e-01 1.991e-01 ]
GSL::Vector
[ 5.653e-03 9.100e-03 5.033e-03 4.856e-03 ]

GNUPLOT result:
Final set of parameters            Asymptotic Standard Error
=======================            ==========================

y0              = 0.495446         +/- 0.005656     (1.142%)
m               = 1.00422          +/- 0.009105     (0.9067%)
x0              = 0.991588         +/- 0.005033     (0.5076%)
r               = 0.199059         +/- 0.00486      (2.442%)

=end
#!/usr/bin/env ruby
require("gsl")

GSL::Rng.env_setup()

r = GSL::Rng.alloc(GSL::Rng::DEFAULT)

n = 19
dim = 3
X = GSL::Matrix.alloc(n, dim)
y = GSL::Vector.alloc(n)
w = GSL::Vector.alloc(n)

file0 = "data.dat"
file1 = "fit.dat"

a = 0.1
File.open(file0, "w") do |f|
  for i in 0...n
    y0 = Math::exp(a)
    sigma = 0.1*y0
    val = r.gaussian(sigma)
    X[i,0] = 1.0
    X[i,1] = a
    X[i,2] = a*a
    y[i] = y0 + val
    w[i] = 1.0/(sigma*sigma)
    f.printf("%g %g %g\n", a, y[i], sigma)
    a += 0.1
  end
end

c, cov, chisq, status = GSL::MultiFit.wlinear(X, w, y)

printf("# best fit: Y = %g + %g X + %g X^2\n", c[0], c[1], c[2])
printf("# covariance matrix:\n")
printf("[ %+.5e, %+.5e, %+.5e\n", cov[0,0], cov[0,1], cov[0,2])
printf("  %+.5e, %+.5e, %+.5e\n", cov[1,0], cov[1,1], cov[1,2])
printf("  %+.5e, %+.5e, %+.5e ]\n", cov[2,0], cov[2,1], cov[2,2])
printf("# chisq = %g\n", chisq)

str = sprintf("%4.3f", c[0])
if c[1] > 0.0
  str += sprintf("+ %4.3f*x", c[1].abs)
else
  str += sprintf("- %4.3f*x", c[1].abs)
end
if c[2] > 0.0
  str += sprintf("+ %4.3f*x*x", c[2].abs)
else
  str += sprintf("- %4.3f*x*x", c[2].abs)
end

func = GSL::Function.alloc { |x, params|
  c0 = params[0]; c1 = params[1]; c2 = params[2]
  c0 + x*(c1 + x*c2)
}

func.set_params(c)

File.open(file1, "w") do |f|
  x = 0
  while x < 2
    f.printf("%e %e\n", x, func.eval(x))
    x += 0.01
  end
end

system("graph -T X -C -g 3 -y 0 7 -L '#{str}' -I e -m -1 -S 4 data.dat -I a -m 2 -S 0 fit.dat")

File.delete(file0)
File.delete(file1)
#!/usr/bin/env ruby
require("gsl")

# Create data
r = GSL::Rng.alloc("knuthran")
sigma = 1.5
x0 = 1.0
amp = 2.0
y0 = 3.0
N = 100
x = GSL::Vector.linspace(-4, 6, N)
y = y0 + amp*GSL::Ran::gaussian_pdf(x - x0, sigma) + 0.02*GSL::Ran::gaussian(r, 1.0, N)

coef, err, chi2, dof =  GSL::MultiFit::FdfSolver.fit(x, y, "gaussian")
sigma2 = Math::sqrt(coef[3])
x02 = coef[2]
amp2 = coef[1]*Math::sqrt(2*Math::PI)*sigma
y02 = coef[0]
y2 = y02 + amp2*GSL::Ran::gaussian_pdf(x - x02, sigma2)

GSL::graph(x, y, y2, "-C -g 3 -x -4 6")

printf("Expect:\n")
printf("sigma = #{sigma}, x0 = #{x0}, amp = #{amp}, y0 = #{y0}\n")
printf("Result:\n")
printf("sigma = %5.4e +/- %5.4e\n", sigma2, err[3])
printf("   x0 = %5.4e +/- %5.4e\n", x02, err[2])
printf("  amp = %5.4e +/- %5.4e\n", amp2, err[1])
printf("   y0 = %5.4e +/- %5.4e\n", y02, err[0])
#!/usr/bin/env ruby
require("gsl")

N = 100

y0 = 1.0
A = 2.0
x0 = 3.0
w = 0.5

r = GSL::Rng.alloc()
x = GSL::Vector.linspace(0.01, 10, N)
sig = 1
y =  y0 + A*GSL::Sf::exp(-GSL::pow_2(GSL::Sf::log(x/x0)/w)) + 0.1*GSL::Ran::gaussian(r, sig, N)

coef, err, chi2, dof = GSL::MultiFit::FdfSolver.fit(x, y, "lognormal", [0, 3, 2, 1])
y0 = coef[0]
amp = coef[1]
x0 = coef[2]
w = coef[3]

p coef
p err

GSL::graph(x, y, y0+amp*GSL::Sf::exp(-GSL::pow_2(GSL::Sf::log(x/x0)/w)))

#!/usr/bin/env ruby
require("gsl")

FFF = GSL::Function.alloc { |t, params|
  a = params[0]; lambda = params[1]; b = params[2]
  a*Math::exp(-lambda*t) + b
}

procf = Proc.new { |x, t, y, sigma, f|
  a = x[0]; lambda = x[1]; b = x[2]
  FFF.set_params(x)
  n = t.size
  for i in 0...n do
    yi = FFF.eval(t[i])
    f[i] = (yi - y[i])/sigma[i]
  end
}

procdf = Proc.new { |x, t, y, sigma, jac|
  a = x[0]; lambda = x[1]
  n = t.size
  for i in 0...n do
    ti = t[i]
    si = sigma[i]
    ei = Math::exp(-lambda*ti)
    jac[i,0] = ei/si
    jac[i,1] = -ti*a*ei/si
    jac[i,2] = 1.0/si
  end
}

n = 20
np = 3

f = GSL::MultiFit::Function_fdf.alloc(procf, procdf, np)

r = GSL::Rng.alloc()
t = GSL::Vector.alloc(n)
y = GSL::Vector.alloc(n)
sigma = GSL::Vector.alloc(n)
File.open("expdata.dat", "w") do |fp|
  for i in 0...n do
    t[i] = i
    y[i] = 1.0 + 5*Math::exp(-0.1*t[i]) + r.gaussian(0.2)
    sigma[i] = 0.2
    fp.printf("%d %g %g\n", t[i], y[i], sigma[i])
#    fp.printf("%d %g\n", t[i], y[i])
  end
end

f.set_data(t, y, sigma)
x = GSL::Vector.alloc([1.0, 0.0, 0.0])

solver = GSL::MultiFit::FdfSolver.alloc(GSL::MultiFit::FdfSolver::LMSDER, n, np)
#solver = GSL::MultiFit::FdfSolver.alloc(GSL::MultiFit::FdfSolver::LMDER, n, np)
solver.set(f, x)

iter = 0
solver.print_state(iter)
begin
  iter += 1
  status = solver.iterate
  solver.print_state(iter)
  status = solver.test_delta(1e-4, 1e-4)
end while status == GSL::CONTINUE and iter < 500

covar = solver.covar(0.0)
position = solver.position

chi2 = GSL::pow_2(solver.f.dnrm2)
dof = n - np
printf("A      = %.5f +/- %.5f\n", position[0], Math::sqrt(chi2/dof*covar[0,0]))
printf("lambda = %.5f +/- %.5f\n", position[1], Math::sqrt(chi2/dof*covar[1,1]))
printf("b      = %.5f +/- %.5f\n", position[2], Math::sqrt(chi2/dof*covar[2,2]))

str = sprintf("%4.3f*exp(-%4.3f*x)+%4.3f", position[0], position[1], position[2])

FFF.set_params(position)
x = 0
File.open("fit.dat", "w") do |f|
  while x < 40
    f.printf("%e %e\n", x, FFF.eval(x))
    x += 0.1
  end
end

system("graph -T X -C -g 3 -L '#{str}' -X x -I e -m -1 -S 4 expdata.dat -I a -m 2 -S 0 fit.dat")
#File.delete("expdata.dat")
#File.delete("fit.dat")
#!/usr/bin/env ruby
require("gsl")
include Math

def ran_power_law(slope, range, rng)
  x = rng.uniform
  xmin = GSL::pow(10.0, range*(1.0 + slope));
  x2 = (1 - xmin)*x + xmin;
  return GSL::pow(x2, 1.0/(1+slope));
end

h = GSL::Histogram.alloc(19, [1, 20])
rng = GSL::Rng.alloc
for i in 0..5000
  x = ran_power_law(-3.2, 1000, rng)
  h.increment(x)
end

result = h.fit_power
x = GSL::Vector.logspace2(1, 20, 19)
y = result[0]*GSL::pow(x, result[1])
GSL::graph(h, [x, y], "-l x -l y -x 1 20 -y 1 10000 -C -g 3")

puts("Expected power index: -3.2")
printf("Estimated power index: %5.4f +/- %5.4f\n", result[1], result[3])
#!/usr/bin/env ruby
require("gsl")

NDATA = 1000
NBINS = 100
MAX = 8

rng = GSL::Rng.alloc()
data = GSL::Ran.gaussian(rng, 1.0, NDATA) + 2
h = GSL::Histogram.alloc(NBINS, [-MAX, MAX])
h.fill(data)

hpdf = GSL::Histogram::Pdf.alloc(h)

rng2 = GSL::Rng.alloc()
h2 = GSL::Histogram.alloc(NBINS, [-MAX, MAX])
NDATA2 = 10000
for i in 0...NDATA2 do
  val = hpdf.sample(rng2.uniform())
  h2.fill(val)
end

GSL::graph(h, h2)

sum = h.sum()      # NDATA
sum2 = h2.sum()    # NDATA2
GSL::graph(h, h2.scale(sum/sum2))
#!/usr/bin/env ruby
# This is equivalent to the gsl-histogram program

require("gsl")
require("getopts")

getopts(nil, "DISPLAY_STATS")

case ARGV.size
when 2
  a = ARGV[0].to_f
  b = ARGV[1].to_f
  n = (b - a).to_i
when 3
  a = ARGV[0].to_f
  b = ARGV[1].to_f
  n = ARGV[2].to_i
else
  puts("Usage: : gsl-histogram.rb [--DISPLAY_STATS] xmin xmax [n]")
  puts("Computes a histogram of the data on stdin using n bins from xmin to xmax.")
  puts("If n is unspecified then bins of integer width are used.")
  exit
end

h = GSL::Histogram.alloc(n)
h.set_ranges_uniform(a, b)

while line = STDIN.gets
  x = line.chomp.split[0].to_f
  h.increment(x)
end

if $OPT_DISPLAY_STATS
  printf("# mean = %g\n", h.mean)
  printf("# sigma = %g\n", h.sigma)
end

h.fprintf(STDOUT, "%g", "%g")

exit
#!/usr/bin/env ruby
require("gsl")

N = 10000
BINS = 100

rng1 = GSL::Rng.alloc(2)

h = GSL::Histogram.alloc(BINS, [-5, 5])

for i in 0...N do
  r1 = rng1.gaussian
  h.increment(r1)
end

# Integrate: cumulative distribution
hi = h.integrate

a = hi.diff

# Scale the histograms to ~ 1 at the maximum (to display together)
h.scale!(1.0/h[BINS/2])
a.scale!(1.0/a[BINS/2])

hi.normalize!                  # this is equivalent to hi.scale(1.0/hi[BINS-1])

GSL::graph(h, hi,a,  "-T X -C -g 3")

#!/usr/bin/env ruby
require("gsl")

N = 5000
BINS = 50
rng = GSL::Rng.alloc(1)

h = GSL::Histogram3d.alloc(BINS, [-5, 5], BINS, [-4, 8], BINS, [-8, 3])
sig1 = 1
sig2 = 2
sig3 = 1.3

for i in 0...N do
  r1 = rng.gaussian(sig1) + 1
  r2 = rng.gaussian(sig2) + 1.5
  r3 = rng.gaussian(sig3) - 2
  h.increment(r1, r2, r3)
end

hxy = h.xyproject
h1 = hxy.xproject
h2 = hxy.yproject
hxz = h.xzproject
h3 = hxz.yproject

x = GSL::Vector.linspace(-7, 7, 100)
a = h1.fit_gaussian   # a[0]: sigma, a[1]: mean, a[2]: height
y1 = a[2]*GSL::Ran::gaussian_pdf(x-a[1], a[0])
a = h2.fit_gaussian   # a[0]: sigma, a[1]: mean, a[2]: height
y2 = a[2]*GSL::Ran::gaussian_pdf(x-a[1], a[0])
a = h3.fit_gaussian   # a[0]: sigma, a[1]: mean, a[2]: height
y3 = a[2]*GSL::Ran::gaussian_pdf(x-a[1], a[0])

GSL::graph(h1, h2, h3, [x, y1], [x, y2], [x, y3])
#!/usr/bin/env ruby
require("gsl")
N = 10000
BINS = 100

rng = GSL::Rng.alloc("mt19937", 123456)

h2 = GSL::Histogram2d.alloc(BINS, [-8, 8], BINS, [-8, 8])

sig1 = 0.8
sig2 = 2.0

for i in 0...N do
  r1 = rng.gaussian(sig1) + 2.5
  r2 = rng.gaussian(sig2) - 1
  h2.increment(r1, r2)
end

hx = h2.xproject
hy = h2.yproject
printf("%f %f %f %f\n", h2.xmean, h2.ymean, hx.mean, hy.mean)
printf("%f %f %f %f\n", h2.xsigma, h2.ysigma, hx.sigma, hy.sigma)

x = GSL::Vector.linspace(-8, 8, 100)
result = hx.fit_gaussian
y1 = result[2]*GSL::Ran::gaussian_pdf(x-result[1], result[0])
result = hy.fit_gaussian
y2 = result[2]*GSL::Ran::gaussian_pdf(x-result[1], result[0])
GSL::graph(hx, hy, [x, y1], [x, y2], "-T X -C -g 3")


#!/usr/bin/env ruby
require("gsl")

N = 10000
rng = GSL::Rng.alloc
data = rng.exponential(2, N)
h = GSL::Histogram.alloc(100, [0, 15])
h.fill(data)

#result = h.fit_exponential
result = h.fit("exponential")
a = result[0]
b = result[1]

x = GSL::Vector.linspace(0, 15, 100)
y = a*GSL::Sf::exp(x*b)
GSL::graph(h, [x, y], "-C -g 3")


#!/usr/bin/env ruby
require("gsl")

h = GSL::Histogram.alloc(100, [-4, 4])

rng = GSL::Rng.alloc
for i in 0..10000 do
  h.increment(rng.gaussian)
end

h2 = h.rebin
h5 = h.rebin(5)
h7 = h.rebin(7)

printf("%d %d %d %d\n", h.n, h2.n, h5.n, h7.n)
printf("%f %f %f %f\n", h.sigma, h2.sigma, h5.sigma, h7.sigma)
GSL::graph(h, h2, h5, h7, "-T X -C -g 3 -x -4 4")
#!/usr/bin/env ruby
require("gsl")

h = GSL::Histogram.alloc(5)
p h
p h.size

h.set_ranges([1, 5, 23, 45, 67, 89])
p h.range

h.set_ranges_uniform(0.0, 100)
p h.range
p h.get_range(3)
p h.max
p h.bins
p h.find(55)

#File.open("smp.dat") do |f|
#  h.fscanf(f)
#end

h.fscanf("smp.dat")

p h.max_val
p h.max_bin

#!/usr/bin/env ruby
require("gsl")
GSL::Rng.env_setup()

N = 10000
rng = GSL::Rng.alloc

h = GSL::Histogram.alloc(20, [0, 20])

=begin
for i in 0...N do
  r = rng.poisson(5)
#  r = GSL::Ran::poisson(rng, 5)
  h.increment(r)
end
=end

v = rng.poisson(5, N)
h.fill(v)

h.normalize!
x = GSL::Vector.linspace(0, 20, 100)
y = GSL::Ran::poisson_pdf(x, 5)
GSL::graph(h, [x, y], "-C -g 3 -L 'Poisson distribution, mu = 5'")



#!/usr/bin/env ruby
require("gsl")

N = 10000
rng = GSL::Rng.alloc
data = rng.gamma(2, 1.5, N)
h = GSL::Histogram.alloc(100, [0, 15])
h.fill(data)
p h.bin

#result = h.fit_exponential
result = h.fit("xexp")
b = result[0]
amp = result[1]
p amp
p 1.0/b
x = GSL::Vector.linspace(0, 15, 100)
y = amp*x*GSL::Sf::exp(-x*b)
GSL::graph(h, [x, y], "-C -g 3")


#!/usr/bin/env ruby
require("gsl")

N = 10000
MAX = 8
rng = GSL::Rng.alloc(2)

data = GSL::Ran.gaussian(rng, 1.5, N) + 2
h = GSL::Histogram.alloc(100, [-MAX, MAX])
h.increment(data)

sigma, mean, height, = h.fit_gaussian

x = GSL::Vector.linspace(-MAX, MAX, 100)
y = height*GSL::Ran::gaussian_pdf(x-mean, sigma)
GSL::graph(h, [x, y], "-T X -C -g 3")
#!/usr/bin/env ruby
# Usage from command line:
#  % gsl-randist 0 10000 cauchy 30 | ./hist1d.rb -100 100 200

require("gsl")

if ARGV.size != 3
  puts("Usage: gsl-histogram xmin xmax n")
  puts("  Computes a histogram of the data")
  puts("  on stdin using n bins from xmin to xmax")
end

a = ARGV.shift.to_f
b = ARGV.shift.to_f
n = ARGV.shift.to_i

h = GSL::Histogram.alloc(n, a, b)

while line = STDIN.gets
  x = line.chomp.to_f
  h.increment(x)
end

h.graph("-C -g 3 -L 'gsl-randist 0 10000 cauchy 30'")



#!/usr/bin/env ruby
require("gsl")

p GSL::pow_int(8, 3)
p 8*8*8.0

p GSL::pow_2(2)
p GSL::pow_3(2)
p GSL::pow_4(2)
p GSL::pow_5(2)
p GSL::pow_6(2)
p GSL::pow_7(2)
p GSL::pow_8(2)
p GSL::pow_9(2)

p GSL::pow(3.2, 4.5)
p GSL::pow([1, 2, 3, 4, 5], 3)
p GSL::pow(GSL::Vector[1, 2, 3, 4, 5], 3)
#!/usr/bin/env ruby
require("gsl")
include GSL

puts("GSL_POSINF")
p GSL::POSINF
p GSL::POSINF.class
p isinf(GSL::POSINF)
p isinf?(GSL::POSINF)
p isnan(GSL::POSINF)
p isnan?(GSL::POSINF)
p finite(GSL::POSINF)
p finite?(GSL::POSINF)

puts("GSL_NEGINF")
p GSL::NEGINF
p GSL::NEGINF.class
p isinf(GSL::NEGINF)
p isinf?(GSL::NEGINF)
p isnan(GSL::NEGINF)
p isnan?(GSL::NEGINF)
p finite(GSL::NEGINF)
p finite?(GSL::NEGINF)

puts("GSL_NAN")
p GSL::NAN
p GSL::NAN.class
p isinf(GSL::NAN)
p isinf?(GSL::NAN)
p isnan(GSL::NAN)
p isnan?(GSL::NAN)
p finite(GSL::NAN)
p finite?(GSL::NAN
)
#!/usr/bin/env ruby
require("gsl")

puts("gsl_log1p")
p GSL::log1p(0.1)

a = GSL::Vector.alloc(0.1, 1, 2, 3, 4)
p GSL::log1p(a)

b = GSL::Matrix.alloc([1, 2], [3, 4])
p GSL::log1p(b)
exit

puts("gsl_expm1")
p GSL::expm1(0.1)
p Math::exp(0.1) - 1.0

puts("gsl_hypot")
p GSL::hypot(20000, 30000)
p Math::sqrt(20000*20000 + 30000*30000)

puts("gsl_acosh")
p GSL::acosh(1.5)
p Math::acosh(1.5)

puts("gsl_asinh")
p GSL::asinh(1.5)
p Math::asinh(1.5)

puts("gsl_atanh")
p GSL::atanh(0.5)
p Math::atanh(0.5)

puts("gsl_ldexp")
p GSL::ldexp(1.5, 8)
p Math::ldexp(1.5, 8)

puts("gsl_frexp")
p GSL::frexp(100)
p Math::frexp(100)

#!/usr/bin/env ruby
require("gsl")

p GSL::MAX(1, 2)
p GSL::MAX(1, 2.0)
p GSL::MAX(3, 1)
p GSL::MAX(3.0, 1)

p GSL::MIN(1, 2)
p GSL::MIN(1.0, 2.0)
p GSL::MIN(3, 1.0)
p GSL::MIN(3.0, 1)

p GSL::MAX_INT(5, 6)
p GSL::MAX_INT(5, 6.0)
p GSL::MAX_INT(6, 5)
p GSL::MAX_INT(6.0, 5)

p GSL::MIN_INT(2, 2)
p GSL::MIN_INT(2.0, 2.0)
p GSL::MIN_INT(7, 2.0)
p GSL::MIN_INT(7.0, 2)
#!/usr/bin/env ruby
require("gsl")

puts("gsl_log1p")
p GSL::log1p(0.1)
p Math::log(1 + 0.1)

puts("gsl_expm1")
p GSL::expm1(0.1)
p Math::exp(0.1) - 1.0

puts("gsl_hypot")
p GSL::hypot(20000, 30000)
p Math::sqrt(20000*20000 + 30000*30000)

puts("gsl_acosh")
p GSL::acosh(1.5)
p Math::acosh(1.5)

puts("gsl_asinh")
p GSL::asinh(1.5)
p Math::asinh(1.5)

puts("gsl_atanh")
p GSL::atanh(0.5)
p Math::atanh(0.5)

puts("gsl_ldexp")
p GSL::ldexp(1.5, 8)
p Math::ldexp(1.5, 8)

puts("gsl_frexp")
p GSL::frexp(100)
p Math::frexp(100)

#!/usr/bin/env ruby
require("gsl")

puts("sign of 5.0")
p GSL::SIGN(5.0)

puts("sign of -2.0")
p GSL::SIGN(-2.0)

puts("sign of 0: positive")
p GSL::SIGN(0)

puts("Is 1 odd?")
p GSL::IS_ODD(1)
p GSL::IS_ODD?(1)
puts("Is 1 even?")
p GSL::IS_EVEN(1)
p GSL::IS_EVEN?(1)

puts("Is 4 odd?")
p GSL::IS_ODD(4)
p GSL::IS_ODD?(4)
puts("Is 4 even?")
p GSL::IS_EVEN(4)
p GSL::IS_EVEN?(4)

puts("frcmp")

p GSL::fcmp(1.0, 1.0, 1e-10)
p GSL::fcmp(1.1, 1.0, 1e-10)
p GSL::fcmp(1.0, 1.1, 1e-10)
#!/usr/bin/env ruby
require("gsl")
include GSL

puts("e")
p GSL::M_E
p Math::exp(1)


puts("log10(e)")
p GSL::M_LOG10E
p Math::log10(M_E)

puts("sqrt(2)")
p GSL::M_SQRT2
p Math::sqrt(2)

puts("sqrt(1/2)")
p GSL::M_SQRT1_2
p Math::sqrt(1.0/2)

puts("sqrt(3)")
p GSL::M_SQRT3
p Math::sqrt(3)

puts("pi")
p GSL::M_PI
p Math::PI

puts("pi/2")
p GSL::M_PI_2
p Math::PI/2.0

puts("pi/4")
p GSL::M_PI_4
p Math::PI/4.0

puts("sqrt(pi)")
p GSL::M_SQRTPI
p Math::sqrt(Math::PI)

puts("2/sqrt(pi)")
p GSL::M_2_SQRTPI
p 2.0/Math::sqrt(Math::PI)

puts("1/pi")
p GSL::M_1_PI
p 1.0/Math::PI

puts("2/pi")
p GSL::M_2_PI
p 2.0/Math::PI

puts("ln10")
p GSL::M_LN10
p Math::log(10)

puts("ln2")
p GSL::M_LN2
p Math::log(2)

puts("ln(pi)")
p GSL::M_LNPI
p Math::log(Math::PI)

puts("euler constant 0.5772156...")
p GSL::M_EULER
#!/usr/bin/env ruby
require("gsl")

data =  GSL::Vector[17.2, 18.1, 16.5, 18.3, 12.6]
mean     = data.mean()
variance = data.variance()
largest  = data.max()
smallest = data.min()

printf("The dataset is %g, %g, %g, %g, %g\n",
        data[0], data[1], data[2], data[3], data[4]);

printf("The sample mean is %g\n", mean);
printf("The estimated variance is %g\n", variance);
printf("The largest value is %g\n", largest);
printf("The smallest value is %g\n", smallest);

p data.stats_sd
#!/usr/bin/env ruby
require("gsl")

N = 100000
rng = GSL::Rng.alloc

v = rng.gaussian(2, N)

p v.mean
p v.variance
p v.sd

p v.variance_m(0)
p v.sd_m(0)

p v.variance_with_fixed_mean(0)
p v.sd_with_fixed_mean(0)
#!/usr/bin/env ruby
require("gsl")

v = GSL::Vector.alloc([17.2, 18.1, 16.5, 18.3, 12.6])
p GSL::Stats.mean(v)
p GSL::Stats.variance(v)
p GSL::Stats.sd(v)
p GSL::Stats.max(v)
p GSL::Stats.min(v)
#!/usr/bin/env ruby
require("gsl")
include GSL
include Linalg

m = Matrix::alloc([0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                  [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85])
m.print

lu, perm = m.LU_decomp

b = [1, 2, 3, 4]
x = Vector.alloc(4)

p m.class

p LU.solve(lu, perm, b)
LU.solve(lu, perm, b, x)
p x
p LU.solve(m, b)
LU.solve(m, b, x)
p x

LU.solve(m, perm, b, x)
p x

bv = b.to_gv
LU.svx(m, perm, bv)
p bv

m.print
#!/usr/bin/env ruby
require("gsl")
include GSL
include Linalg

m = Matrix::alloc([0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                  [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85])
m.print

lu, perm = m.LU_decomp
m.print
lu.print

b = Vector[1, 2, 3, 4]
x = LU.solve(lu, perm, b)
x = LU.solve(lu, perm, b)
p x
p m

p m.LU_solve(b)
p m.LU_solve(perm, b)
p m.LU_solve(perm, b, x)
p lu.LU_solve(perm, b, x)

p x
LU.refine(m, lu, perm, b, x)
p x

#p b
#m.LU_svx(b)
#p b
#LU.svx(lu, perm, b)
#p b
#p m.LU_solve(perm, b)
#p m.LU_solve(perm, b, x)
#p lu.LU_solve(perm, b, x)

#exit

LU.svx(lu, perm, b)
p b

p m*x.col

b = [1, 2, 3, 4].to_gv
p LU.solve(m, b)

puts("")

m2 = Matrix.alloc([1, 2, 3, 6, 5, 4, 7, 8, 1], 3, 3)
m2.print
lu2, p2, sign = m2.LU_decomp

m3 = Matrix.alloc([1, 2, 3, 4, 5, 6, 7, 8, 0], 3, 3)
m3.print
lu, perm = m3.LU_decomp
LU.invert(lu, perm).print
p m3.class
p lu.class
m4 = m3.invert
LU.invert(m3).print
p m4.invert
p m3.invert.invert.invert

p m2.det
p lu2.det(p2, sign)
p m2.det(p2)

p LU.det(m2)

p LU.lndet(m2)
p LU.lndet(lu2)
p m2.lndet
p lu2.lndet

p LU.sgndet(m2)
p LU.sgndet(lu2, sign)
p m2.sgndet
p lu2.sgndet(sign)

p m
p m/b.col

__END__
#!/usr/bin/env ruby
require("gsl")
include GSL
include GSL::Linalg

m = GSL::Matrix[[0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85]]

b = Vector.alloc(1, 2, 3, 4)
p HH.solve(m, b)

p m.HH_solve(b)

m.HH_svx(b)
p b
#!/usr/bin/env ruby
require("gsl")
include GSL

m = Matrix[[-2, 1, 1], [1, -2, 1], [1, 1, -2], [-2, 1, 1]]
u, v, s = m.SV_decomp
p u.class
p v.class
p s.class

m2 = Matrix[[5, 6, 8, 4], [6, 2, 4, 2], [8, 2, 3, 5], [1, 7, 2, 3]]
u2, v2, s2 = m2.SV_decomp
p u2
p v2
p s2

m = GSL::Matrix[[0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85]]

u, v, s = Linalg::SV.decomp_jacobi(m)

b = [1, 2, 3, 4].to_gv

p Linalg::SV.solve(u, v, s, b)
p Linalg::SV.solve(u, v, s, [1, 2, 3, 4])

puts "OK"
p m.SV_solve(b)
p Linalg::SV.solve(m, b)

####
A = Matrix[1..4, 2, 2]
I = Matrix.identity(2)
Ainv = A.inv

u, v, s = A.SV_decomp
sm = s.to_m_diagonal
sinv = s.collect { |elm| 1.0/elm }.to_m_diagonal
a = u*sm*v.trans
ainv = v*sinv*u.trans
p a == A
p ainv == Ainv
p (u.trans*u) == I
p (v.trans*v) == I
p A*v == u*sm
p A.trans*u == v*sm



#!/usr/bin/env ruby
require("gsl")
include GSL

m = Matrix::alloc([0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                  [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85])
m.transpose!
lq, tau = m.PTLQ_decomp
p lq.class
p tau.class

b = Vector[1, 2, 3, 4]

lq, tau, p = m.PTLQ_decomp

p Linalg::PTLQ.solve_T(lq, tau, p, b)
p Linalg::PTLQ.solve_T(m, b)
p m.PTLQ_solve_T(b)
p lq.PTLQ_solve_T(tau, p, b)
p m.PTLQ_solve_T(b)

bb = b.clone
p Linalg::PTLQ.solve_T(lq, tau, p, bb)
bb = b.clone
p Linalg::PTLQ.solve_T(m, bb)
bb = b.clone
p m.PTLQ_solve_T(b)
bb = b.clone
p lq.PTLQ_solve_T(tau, p, bb)
bb = b.clone
p m.PTLQ_solve_T(bb)
bb = b.clone
p lq.class
p lq.solve_T(tau, p, bb)

q, l, tau, p = m.PTLQ_decomp2
p q.class
p l.class

p Linalg::PTLQ.LQsolve_T(q, l, p, b)

bb = b.clone
lq.svx_T(tau, p, bb)
p bb
bb = b.clone
m.PTLQ_svx_T(bb)
p bb
#!/usr/bin/env ruby
require("gsl")
include GSL
include Linalg

m = Matrix.alloc([4, 2], [2, 3])
c = Cholesky.decomp(m)
p c.class
p c

b = Vector[1, 2]
p Cholesky.solve(c, b)    # Expected [-0.125, 0.75]

begin
  m = Matrix::alloc([0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                  [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85])

  c = Cholesky.decomp(m)
  b = [1, 2, 3, 4].to_gv
  p Cholesky.solve(c, b)
rescue
  puts("Matrix must be positive definite.")
end

m = Matrix.pascal(6)
c = m.cholesky_decomp
a = c.lower
p (a*a.trans) == m

#!/usr/bin/env ruby
require("gsl")
include GSL::Linalg

m = NMatrix[[0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
            [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85]]

b = NVector[1.0, 2, 3, 4]
p HH.solve(m, b)
p b
HH.svx(m, b)
p b

#!/usr/bin/env ruby
require("gsl")
include GSL

m = NMatrix[[0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
            [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85]]

u, v, s = Linalg::SV.decomp(m)

puts "u ->"
p u

puts "v ->"
p v

puts "s ->"
p s

b = NArray[1.0, 2, 3, 4]

puts "solved ->"
p Linalg::SV.solve(u, v, s, b)
#!/usr/bin/env ruby
require("gsl")
include GSL

na = NArray[[1.0, 4], [2, 3]]
lu, perm, signum = Linalg::LU.decomp(na)

inv = Linalg::LU.invert(lu, perm)
p inv

#!/usr/bin/env ruby
require("gsl")
include GSL
include Linalg

m = Matrix::alloc([0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                  [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85])
m.inv.print
p m.det

#lu, perm = m.LU_decomp
#LU.invert(lu, perm).print
#p lu.det

zm = Matrix::Complex.alloc(4, 4)

zm.set_row(0, [0.18, 0], [0.60, 0], [0.57, 0], [0.96, 0])
zm.set_row(1, [0.41, 0], [0.24, 0], [0.99, 0], [0.58, 0])
zm.set_row(2, [0.14, 0], [0.30, 0], [0.97, 0], [0.66, 0])
zm.set_row(3, [0.51, 0], [0.13, 0], [0.19, 0], [0.85, 0])

p zm.inv
p zm.det

b = Vector::Complex.alloc(4)
b.set(1.0, 2, 3, 4)

#p zm.LU_solve(b)

#lu2, perm2, signum = zm.LU_decomp
lu2, perm2, signum = LU::decomp(zm)
p lu2
p lu2.det(signum)

p x = lu2.solve(perm2, b)

p zm*x

p lu2.LU_invert(perm2)
p lu2.LU_det(signum)

#p zm.LU_svx(b)

p Linalg::Complex::LU_invert(zm)
p Linalg::Complex::LU::invert(zm)
p Linalg::Complex::LU_invert(lu2, perm2)
p Linalg::Complex::LU::invert(lu2, perm2)
p zm.invert
p lu2.invert(perm2)

p Linalg::Complex::LU_det(zm)
p Linalg::Complex::LU::det(zm)
p Linalg::Complex::LU_det(lu2, signum)
p Linalg::Complex::LU::det(lu2, signum)
p zm.det
p lu2.det(signum)

#!/usr/bin/env ruby
require("gsl")
include GSL

m = GSL::Matrix::alloc([0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
        [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85])
m.transpose!
lq, tau = m.LQ_decomp

b = Vector[1, 2, 3, 4]

lq, tau = m.LQ_decomp

p Linalg::LQ.solve_T(lq, tau, b)
p Linalg::LQ.solve_T(m, tau, b)
p Linalg::LQ.solve_T(m, b)

begin
  p Linalg::LQ.solve_T(lq, b)    # Error
rescue
  puts("Error Linalg::LQ.solve_T(lq, b)")
end

x = Vector.alloc(4)
p m.LQ_solve_T(b)
p m.LQ_solve_T(tau, b)
p lq.LQ_solve_T(tau, b)
p lq.class
p lq.solve_T(tau, b)

m.LQ_solve_T(b, x)
p x
m.LQ_solve_T(tau, b, x)
p x
lq.LQ_solve_T(tau, b, x)
p x
lq.solve_T(tau, b, x)
p x

bb = b.clone
lq.svx_T(tau, bb)
p bb
bb = b.clone
m.LQ_svx_T(bb)
p bb

bb = b.clone
Linalg::LQ.svx_T(m, bb)
p bb
bb = b.clone
Linalg::LQ.svx_T(lq, tau, bb)
p bb

p m.LQ_lssolve_T(b)
p m.LQ_lssolve_T(tau, b)
p lq.LQ_lssolve_T(tau, b)
p lq.lssolve_T(tau, b)

p Linalg::LQ.lssolve_T(m, b)
p Linalg::LQ.lssolve_T(lq, tau, b)

m3 = Matrix.alloc([5, 4, 1, 1], [4, 5, 1, 1], [1, 1, 4, 2], [1, 1, 2, 4])
m3.transpose!
lq, tau = m3.LQ_decomp

q, l = lq.unpack(tau)

q, l = Linalg::LQ.unpack(lq, tau)

lq, tau = m.LQ_decomp
q, l = Linalg::LQ.unpack(lq, tau)
p Linalg::LQ.LQsolve_T(q, l, b)

#!/usr/bin/env ruby
require("gsl")
include GSL

m = Matrix[[0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
           [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85]]
p m
qr, tau = m.QR_decomp
p qr.class
p tau.class

q, r = qr.unpack(tau)
p q.class
p r.class
p q*r
p q*q.trans   # Q: orthonormal


#!/usr/bin/env ruby
require("gsl")
require 'narray'
include GSL

m = NMatrix[[0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
           [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85]]
qr, tau = Linalg::QR.decomp(m)

p qr, tau

b = NVector[1.0, 2, 3, 4]

p Linalg::QR.solve(qr, tau, b)#!/usr/bin/env ruby
require("gsl")

A = GSL::Matrix[[3, 5, 2], [6, 2, 1], [4, 7, 3]]
p A
u, v, s = A.SV_decomp
p u.class
p v.class
p s.class

# u and v are orthonormal
p u*u.trans
p v*v.trans

# Reconstruct the matrix A from u, v, and s.
p u*GSL::Matrix.diagonal(s)*v.trans
#!/usr/bin/env ruby
require("gsl")
include GSL


m = Matrix::alloc([0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                  [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85])
qr, tau = m.QRPT_decomp
p qr.class
p tau.class

b = Vector.alloc([1, 2, 3, 4])

qr, tau, p = m.QRPT_decomp

p Linalg::QRPT.solve(qr, tau, p, b)
p Linalg::QRPT.solve(m, b)
p m.QRPT_solve(b)
p qr.QRPT_solve(tau, p, b)
p m.QRPT_solve(b)

bb = b.clone
p Linalg::QRPT.solve(qr, tau, p, bb)
bb = b.clone
p Linalg::QRPT.solve(m, bb)
bb = b.clone
p m.QRPT_solve(b)
bb = b.clone
p qr.QRPT_solve(tau, p, bb)
bb = b.clone
p m.QRPT_solve(bb)
bb = b.clone
p qr.class
p qr.solve(tau, p, bb)

q, r, tau, p = m.QRPT_decomp2
p q.class
p r.class

p Linalg::QRPT.QRsolve(q, r, p, b)

bb = b.clone
qr.svx(tau, p, bb)
p bb
bb = b.clone
m.QRPT_svx(bb)
p bb
#!/usr/bin/env ruby
require("gsl")
include GSL

m = Matrix[[0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
           [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85]]
qr, tau = m.QR_decomp

b = Vector[1, 2, 3, 4]

qr, tau = m.QR_decomp

p Linalg::QR.solve(qr, tau, b)
p Linalg::QR.solve(m, tau, b)
p Linalg::QR.solve(m, b)
begin
  p Linalg::QR.solve(qr, b)    # Error
rescue
  puts("Error Linalg::QR.solve(qr, b)")
end

x = Vector.alloc(4)
p m.QR_solve(b)
p m.QR_solve(tau, b)
p qr.QR_solve(tau, b)
p qr.class
p qr.solve(tau, b)

m.QR_solve(b, x)
p x
m.QR_solve(tau, b, x)
p x
qr.QR_solve(tau, b, x)
p x
qr.solve(tau, b, x)
p x

bb = b.clone
qr.svx(tau, bb)
p bb
bb = b.clone
m.QR_svx(bb)
p bb

bb = b.clone
Linalg::QR.svx(m, bb)
p bb
bb = b.clone
Linalg::QR.svx(qr, tau, bb)
p bb

p m.QR_lssolve(b)
p m.QR_lssolve(tau, b)
p qr.QR_lssolve(tau, b)
p qr.lssolve(tau, b)

p Linalg::QR.lssolve(m, b)
p Linalg::QR.lssolve(qr, tau, b)

m3 = Matrix.alloc([5, 4, 1, 1], [4, 5, 1, 1], [1, 1, 4, 2], [1, 1, 2, 4])
qr, tau = m3.QR_decomp
p qr
p tau

q, r = qr.unpack(tau)
p q
p r
p q*r

q, r = Linalg::QR.unpack(qr, tau)
p q
p r
p q*r

qr, tau = m.QR_decomp
q, r = Linalg::QR.unpack(qr, tau)
p Linalg::QR.QRsolve(q, r, b)
exit
#!/usr/bin/env ruby
require("gsl")
include GSL
include Linalg

m = NArray[[4.0, 2], [2, 3]]
c = Cholesky.decomp(m)
puts "decomp ->"
p c

b = NArray[1.0, 2]
puts "solve ->"
p Cholesky.solve(c, b)    # Expected [-0.125, 0.75]

b = NArray[1.0, 2]
Cholesky.svx(c, b)
puts "svx ->"
p b
#!/usr/bin/env ruby
require("gsl")
include GSL
include Linalg

m = NArray[[0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
           [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85]]
b = NArray[1.0, 2, 3, 4]

lu, perm, signum = LU.decomp(m)
p m
p lu

x = LU.solve(lu, perm, b)
p x
p b

LU.svx(lu, perm, b)
p b

m2 = Matrix.alloc([1, 2, 3, 6, 5, 4, 7, 8, 1], 3, 3).to_nmatrix
lu, perm, signum = LU.decomp(m2)
p LU.det(lu, signum)

#!/usr/bin/env ruby
require("gsl")

params = [1.0, 10.0]
func = GSL::MultiRoot::Function.alloc(2, params) { |x, params, f|
  a = params[0]
  b = params[1]
  x0 = x[0]
  x1 = x[1]
  f[0] = a*(1 - x0)
  f[1] = b*(x1 - x0*x0)
}

#fsolver = GSL::MultiRoot::FSolver.alloc("hybrids", 2)
#fsolver = GSL::MultiRoot::FSolver.alloc("hybrid", 2)
#fsolver = GSL::MultiRoot::FSolver.alloc("dallocton", 2)
fsolver = GSL::MultiRoot::FSolver.alloc("broyden", 2)

x = GSL::Vector.alloc(-10.0, -5.0)
fsolver.set(func, x)
#p fsolver.name
#p fsolver.x

iter = 0
begin
  iter += 1
  status = fsolver.iterate
  root = fsolver.root
  f = fsolver.f
  printf("iter = %3u x = % .3f % .3f f(x) = % .3e % .3e\n",
          iter, root[0], root[1], f[0], f[1])
  status = fsolver.test_residual(1e-7)
end while status == GSL::CONTINUE and iter < 1000
#!/usr/bin/env ruby
require("gsl")

n = 2

procf = Proc.new { |x, params, f|
  a = params[0]
  b = params[1]
  x0 = x[0]
  x1 = x[1]
  f[0] = a*(1 - x0)
  f[1] = b*(x1 - x0*x0)
}

procdf = Proc.new { |x, params, jac|
  a = params[0]
  b = params[1]
  jac[0,0] = -a
  jac[0,1] = 0
  jac[1,0] = -2*b*x[0]
  jac[1,1] = b
}

params = [1.0, 10.0]
f = GSL::MultiRoot::Function_fdf.alloc(procf, procdf, n, params)

fdfsolver = GSL::MultiRoot::FdfSolver.alloc("gnewton", n)
#fdfsolver = GSL::MultiRoot::FdfSolver.alloc("newton", n)
#fdfsolver = GSL::MultiRoot::FdfSolver.alloc("hybridj", n)
#fdfsolver = GSL::MultiRoot::FdfSolver.alloc("hybridsj", n)
p fdfsolver.name

#x = GSL::Vector.alloc(-10.0, -5.0)
x = [-10.0, -5.0]

#p fdfsolver.x

fdfsolver.set(f, x)

iter = 0
begin
  iter += 1
  status = fdfsolver.iterate
  root = fdfsolver.root
  f = fdfsolver.f
  printf("iter = %3u x = % .3f % .3f f(x) = % .3e % .3e\n",
          iter, root[0], root[1], f[0], f[1])
  status = fdfsolver.test_residual(1e-7)
end while status == GSL::CONTINUE and iter < 1000

#!/usr/bin/env ruby
require("gsl")
include Math

# Expected: x0 ~ 0.57983, x1 ~ 2.54621
func = GSL::MultiRoot::Function.alloc(2) { |x, f|
  x0 = x[0]
  x1 = x[1]
  f[0] = -2.0*x0*x0 + 3.0*x0*x1 + 4.0*sin(x1) - 6.0
  f[1] = 3.0*x0*x0 - 2.0*x0*x1*x1 + 3.0*cos(x0) + 4.0
}

p func.solve([1.0, 2.0].to_gv, 1000, 1e-7, "hybrids")
p func.solve([1.0, 2.0].to_gv, 1000, "broyden")
p func.solve([1.0, 2.0], "hybrid")
p func.solve([1.0, 2.0], 2000, "hybrid")
p func.solve([1.0, 2.0])

#fsolver = GSL::MultiRoot::FSolver.alloc("dallocton", 2)
fsolver = GSL::MultiRoot::FSolver.alloc("broyden", 2)

x = GSL::Vector.alloc([1.0, 2.0])
fsolver.set(func, x)

p ans = fsolver.solve()
#ans = MultiRoot::FSolver.solve(fsolver)
#!/usr/bin/env ruby
require("gsl")

params = [1.0, 10.0]
func = GSL::MultiRoot::Function.alloc(2, params) { |x, params, f|
  a = params[0]
  b = params[1]
  x0 = x[0]
  x1 = x[1]
  f[0] = a*(1 - x0)
  f[1] = b*(x1 - x0*x0)
}

fsolver = GSL::MultiRoot::FSolver.alloc("hybrids", 2)
#fsolver = GSL::MultiRoot::FSolver.alloc("hybrid", 2)
#fsolver = GSL::MultiRoot::FSolver.alloc("dallocton", 2)
#fsolver = GSL::MultiRoot::FSolver.alloc("broyden", 2)

x = GSL::Vector.alloc(-10.0, -5.0)
fsolver.set(func, x)
#p fsolver.name
#p fsolver.x

iter = 0
IO.popen("graph -T X -C -g 3 -X x -Y y -S 4", "w") do |io|
  begin
    iter += 1
    status = fsolver.iterate
    root = fsolver.root
    f = fsolver.f
    printf("iter = %3u x = % .3f % .3f f(x) = % .3e % .3e\n",
           iter, root[0], root[1], f[0], f[1])
    io.printf("%e %e\n", root[0], root[1])
    status = fsolver.test_residual(1e-7)
  end while status == GSL::CONTINUE and iter < 1000
end
#!/usr/bin/env ruby
require("gsl")
include Math

# Expected: x0 ~ 0.57983, x1 ~ 2.54621
#   (by Octave)
func = GSL::MultiRoot::Function.alloc(2) { |x, f|
  x0 = x[0]
  x1 = x[1]
  f[0] = -2.0*x0*x0 + 3.0*x0*x1 + 4.0*sin(x1) - 6.0
  f[1] = 3.0*x0*x0 - 2.0*x0*x1*x1 + 3.0*cos(x0) + 4.0
}

#fsolver = GSL::MultiRoot::FSolver.alloc("dallocton", 2)
fsolver = GSL::MultiRoot::FSolver.alloc("broyden", 2)
p fsolver.name

x = GSL::Vector.alloc([1.0, 2.0])
fsolver.set(func, x)

iter = 0
begin
  iter += 1
  status = fsolver.iterate
  root = fsolver.root
  f = fsolver.f
  status = fsolver.test_residual(1e-6)
end while status == GSL::CONTINUE and iter < 1000

x0 = fsolver.root[0]
x1 = fsolver.root[1]
printf("%f %f\n", x0, x1)
#!/usr/bin/env ruby
#  This solves the Saha's equation, to investigate
#  'recombination' of hot cosmic plasma.
require("gsl")
include GSL
include GSL::CONST::CGSM
include Math

KB =  BOLTZMANN
HBAR = PLANCKS_CONSTANT_HBAR

class Recombination
  def initialize(t0, bdensity, eion)
    @t = 2500
    @tCMB = t0                   # Present temperature of CMB [K]
    @n0 = bdensity/MASS_PROTON   # Barion number density [cm-3]
    @eion = eion*ELECTRON_VOLT   # Hydrogen ionization potential [eV]
    @saha_equation = Function.alloc { |x|   # x: fractional ionization
      n = @n0*pow_3(@t/@tCMB)
      tmp1 = pow(MASS_ELECTRON*KB*@t/2.0/PI/HBAR/HBAR, 1.5)
      tmp2 = exp(-@eion/KB/@t)
      x*x - (1.0 - x)*tmp1*tmp2/n
    }
  end

  def zplus1()
    @t/@tCMB
  end

  attr_accessor :t
  attr_reader :saha_equation
end

###########################
## Cosmological parameter
TCMB = 2.725        # Temperature of cosmic microwave background at present [K]
BDENSITY = 1e-29    # Barion density [g cm-3]
EIONIZE = 13.6      # Hydrogen ionization potential [eV]
unv = Recombination.new(TCMB, BDENSITY, EIONIZE)

# FSolver
solver = Root::FSolver.alloc(Root::FSolver::BRENT)

TMIN = 2500
TMAX = 6500

begin
  file = File.open("recombination.dat", "w")
  t = TMIN
  while t < TMAX
    unv.t = t  # Temperature
    x, iter, status = solver.solve(unv.saha_equation, [1e-8, 1.0], [0, 1e-4])
    file.printf("%e %e %e\n", unv.t, unv.zplus1, x)
    t *= 1.01
  end
ensure
  file.close
end
system("gnuplot -persist recombination.gp")
File.delete("recombination.dat")
#puts("Try \"gnuplot -persist recombination.gp\"")
#!/usr/bin/env ruby
require("gsl")
include Math

def f_to_solve(x)
  x*x - 5.0
end

def df_to_solve(x)
  2*x
end

f = Proc.new { |x|
  f_to_solve(x)
}

df = Proc.new { |x|
  df_to_solve(x)
}

expected = sqrt(5.0)
x = 5.0

function_fdf = GSL::Function_fdf.alloc(f, df)

solver = GSL::Root::FdfSolver.alloc(GSL::Root::FdfSolver::STEFFENSON)
puts "using #{solver.name} method"

solver.set(function_fdf, x)

printf("%-5s %10s %10s %10s\n",
          "iter", "root", "err", "err(est)")
iter = 0
status = nil
while status != GSL::SUCCESS
  iter += 1
  status = solver.iterate
  x0 = x
  x = solver.root
  status = GSL::Root::test_delta(x, x0, 0, 1e-3)

  if status == GSL::SUCCESS
    printf("Converged:\n")
  end
  printf("%5d %10.7f %+10.7f %10.7f\n",
         iter, x, x - expected, x - x0)

end
#!/usr/bin/env ruby
require("gsl")
include Math

f = Proc.new { |x, params|
  a = params[0]
  b = params[1]
  c = params[2]
  (a*x + b)*x + c
}

df = Proc.new { |x, params|
  a = params[0]
  b = params[1]
  2.0*a*x + b
}

expected = sqrt(5.0)
x = 5.0

function_fdf = GSL::Function_fdf.alloc(f, df)
function_fdf.set_params([1.0, 0, -5])

solver = GSL::Root::FdfSolver.alloc(GSL::Root::FdfSolver::NEWTON)
puts "using #{solver.name} method"

solver.set(function_fdf, x)

printf("%-5s %10s %10s %10s\n",
          "iter", "root", "err", "err(est)")
iter = 0
status = nil
while status != GSL::SUCCESS
  iter += 1
  status = solver.iterate
  x0 = x
  x = solver.root
  status = GSL::Root::test_delta(x, x0, 0, 1e-3)

  if status == GSL::SUCCESS
    printf("Converged:\n")
  end
  printf("%5d %10.7f %+10.7f %10.7f\n",
         iter, x, x - expected, x - x0)

end
#!/usr/bin/env ruby
require("gsl")
solver = GSL::Root::FSolver.alloc(GSL::Root::FSolver::BISECTION)
puts "Using #{solver.name} method"
f = GSL::Function.alloc { |x, params|
  a = params[0];  b = params[1];  c = params[2]
  (a*x + b)*x + c
}
f.set_params(1, 0, -5)
expected = Math::sqrt(5.0)
printf("%5s [%9s, %9s] %9s %10s %9s\n",
       "iter", "lower", "upper", "root",  "err", "err(est)")
solver.set(f, 0.0, 5.0)
iter = 0
status = nil
while status != GSL::SUCCESS
  iter += 1
  status = solver.iterate
  r = solver.root;  xl = solver.x_lower;  xu = solver.x_upper
  status = solver.test_interval(0, 0.001)
  if status == GSL::SUCCESS; printf("Converged:\n"); end
  printf("%5d [%.7f, %.7f] %.7f %+.7f %.7f\n",
         iter, xl, xu, r, r - expected, xu - xl)
end

#!/usr/bin/env ruby
require("gsl")
solver = GSL::Root::FSolver.alloc(GSL::Root::FSolver::BISECTION)
f = GSL::Function.alloc { |x, params|
  a = params[0]; b = params[1]; c = params[2]
  (a*x + b)*x + c
}
f.set_params(1, 0, -5)
expected = Math::sqrt(5.0)
printf("%5s [%9s, %9s] %9s %10s %9s\n", "iter",
       "lower", "upper", "root", "err", "err(est)")
solver.set(f, 0.0, 5.0)
iter = 0; status = nil
IO.popen("graph -T X -C -g 3 -X Iterations -Y 'Root'\
         --toggle-rotate-y-label\
         -L 'x^2 - 5 = 0, #{solver.name}' -I e -S 4", "w") do |io|
  while status != GSL::SUCCESS
    iter += 1
    status = solver.iterate
    r = solver.root
    xl = solver.x_lower; xu = solver.x_upper
    status = solver.test_interval(0, 0.001)
    if status == GSL::SUCCESS; printf("Converged:\n"); end
    printf("%5d [%.7f, %.7f] %.7f %+.7f %.7f\n",
           iter, xl, xu, r, r - expected, xu - xl)
    io.printf("%d %e %e\n", iter, r, (xu-xl)/2)
  end
end


#!/usr/bin/env ruby
require("gsl")
include Math

#solver = GSL::Root::FSolver.alloc(GSL::Root::FSolver::BISECTION)
#solver = GSL::Root::FSolver.alloc("falsepos")
#solver = GSL::Root::FSolver.alloc("brent")
solver = GSL::Root::FSolver.alloc(GSL::Root::FSolver::BRENT)
puts "using #{solver.name} method"

f = GSL::Function.alloc { |x, params|
  a = params[0]
  b = params[1]
  c = params[2]
  (a*x + b)*x + c
}

f.set_params(1, 0, -5)
expected = sqrt(5.0)

printf("%5s [%9s, %9s] %9s %10s %9s\n",
          "iter", "lower", "upper", "root",
          "err", "err(est)")

solver.set(f, 0.0, 5.0)
iter = 0
status = nil
while status != GSL::SUCCESS
  iter += 1
  status = solver.iterate
  r = solver.root
  xl = solver.x_lower
  xu = solver.x_upper
  status = solver.test_interval(0, 0.001)

  if status == GSL::SUCCESS
    printf("Converged:\n")
  end
  printf("%5d [%.7f, %.7f] %.7f %+.7f %.7f\n",
         iter, xl, xu, r, r - expected, xu - xl)
end

p f.fsolve(0, 5)
#!/usr/bin/env ruby
require("gsl")

exit unless GSL.const_defined?("ALF")

lmax = 3
#w = GSL::ALF::Workspace.alloc(lmax)
#w = GSL::ALF.alloc(lmax)
w = GSL::alf_alloc(lmax)
w.params(0, 0, GSL::ALF::NORM_NONE)


result = GSL::Vector.alloc(GSL::ALF::array_size(lmax))
deriv = GSL::Vector.alloc(GSL::ALF::array_size(lmax))

ind11 = GSL::ALF::array_index(1, 1)
ind21 = GSL::ALF::array_index(2, 1)
ind22 = GSL::ALF::array_index(2, 2)
ind31 = GSL::ALF::array_index(3, 1)

File.open("alf.dat", "w") do |f|
  theta = 0.01
  while theta < 1.99*Math::PI do
    x = Math.cos(theta)
#    w.Plm_deriv_array(lmax, x, result, deriv)
    w.Plm_array(lmax, x, result, deriv)
    f.printf("%e %e %e %e %e\n", theta, result[ind11], result[ind21], result[ind22], result[ind31])
    theta += 0.01
  end
end

system("gnuplot -persist alf.gp")
#!/usr/bin/env ruby
require("gsl")

p = GSL::Permutation::alloc(10)
p.init
p.swap(4, 7)
#p p.to_a
p.print

#p p.inverse.to_a
#p p.next.to_a
#p p.next.to_a
#p p.next.to_a

p.printf("%u \n")

#!/usr/bin/env ruby
require("gsl")

N = 10
pp = GSL::Permutation.alloc(N)
GSL::Rng::env_setup()
r = GSL::Rng.alloc("gsl_rng_default")

puts("initial permutation:")
pp.init
pp.fprintf(STDOUT, " %u")
printf("\n")

puts(" random permutation:");
r.shuffle(pp)
pp.fprintf(STDOUT, " %u")
printf("\n");

puts("inverse permutation:");
q = pp.inverse
q.fprintf(STDOUT, " %u")
printf ("\n");
#!/usr/bin/env ruby
require("gsl")

v = GSL::Vector.alloc(3)
n = GSL::Ntuple.alloc("test.dat", v)

GSL::Rng.env_setup()
r = GSL::Rng.alloc
for i in 0...10000 do
  for j in 0...3 do
    v[j] = r.gaussian()
  end
  n.write
end

puts("Data file test.dat is created.")
puts("Try project.rb.")
#!/usr/bin/env ruby
require("gsl")

sel_func = GSL::Ntuple::SelectFn.alloc { |data, params|
  x = data[0]; y = data[1]; z = data[2]
  scale = params

  e2 = x*x + y*y + z*z
  e2 > scale
}

lower = 1.5
sel_func.set_params(lower)

val_func = GSL::Ntuple::ValueFn.alloc { |data|
  x = data[0]; y = data[1]; z = data[2]
  x*x + y*y + z*z
}

v = GSL::Vector.alloc(3)
n = GSL::Ntuple.open("test.dat", v)

h = GSL::Histogram.alloc(100)
h.set_ranges_uniform(0, 10.0)

#Ntuple.project(h, n, val_func, sel_func)
n.project(h, val_func, sel_func)

h.graph("-C -X 'E2' -Y 'n' -L 'GSL::Ntuple, Select E2 > 1.5'")
File.delete("test.dat")

#!/usr/bin/env ruby
require("gsl")

n = 630
data = GSL::Vector::Complex::alloc(n)

table = GSL::FFT::ComplexWavetable.alloc(n)
space = GSL::FFT::ComplexWorkspace.alloc(n)

data[0] = 1.0
for i in 1..10 do
  data[i]   = GSL::Complex[1.0, 0.0]
  data[n-i] = GSL::Complex[1.0, 0.0]
end

# Select whichever you like
#ffted = data.forward(table, space)
#ffted = data.forward(table)
#ffted = data.forward(space)
#ffted = data.forward()
#ffted = data.transform(table, space, GSL::FFT::Forward)
#ffted = data.transform(GSL::FFT::Forward)
ffted = data.transform(GSL::FFT::Forward)
ffted /= Math::sqrt(n)
GSL::graph(nil, data.re, ffted.re, "-C -g 3")
#!/usr/bin/env ruby
require("gsl")

n = 100
data = GSL::Vector.alloc(n)
#data = NArray.float(n)

for i in (n/3)...(2*n/3) do
  data[i] = 1.0
end
org = data.clone

rtable = GSL::FFT::RealWavetable.alloc(n)
rwork = GSL::FFT::RealWorkspace.alloc(n)

data.real_transform!(rtable, rwork)

for i in 11...n do
  data[i] = 0.0
end

hctable = GSL::FFT::HalfComplexWavetable.alloc(n)

#data.halfcomplex_inverse!(hctable, rwork)
#data.halfcomplex_inverse!()
#data.ifft!
#data.halfcomplex_inverse!(hctable, rwork)
data.ifft!(hctable, rwork)

GSL::graph(nil, org, data, "-T X -C -g 3 -L 'Real-halfcomplex' -x 0 #{data.size}")
#!/usr/bin/env ruby
require("gsl")

n = 100
data = GSL::Vector.alloc(n)
#data = NArray.float(n)

for i in (n/3)...(2*n/3) do
  data[i] = 1.0
end

rtable = GSL::FFT::RealWavetable.alloc(n)
rwork = GSL::FFT::RealWorkspace.alloc(n)

#ffted = data.real_transform(rtable, rwork)
#ffted = data.real_transform(rtable)
#ffted = data.real_transform(rwork)
#ffted = data.real_transform()
#ffted = data.fft
ffted = data.real_transform()

for i in 11...n do
  ffted[i] = 0.0
end

hctable = GSL::FFT::HalfComplexWavetable.alloc(n)

#data2 = ffted.halfcomplex_inverse(hctable, rwork)
#data2 = ffted.halfcomplex_inverse()
#data2 = ffted.ifft
data2 = ffted.halfcomplex_inverse()

GSL::graph(nil, data, data2, "-T X -C -g 3 -L 'Real-halfcomplex' -x 0 #{data.size}")
#!/usr/bin/env ruby
require("gsl")

n = 128
data = GSL::Vector::Complex.alloc(n)

data[0] = 1.0
c = GSL::Complex[1, 0]
for i in 1..10 do
  data[i] = c
  data[n-i] = c
end

ffted = data.radix2_forward
ffted /= Math::sqrt(n)

GSL::graph(nil, data.re, ffted.re, "-T X -C -g 3 -L 'Radix-2' -x 0 #{data.size/2}")

#!/usr/bin/env ruby
# Analysis of the solar activity of 11-years cycle
# from the number of sunspots.
# This example is taken from the MATLAB user's manual Chap 13.

require("gsl")

year, sunspot = GSL::Vector.filescan("sunspot.dat")
N = year.size
ffted = sunspot.fft

#power = GSL.sqrt(ffted[1..(N-2)].to_complex2.abs2)*2/N
power = GSL.sqrt(ffted.to_complex2.abs2)*2/N
freq = GSL::Vector.linspace(1, N/2, power.size)/N
period = 1.0/freq
GSL::graph(period, power, "-C -g 3 -x 0 40 -X 'Period [year]'")
#!/usr/bin/env ruby
require("gsl")

N = 2048
SAMPLING = 1000   # 1 kHz
TMAX = 1.0/SAMPLING*N
FREQ1 = 50
FREQ2 = 120
t = GSL::Vector.linspace(0, TMAX, N)
x = GSL::Sf::sin(2*Math::PI*FREQ1*t) + GSL::Sf::sin(2*Math::PI*FREQ2*t)
x.fft!

y2 = x.subvector(1, N-2).to_complex2
mag = y2.abs
phase = y2.arg
f = GSL::Vector.linspace(0, SAMPLING/2, mag.size)
GSL::graph(f, mag, "-C -g 3 -x 0 200 -X 'Frequency [Hz]'")
#!/usr/bin/env ruby
require("gsl")

n = 128
data = GSL::Vector.alloc(n)
#data = NArray.float(n)

data[0] = 1.0
for i in 1..10 do
  data[i] = 1.0
  data[n-i] = 1.0
end

#ffted = data.radix2_transform(GSL::FFT:FORWARD)
#ffted = data.real_radix2_transform(GSL::FFT::FORWARD)
# etc...
ffted = data.radix2_transform(GSL::FFT::FORWARD)
ffted /= Math::sqrt(n)
GSL::graph(nil, data, ffted, "-T X -C -g 3 -L 'Real Radix-2' -x 0 #{data.size}")
#!/usr/bin/env ruby
require("gsl")

N = 2048
SAMPLING = 1000   # 1 kHz
TMAX = 1.0/SAMPLING*N
FREQ1 = 50
FREQ2 = 120
t = GSL::Vector.linspace(0, TMAX, N)
x = GSL::Sf::sin(2*Math::PI*FREQ1*t) + GSL::Sf::sin(2*Math::PI*FREQ2*t)
y = x.fft

y2 = y.subvector(1, N-2).to_complex2
mag = y2.abs
phase = y2.arg
f = GSL::Vector.linspace(0, SAMPLING/2, mag.size)
GSL::graph(f, mag, "-C -g 3 -x 0 200 -X 'Frequency [Hz]'")
#!/usr/bin/env ruby
require("gsl")

n = 630
data = GSL::Vector::Complex.alloc(n)

table = GSL::FFT::ComplexWavetable.alloc(n)
space = GSL::FFT::ComplexWorkspace.alloc(n)

data[0] = 1.0
for i in 1..10 do
  data[i] = GSL::Complex[1.0, 0.0]
  data[n-i] = GSL::Complex[1.0, 0.0]
end
org = data.clone

# Select whichever you like
#data.forward!(table, space)
#data.forward!(table)
#data.forward!(space)
#data.forward!()
#data.transform!(table, space, GSL::FFT::Forward)
#data.transform!(GSL::FFT::Forward)
data.forward!(table, space)
data /= Math::sqrt(n)
GSL::graph(nil, org.re, data.re, "-C -g 3")
#!/usr/bin/env ruby
require("gsl")
include GSL
include Monte
include Math

proc_f = Proc.new { |k, dim, params|
  pi = Math::PI
  a = 1.0/(pi*pi*pi)
  a/(1.0 - cos(k[0])*cos(k[1])*cos(k[2]))
}

def display_results(title, result, error)
  exact = 1.3932039296856768591842462603255

  diff = result - exact
  printf("%s ==================\n", title);
  printf("result = % .6f\n", result);
  printf("sigma  = % .6f\n", error);
  printf("exact  = % .6f\n", exact);
  printf("error  = % .6f = %.1g sigma\n", diff, diff.abs/error)
end

dim = 3
xl = Vector.alloc([0, 0, 0])
xu = Vector.alloc([PI, PI, PI])
G = Monte::Function.alloc(proc_f, dim)
calls = 10000
r = GSL::Rng.alloc(Rng::DEFAULT)

miser = Monte::Miser.alloc(dim)

result, error = Monte::Miser::integrate(G, xl, xu, dim, calls, r, miser)
#result, error = Monte::Miser::integrate(G, xl, xu, calls, r, miser)
#result, error = Monte::Miser::integrate(G, xl, xu, calls, miser)
#result, error = Monte::Miser::integrate(G, xl, xu, dim, calls, r, "miser")

#result, error = G.integrate(xl, xu, dim, calls, r, miser)
#result, error = G.integrate(xl, xu, calls, r, miser)
#result, error = G.integrate(xl, xu, calls, miser)

#result, error = miser.integrate(G, xl, xu, dim, calls, r)
#result, error = miser.integrate(G, xl, xu, calls, r)
#result, error = miser.integrate(G, xl, xu, dim, calls)
#result, error = miser.integrate(G, xl, xu, calls)

display_results("miser", result, error)
#!/usr/bin/env ruby
require("gsl")
include GSL
include Monte
include Math

proc_f = Proc.new { |k, dim, params|
  pi = Math::PI
  a = 1.0/(pi*pi*pi)
  a/(1.0 - cos(k[0])*cos(k[1])*cos(k[2]))
}

def display_results(title, result, error)
  exact = 1.3932039296856768591842462603255

  diff = result - exact
  printf("%s ==================\n", title);
  printf("result = % .6f\n", result);
  printf("sigma  = % .6f\n", error);
  printf("exact  = % .6f\n", exact);
  printf("error  = % .6f = %.1g sigma\n", diff, diff.abs/error)
end

dim = 3
xl = Vector.alloc([0, 0, 0])
xu = Vector.alloc([PI, PI, PI])
G = Monte::Function.alloc(proc_f, dim)
calls = 10000
r = GSL::Rng.alloc(Rng::DEFAULT)

vegas = Monte::Vegas.alloc(dim)
result, error = Monte::Vegas::integrate(G, xl, xu, dim, calls, r, vegas)
#result, error = Monte::Vegas::integrate(G, xl, xu, calls, r, vegas)
#result, error = Monte::Vegas::integrate(G, xl, xu, calls, vegas)
#result, error = Monte::Vegas::integrate(G, xl, xu, dim, calls, r, "vegas")

#result, error = G.integrate(xl, xu, dim, calls, r, vegas)
#result, error = G.integrate(xl, xu, calls, r, vegas)
#result, error = G.integrate(xl, xu, calls, vegas)

#result, error = vegas.integrate(G, xl, xu, dim, calls, r)
#result, error = vegas.integrate(G, xl, xu, calls, r)
#result, error = vegas.integrate(G, xl, xu, dim, calls)
#result, error = vegas.integrate(G, xl, xu, calls)

display_results("vegas", result, error)
#!/usr/bin/env ruby
require("gsl")
include GSL
include Monte
include Math

proc_f = Proc.new { |k, dim, params|
  pi = Math::PI
  a = 1.0/(pi*pi*pi)
  a/(1.0 - cos(k[0])*cos(k[1])*cos(k[2]))
}

def display_results(title, result, error)
  exact = 1.3932039296856768591842462603255

  diff = result - exact
  printf("%s ==================\n", title);
  printf("result = % .6f\n", result);
  printf("sigma  = % .6f\n", error);
  printf("exact  = % .6f\n", exact);
  printf("error  = % .6f = %.1g sigma\n", diff, diff.abs/error)
end

dim = 3
xl = Vector.alloc([0, 0, 0])
xu = Vector.alloc([PI, PI, PI])
G = Monte::Function.alloc(proc_f, dim)
calls = 10000
r = GSL::Rng.alloc(Rng::DEFAULT)

plain = Monte::Plain.alloc(dim)

result, error = Monte::Plain::integrate(G, xl, xu, dim, calls, r, plain)
#result, error = Monte::Plain::integrate(G, xl, xu, calls, r, plain)
#result, error = Monte::Plain::integrate(G, xl, xu, calls, plain)
#result, error = Monte::Plain::integrate(G, xl, xu, dim, calls, r, "plain")

#result, error = G.integrate(xl, xu, dim, calls, r, plain)
#result, error = G.integrate(xl, xu, calls, r, plain)
#result, error = G.integrate(xl, xu, calls, plain)

#result, error = plain.integrate(G, xl, xu, dim, calls, r)
#result, error = plain.integrate(G, xl, xu, calls, r)
#result, error = plain.integrate(G, xl, xu, dim, calls)
#result, error = plain.integrate(G, xl, xu, calls)

display_results("plain", result, error)
#!/usr/bin/env ruby
require("gsl")
include GSL
include Monte
include Math

proc_f = Proc.new { |k, dim, params|
  pi = Math::PI
  a = 1.0/(pi*pi*pi)
  a/(1.0 - cos(k[0])*cos(k[1])*cos(k[2]))
}

def display_results(title, result, error)
  exact = 1.3932039296856768591842462603255

  diff = result - exact
  printf("%s ==================\n", title);
  printf("result = % .6f\n", result);
  printf("sigma  = % .6f\n", error);
  printf("exact  = % .6f\n", exact);
  printf("error  = % .6f = %.1g sigma\n", diff, diff.abs/error)
end

dim = 3
xl = Vector.alloc([0, 0, 0])
xu = Vector.alloc([PI, PI, PI])
G = Monte::Function.alloc(proc_f, dim)
calls = 500000
r = GSL::Rng.alloc(Rng::DEFAULT)

plain = Monte::Plain.alloc(dim)
result, error = G.integrate(xl, xu, dim, calls, r, plain)
display_results("plain", result, error)

miser = Monte::Miser.alloc(dim)
result, error = G.integrate(xl, xu, dim, calls, r, miser)
display_results("miser", result, error)

vegas = Monte::Vegas.alloc(dim)
result, error = G.integrate(xl, xu, dim, 10000, r, vegas)
display_results("vegas warm-up", result, error)
puts("converging...");
begin
  result, error = G.integrate(xl, xu, dim, calls/5, r, vegas)
  printf("result = % .6f sigma = % .6f chisq/dof = %.1f\n", result, error, vegas.chisq)
end while (vegas.chisq-1.0).abs > 0.5
display_results("vegas final", result, error)
#!/usr/bin/env ruby
require("gsl")
include Math

m = GSL::Matrix.alloc(10, 10)
for i in 0...10
  for j in 0...10
    m.set(i, j, sin(i) + cos(j))
  end
end

for j in 0...10
  col = m.col(j)
  d = GSL::Blas.dnrm2(col)
  printf("matrix column %d, norm = %g\n", j, d)
end
#!/usr/bin/env ruby
require("gsl")

a = GSL::Vector[0.11, 0.12, 0.13, 0.21, 0.22, 0.23]
b = GSL::Vector[1011, 1012, 1021, 1022, 1031, 1032]

A = a.matrix_view(2, 3)
B = b.matrix_view(3, 2)

C = GSL::Blas.dgemm(GSL::Blas::NoTrans, GSL::Blas::NoTrans, 1.0, A, B, 0.0)
p C

p A*B
#!/usr/bin/env ruby
require("gsl")
include GSL
include GSL::Blas

x = GSL::Vector[1, 2, 3]
y = GSL::Vector[4, 5, 6]

p x.blas_ddot(y)
p GSL::Blas.ddot(x, y)

xz = GSL::Vector::Complex.alloc([1, 0], [2, 0], [3, 0])
yz = GSL::Vector::Complex.alloc([4, 0], [5, 0], [6, 0])
p zdotu(xz, yz)

p x.nrm2
p GSL::Blas.dnrm2(x)
p xz.nrm2
p GSL::Blas.dznrm2(xz)

p x.asum
p GSL::Blas.dasum(x)
p xz.asum
p GSL::Blas.dzasum(xz)

x.swap(y)
p x
p y

GSL::Blas.dswap(x, y)
p x
p y

xz.swap(yz)
p xz
p yz

GSL::Blas.zswap(xz, yz)
p xz
p yz

p x.axpy(2, y)
p y
p GSL::Blas.daxpy(2, x, y)
p y

p x.axpy!(2, y)
p y
p GSL::Blas.daxpy!(2, x, y)
p y

y = GSL::Vector[4, 5, 6]

az = GSL::Complex.alloc(2, 0)
p xz.zaxpy(az, yz)
p yz
p GSL::Blas.zaxpy(az, xz, yz)
p yz

az = GSL::Complex[2, 0]
p xz.axpy!(az, yz)
p yz
p GSL::Blas.zaxpy!(az, xz, yz)
p yz

yz = GSL::Vector::Complex.alloc([4, 0], [5, 0], [6, 0])

p x.scal(2)
p x

p x.scal!(2)
p x

x = GSL::Vector[1, 2, 3]

p xz.zscal(az)
p xz.zdscal(2)

p y
p GSL::Blas.drot(x, y, 2, 3)
p drot(x, y, 2, 3)
#!/usr/bin/env ruby
require("gsl")
include GSL::Blas

a = GSL::Matrix.alloc([1, 5], [4, 6])
b = GSL::Matrix.alloc([10, 2], [3, 8])
c = GSL::Matrix.alloc(2, 2)

p GSL::Blas.dgemm(NoTrans, NoTrans, 1, a, b, 1, c)
p GSL::Blas.dgemm(a, b)
p a*b

#!/usr/bin/env ruby
require("gsl")
include GSL::Blas

x = GSL::Vector[1, 2, 3]
y = GSL::Vector[4, 5, 6]

A = GSL::Matrix.alloc([1, 2, 3], [4, 5, 6], [7, 8, 9])
# [28, 64, 100]
p GSL::Blas.dgemv(CblasNoTrans, 2, A, x)
p dgemv(CblasNoTrans, 2, A, x)
#!/usr/bin/env ruby
require("gsl")

n = 256
nc = 20

data = GSL::Vector.alloc(n)
File.new(File.dirname(__FILE__) + '/ecg.dat').each_with_index do |l, i|
  data[i] = l.to_f
end

w = GSL::Wavelet.alloc("daubechies", 4)
work = GSL::Wavelet::Workspace.alloc(n)

# Choose as you like...
data2 = w.transform(data, GSL::Wavelet::FORWARD, work)
#data2 = data.wavelet_transform(w, GSL::Wavelet::FORWARD, work)
#data2 = data.wavelet_transform_forward(w, work)
#data2 = w.transform(data, work)
#data2 = w.transform(data)
#data2 = w.transform(data, GSL::Wavelet::FORWARD)
#data2 = w.transform_forward(data, work)
#data2 = w.transform_forward(data)
#data2 = GSL::Wavelet.transform(w, data, GSL::Wavelet::FORWARD, work)
#data2 = GSL::Wavelet.transform(w, data, GSL::Wavelet::FORWARD)
#data2 = GSL::Wavelet.transform(w, data, work)
#data2 = GSL::Wavelet.transform(w, data)
#data2 = GSL::Wavelet.transform_forward(w, data, work)
#data2 = GSL::Wavelet.transform_forward(w, data)

perm = data2.abs.sort_index

i = 0
while (i + nc) < n
  data2[perm[i]] = 0.0
  i += 1
end

# Choose as you like...
data3 = w.transform(data2, GSL::Wavelet::BACKWARD, work)
#data3 = data2.wavelet_transform(w, GSL::Wavelet::BACKWARD, work)
#data3 = data2.wavelet_transform_inverse(w, work)
#data3 = w.transform(data2, GSL::Wavelet::BACKWARD)
#data3 = w.transform_inverse(data2, work)
#data3 = w.transform_inverse(data2)
#data3 = GSL::Wavelet.transform(w, data2, GSL::Wavelet::BACKWARD, work)
#data3 = GSL::Wavelet.transform(w, data2, GSL::Wavelet::BACKWARD)
#data3 = GSL::Wavelet.transform_inverse(w, data2, work)
#data3 = GSL::Wavelet.transform_inverse(w, data2)

# GSL::graph(nil, data, data3, "-T X -C -g 3 -x 0 #{data.size} -L 'Red: data, Green: DWT'")

#!/usr/bin/env ruby
# Find synchrotron spectrum peak
require("gsl")

# Create Function object from the module function
F = GSL::Function.alloc { |x| GSL::Sf::synchrotron_1(x) }
# Derivative of the function
DF = GSL::Function.alloc { |x|
  result, abserr, status = F.deriv_central(x, 1e-6)
  result
}
# Find zero-point of the derivative in interval (0.01, 5)
peak, = DF.fsolve(0.01, 5)
printf("A peak is found at %3.2f.\n", peak)

x = GSL::Vector.linspace(0, 5, 100)
s = GSL::Sf::synchrotron_1(x)
s.graph(x, "-C -g 3 -X x -L 'Sf::synchrotron_1(x)'")
#!/usr/bin/env ruby
require("gsl")

f_log = GSL::Function.alloc { |x| Math::log(x) }
x = GSL::Vector.linspace(1, 100, 10)
x2 = GSL::Vector.logspace2(1, 100, 10)
GSL::graph([x, f_log.eval(x)], [x2, f_log.eval(x2)], "-T X -C -g 3 -l x -S 4 -L 'log(x)'")
#!/usr/bin/env ruby
require("gsl")

humps = GSL::Function.alloc { |x|
  1.0/(GSL::pow_2(x-0.3) + 0.01) + 1.0/(GSL::pow_2(x-0.9)+0.04) - 6
}

iter = 0;  max_iter = 500
m = 0.7             # initial guess
m_expected = 0.6370
a = 0.3; b = 1.0
gmf = GSL::Min::FMinimizer.alloc(GSL::Min::FMinimizer::BRENT)
gmf.set(humps, m, a, b)
printf("Using %s method\n", gmf.name)
printf("%5s [%9s, %9s] %9s %10s %9s\n", "iter", "lower", "upper", "min",
       "err", "err(est)")
printf("%5d [%.7f, %.7f] %.7f %+.7f %.7f\n",
       iter, a, b, m, m - m_expected, b - a)
begin
  iter += 1
  status = gmf.iterate
  status = gmf.test_interval(0.0001, 0.0)
  puts("Converged:") if status == GSL::SUCCESS
  a = gmf.x_lower;  b = gmf.x_upper
  m = gmf.x_minimum
  printf("%5d [%.7f, %.7f] %.7f %+.7f %.7f\n",
         iter, a, b, m, m - m_expected, b - a);
end while status == GSL::CONTINUE and iter < max_iter

x = GSL::Vector.linspace(-0.5, 1.5, 100)
GSL::graph([x, humps.eval(x)], [GSL::Vector[m], GSL::Vector[humps.eval(m)]], "-C -g 3 -S 4 -m -1")


#!/usr/bin/env ruby
require("gsl")

x = GSL::Vector.linspace(0, 2*Math::PI, 20)
f = GSL::Function.alloc { |x|
  GSL::Sf::sin(x)
}

f.graph(x, "-T X -g 3 -C -L 'sin(x)'")

#!/usr/bin/env ruby
require("gsl")
include Math

f = GSL::Function::alloc{ |x, params|
  a = params[0]
  b = params[1]
  c = params[2]
  (a*x + b)*x + c
}

p f.proc
p f.params
a = 1; b = 2; c = 3
f.set_params(a, b, c)
p f.params

p f.eval(2)
p f.call(4)


f.set { |x|
  x*x*x
}

p f.params

p f.eval(2)
p f[4]

f2 = GSL::Function.alloc { |x|
  sin(x) - log(x)*sqrt(x)
}

p f2.eval(2.5)
p f2.arity
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Initialize random number generator with fixed seed for repeatable sequence
r = GSL::Rng.alloc(GSL::Rng::MT19937, ?r-?b+?g-?s-?l)

# Create 3x3 matrix initialized with numbers from uniform distribution
u = GSL::Matrix.rand(3, 3, r)

# Create 3x3 matrix initialized with numbers from normal distribution
n = GSL::Matrix.randn(3, 3, r)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create 3x3 test Matrix a
a = GSL::Matrix.alloc([1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 3)

# Create Vector initialized from row 0 of Matrix a
b = a.get_row(0)

# Create Vector::Col for column 2 of Matrix a
c = a.get_col(2)

# Set column 2 of Matrix a from Vector from row 0
a.set_col(2, b)

# Set row 0 of Matrix a from Vector::Col from column 2
a.set_row(0, c)

# Create new Matrix from a with rows 1 and 2 swapped
a.swap_rows(1, 2)

# Show that Matrix a remains unmodified
a

# Swap columns 1 and 2 of Matrix a in-place
a.swap_cols!(1, 2)

# Show that Matrix a is modified
a

# Create new Matrix that is transpose of Matrix a
atrans = a.transpose

# Transpose Matrix a in-place
a.transpose!

# Transpose Matrix a in-place again
a.transpose!
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create a 3x3 matrix m
m = GSL::Matrix.alloc([1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 3)

# Get Vector::View for row 1 of Matrix m
m.row(1)

# Get Vector::Col::View for column 0 of Matrix m
m.col(0)

# Get Vector::View for diagonal of Matrix m
m.diagonal

# Get Vector::View for subdiagonal 1 of Matrix m
m.subdiagonal(1)

# Get Vector::View for subdiagonal 0 of Matrix m
m.subdiagonal(0)

# Get Vector::View for superdiagonal 1 of Matrix m
m.superdiagonal(1)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create to 3x3 matrices
a = GSL::Matrix.alloc([1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 3)
b = GSL::Matrix.alloc([6, 7, 8], [2, 3, 4], [3, 4, 5])

# Add together to create new matrix
a + b

# Add b to a, modifying a
a += b

# Show that a is modified
a

# Subtract b from a, modifying a
a -= b

# Add 2 to all elements of a, creating new matrix
a + 2

# Another way to add 2 to all elements of a, creating new matrix
2 + a

# Add 2 to all elements of a, modifying a
a += 2

# Show that a is modified
a

# Subtract 2 from all elements of a, modifying a
a -= 2

# Show that a is modified
a
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create two 3x3 matrices
m = GSL::Matrix.alloc(1..9, 3, 3)
n = GSL::Matrix.alloc(11..19, 3, 3)

# Get Vector::Col::View for column 1 of Matrix a
a = m.col(1)

# Get Vector::Col::View for column 2 of Matrix b
b = n.col(2)

# Create new Matrix from Vector::Col::Views
c = GSL::Matrix[a, b]
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create 3x3 Hilbert matrix m
m = GSL::Matrix.hilbert(3)

# Compute inverse of m
invm = m.inv

# Create inverse of 3x3 Hilbert matrix directly
invm2 = GSL::Matrix.invhilbert(3)

# Show that both inverse matrices are inverses of m
m*invm
m*invm2

# Show that the two inverse matrices are equal
# to absolute accuracy eps = 1e-10
invm == invm2

# Show that they may not be exactly equal
invm - invm2
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Matrix
a = GSL::Matrix.alloc([1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 3)

# Find maximum
a.max

# Find minimum
a.min

# Find minimum and maximum
a.minmax

# Find index of maximimum
a.max_index

# Find index of minimimum
a.min_index

# Find indices of minimum and maximum
minmax_idx = a.minmax_index

# Use minmax_idx to get minimnum
a[minmax_idx[0]]

# Use minmax_idx to get maximnum
a[minmax_idx[1]]

# Show that #isnull returns 0 for non-null Matrix
a.isnull

# Show that #isnull? returns false for non-null Matrix
a.isnull?

# Set all elements to zero
a.set_zero

# Show that #isnull returns 1 for null Matrix
a.isnull

# Show that #isnull? returns true for null Matrix
a.isnull?
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create matrix with diagonal given by Range
GSL::Matrix.diagonal(1..3)

# Create matrix with diagonal given by Array
GSL::Matrix.diagonal([1, 2, 3])

# Create matrix with diagonal given by GSL::Vector
GSL::Matrix.diagonal(GSL::Vector.indgen(3,1))

# Create matrix with diagonal given by individual elements
GSL::Matrix.diagonal(1, 2, 3)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create a 2x2 Matrix::Int and a 2x3 Matrix::Int
a = GSL::Matrix::Int[1..4, 2, 2]
b = GSL::Matrix::Int[5..10, 2, 3]

# Concatenate them horizontally using Matrix::Int#horzcat
a.horzcat(b)

# Concatenate them horizontally using Matrix::Int.horzcat
GSL::Matrix::Int.horzcat(a, b)

# Create a 2x2 Matrix::Int and a 3x2 Matrix::Int
a = GSL::Matrix::Int[1..4, 2, 2]
b = GSL::Matrix::Int[5..10, 3, 2]

# Concatenate them vertically using Matrix::Int#vertcat
a.vertcat(b)

# Concatenate them vertically using Matrix::Int.vertcat
GSL::Matrix::Int.vertcat(a, b)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# These examples show some of the ways that Matrix#set or its alias Matrix#[]=
# can be invoked. First, create test matrix m...

m = GSL::Matrix[3,4]

# For a single Array argument, i.e. m.set([row0,row1,...]) or
# m[]=[row0,row1,...], the Array's elements are taken as row contents.  Each
# given row must have exactly the same number of elements as the Matrix has
# columns, but the number of rows given need not match the Matrix's row count.
# Extra given rows are ignored, while Matrix rows beyond those given are not
# affected.

m[] = [[1,2,3,4],[5,6,7,8],[9,8,7,6]]

m

# Note the different return values of Matrix#set and Matrix#[]=.  Matrix#set
# return self (see below), but Matrix[]= returns the value to the right of the
# = sign (see above).  This must be standard Ruby behavior since the underlying
# code returns the same value to Ruby regardless of whether it is invoked as
# #set or #[]=.

m.set([[9,8,7,6],[5,4,3,2],[1,0,1,2]])

# For a single non-Array argument, Matrix#set and Matrix#[] are equivalent to
# Matrix#set_all (other than the difference in the return value of Matrix#[] as
# noted above).

m.set(1.2)             # could also use:  m[] = 1.2

# For two arguments with the first being an Array and the second a non-Array,
# i.e. m.set([i,j], x) or m[[i,j]]=x (note the double square brackets), the
# first two elements of the Array must be Fixnums which specify the row and
# column of the element that will be set to the value of the second (non-Array)
# argument.  This special case exists to allow values returned by
# Matrix#max_index and Matrix#min_index to be used as indexes.

m.indgen!

m[m.max_index] = 100

m[m.min_index] = -100

m

# For three arguments with the first two being Fixnums i and j, this sets
# element (i,j) to the value of the last argument.

m[1,2] = 50; m[-2,-3] = -50; m

# For multiple arguments with the first two being Arrays, i.e.
# m.set(row0,row1,...), this behaves as if the rows were given in a single
# Array (see the first case above).

m.set([1,2,3,4], [5,6,7,8], [9,8,7,6])

# All other forms treat all but the last argument as with Matrix#submatrix and
# set the specified elements based on the last argument, which can be a Matrix
# (or Matrix::View), an Array (of Numerics or Arrays of Numerics), a Range, or
# a Numeric.  Matrix, Array, and Range rvalues must have the same number of
# elements as the specified submatrix.  For a Numeric rvalue, all elements of
# the submatrix are set to that value.
#
# See examples/matrix/view_all.rb for additional examples of how to specify
# submatrices.

m[nil,1] = 0; m

m[1,nil] = 1; m

m[1..2,1..3] = 1..6; m

# Also be careful when setting part of a Matrix from another part of the same
# Matrix.  The GSL method that performs this operation uses memcpy, which does
# not handle overlapping memory regions in a well defined way.

m.indgen!

# This is faster but has problems with overlap
m[1..2,1..2] = m[0..1,0..1]; m

n = GSL::Matrix[3,4].indgen!

# Converting right hand side to Array avoids the problem, but is slower
n[1..2,1..2] = n[0..1,0..1].to_a; n

# See the difference at element [2,2]
n-m
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# These examples show all(?) the ways that a Matrix::View can be created using
# Matrix#submatrix or its alias Matrix#view.  Note that Matrix#get or, more
# commonly, its alias Matrix#[] can also be used to create a Matrix::View.  See
# examples/matrix/get_all.rb for more examples.

# Create 4x4 test matrix m
m = GSL::Matrix.indgen(4, 4)

# Matrix#view with zero args returns a Matrix::View of entire Matrix
m.view

# Matrix#view with one Fixnum argument, i, treats the Matrix as a Vector and
# returns a Matrix::View of the i'th element if i is positive or the
# (i+size1*size2)'th element if i is negative.
m.view(3)
m.view(-3)

# When Matrix#view is called with two arguments, the first specifies which
# row(s) the view will cover and the second specifies which column(s) the view
# will cover.  The arguments may be nil (indicating all rows or columns),
# a Fixnum (indicating a single row or column), or a Range (indicating a range
# of rows or columns).  The return type is Matrix::View unless exactly one
# argument is a Fixnum in which case a Vector::View or Vector::Col::View is
# returned.
#
# NOTE: GSL 1.11 (and maybe earlier versions) has a bug that can prevent the
# exactly-one-Fixnum case from working properly if the Matrix does not have an
# equal number of rows and columns!!!

# Matrix#view(nil, nil) returns a Matrix::View of entire Matrix
m.view(nil, nil)

# Matrix#view(Fixnum, Fixnum) returns a Matrix::View of the single element at
# the specified row and column.
m.view(2, 3)
m.view(-1, -3)

# Matrix#view(Range, Range) returns a Matrix::View of the rows and columns
# specified by the two Ranges.
m.view(0...2, 1..-2)
m.view(-3..-1, -4...4)

# Matrix#view(Fixnum, nil) returns a Vector::View of the entire row specified
# by the Fixnum argument.  A negative value is treated as counting backwards
# from the end of the corresponding dimension.  NOTE: GSL 1.11 (and maybe
# earlier versions) has a bug that prevents this from working if the Matrix has
# more columns than rows!!!
m.view(1, nil)
m.view(-2, nil)

# Matrix#view(nil, Fixnum) returns a Vector::Col::View of the entire column
# specified by the Fixnum argument.  A negative value is treated as counting
# backwards from the end of the corresponding dimension.  NOTE: GSL 1.11 (and
# maybe earlier versions) has a bug that prevents this from working if the
# Matrix has more rows than columns!!!
m.view(nil, 1)
m.view(nil, -2)

# Matrix#view(Range,nil) returns a Matrix::View of all columns and the rows
# specified by the Range argument.  Note that negative begin and/or end values
# are treated as counting backwards from the end of corresponding dimension.
m.view(1...3, nil)
m.view(0..-2, nil)
m.view(-2..3, nil)
m.view(-2..-1, nil)

# Matrix#view(nil, Range) returns a Matrix::View of all rows and the columns
# specified by the Range argument.  Note that negative begin and/or end values
# are treated as counting backwards from the end of corresponding dimension.
m.view(nil, 1...3)
m.view(nil, 0..-2)
m.view(nil, -2..3)
m.view(nil, -2..-1)

# Matrix#view(Range, Fixnum) returns a Vector::Col::View of the rows specified
# by the Range argument of the column specified by the Fixnum argument.  A
# negative value is treated as counting backwards from the end of the
# corresponding dimension.  NOTE: GSL 1.11 (and maybe earlier versions) has a
# bug that prevents this from working if the Matrix has more rows than
# columns!!!
m.view(1...3, 0)
m.view(0..-2, 1)
m.view(-2..3, -2)
m.view(-2..-1, -1)

# Matrix#view(Fixnum, Range) returns a Vector::View of the columns specified
# by the Range argument of the row specified by the Fixnum argument.  A
# negative value is treated as counting backwards from the end of the
# corresponding dimension.  NOTE: GSL 1.11 (and maybe earlier versions) has a
# bug that prevents this from working if the Matrix has more rows than
# columns!!!
m.view(0, 1...3)
m.view(1, 0..-2)
m.view(-2, -2..3)
m.view(-1, -2..-1)

# When Matrix#view is called with three arguments, the first or last argument
# must be nil or a Range and the other two arguments must be Fixnums.  The two
# Fixnums indicate a span whose offset is given by the first Fixnum and whose
# length is given by the second Fixnum.  If they are the first two arguments,
# they indicate which rows the returned view will cover.  If they are the last
# two arguments, they indicate which columns the returned view will cover.  The
# nil or Range argument indicate what portion of the other dimension will be
# covered by the returned view (nil means all rows or columns).

# Matrix#view(nil, Fixnum, Fixnum) returns a Matrix::View covering all rows of
# the column span specified by the two Fixnums.
m.view(nil, 1, 2)
m.view(nil, -2, 2)

# Matrix#view(Fixnum, Fixnum, nil) returns a Matrix::View covering all columns
# of the row span specified by the two Fixnums.
m.view(nil, 1, 2)
m.view(nil, -2, 2)

# Matrix#view(Range, Fixnum, Fixnum) returns a Matrix::View covering Range rows
# of the column span specified by the two Fixnums.
m.view(0...2, -3, 2)
m.view(1..-2, 1, 2)
m.view(-3..-1, 3, 1)
m.view(-4...4, -4, 2)

# Matrix#view(Fixnum, Fixnum, Range) returns a Matrix::View covering Range
# columns of the row span specified by the two Fixnums.
m.view(-3, 2, 0...2)
m.view(1, 2, 1..-2)
m.view(3, 1, -3..-1)
m.view(-4, 2, -4...4)

# When Matrix#view is called with four arguments, all four arguments must be
# Fixnums.  The first two Fixnums specify the Matrix element that will be the
# upper left corner of the view (negative values are treated as counting
# backwrds from the end of the corresponding dimension).  The last two Fixnums
# specify the number of rows and columns that the view will have.
m.view(0, 1, 2, 3)
m.view(-2, -3, 2, 1)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test matrix
m = GSL::Matrix.alloc([1, 2, 3, 4, 5, 6, 7, 8 ,9], 3, 3)

# Iterate through columns
m.each_col do |v|
  p v
end
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Matrix
m = GSL::Matrix.alloc([1, 2], [3, 4])

# Write Matrix in binary format to file a.dat
m.fwrite("a.dat")

# Create another test Matrix
m2 = GSL::Matrix.alloc([5, 6], [7, 8])

# Write Matrix in text format to file b.dat
m2.fprintf("b.dat")
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Crete test matrix m
m = GSL::Matrix[[1, 2, 3, 4, 5, 6, 7, 8 ,0], 3, 3]

# Calculate determinant of m
m.det

# Calculate trace of m (sum of diagonal elements)
m.trace

# Convert to Matrix::Complex mz
mz = m.to_complex

# Calulate determinant of mz
mz.det

# Calculate trace of mz (sum of diagonal elements)
mz.trace
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# These examples show all(?) the ways that Matrix#get or its alias Matrix#[]
# can be invoked.  For one or two Fixnum arguments or a single two-element
# Array argument, a single element is returned.  For all other cases,
# Matrix#get is essentially an alias for Matrix#submatrix.  See
# examples/matrix/view_all.rb for more examples.

# Create 4x4 test matrix m
m = GSL::Matrix.indgen(4, 4)

# Matrix#[] with zero args returns a Matrix::View of entire Matrix
m[]

# Matrix#[] with one Fixnum argument, i, treats the Matrix as a Vector and
# returns a Matrix::View of the i'th element if i is positive or the
# (i+size1*size2)'th element if i is negative.
m[3]
m[-3]

# Matrix#[Fixnum, Fixnum] returns a Matrix::View of the single element at
# the specified row and column.
m[2, 3]
m[-1, -3]

# Matrix#[[Fixnum, Fixnum]] (note the double square brackets) is treated the
# same as Matrix#[Fixnum, Fixnum].  This special case exists to allow values
# returned by Matrix#max_index and Matrix#min_index to be used as indexes.
m[[2, 3]]
m[[-1, -3]]
m.max_index
m[m.max_index]
m.min_index
m[m.min_index]

# When Matrix#[] is called with two arguments, the first specifies which
# row(s) the view will cover and the second specifies which column(s) the view
# will cover.  The arguments may be nil (indicating all rows or columns),
# a Fixnum (indicating a single row or column), or a Range (indicating a range
# of rows or columns).  The return type is Matrix::View unless exactly one
# argument is a Fixnum in which case a Vector::View or Vector::Col::View is
# returned.
#
# NOTE: GSL 1.11 (and maybe earlier versions) has a bug that can prevent the
# exactly-one-Fixnum case from working properly if the Matrix does not have an
# equal number of rows and columns!!!

# Matrix#[nil, nil] returns a Matrix::View of entire Matrix
m[nil, nil]

# Matrix#[Range, Range] returns a Matrix::View of the rows and columns
# specified by the two Ranges.
m[0...2, 1..-2]
m[-3..-1, -4...4]

# Matrix#[Fixnum, nil] returns a Vector::View of the entire row specified
# by the Fixnum argument.  A negative value is treated as counting backwards
# from the end of the corresponding dimension.  NOTE: GSL 1.11 (and maybe
# earlier versions) has a bug that prevents this from working if the Matrix has
# more columns than rows!!!
m[1, nil]
m[-2, nil]

# Matrix#[nil, Fixnum] returns a Vector::Col::View of the entire column
# specified by the Fixnum argument.  A negative value is treated as counting
# backwards from the end of the corresponding dimension.  NOTE: GSL 1.11 (and
# maybe earlier versions) has a bug that prevents this from working if the
# Matrix has more rows than columns!!!
m[nil, 1]
m[nil, -2]

# Matrix#[Range,nil] returns a Matrix::View of all columns and the rows
# specified by the Range argument.  Note that negative begin and/or end values
# are treated as counting backwards from the end of corresponding dimension.
m[1...3, nil]
m[0..-2, nil]
m[-2..3, nil]
m[-2..-1, nil]

# Matrix#[nil, Range] returns a Matrix::View of all rows and the columns
# specified by the Range argument.  Note that negative begin and/or end values
# are treated as counting backwards from the end of corresponding dimension.
m[nil, 1...3]
m[nil, 0..-2]
m[nil, -2..3]
m[nil, -2..-1]

# Matrix#[Range, Fixnum] returns a Vector::Col::View of the rows specified
# by the Range argument of the column specified by the Fixnum argument.  A
# negative value is treated as counting backwards from the end of the
# corresponding dimension.  NOTE: GSL 1.11 (and maybe earlier versions) has a
# bug that prevents this from working if the Matrix has more rows than
# columns!!!
m[1...3, 0]
m[0..-2, 1]
m[-2..3, -2]
m[-2..-1, -1]

# Matrix#[Fixnum, Range] returns a Vector::View of the columns specified
# by the Range argument of the row specified by the Fixnum argument.  A
# negative value is treated as counting backwards from the end of the
# corresponding dimension.  NOTE: GSL 1.11 (and maybe earlier versions) has a
# bug that prevents this from working if the Matrix has more rows than
# columns!!!
m[0, 1...3]
m[1, 0..-2]
m[-2, -2..3]
m[-1, -2..-1]

# When Matrix#[] is called with three arguments, the first or last argument
# must be nil or a Range and the other two arguments must be Fixnums.  The two
# Fixnums indicate a span whose offset is given by the first Fixnum and whose
# length is given by the second Fixnum.  If they are the first two arguments,
# they indicate which rows the returned view will cover.  If they are the last
# two arguments, they indicate which columns the returned view will cover.  The
# nil or Range argument indicate what portion of the other dimension will be
# covered by the returned view (nil means all rows or columns).

# Matrix#[nil, Fixnum, Fixnum] returns a Matrix::View covering all rows of
# the column span specified by the two Fixnums.
m[nil, 1, 2]
m[nil, -2, 2]

# Matrix#[Fixnum, Fixnum, nil] returns a Matrix::View covering all columns
# of the row span specified by the two Fixnums.
m[nil, 1, 2]
m[nil, -2, 2]

# Matrix#[Range, Fixnum, Fixnum] returns a Matrix::View covering Range rows
# of the column span specified by the two Fixnums.
m[0...2, -3, 2]
m[1..-2, 1, 2]
m[-3..-1, 3, 1]
m[-4...4, -4, 2]

# Matrix#[Fixnum, Fixnum, Range] returns a Matrix::View covering Range
# columns of the row span specified by the two Fixnums.
m[-3, 2, 0...2]
m[1, 2, 1..-2]
m[3, 1, -3..-1]
m[-4, 2, -4...4]

# When Matrix#[] is called with four arguments, all four arguments must be
# Fixnums.  The first two Fixnums specify the Matrix element that will be the
# upper left corner of the view (negative values are treated as counting
# backwrds from the end of the corresponding dimension).  The last two Fixnums
# specify the number of rows and columns that the view will have.
m[0, 1, 2, 3]
m[-2, -3, 2, 1]
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create 3x3 Matrix::Complex mz
mz = GSL::Matrix::Complex.alloc(3, 3)

# Set element at row 1, column 2 to 3+5.6i
mz.set(1, 2, GSL::Complex[3, 5.6])

# Get element at row 1, column 2
a = mz.get(1, 2)

# Create Matrix::Complex::View of mz
# starting at row 1, column 1 and
# spanning 2 rows and 2 columns
mzv = mz.submatrix(1, 1, 2, 2)

# Create a Vector::Complex::View for row 1 of mz
row = mz.row(1)

# Create a Vector::Complex::Col::View for column 2 of mz
col = mz.col(2)

# Iterate through rows of mz
mz.each_row do |v|
  p v
end

# Iterate through columns of mz
mz.each_col do |v|
  p v
end
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test matrix m
m = GSL::Matrix.alloc([1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 3)

# Set rows of m from Arrays
m.set([6, 5, 6], [4, 5, 7], [8, 5, 21])

# Set column 1 of m from GSL::Vector
m.set_col(1, GSL::Vector[12, 3, 55])

# Create transpose of m
m2 = m.transpose

# Swap rows 1 and 2 of m
m.swap_rows(1, 2)

# Create Vector::Col::View for column 0 of m
v = m.col(0)

# Create Vector::View of diagonal of m
m.diagonal

# Create Array containing diagonal elements of m
m.diagonal.to_a

# Create another test matrix m
m = GSL::Matrix.alloc([1, 2, 3], [6, 5, 4], [7, 8, 1])

# Get element at row 1, column 2
m.get(1, 2)

# Perform LU decomposition of m
lu, perm, sign = m.LU_decomp

# Create 5x5 zero matrix m5
m5 = GSL::Matrix.alloc(5, 5)

# Initialize elements of m5
for i in 0...5 do
  for j in 0...5 do
    m5[i, j] = 0.5*(i+0.4)*(j+1.2)
  end
end

# Show m5
m5
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create a 2x2 test Matrix m
m = GSL::Matrix.alloc(2, 2)

# Read data into Matrix m from binary file a.dat using #fread
m.fread("a.dat")

# Show m
m

# Create a 2x2 test Matrix m2
m2 = GSL::Matrix.alloc(2, 2)

# Read data into Matrix m2 from text file b.dat using #fscanf
m2.fscanf("b.dat")

# Show m2
m2
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create a 3x3 matrix
m = GSL::Matrix.alloc([1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 3)

# Create a 3x4 matrix
m = GSL::Matrix.indgen(3, 4)

# Set element at row 1, column 2 to 99.9
m[1,2] = 99.9

# Show matrix
m

# Set all elements to 5 using #set_all
m.set_all(5)

# Set all elements to 4.3 using #set
m.set(4.3)

# Set all elements to 2 using #[]
m[] = 2

# Show matrix
m

# Set all elements to 0
m.set_zero

# Set matrix to identity matrix
m.set_identity
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create two 3x3 test matrices
a = GSL::Matrix.alloc([1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 3)
b = GSL::Matrix.alloc([6, 7, 8], [2, 3, 4], [3, 4, 5])

# Multiply elements of Matrix a by 2 (Matrix a remains unmodifided)
a * 2

# Multiply elements of Matrix a by 2 (Matrix a remains unmodifided)
2 * a

# Multiply elements of Matrix a by 2, modifying Matrix a
a *= 2

# Show a
a

# Divide elements of Matrix a by 2, modifying Matrix a
a /= 2

# Show a
a

# Matrix-multiply Matrix a and Matrix b
a*b

# Do element-wise multiplication of a and b
a.mul_elements(b)
END
#!/usr/bin/env ruby
require("gsl")

for n in 0..10
  p GSL::Poly.bell(n)
end
#!/usr/bin/env ruby
require("gsl")

for n in 0..10
  p GSL::Poly.cheb(n)
end
#!/usr/bin/env ruby
require('gsl')

poly = GSL::Poly.alloc(-1, 0, 0, 0, 0, 1)

w = GSL::Poly::Complex::Workspace.alloc(6)
z = poly.solve(w)

for i in 0...5 do
  printf("z%d = %+.18f %+.18f\n", i, z[i].re, z[i].im)
end

__END__
#!/usr/bin/env ruby
require("gsl")
include GSL

x = Vector[1, 2, 3, 4, 5]
y = Vector[5.5, 43.1, 128, 290.7, 498.4]
coef, cov, chisq, status = Poly.fit(x, y, 3)
p coef
x2 = Vector.linspace(1, 5, 20)
graph([x, y], [x2, coef.eval(x2)], "-C -g 3 -S 4 -X X -Y Y")

#

x = Vector[0, 0.3, 0.8, 1.1, 1.6, 2.3]
y = Vector[0.5, 0.82, 1.14, 1.25, 1.35, 1.40]
coef, cov, chisq, status = MultiFit.polyfit(x, y, 2)
p coef
x2 = Vector.linspace(0, 2.5, 20)
graph([x, y], [x2, coef.eval(x2)], "-C -g 3 -S 4 -X X -Y Y")


#!/usr/bin/env ruby
require("gsl")

for n in 0..10
  p GSL::Poly.bessel(n)
end
#!/usr/bin/env ruby
require("gsl")

for n in 0..10
  p GSL::Poly.hermite(n)
end
#!/usr/bin/env ruby
require('gsl')

puts("Solve 2 - 3*x + x*x = 0")

p GSL::Poly.solve_quadratic([1, -3, 2])
p GSL::Poly.solve_quadratic(1, -3, 2)
z = GSL::Poly.complex_solve_quadratic(1, -3, 2)
printf("%f %f\n", z[0].re, z[0].im)
printf("%f %f\n", z[1].re, z[1].im)
#p GSL::Poly.complex_solve_quadratic([1, -3, 2])
#z = GSL::Poly.solve([2, -3, 1])

poly = GSL::Poly.alloc(2, -3, 1)
z = poly.solve
printf("%f %f\n", z[0].re, z[0].im)
printf("%f %f\n", z[1].re, z[1].im)

z = GSL::Poly.solve([2, -3, 1])
printf("%f %f\n", z[0].re, z[0].im)
printf("%f %f\n", z[1].re, z[1].im)



__END__
#!/usr/bin/env ruby
require("gsl")
include GSL

# Polynomial p(x) = 1.5-1.25x-3.75x^2+x^4
poly = Poly[1.5, -1.25, -3.75, 0, 1]
# Solve the equation p(x) == 0
root = poly.solve    # Vector::Complex
# Extract only the real parts
# (imaginary parts are zero for this case)
re = root.real       # Vector::View

puts("p(x) = 1.5-1.25x-3.75x^2+x^4 == 0")
puts("Roots are found at #{re[0]}, #{re[1]}, #{re[2]}, #{re[3]}")

# Display the result
x = Vector.linspace(-2.5, 2.5, 20)
y = poly.eval(x)
zero = Vector.calloc(4)
graph([x, y], [re, zero], "-T X -C -g 3 -S 4 -X x -L 'p(x) = 1.5-1.25x-3.75x^2+x^4'")
#!/usr/bin/env ruby
require('gsl')

puts("Solve x^3 - 1 == 0")
puts("x = 1, (-1 +/- i sqrt(3))/2")
p GSL::Poly.complex_solve_cubic(0, 0, -1)


__END__
#!/usr/bin/env ruby
require("gsl")

# f(x) = 1 + 2x + 3x^3
# Evaluate at x = 2 ---> f(x) = 17
p GSL::Poly.eval([1, 2, 3], 2)
p GSL::Poly.eval([1, 2, 3].to_gv, 2)
p GSL::Poly.eval(NArray[1.0, 2, 3], 2)

# f(1) = 6, f(2) = 17, f(3) = 34
p GSL::Poly.eval([1, 2, 3], [1, 2, 3])
p GSL::Poly.eval([1, 2, 3], [1, 2, 3].to_gv)
p GSL::Poly.eval([1, 2, 3], NArray[1.0, 2, 3])


v = GSL::Vector[1, 2, 3]
p GSL::Poly.eval(v, [1, 2, 3])
p GSL::Poly.eval(v, [1, 2, 3].to_gv)
p GSL::Poly.eval(v, NArray[1.0, 2, 3])

v = NArray[1.0, 2, 3]
p GSL::Poly.eval(v, [1, 2, 3])
p GSL::Poly.eval(v, [1, 2, 3].to_gv)
p GSL::Poly.eval(v, NArray[1.0, 2, 3])

v = GSL::Vector[1, 2, 3]
x = GSL::Matrix.alloc(1...9, 3, 3)
p GSL::Poly.eval(v, x)
#!/usr/bin/env ruby
require("gsl")

poly = [1, 2, 3]
p GSL::Poly::eval_derivs(poly, 1)   # Returned Array

poly = NArray[1.0, 2, 3]
p GSL::Poly::eval_derivs(poly, 1)   # Returned NArray

poly = GSL::Poly.alloc([1, 2, 3])   # Returned GSL::Poly
p GSL::Poly::eval_derivs(poly, 1)

p poly.eval_derivs(1, 3)

#!/usr/bin/env ruby
require("gsl")

for n in 0..10
  p GSL::Poly.cheb_II(n)
end
#!/usr/bin/env ruby
require("gsl")

N = 10000
r = GSL::Rng.alloc
v = r.gaussian(1, N)
h = v.histogram(100, -4, 4)
h.graph

#!/usr/bin/env ruby
# 1-dimensional random work:
# This demonstrates 1000 trials of 50 left-or-right steps.
# The distribution of the end points of the trials
# will be Gaussian of standard deviation sqrt(50).

require("gsl")

N = 50
M = 1000
GSL::Rng.env_setup()
T = GSL::Rng::DEFAULT
seed = 2
rng = GSL::Rng.alloc(T, seed)

sigma = Math::sqrt(N).to_i

h = GSL::Histogram.alloc(8*sigma+1, [-4*sigma-0.5, 4*sigma+0.5])

M.times do
  s = 0
  N.times do
    ds = rng.get%2 == 0 ? 1 : -1
    s += ds
  end
  h.increment(s)
end

x = GSL::Vector.linspace(-40, 40, 80)
y = GSL::Ran::gaussian_pdf(x, sigma)*M*2
# Factor 2 is not important, but necessary
# because only the even ranges are filled:
#   a + b = N     a: positive steps, b: negative steps
#   a - b = s     s: the end point after the N steps
# Since N = 1000 and a, b, s are integer, s must be even.
GSL::graph(h, [x, y], "-C -x #{-4*sigma} #{4*sigma}")

#!/usr/bin/env ruby
# 1-dimensional random work:
# This demonstrates M = 1000 trials of N = 6, 50 and 100 left-or-right steps.
# The distribution of the end points of the trials
# will be Gaussian of standard deviation sqrt(N).

require("gsl")

M = 1000
GSL::Rng.env_setup()
T = GSL::Rng::DEFAULT
seed = 2
rng = GSL::Rng.alloc(T, seed)

h = Array.new(3)
h[0] = GSL::Histogram.alloc(61, -30, 30)
h[1] = GSL::Histogram.alloc(61, -30, 30)
h[2] = GSL::Histogram.alloc(61, -30, 30)

i = 0
for n in [6, 50, 100] do
  M.times do
    s = 0
    n.times do
      ds = rng.get%2 == 0 ? 1 : -1
      s += ds
    end
    h[i].increment(s)
  end
  i += 1
end

#GSL::graph(h[0].shift(250), h[1].shift(100), h[2])
GSL::graph(h[0] + 250, h[1] + 100, h[2])
#!/usr/bin/env ruby
require("gsl")
rng = GSL::Rng.alloc()

N = 100
XMAX = 5.0
sigma = 1.0
h = GSL::Histogram.alloc(N, 0, XMAX)
for i in 0...10000 do
  x = rng.rayleigh(sigma)
  h.increment(x)
end

sig, amp = h.fit_rayleigh
p sig
p amp

v = GSL::Vector.linspace(0, XMAX, N)
val = GSL::Ran::rayleigh_pdf(v, sig)
val *= amp
GSL::graph(h, [v, val], "-T X -C")

h2 = GSL::Histogram.alloc(N, 0, XMAX)
for i in 0...10000 do
  x = rng.gaussian(sigma)
  y = rng.gaussian(sigma)
  r = Math.sqrt(x*x + y*y)
  h2.increment(r)
end
sig2, amp2 = h2.fit_rayleigh
p sig2
p amp2
val2 = GSL::Ran::rayleigh_pdf(v, sig2)
val2 *= amp2
GSL::graph(h2, [v, val2], "-T X -C")

#!/usr/bin/env ruby
require("gsl")
include GSL

names = ["default", "mt19937", "mt19937_1999", "mt19937_1998", "ranlxs0", "ranlxs1",
"ranlxs2", "ranlxd1", "ranlxd2", "ranlux", "ranlux389", "cmrg", "mrg", "taus", "taus2",
"gfsr4", "rand", "random_bsd", "random8_bsd", "random32_bsd", "random64_bsd",
"random128_bsd", "random256_bsd", "random_libc5", "random_glibc2", "rand48", "ran0",
"ran1", "ran2", "ran3", "ranf", "ranmar", "r250", "tt800", "vax", "transputer",
"randu", "minstd", "uni", "uni32", "slatec", "zuf", "borosh13", "coveyou",
"fishman18", "fishman20", "fishman2x", "knuthran2", "knuthran", "lecuyer21",
"waterman14"]

names.each do |name|
  r = Rng.alloc(name)
  printf("%s %s\n", name, r.name)
end

names.each do |name|
  name2 = "gsl_rng_" + name
  r = Rng.alloc(name)
  printf("%s %s\n", name, r.name)
end


r = Rng.alloc(Rng::KNUTHRAN)
p r.name
#!/usr/bin/env ruby
require("gsl")

r = GSL::Rng.alloc
10.times {
  p r.uniform
}

__END__
#include GSL
#require 'gsl/gsl_rng'

r = GSL::Random::Rng.alloc
r.set(2)
p r.get
p r.get
p r.max
p r.get
p r.get

r2 = GSL::Random::Rng.alloc
p r2.uniform
p r2.uniform

__END__
rf = GSL::Random::Rng.alloc
p rf.uniform
p rf.uniform

p rf.name


p gsl_rng_types_setup
#!/usr/bin/env ruby
require("gsl")

N = 1000
GSL::Rng.env_setup()
T = GSL::Rng::DEFAULT
r = GSL::Rng.alloc(T)

x = 0.0
y = 0.0

printf("%g %g\n", x, y);

N.times do
  dx, dy = r.dir_2d()
  x += dx
  y += dy
  printf("%g %g\n", x, y);
end
#!/usr/bin/env ruby
require("gsl")

r1 = GSL::Rng.alloc(GSL::Rng::RNGEXTRA_RNG1)
p r1.name
p r1.uniform
p r1.gaussian

r2 = GSL::Rng.alloc("rngextra_rng2")
p r2.name
p r2.get
p r2.get
p r2.uniform
p r2.poisson(3)
#!/usr/bin/env ruby
require("gsl")
include GSL

dim = 2
#q = QRng.alloc(QRng::SOBOL, dim)
q = QRng.alloc("sobol", dim)
#q = QRng.alloc("niederreiter_2", dim)
#q = QRng.alloc(QRng::NIEDERREITER_2, dim)

v = Vector.alloc(dim)
IO.popen("graph -T X -C --title-font-size 0.04 -L 'Distribution of first 1024 points from the quasi-random Sobol sequence' -m -1 -S 2", "w") do |io|
  for i in 0..1024 do
    #       v = q.get()    # by creating a alloc vector
    q.get(v)       # by using an existing vector (efficient)
    io.printf("%e %e\n", v[0], v[1])
  end
end

#!/usr/bin/env ruby
require("gsl")

N = 10000
r = GSL::Rng.alloc
v = r.poisson(5, N)
h = v.histogram(20, 0, 20)
h.graph

#!/usr/bin/env ruby
require("gsl")
include GSL

dim = 2
q = QRng.alloc(QRng::HDSOBOL, dim)
#q = QRng.alloc("sobol", dim)
#q = QRng.alloc("niederreiter_2", dim)
#q = QRng.alloc(QRng::NIEDERREITER_2, dim)

p q.name

v = Vector.alloc(dim)
IO.popen("graph -T X -C --title-font-size 0.04 -L 'Distribution of first 1024 points from the quasi-random HDSobol sequence' -m -1 -S 2", "w") do |io|
  for i in 0..1024 do
    #       v = q.get()    # by creating a alloc vector
    q.get(v)       # by using an existing vector (efficient)
    io.printf("%e %e\n", v[0], v[1])
  end
end

#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create Vector of 10 elements increasing logarithmically
# from 0 to 10000, inclusive, using Vector.logspace
v = GSL::Vector.logspace(0, 4, 10)

# Plot v
v.graph("-C -Y v -l y -S 4 -L 'Vector.logspace(0, 4, 10)'")

# Create Vector of 10 elements increasing logarithmically
# from 0 to 10000, inclusive, using Vector.logspace2
v = GSL::Vector.logspace2(1, 10000, 10)

# Plot v
v.graph("-C -Y v -l y -S 4 -L 'Vector.logspace2(1, 10000, 10)'")
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create three Vectors: x, y, z
x = GSL::Vector::Int[1, 2, 3]
y = GSL::Vector::Int[1, 2, 5]
z = GSL::Vector::Int[0, 2, 9]

# Test element-wise "==" method
x.eq(y)

# Test element-wise "!=" method
x.ne(y)

# Test element-wise ">=" method
x.ge(y)

# Test element-wise "<" method
x.lt(z)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create three test Vectors
v1 = GSL::Vector[1..2]
v2 = GSL::Vector[3..4]
v3 = GSL::Vector[5..7]

# Connect them using GSL::Vector#connect
v1.connect(v2, v3)

# Connect them using GSL::Vector.connect
GSL::Vector.connect(v1, v2, v3)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Vector containing the first few powers of 10
v = GSL::Vector[1, 10, 100, 1000, 10000]

# Take log10 of v
v.log10
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# These examples show all(?) the ways that a Vector::Complex::Complex::View can
# be created using Vector::Complex#subvector or its alias Vector::Complex#view.
# Note that Vector::Complex#get or, more commonly, its alias Vector::Complex#[]
# can also be used to create a Vector::Complex::View.  See
# examples/vector/complex_get_all.rb for more examples.

# Create test vector v
v = GSL::Vector::Complex.indgen(9)

# Vector::Complex#view with zero args returns a Vector::Complex::View of entire
# Vector::Complex.
v.view

# Vector::Complex#view with one Fixnum argument, i, returns a
# Vector::Complex::View of the first i'th elements if i is positive or the last
# i'th elements if i is negative.
v.view(3)
v.view(-3)

# Vector::Complex#view with one Range argument returns a Vector::Complex::View
# of the specified elements.  If the begin value is greater than the end value,
# the View will have the elements in reverse order.  If begin and/or end value
# is negative, the value is taken to be "size-n".
v.view(1..4)
v.view(4..1)
v.view(1...4)
v.view(4...1)

v.view(4..-2)
v.view(-2..4)
v.view(4...-2)
v.view(-2...4)

v.view(-4..8)
v.view(8..-4)
v.view(-4...8)
v.view(8...-4)

v.view(-5..-2)
v.view(-2..-5)
v.view(-5...-2)
v.view(-2...-5)

# Vector::Complex#view with a Range argument and a Fixnum argument is like a
# single Range argument, but with a stride given by the Fixnum argument.
v.view(1..7, 3)
v.view(7..1, 3)
v.view(1...7, 3)
v.view(7...1, 3)

# Vector::Complex#view with two Fixnum arguments is offset, length.  If offset
# is negative, it means size+offset.  If length is negative, it means step is
# -1.
v.view(2, 4)
v.view(4, 2)
v.view(-4, 2)
v.view(-2, -4)

# Vector::Complex#view with three Fixnum arguments is offset, stride, length.
# If offset is negative, it means size+offset.  If length is negative, the sign
# of both stride and length is inverted.
v.view(1, 2, 3)
v.view(1, -2, -3)
v.view(-1, -2, 3)
v.view(-1, 2, -3)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create NMatrix m
m = NMatrix[[0, 1.2, 1],[1.5, 0, 2]]

# Convert NMatrix m to Vector gv
gv = m.to_gv

# Convert Vector gv to NArray m2
m2 = gv.to_na
m2.class

# Create GSL::Vector v
v = GSL::Vector.alloc(1..4)

# Convert v to NArray na
na = v.to_na
na.class

# Convert na back to Vector
v2 = na.to_gv

# Create new Vector copy of na
v3 = GSL::Vector.alloc(na)

# Create Vector::View of na
v4 = na.to_gv_view

# Set element of Vector::View
v4[2] = 123

# Show that na was modified
na

# Show that v3 was not modified
v3
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test vector v
v = GSL::Vector.alloc(1, 2, 3, 4, 5, 6, 7, 8, 9)

# Create Vector::View of Vector v starting at element 2 and spanning 3 elements
vv = v.subvector(2, 3)

# Set element 1 of View to 9.0
vv.set(1, 9)

# Show that Vector is also modified
v

# Create Matrix::View of Vector
m = v.matrix_view(3, 3)

# Create Vector::View spanning the entire Vector
v2 = v.view

# Create Vector::View of Vector starting at element 0 and spanning 3 elements
v2 = v.view(3)

# Show size of Vector::View
v2.size
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create Vector of 10 elements increasing linearly
# from 0 to 5, inclusive, using Vector.linspace
v = GSL::Vector.linspace(0, 5, 10)

# Plot v
v.graph("-C -Y v -S 4 -L 'Vector.linspace(0, 5, 10)'")

# Create Vector of 11 elements from 0 to 5, inclusive, using Vector.linspace
v = GSL::Vector.linspace(0, 5, 11)

# Plot v
v.graph("-C -Y v -S 4 -L 'Vector.linspace(0, 5, 11)'")
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create three test vectors of varying lengths
a = GSL::Vector[0..4]
b = GSL::Vector[2, 3, 4]
c = GSL::Vector[5, 7, 4, 8, 9, 2]

# Zip them together using Vector#zip
a.zip(b, c)

# Zip them together using GSL::Vector.zip
GSL::Vector.zip(a, b, c)

# Convert test Vectors to Vector::Complex
aa = a.to_complex
bb = b.to_complex
cc = c.to_complex

# Zip Vector::Complex objects together using Vector::Complex#zip
aa.zip(bb, cc)


# Zip Vector::Complex objects together using GSL::Vector::Complex.zip
GSL::Vector::Complex.zip(aa, bb, cc)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Setup constants
N = 1000
DECIMATE1 = 10
DECIMATE2 = 100

# Setup random number generator
r = GSL::Rng.alloc

# Create Vector of x values
x0 = GSL::Vector.linspace(0, 20, N)

# Data: Bessel function + noise
y0 = GSL::Sf::bessel_J0(x0) + GSL::Ran::gaussian(r, 0.1, N)

# Decimate y0 by DECIMATE1
y1 = y0.decimate(DECIMATE1)

# Decimate y0 by DECIMATE2
y2 = y0.decimate(DECIMATE2)

# Create Vectors of decimated x values
x1 = GSL::Vector.linspace(0, 20, N/DECIMATE1)
x2 = GSL::Vector.linspace(0, 20, N/DECIMATE2)

# y1 and y2 are shifted vertically for visual purpose
GSL::graph([x0, y0], [x1, y1-1], [x2, y2-2])
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create two Vectors
a = GSL::Vector.alloc(1, 2, 3, 4, 5)
b = GSL::Vector.alloc(6, 7, 8, 9, 10)

# Show the sum of a and b
a + b

# Add b to a
a += b

# Show a
a

# Subtract b from a
a -= b

# Show a
a

# Create new Vector containing 2 added to all elements of a
a + 2

# Show that a remains unmodified
a

# Add 2 to all elements of a in-place
a += 2

# Show the modified a
a

# Subtract 2 from all elements of a in-place
a -= 2

# Show that a remains unmodified
a

# Show coersion
2 + a

5 - a

# Show that a remains unmodified
a
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
#Create test Vector
v = GSL::Vector[1.1, 2.7, 3.5, 5.8, -1.2, -2.8, -3.5]

# Show result of #floor
v.floor

# Show result of #ceil
v.ceil

# Show result of #round
v.round
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Vector::Int
z = GSL::Vector::Int[1, 0, 0, 5, 2, 0, 9]


# #where without a block indices of non-zero elements.
z.where

# #where with a block returns indices of elements for which block returns true.
z.where {|e| e >= 2}

# #where2 without a block returns ["indices of non-zero elemens", "indices of
# zero elements"]
z.where2

# #where2 with a block returns ["indices of elements for which block returned
# true", "indices of elements for which block returned false"]
z.where2 {|e| e >= 2}
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Vector
a = GSL::Vector.alloc(1, 2, 3, 4, 5)

# Find maximum
a.max

# Find minimum
a.min

# Find minimum and maximum
a.minmax

# Find index of maximimum
a.max_index

# Find index of minimimum
a.min_index

# Find indices of minimum and maximum
a.minmax_index

# Show that #isnull returns 0 for non-null Vector
a.isnull

# Show that #isnull? returns false for non-null Vector
a.isnull?

# Set all elements to zero
a.set_zero

# Show that #isnull returns 1 for null Vector
a.isnull

# Show that #isnull? returns true for null Vector
a.isnull?
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create Vector to plot
y1 = GSL::Vector[0.2, 3, 2, 0.4, 0, 4, 0]

# Plot it using #graph()
y1.graph

# Create x and y2 Vectors
x = GSL::Vector.linspace(0, 10, 50)

y2 = GSL::Sf::bessel_J0(x)

# Plot x vs y using #graph(x)
y2.graph(x)

# Plot y1 and x vs y2 using GSL::Vector.graph
GSL::Vector.graph([nil, y1], [x, y2])
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# These examples show some of the ways that Vector#set or its alias Vector#[]=
# can be invoked.  For a single argument, this is equivalent to Vector#set_all.
# For two arguments with the first a Fixnum i, this sets the i'th element (or
# the (size-i)'th element to the value of the second argument.  All other forms
# treat all but the last argument as with Vector#subvector and set the
# specified elements based on the last argument, which can be a Vector (or
# Vector::View), an Array, a Range, or a Numeric.  Vector, Array, and Range
# rvalues must have the same number of elements as the specified subvector.
# For a Numeric rvalue, all elements of the subvector are set to that value.
#
# Note the different return values of Vector#set and Vector#[]=.  Vector#set
# return self, but Vector[]= return the value to the right of the = sign.  This
# must be standard Ruby behavior since the underlying code returns the same
# value to Ruby regardless of whether it is invoked as #set or #[]=.
#
# Also be careful is setting part of a Vector from another part of the same
# vector.  The GSL method that performs this operation uses memcpy, which does
# not handle overlapping memory regions in a well defined way.  See the last
# two examples.
#
# See examples/vector/view_all.rb for additional examples of how to specify
# subvectors.

# Create test vector v
v = GSL::Vector.indgen(9)

# Vector#set and Vector#[]= with one arg sets all elements
v.set(1.2)
v[] = 3.4
v

# Vector#[i]= Numeric sets the i'th element if i is
# positive or the (size+i)'th element if i is negative.
v[3] = 5.6
v[-8] = 7.8
v

# Specifying subvector using Range with various rvalue types
v[1..4] = GSL::Vector[2, 3, 5, 7] # rvalue is Vector
v

v[1..4] = [11, 13, 17, 19] # rvalue is Array
v

v[1..4] = 24..27 # rvalue is Range
v

v[1..4] = 1.0 # rvalue is Numeric
v

# Specifying subvector using Range and stride with various rvalue types
v[0..4, 2] = GSL::Vector[2, 3, 5] # rvalue is Vector
v

v[0..4, 2] = [7, 11, 13] # rvalue is Array
v

v[0..4, 2] = 8..10 # rvalue is Range
v

v[0..4, 2] = 1.0 # rvalue is Numeric
v

# Specifying subvector using two Fixnums (offset, length) with various rvalue
# types
v[2, 4] = GSL::Vector[2, 3, 5, 7] # rvalue is Vector
v

v[2, 4] = [11, 13, 17, 19] # rvalue is Array
v

v[2, 4] = 24..27 # rvalue is Range
v

v[2, 4] = 1.0 # rvalue is Numeric
v

# Specifying subvector using three Fixnum arguments (offset, stride, length)
# with various rvalue types
v[1, 2, 3] = GSL::Vector[2, 3, 5] # rvalue is Vector
v

v[1, 2, 3] = [7, 11, 13] # rvalue is Array
v

v[1, 2, 3] = 8..10 # rvalue is Range
v

v[1, 2, 3] = 1.0 # rvalue is Numeric
v

# Copying part of a Vector to another part of the same Vector can potentially
# be problematic if the regions overlap.
v.indgen!
v[0, 3] = v[2, 3]
v

v.indgen!
v[2, 3] = v[0, 3]
v

# But it's OK if the regions do not overlap
v.indgen!
v[0, 3] = v[3, 3]
v

v.indgen!
v[3, 3] = v[0, 3]
v
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Vector with 15 elements initialized to 0.0
v = GSL::Vector::alloc(15)

# Set elements of v from file smpv.dat
File.open("smpv.dat") do |f|
  v.fscanf(f)
end

# Show v
v

# Create another test vector with three elements
# initialized to 10.0, 1.0, and 3.0.
v2 = GSL::Vector.alloc(10, 1, 3)
END

__END__

# TODO Remove examples below that are duplicated elsewhere
# TODO Include examples below that are not duplicated elsewhere
v = GSL::Vector::alloc([9, 1, 2, 3, 12, 6, 0.1, 0.56, 5, 7, 2])
v.print
p v.size
v2 = GSL::Vector::alloc(11)
v2.set(1, 123)
p v2.to_a

v = GSL::Vector::alloc([1, 2, 3, 4, 5])
v.print
a = v.to_a
p a
a[2] = 12.0
v2 = a.to_gv
v2.print
__END__

p = v.sort_index
p p.to_a

v2 = GSL::Vector::alloc([5, 6, 7])

v3 = v2.scale!(2)
v3.print
v2.print

p v3.minmax

p v3.max_index
p v3.min_index
p v3.minmax_index

a = [1, 2, 3]
v = a.to_gv
p v.to_a

__END__

v3 = v * v2
v3.print

v.print

v.mul!(v2)
v.print

__END__

v = GSL::Vector::alloc(10)
for i in 1...10 do
  v.set(i, i.to_f)
end
v.print

v.swap_elements(3, 5)
v.print

v.reverse.print

__END__

v2 = v.subvector(2, 3)
v2.print

v3 = v.subvector_with_stride(2, 2, 3)
v3.print

v3.set([2, 3, 9])
v3.print

v4 = GSL::Vector::alloc([1, 2, 3, 5])
v4.print

a = v4.to_a
p a

__END__
v.each do |x|
  p x
end
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# These examples show all(?) the ways that a Vector::View can be created using
# Vector#subvector or its alias Vector#view.  Note that Vector#get or, more
# commonly, its alias Vector#[] can also be used to create a Vector::View.  See
# examples/vector/get_all.rb for more examples.

# Create test vector v
v = GSL::Vector.indgen(9)

# Vector#view with zero args returns a Vector::View of entire Vector
v.view

# Vector#view with one Fixnum argument, i, returns a Vector::View of the first
# i'th elements if i is positive or the last i'th elements if i is negative.
v.view(3)
v.view(-3)

# Vector#view with one Range argument returns a Vector::View of the specified
# elements.  If the begin value is greater than the end value, the View will
# have the elements in reverse order.  If begin and/or end value is negative,
# the value is taken to be "size-n".
v.view(1..4)
v.view(4..1)
v.view(1...4)
v.view(4...1)

v.view(4..-2)
v.view(-2..4)
v.view(4...-2)
v.view(-2...4)

v.view(-4..8)
v.view(8..-4)
v.view(-4...8)
v.view(8...-4)

v.view(-5..-2)
v.view(-2..-5)
v.view(-5...-2)
v.view(-2...-5)

# Vector#view with a Range argument and a Fixnum argument is like a single
# Range argument, but with a stride given by the Fixnum argument.
v.view(1..7, 3)
v.view(7..1, 3)
v.view(1...7, 3)
v.view(7...1, 3)

# Vector#view with two Fixnum arguments is offset, length.  If offset is
# negative, it means size+offset.  If length is negative, it means step is -1.
v.view(2, 4)
v.view(4, 2)
v.view(-4, 2)
v.view(-2, -4)

# Vector#view with three Fixnum arguments is offset, stride, length.  If offset
# is negative, it means size+offset.  If length is negative, the sign of both
# stride and length is inverted.
v.view(1, 2, 3)
v.view(1, -2, -3)
v.view(-1, -2, 3)
v.view(-1, 2, -3)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# These examples show all(?) the ways that Vector::Complex#get or its alias
# Vector::Complex#[] can be invoked.  For a single Fixnum argument, a single
# element is returned.  For a single Array or GSL::Permutation argument, a new
# GSL::Vector::Complex containing the specified elements, in the specified
# order, is returned.  For all other cases, Vector::Complex#get is essentially
# an alias for Vector::Complex#subvector.  See examples/vector/view_all.rb for
# more examples.

# Create test vector v
v = GSL::Vector::Complex.indgen(9)

# Vector::Complex#[] with zero args returns a Vector::Complex::View of entire
# Vector::Complex
v[]

# Vector::Complex#[] with one Fixnum argument, i, returns the i'th element if i
# is positive or the (size+i)'th element if i is negative.
v[3]
v[-3]

# Vector::Complex#[] with single Array argument.  Notice the inner pair of
# brackets!
v[[1,4,-9]]

# Vector::Complex#[] with a single GSL::Permutation argument.
p = GSL::Permutation.calloc(4).reverse
v[p]

# Vector::Complex#[] with one Range argument returns a Vector::Complex::View of
# the specified elements.  If the begin value is greater than the end value,
# the View will have the elements in reverse order.  If begin and/or end value
# is negative, the value is taken to be "size-n".
v[1..4]
v[4..1]
v[1...4]
v[4...1]

v[4..-2]
v[-2..4]
v[4...-2]
v[-2...4]

v[-4..8]
v[8..-4]
v[-4...8]
v[8...-4]

v[-5..-2]
v[-2..-5]
v[-5...-2]
v[-2...-5]

# Vector::Complex#[] with a Range argument and a Fixnum argument is like a
# single Range argument, but with a stride given by the Fixnum argument.
v[1..7, 3]
v[7..1, 3]
v[1...7, 3]
v[7...1, 3]

# Vector::Complex#[] with two Fixnum arguments is offset, length.  If offset is
# negative, it means size+offset.  If length is negative, it means step is -1.
v[2, 4]
v[4, 2]
v[-4, 2]
v[-2, -4]

# Vector::Complex#[] with three Fixnum arguments is offset, stride, length.  If
# offset is negative, it means size+offset.  If length is negative, the sign of
# both stride and length is inverted.
v[1, 2, 3]
v[1, -2, -3]
v[-1, -2, 3]
v[-1, 2, -3]
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Vector
v = GSL::Vector.alloc([1, 2, 3, 4])

# Write Vector in binary format to file a.dat
v.fwrite("a.dat")

# Create another test Vector
v2 = GSL::Vector.alloc([5, 6, 7, 8])

# Write Vector in text format to file b.dat
v2.fprintf("b.dat")
END

#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create 10,000 random numbers from Gaussian distribution
N = 10000
r = GSL::Rng.alloc
v = r.gaussian(1.0, N)    # Generate N random numbers

# Bin them into 50 bins spanning -4 to +4
h = v.histogram(50, [-4, 4])

# Plot them using graph
h.graph("-T X -C -g 3")
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'gnuplot'
require 'gsl'
require 'gsl/gnuplot';

# Plot using gnuplot
Gnuplot.open do |gp|
  Gnuplot::Plot.new( gp ) do |plot|

    plot.xrange "[0:10]"
    plot.yrange "[-1.5:1.5]"
    plot.title  "Sin Wave Example"
    plot.xlabel "x"
    plot.ylabel "sin(x)"
    plot.pointsize 3
    plot.grid

    x = GSL::Vector[0..10]
    y = GSL::Sf::sin(x)

    plot.data = [
      Gnuplot::DataSet.new( "sin(x)" ) { |ds|
        ds.with = "lines"
        ds.title = "String function"
        ds.linewidth = 4
      },

      Gnuplot::DataSet.new( [x, y] ) { |ds|
        ds.with = "linespoints"
        ds.title = "Array data"
      }
    ]

  end
end
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# These examples show all(?) the ways that Vector#get or its alias Vector#[]
# can be invoked.  For a single Fixnum argument, a single element is returned.
# For a single Array or GSL::Permutation argument, a new GSL::Vector containing
# the specified elements, in the specified order, is returned.  For all other
# cases, Vector#get is essentially an alias for Vector#subvector.  See
# examples/vector/view_all.rb for more examples.

# Create test vector v
v = GSL::Vector.indgen(9)

# Vector#[] with zero args returns a Vector::View of entire Vector
v[]

# Vector#[] with one Fixnum argument, i, returns the i'th element if i is
# positive or the (size+i)'th element if i is negative.
v[3]
v[-3]

# Vector#[] with single Array argument.  Notice the inner pair of brackets!
v[[1,4,-9]]

# Vector#[] with a single GSL::Permutation argument.
p = GSL::Permutation.calloc(4).reverse
v[p]

# Vector#[] with one Range argument returns a Vector::View of the specified
# elements.  If the begin value is greater than the end value, the View will
# have the elements in reverse order.  If begin and/or end value is negative,
# the value is taken to be "size-n".
v[1..4]
v[4..1]
v[1...4]
v[4...1]

v[4..-2]
v[-2..4]
v[4...-2]
v[-2...4]

v[-4..8]
v[8..-4]
v[-4...8]
v[8...-4]

v[-5..-2]
v[-2..-5]
v[-5...-2]
v[-2...-5]

# Vector#[] with a Range argument and a Fixnum argument is like a single
# Range argument, but with a stride given by the Fixnum argument.
v[1..7, 3]
v[7..1, 3]
v[1...7, 3]
v[7...1, 3]

# Vector#[] with two Fixnum arguments is offset, length.  If offset is
# negative, it means size+offset.  If length is negative, it means step is -1.
v[2, 4]
v[4, 2]
v[-4, 2]
v[-2, -4]

# Vector#[] with three Fixnum arguments is offset, stride, length.  If offset
# is negative, it means size+offset.  If length is negative, the sign of both
# stride and length is inverted.
v[1, 2, 3]
v[1, -2, -3]
v[-1, -2, 3]
v[-1, 2, -3]
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create a Vector::Complex of 5 elements, all 0+0i
v = GSL::Vector::Complex.alloc(5)

# Set element 2 to 3+4i
v[2] = [3, 4]

# Show vector
v

# Show element 2
v[2]

# Use #map! to modify each element of vector in-place
i = 0
v.map! do |elm|
  i += 1
  elm += i
end

# Show vector
v

# Show element 3
v[3]

# Set all elements to 2+4.7i
v.set_all([2, 4.7])

# Create subvector starting at element 1 and spanning 3 elements
v2 = v.subvector(1, 3)

# Show size of subvector
v2.size

# Get a Vector::View of the real components of Vector::Complex v
p v.real

# Convert v to an Array
v.to_a
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Vector v
v = GSL::Vector.alloc(4)

# Read data into Vector v from binary file a.dat using #fread
v.fread("a.dat")

# Show v
v

# Create another test Vector
v2 = GSL::Vector.alloc(4)

# Read data into Vector v2 from text file b.dat using #fscanf
v2.fscanf("b.dat")

# Show v2
v2
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# These examples show some of the ways that Vector::Complex#set or its alias
# Vector::Complex#[]= can be invoked.  For a single argument, this is
# equivalent to Vector::Complex#set_all.  For two arguments with the first
# being a Fixnum i, this sets the i'th element (or the (size-i)'th element to
# the complex value derived from the second argument.  The second argument may
# be a Fixnum, Bignum, Float or two element Array.  For the Array case, the
# first element is the real component and the second element is the imaginary
# component.  A nil component leave that component unchanged.  All other forms
# treat all but the last argument as with Vector::Complex#subvector and set the
# specified elements based on the last argument, which can be a Vector::Complex
# (or Vector::Complex::View), Array, Range, Fixnum, Bignum, or Float.
# Vector::Complex, Array, and Range rvalues must have the same number of
# elements as the specified subvector.  For a Fixnum, Bignum, or Float rvalue,
# all elements of the subvector are set to that value.
#
# Note the different return values of Vector::Complex#set and
# Vector::Complex#[]=.  Vector::Complex#set return self, but Vector::Complex[]=
# return the value to the right of the = sign.  This must be standard Ruby
# behavior since the underlying code returns the same value to Ruby regardless
# of whether it is invoked as #set or #[]=.
#
# Also be careful is setting part of a Vector::Complex from another part of the
# same vector.  The GSL method that performs this operation uses memcpy, which
# does not handle overlapping memory regions in a well defined way.  See the
# last two examples.
#
# See examples/vector/complex_view_all.rb for additional examples of how to
# specify subvectors.

# Create test vector v
v = GSL::Vector::Complex.indgen(9)

# Vector::Complex#set and Vector::Complex#[]= with one arg sets all elements
v.set(1.2)
v[] = 3.4
v

# Vector::Complex#[i]= Numeric sets the i'th element if i is
# positive or the (size+i)'th element if i is negative.
v[3] = 5.6
v[-8] = 7.8
v
v[-8] = [nil, 1.0] # Set imaginary component only
v[-8]
v[-8] = [nil, 0.0] # Set imaginary component only
v[-8]

# Specifying subvector using Range with various rvalue types
v[1..4] = GSL::Vector::Complex[[2,3],[5,7],[11,13],[17,19]]
v

v[1..4] = [11, 13, 17, 19] # rvalue is Array
v

v[1..4] = 24..27 # rvalue is Range
v

v[1..4] = 1.0 # rvalue is Float
v

# Specifying subvector using Range and stride with various rvalue types
v[0..4, 2] = GSL::Vector::Complex[[2,3],[5,7],[11,13]]
v

v[0..4, 2] = [7, 11, 13] # rvalue is Array
v

v[0..4, 2] = 8..10 # rvalue is Range
v

v[0..4, 2] = 1.0 # rvalue is Float
v

# Specifying subvector using two Fixnums (offset, length) with various rvalue
# types
v[2, 4] = GSL::Vector::Complex[[2,3],[5,7],[11,13],[17,19]]
v

v[2, 4] = [11, 13, 17, 19] # rvalue is Array
v

v[2, 4] = 24..27 # rvalue is Range
v

v[2, 4] = 1.0 # rvalue is Float
v

# Specifying subvector using three Fixnum arguments (offset, stride, length)
# with various rvalue types
v[1, 2, 3] = GSL::Vector::Complex[[2,3],[5,7],[11,13]]
v

v[1, 2, 3] = [7, 11, 13] # rvalue is Array
v

v[1, 2, 3] = 8..10 # rvalue is Range
v

v[1, 2, 3] = 1.0 # rvalue is Float
v

# Copying part of a Vector::Complex to another part of the same Vector::Complex can potentially
# be problematic if the regions overlap.
v.indgen!
v[0, 3] = v[2, 3]
v

v.indgen!
v[2, 3] = v[0, 3]
v

# But it's OK if the regions do not overlap
v.indgen!
v[0, 3] = v[3, 3]
v

v.indgen!
v[3, 3] = v[0, 3]
v
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create one Vector and two Vector::Ints
x = GSL::Vector[1, 2, 3]
y = GSL::Vector::Int[1, 0, 5]
a = GSL::Vector::Int[0, 0, 0]

# Call #any? on them
x.any?
y.any?
a.any?

# Call #all? on them
x.all?
y.all?
a.all?

# Call #none? on them
x.none?
y.none?
a.none?

# Call x.any? with blocks
x.any? { |val| val > 5 }
x.any? { |val| val > 2 }

# Call x.all? with blocks
x.all? { |val| val >= 1 }
x.all? { |val| val >= 2 }

# Call x.none? with blocks
x.none? { |val| val == 1 }
x.none? { |val| val == 5 }
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create two test Vectors
a = GSL::Vector[1, 0, 3, 0]
b = GSL::Vector[3, 4, 0, 0]

# Show result of (a AND b)
a.and(b)
b.and(a)

# Show result of (a OR b)
a.or(b)
b.or(a)

# Show result of (a XOR b)
a.xor(b)
b.xor(a)

# Show result of (NOT a)
p a.not

# Show result of (NOT b)
p b.not
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Vector
v = GSL::Vector.alloc(1, 2, 3, 4, 5)

# Show third element
v[3]

# Set all elements to 9
v.set_all(9)

# Set all elements to 0
v.set_zero

# Set all elements to 3
v[] = 3

# Show v
v

# Set all elements to 0, except element 3 which is set to 1
v.set_basis(3)

# Set element 2 to 5.0
v.set(2, 5)
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

# This script is written by Cameron McBride.
# Thank you Cameron!

#gem 'gsl', '=1.10.3'
require 'irb/xmp'
require 'gsl'
puts "Using rb-gsl #{GSL::RB_GSL_VERSION}"

# Seed random number generator for repeatable results
srand(?r-?b+?g-?s-?l)

# The creation of the test Vector below can be replaced with any of these lines
# to show the behavior with GSL::Block, GSL::Vector::Int, and
# GSL::Vector::Int::Block.  Note that the block objects should NOT be created
# using "v = GSL::Vector[0..9].block" because the Vector object will be subject
# to garbage collection which will free the memory that the Block object points
# to.  See the BUGS file for more information.
#
# vv = GSL::Vector[0..9]; v = vv.block
# v = GSL::Vector::Int[0..9]
# vv = GSL::Vector::Int[0..9]; v = vv.block

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create test Vector v
v = GSL::Vector[0..9]

# Create mask
mask = (v > 2)

# Show mask.where with no block
mask.where

# Show mask.where with "true" block
mask.where { true }

# Show mask.where with "false" block
# NB: Returns nil, not empty object!
mask.where { false }

# Show mask.where with no block
mask.where2

# Show mask.where with "true" block
mask.where2 { true  }

# Show mask.where with "false" block
mask.where2 { false }

# Show mask.where with random block
mask.where2 { rand > 0.5 }
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create two test Vectors
a = GSL::Vector.alloc(1, 2, 3, 4, 5)
b = GSL::Vector.alloc(6, 7, 8, 9, 10)

# Show element-wise multiplication
a * b

# Show that *= is not an in-place operation
# (it sets receiver to new object).
a.object_id
a *= b
a.object_id

# Show that #mul! is a true in-place operation
# (object_id does not change).
a.object_id
a.mul!(b)
a.object_id

# Same as "a = a / b" (element-wise division)
a /= b

# Show multiply by constant
a * 2

# Show coersion
2 * a

# Show coersion
5 / a

# Show that Vector * Vector::Col produces dot product
a * b.trans
a.dot(b)

# Show that Vector::Col * Vector produces Matrix
a.trans * b
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create Vector v
v = GSL::Vector::Int[0..5]

# Create new Vector whose elements are squares of v's elements
v.collect { |a| a*a }

# Show that v us unmodified
v

# Square elements of v in-place
v.collect! { |a| a*a }

# Show that v is modified
v
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Read file "c.dat" as doubles
a, b, c, d = GSL::Vector.filescan("c.dat")

# Read file "c.dat" as ints
a, b, c, d = GSL::Vector::Int.filescan("c.dat")
END
#!/usr/bin/env ruby
# Turn on warnings
$-w = true

require 'irb/xmp'
require 'gsl'

# Apparently, IRB::Frame has a bug that prevents the defaults from working, so
# an XMP instance must be created explicitly this way instead of using the
# otherwise convenient xmp method.
XMP.new(IRB::Frame.top(-1)).puts <<END
# Create Vector of x values
x = GSL::Vector.linspace(1, 5, 5)

# Create Vector y = x**5
y = GSL::pow_5(x)

# Compute succesive differences
y1 = y.diff
y2 = y1.diff
y3 = y2.diff
y4 = y3.diff

# Show that successive differences can be computed directly from y
y.diff(2) == y2
y.diff(3) == y3
y.diff(4) == y4

# Plot x and y Vectors
GSL::graph(x, y, y1, y2, y3, "-C -g 3 -l x -l y -x 1 5 1")
END
#!/usr/bin/env ruby
# This example solves Lane-Emden equation to calculate white dwarf
# structure, using Chandrasekhar's model, as a polytrope gas sphere
# of self-gravitating body supported by eletron degeneration pressure.

require("gsl")
include Math
include GSL::CONST::CGSM
include GSL::Odeiv

# Degenerated electron/neutron gas
# Reference: "Black holes, white dwarfs, and neutron stars"
#            S.L. Shapiro & S.A. Teukolsky, Willey, 1983
module Degenerate
  hbar = PLANCKS_CONSTANT_HBAR    # Planck's constant
  me = MASS_ELECTRON              # Electron mass
  mn = MASS_NEUTRON               # Neutron mass
  mu = UNIFIED_ATOMIC_MASS
  c = SPEED_OF_LIGHT
  ELambda = hbar/me/c             # Compton length of electron
  NLambda = hbar/mn/c
  MeC2 = me*c*c                   # Electron rest mass energy
  MnC2 = mn*c*c
  Factor_xe = GSL::pow(3.0*PI*PI/mu, 1.0/3.0)*ELambda
  Factor_xn = GSL::pow(3.0*PI*PI/mu, 1.0/3.0)*NLambda

# See Shapiro&Teukolsky Chapter 2
  def phi(x)
    tmp = sqrt(1.0 + x*x)
    (x*tmp*(2.0*x*x/3.0 - 1.0) + log(x + tmp))/8/PI/PI
  end

  def chi(x)
    tmp = sqrt(1.0 + x*x)
    (x*tmp*(1.0 + 2*x*x) - log(x + tmp))/8/PI/PI
  end

  def xe_rho_mue(rho, mue)
    Factor_xe*GSL::pow(rho/mue, 1.0/3.0)
  end

  def xn_rho(rho)
    Factor_xn*GSL::pow(rho, 1.0/3.0)
  end

end

# Polytrope gas sphere
module Polytrope

# Lane-Emden equation
#   n: polytrope index
  EmdenEq = Proc.new { |x, y, dydx, n|
    dydx[0] = y[1]
    dydx[1] = -GSL::pow(y[0], n) - 2.0/x*y[1]
  }

  def emden_xi(n)
    dim = 2
    y = GSL::Vector[1.0, 0.0]
    dydx = GSL::Vector.alloc(dim)

    solver = Solver.alloc(Step::RKF45, [1e-6, 0], EmdenEq, dim)
    solver.set_params(n)
    solver.reset

    vx = GSL::Vector.alloc(10000)
    vy = GSL::Vector.alloc(10000)
    vdy = GSL::Vector.alloc(10000)

    x = 0.0001
    xend = 10.0
    h = 1e-6

    file = File.open("polytrope.dat", "w")
    i = 0
    while x < xend
      x, h, status = solver.apply(x, xend, h, y)
      break if GSL::isnan?(y[0])
      break if GSL::isnan?(y[1])
      vx[i] = x
      vy[i] = y[0]
      vdy[i] = y[1]
      file.printf("%e %e %e %e\n", x, y[0], y[1], GSL::pow_3(y[0]))
      i += 1
      break if status != GSL::SUCCESS
      break if y[0] <= -0.1
    end
    file.close
#    p vx.size
#    p i
    vx2 = vx.subvector(0, i)
    vy2 = vy.subvector(0, i)
    vdy2 = vdy.subvector(0, i)
    spline = GSL::Spline.alloc(GSL::Interp::AKIMA, i)
    spline.init(vy2.reverse, vx2.reverse)

# Find star surface:
# Star sufrace is defined as the zero point of density structure function
    x1 = spline.eval(0.0)
    spline.init(vx2, vdy2)
    yx2 = spline.eval(x1).abs
    return [x1, yx2*x1*x1]

  end
end

# Chandrasekhar white dwarf model:
#   * Polytrope gas sphere
#   * Support its self gravity by electron degeneration pressure
class WhiteDwarf
  include Degenerate
  include Polytrope

  G = GRAVITATIONAL_CONSTANT
  @@x1 = nil
  @@x12 = nil

  def initialize(n, rhoc, mue)
    @n = n
    @gam = 1.0 + 1.0/n
    @rhoc = rhoc
    @mue = mue
    x = xe_rho_mue(@rhoc, mue)
    phix = phi(x)
    @K = MeC2*phix/GSL::pow_3(ELambda)/GSL::pow(@rhoc, @gam)
    @a = sqrt((@n + 1)*@K*GSL::pow(@rhoc, 1.0/@n - 1.0)/4/PI/G)
    if !@@x1
      @@x1, @@x12 = emden_xi(@n)
    end
    @Pc = MeC2*phix/GSL::pow_3(ELambda)*phix   # Electron Fermi pressure
    @radius = @a*@@x1                     # White dwarf radius
    @mass = 4.0*PI*GSL::pow_3(@a)*@rhoc*@@x12  # White dwarf mass
  end

  attr_accessor :radius
  attr_accessor :mass
  attr_accessor :rhoc    # Central density
  attr_accessor :Pc      # Central pressure
  attr_accessor :gam     # Adiabatic index
  attr_accessor :n       # Polytrope index
  attr_accessor :mue     # Mean eletron number per barion
  attr_accessor :K       # Normalization constant
  attr_accessor :a
end

file = File.open("whitedwarf.dat", "w")
rho = 1e6     # central density
while rho < 1e11
  wd = WhiteDwarf.new(3, rho, 2)
  file.printf("%e %e %e %e\n", rho, wd.Pc, wd.radius/1000/100, wd.mass/SOLAR_MASS)
  rho *= 1.2
end
file.close

system("gnuplot -persist whitedwarf.gp")
File.delete("polytrope.dat")
File.delete("whitedwarf.dat")
#!/usr/bin/env ruby
#
# Solve Legendre's differential equation
#   l = 2, m = 1
require("gsl")
dim = 2

fleg = Proc.new { |x, y, f, params|
  l = params[0]
  m = params[1]
  f[0] = y[1]
  f[1] = 2.0*x/(1-x*x)*y[1] - (l*(l + 1) - m*m/(1-x*x))/(1-x*x)*y[0]
}

solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RKF45, [1e-6, 0.0], fleg, dim)

# P21
l = 2
m = 1
solver.set_params(l, m)

x = 0.0      # initial position
xend = 0.999
hstart = 1e-8

h = hstart*1.0

# Initial conditions, at x = 0
# P21(0) = 0, P21'(0) = 3
y = GSL::Vector.alloc(0.0, 3.0)

File.open("legode.dat", "w") do |f|
  while x < xend
    x, h, status = solver.apply(x, xend, h, y)
    f.printf("%g %g\n", x, y[0])
    break if status != GSL::SUCCESS
  end
end

File.open("plm.dat", "w") do |f|
  x = 0.0
  while x < xend
    plmx = GSL::Sf::legendre_Plm(l, m, x).abs
    f.printf("%g %g\n", x, plmx)
    x += 0.01
  end
end

system("graph -T X -C -g 3 -X x -Y 'P21(x)' --toggle-rotate-y-label --title-font-size 0.05 -L 'Red: expect, Green: RKF45' -m 1 plm.dat -m -2 -S 4 legode.dat")
File.delete("legode.dat")
File.delete("plm.dat")

#!/usr/bin/env ruby
# An oscillator
#   m: mass
#   k: spring constant
#   b: resist
#   f: external force

require("gsl")

dim = 2

# x[0]: displacement, x[1]: velocity
func = Proc.new { |t, x, dxdt, params|
  m = params[0]; b = params[1]; f = params[2]; k = params[3]
  dxdt[0] = x[1]
  dxdt[1] = (f - b*x[1] - k*x[0])/m
}

gos = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RKF45, [1e-6, 0.0], func, dim)

m = 1.0
b = 1.0
f = 1.0
k = 10.0

gos.set_params(m, b, f, k)

t = 0.0; tend = 10.0
h = 1e-6
x = GSL::Vector.alloc([0.0, 0.0])

GSL::ieee_env_setup()

IO.popen("graph -T X -C -g 3 -S 4 -X Time -Y Amp", "w") do |io|
  while t < tend
    t, h, status = gos.apply(t, tend, h, x)
    break if status != GSL::SUCCESS
#    printf("%.5e %.5e %.5e %.5e\n", t, x[0], x[1], h)
    io.printf("%.5e %.5e\n", t, x[0])
  end
end

#!/usr/bin/env ruby
# Solve
#   dydt = -2y     ---> y(t) = exp(-2t)

require("gsl")
include GSL::Odeiv

dim = 1

PARAM = 2.0

func = Proc.new { |t, y, dydt, param|
  dydt[0] = -param*y[0]
}

jac = Proc.new { |t, y, dfdy, dfdt, param|
  dfdy = -param
  dfdt[0] = 0.0
}

def odeiv_compare_algorithm(solver, steptype, t0, tend, h0, y0, outfile)
  t = t0*1.0
  h = h0*1.0
  y = GSL::Vector.alloc([y0])
  s = Step.alloc(steptype, solver.dim)
  solver.set_step(s)
  solver.evolve.reset
#  p solver.params

  i = 0
  file = File.open(outfile, "w")
  while t < tend
    t, h, status = solver.apply(t, tend, h, y)
    break if status != GSL::SUCCESS
    file.printf("%.5e %.5e %.5e\n", t, y[0], h)
    i += 1
  end
  file.close
  return i
end

if GSL::VERSION >= "1.5.90"
  ALGORITHMS = ["rk2", "rk4", "rkf45", "rkck", "rk8pd", "rk2imp", "rk4imp",
                "bsimp", "gear1", "gear2", "rk2simp"]
  gpfile = "demo2.gp"
else
  ALGORITHMS = ["rk2", "rk4", "rkf45", "rkck", "rk8pd", "rk2imp", "rk4imp",
                "bsimp", "gear1", "gear2"]
  gpfile = "demo.gp"
end

solver = Solver.alloc(Step::RKF45, [1e-6, 0.0], func, jac, dim)
solver.set_params(PARAM)

puts("Solve dydt = -2y, y[0] = 1")
puts("y(t) = exp(-2t)\n\n")
ALGORITHMS.each do |alg|
  outfile = alg + ".dat"
  t0, tend, h0, y0 = 0.0, 3.0, 1e-6, 1.0
  i = odeiv_compare_algorithm(solver, alg, t0, tend, h0, y0, outfile)
  printf("%7s: Iteration %5d\n", alg, i)
end

system("gnuplot -persist #{gpfile}")

ALGORITHMS.each do |alg|
  outfile = alg + ".dat"
  File.delete(outfile)
end
#!/usr/bin/env ruby
#      19/Apr/2004         by Yoshiki Tsunesada
#
#   This is an example to calculate the orbital evolution of
# a double neutron star (binary) system. General relativity predicts
# that the binary orbital decays by radiating gravitational waves,
# and the two stars will coalesce in time scale of 100-1000 Mega-years.
#   The values used here are of the binary system J0730-3039 discovered
# in 2003 (Burgay et al., Nature 2003). The result shows that the two
# neutron stars will merge after about 85 Mega-years. From the age of
# the system 100 Mega-year, the lifetime of the system is estimated
# about 185 Mega-years.
#
# References:
#   1. Burgay et al., Nature 426, 531 (2003)
#   2. Shapiro & Teukolsky, "Black holes, white dwarfs and neutron stars"
#        John Wiley and Sans (1983)
#

require("gsl")
include Math

class BinarySystem
  def initialize(m1, m2)
    @m1 = m1
    @m2 = m2
  end
  attr_reader :m1
  attr_reader :m2
end

GMsolarC3 = 4.925490947e-6
MegaYear = 3600*24*365*1e6

# Time evolution of the binary orbital period and the eccentricity
# due to gravitational radiation.
# The calculation is based on general relativity (See e.g. Ref.2).
#     y[0]: orbital period (pb)
#     y[1]: eccentricity (e)
#  dydt[0]: time derivative of pb
#  dydt[1]: time derivative of e

deriv = Proc.new { |t, y, dydt, binary|
  pb = y[0]            # orbital period
  e = y[1]             # eccentricity
  m1 = binary.m1       # neutron star masses
  m2 = binary.m2
  totalM = m1 + m2     # total mass
  mu = m1*m2/totalM    # reduced mass
  mm = mu*GSL::pow(totalM, 2.0/3.0)
  f_e = GSL::pow(1.0 - e*e, -3.5)*(1.0 + (73.0/24.0 + 37.0/96.0*e*e)*e*e);
  h_e = (1.0 + 121.0/304.0*e*e)*GSL::pow(1.0 - e*e, -2.5)
  tmp = GSL::pow(GMsolarC3*2.0*PI/pb, 5.0/3.0)
  dydt[0] = -192.0*PI/5.0*f_e*tmp*mm              # dP/dt
  dydt[1] = -304.0/15.0*e*h_e*tmp*(2.0*PI/pb)     # de/dt
}

# Neutron star masses in solar-mass unit.
# The values are of the binary system J0730-3039 discoverd in 2003.
# See Burgay et al., Nature 426, 531 (2003)
m1 = 1.34
m2 = 1.24
#m1 = 1.25
#m2 = 2.574 - m1
binary = BinarySystem.new(m1, m2)

# Initial data: the present values
pb = 2.45*3600        # orbital period: 2.45 hours at present
ecc = 0.088           # eccentricity
#pb = 7.67*3600
#ecc = 0.181
y = GSL::Vector[pb, ecc]

# ODE solver using RKF45 algorithm
solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RKF45, [1e-6, 0.0], deriv, 2)
solver.set_params(binary)

# the age of the binary system from birth
age = 100*MegaYear
#age = 444*MegaYear
t = 0
tend = 2500*MegaYear

# initial time step
h = 1.0*MegaYear

begin
  file = File.open("binarysystem.dat", "w")
  while t < tend
    t, h, status = solver.apply(t, tend, h, y)
    break if status != GSL::SUCCESS
    break if GSL::isnan?(y[0])
    file.printf("%e %e %e %e\n", (t+age)/MegaYear, y[0]/3600, y[1], h/MegaYear)
  end
ensure
  file.close
end

system("gnuplot -persist binarysystem.gp")
File.delete("binarysystem.dat")

__END__


#!/usr/bin/env ruby
#  Solve Schroedinger equation
#
#  This example is taken from frei1.cpp
#  in "Numerische Physik" p201-204 (Springer),
#  which simulates the time evolution of a probability density.
#
#  Name: frei1.cpp
#  Zweck: Simuliert ein quantenmechanisches freies Teilchen
#  Gleichung: Schroedingergleichung ohne Potential verwendete
#  Bibiliothek: GSL
#
#  Reference:
#    "Numerische Physik", by Harald Wiedemann, Springer (2004)
#    ISBN: 3-540-40774-X
#    http://www.springeronline.com/sgw/cda/frontpage/0,10735,1-102-22-22345455-0,00.html

require("gsl")

#NMAX = 8192
NMAX = 256

# The wave equation:
# calculate time derivative of the wave function.
# The second spatial derivative is approximated by
#   d2_psi/dx2 ~ (psi[n+1] - 2*psi[n] + pxi[n-1])/(dx*dx)
# See "Numerische Physik" p204, Eq. (5.47).
#
# psi(x), dpsi_dt(x): Complex-valued wavefunction, expressed as
#
#   0              NMAX             2*NMAX
#  |-----------------|-----------------|
#          Real           Imaginary
#
f = Proc.new { |t, psi, dpsi_dt|
  dx2 = $dx*$dx

# Real part
  for n in 1...(NMAX-1) do
    dpsi_dt[n] = -(psi[NMAX+n+1]+psi[NMAX+n-1]-2*psi[NMAX+n])/dx2
  end
  dpsi_dt[0] = -(psi[NMAX+1]+psi[2*NMAX-1]-2*psi[NMAX])/dx2
  dpsi_dt[NMAX-1] = -(psi[NMAX]+psi[2*NMAX-2]-2*psi[2*NMAX-1])/dx2

#  Imaginary part
  for n in (NMAX+1)...(2*NMAX-1) do
    dpsi_dt[n] = +(psi[n+1-NMAX]+psi[n-1-NMAX]-2*psi[n-NMAX])/dx2
  end
  dpsi_dt[NMAX] = +(psi[1]+psi[NMAX-1]-2*psi[0])/dx2
  dpsi_dt[2*NMAX-1] = +(psi[0]+psi[NMAX-2]-2*psi[NMAX-1])/dx2
}

psi = GSL::Vector[2*NMAX]
dpsi_dt = GSL::Vector[2*NMAX]

$dx = 0.1
dt = 0.1
n_out = 20
alpha = 1
p_0 = -0.5
atol = 1e-4
rtol = 0.0

h = 1.0e-4

dx2 = $dx*$dx
sum = 0.0
for n in 0...NMAX do
  x = (n-NMAX/2) * $dx
  psi[n] = Math::exp(-GSL::pow_2(x/alpha)/2)
  sum += GSL::pow_2(psi[n])
end
sum = 1.0/Math::sqrt(sum)

for n in 0...NMAX do
  x = (n-NMAX/2) * $dx
  psi[n+NMAX] = -psi[n] * sum * Math::sin(p_0*x) # Imaginaerteil
  psi[n] = psi[n] * sum * Math::cos(p_0*x)       # Realteil
end

IO.popen("graph -T X -C -g 3", "w") do |io|
  for n1 in 0...NMAX do
    x = (n1-NMAX/2) * $dx
    io.printf("%e %e\n", x, Math::sqrt(GSL::pow_2(psi[n1]) + GSL::pow_2(psi[n1+NMAX])))
  end
  io.printf("\n")

  step = GSL::Odeiv::Step.alloc(GSL::Odeiv::Step::RKF45, 2*NMAX)
  c = GSL::Odeiv::Control.y_new(atol, rtol)
  evolve = GSL::Odeiv::Evolve.alloc(2*NMAX)
  sys = GSL::Odeiv::System.alloc(f, 2*NMAX)

  t = 0.0
  for n in 1..n_out do
    t1 = n*dt
    STDOUT.printf("t = %2.1f (%2d/%2d)\n", t1-dt, n, n_out)
    while t < t1
      t, h, status = evolve.apply(c, step, sys, t, t1, h, psi)
      break if status != GSL::SUCCESS
    end
    if n%10 == 0
      for n1 in 0...NMAX do
        x = (n1-NMAX/2) * $dx
        io.printf("%e %e\n", x, Math::sqrt(GSL::pow_2(psi[n1]) + GSL::pow_2(psi[n1+NMAX])))
      end
      io.printf("\n")
    end
  end
end
#!/usr/bin/env ruby
require("gsl")
dim = 2
func = Proc.new { |t, y, dydt, mu|
  dydt[0] = y[1]
  dydt[1] = -y[0] - mu*y[1]*(y[0]*y[0] - 1.0)
}
step = GSL::Odeiv::Step.alloc(GSL::Odeiv::Step::RKF45, dim)
c = GSL::Odeiv::Control.y_new(1e-6, 0.0)
evolve = GSL::Odeiv::Evolve.alloc(dim)
sys = GSL::Odeiv::System.alloc(func, dim)
mu = 10.0
sys.set_params(mu)
t = 0.0; tend = 100.0
h = 1e-6
y = GSL::Vector[1.0, 0.0]
GSL::ieee_env_setup()

N = 1500
tt = GSL::Vector[N]
yt = GSL::Vector[N]
i = 0
while t < tend and i < N
  t, h, status = evolve.apply(c, step, sys, t, tend, h, y)
  tt[i] = t
  yt[i] = y[0]
  break if status != GSL::SUCCESS
  i += 1
end
yt.subvector(i).graph(tt.subvector(i), "-T X -C -g 3 -x 0 #{tt.max} -L '#{step.name}' -S 4")


#!/usr/bin/env ruby
# This example is taken from frei2.cpp
# in "Numerische Physik" p205-206 (Springer).
#
# Reference:
#   "Numerische Physik", by Harald Wiedemann, Springer (2004)
#   ISBN: 3-540-40774-X
#   http://www.springeronline.com/sgw/cda/frontpage/0,10735,1-102-22-22345455-0,00.html

require("gsl")

#NMAX = 8192
NMAX = 256

psi = GSL::Vector::Complex[NMAX]

dx = 0.1
dt = 0.1
n_out = 20
alpha = 1
p_0 = -0.5

dp = 2*Math::PI/dx/NMAX

sum = 0.0
for n in 0...NMAX
  x = (n-NMAX/2) * dx
  psi[n] = Math::exp(-GSL::pow_2(x/alpha)/2)
  sum += GSL::pow_2(psi[n].re);
end
sum = 1.0/Math::sqrt(sum)

for n in 0...NMAX
  x = (n-NMAX/2) * dx
  psi[n] *= GSL::Complex[
    sum * Math::cos(p_0*x),
    -sum * Math::sin(p_0*x) # Imaginaerteil
  ]
end

IO.popen("graph -T X -C -g 3", "w") do |io|
  psi_p = psi.duplicate
  for n1 in 0...NMAX do
    x = (n1-NMAX/2) * dx
    io.printf("%e %e\n", x, psi[n1].abs)
  end
  io.printf("\n")

  psi_p.radix2_forward!


  t = 0.0
  for n in 1..n_out do
    t1 = n*dt
    STDOUT.printf("t = %2.1f (%2d/%2d)\n", t1, n, n_out)
    for n1 in 0...(NMAX/2) do
      pp = n1*dp
      arg = GSL::pow_2(pp)*t1/2
      psi[n1] = psi_p[n1] * GSL::Complex.polar(1, -arg)
    end
    for n1 in (NMAX/2)...NMAX do
      pp = (n1-NMAX)*dp
      arg = GSL::pow_2(pp)*t1/2
      psi[n1] = psi_p[n1] * GSL::Complex.polar(1, -arg)
    end
    psi.radix2_inverse!
    if n%10 == 0
      for n1 in 0...NMAX do
        x = (n1-NMAX/2) * dx
        io.printf("%e %e\n", x, psi[n1].abs)
      end
      io.printf("\n")
    end
  end
end

#!/usr/bin/env ruby
require("gsl")

dim = 2

func = Proc.new { |t, y, dydt, mu|
  dydt[0] = y[1]
  dydt[1] = -y[0] - mu*y[1]*(y[0]*y[0] - 1.0)
}

jac = Proc.new { |t, y, dfdy, dfdt, mu|
  dfdy[0,0] = 0.0
  dfdy[0,1] = 1.0
  dfdy[1,0] = -2*mu*y[0]*y[1] - 1.0
  dfdy[1,1] = -mu*(y[0]*y[0] - 1.0)
  dfdt[0] = 0.0
  dfdt[1] = 0.0
}

#solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RK8PD, [1e-6, 0.0, 1, 0], func, jac, dim)
#solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RK8PD, [1e-6, 0.0, 1, 0], func, nil, dim)
#solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RK8PD, [1e-6, 0.0], func, nil, dim)
#solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RKF45, [1e-6, 0.0], func, jac, dim)
#solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RKF45, [1e-6, 0.0], func, nil, dim)
solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::BSIMP, [1e-6, 0.0], func, jac, dim)
solver.set_params(10.0)

t = 0.0; tend = 100.0
h = 1e-6
y = GSL::Vector.alloc([1.0, 0.0])

GSL::ieee_env_setup()
N = 1500
tt = GSL::Vector[N]
yt = GSL::Vector[N]
i = 0
while t < tend and i < N
  t, h, status = solver.apply(t, tend, h, y)
  break if status != GSL::SUCCESS
  tt[i] = t
  yt[i] = y[0]
  i += 1
end

GSL::graph(tt.subvector(i), yt.subvector(i),  "-T X -C -g 3 -x 0 #{tt.max} -L '#{solver.step.name}' -S 4")
#!/usr/bin/env ruby
# Self-similar solution of the Sedev-Taylor equation,
# which describes spherically expanding gas
# triggered by a supernova explosion.

require("gsl")
include Math

# Sedov-Taylor equation
#     logx: (log of) the radial coordinate in the gas shpere, x = r/R.
#           logx = 0 at the surface, and negative within the shell
#        y: GSL::GSL::Vector::View::ReadOnly
#           y[0]: gas velocity at the radius
#           y[1]: density
#           y[2]: pressure
#  dydlogx: GSL::GSL::Vector::View, derivatives
#       sh: specific heat of the gas (5/3)
Sedov = Proc.new { |logx, y, dydlogx, sh|
  a = -5.0*(6.0*y[2] - 15.0*y[2]*y[0]*sh + 2.0*y[0]*y[1] - 7.0*y[0]*y[0]*y[1] + 5.0*GSL::pow_3(y[0])*y[1])
  b = -25.0*y[2]*sh + 4.0*y[1] - 20.0*y[0]*y[1] + 25.0*y[0]*y[0]*y[1]
  dydlogx[0] = a/b

  bb = -5.0*(6.0*y[2] - 15.0*y[2]*y[0]*sh + 2.0*y[0]*y[1] - 7.0*y[0]*y[0]*y[1])

  a = -5.0*(-30.0*y[2]*y[1] + 2.0*y[0]*y[1]*y[1] - 25.0*GSL::pow_2(y[0]*y[1]) + 50.0*GSL::pow_3(y[0])*GSL::pow_2(y[1]))
  bb = (-2.0 + 5.0*y[0])*(-25.0*y[2]*sh + 4.0*y[1] - 20.0*y[0]*y[1] + 25.0*y[0]*y[0]*y[1])
  dydlogx[1] = a/bb

  a = -5.0*y[2]*(-10.0*y[2]*sh + 4.0*y[1] - 14.0*y[0]*y[1] + 10.0*y[0]*y[0]*y[1] - y[0]*sh*y[1] + 10.0*y[0]*y[0]*sh*y[1])
  dydlogx[2] = a/b
}

DIM = 3
sh = 5.0/3.0
solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RKF45, [1e-5, 1e-5], Sedov, nil, DIM)
solver.set_params(sh)

def boundary_condition(sh)
  delta = 2.0/5.0
  xx = 1
  y = GSL::Vector[DIM]
  y[0] = 2.0/(sh + 1.0)*delta
  y[1] = (sh + 1.0)/(sh - 1.0)
  y[2] = 2.0/(sh + 1.0)*delta*delta
  y00 = xx*y[0]
  y10 = y[1]
  y20 = xx*xx*y[2]
  c = adiabatic_integ(xx, y, sh);
  return y, y00, y10, y20, c
end

def adiabatic_integ(xx, y, sh)
  GSL::pow(y[1], 1.0 - sh)*y[2]*(y[0] - 2.0/5.0)*GSL::pow_5(xx)
end

# y: GSL::Vector (velocity, density, pressure)
# y00, y10, y20: initial values
# c: adiabatic integral (this must be constant throughout the computation)
y, y00, y10, y20, c = boundary_condition(sh)

# x: the radial coordinates in the shell, x = r/R.
#     x = 1 at the surface (r = R), and zero at the center (r = 0)
x = 1
logx = log(x)
logxend = log(1e-5)
h = -0.000001

N = 150
R = GSL::Vector[N]
V = GSL::Vector[N]
RHO = GSL::Vector[N]
PRESS = GSL::Vector[N]

# The values are normalized to [0, 1]
R[0] = x
V[0] = x*y[0]/y00
RHO[0] = y[1]/y10
PRESS[0] = x*x*y[2]/y20

GSL::ieee_env_setup()

n = 1
while logx > logxend
  logx, h, status = solver.apply(logx, logxend, h, y)
  break if status != GSL::SUCCESS
  break if y[0] < 0.0
  x = exp(logx)
  c = adiabatic_integ(x, y, sh);
  R[n] = x
  V[n] = x*y[0]/y00
  RHO[n] = y[1]/y10
  PRESS[n] = x*x*y[2]/y20
  n += 1
end

GSL::graph(R.subvector(n), V.subvector(n), RHO.subvector(n), PRESS.subvector(n),
      "-T X -C -g 3 -X 'x = r/R' -S 4 -L 'red: v, green: rho, blue: p'")
#!/usr/bin/env ruby
#
# Duffing equation
#
require("gsl")

dim = 2

# x'' + a x' + bx^3 = f cos(omega t)
#
duffing = Proc.new { |t, x, dxdt, params|
  a = params[0]; b = params[1]
  omega = params[2]; f = params[3]
  dxdt[0] = x[1]
  dxdt[1] = -a*x[1] - b*GSL::pow_3(x[0]) + f*Math::cos(omega*t)
}

solver = GSL::Odeiv::Solver.alloc(GSL::Odeiv::Step::RK8PD, [1e-6, 0.0], duffing, dim)

a = 0.05
b = 1.0
omega = 1.0
f = 5.0
solver.set_params(a, b, omega, f)

t = 0.0      # initial position
tend = 200
hstart = 2.0*Math::PI/1000

h = hstart*1.0

# Initial conditions, at x = 0
# P21(0) = 0, P21'(0) = 3
x = GSL::Vector.alloc(0.0, 0.0)
count = 0
IO.popen("graph -T X -C -g 3", "w") do |io|
  while t < tend
    t, h, status = solver.apply(t, tend, h, x)
    if count%2 == 0
      io.printf("%g %g\n", t, x[0])
    end
    break if status != GSL::SUCCESS
    count += 1
  end
end
#!/usr/bin/env ruby
require("gsl")

if ARGV.size != 1
  puts("Usage: integrate n\nn is the number of quadrature points.")
  exit
end

Q = ARGV[0].to_i
if Q < 1
  puts("Usage: integrate n\nn is the number of quadrature points.")
  exit
end

def fun(x)
  Math::cos(3.0*x)
end

def dfun(x)
  -3.0*Math::sin(3.0*x)
end

f = GSL::Vector.alloc(4*Q)

quad = Jac::Quadrature.alloc(Q)
quad.zwd(Jac::GJ, 0.0, 0.0)

for i in 0...Q do
  f[i] = fun(quad.x[i])
end

d = quad.differentiate(f)

printf("X \t Derivative \t Error\n");

for i in 0...Q do
  printf("%f \t %f \t %e\n", quad.x[i], d[i], d[i] - dfun(quad.x[i]));
end


#!/usr/bin/env ruby
require("gsl")

if ARGV.size != 1
  puts("Usage: integrate n\nn is the number of quadrature points.")
  exit
end

Q = ARGV[0].to_i
if Q < 1
  puts("Usage: integrate n\nn is the number of quadrature points.")
  exit
end

def fun(x)
  Math::cos(3.0*x)
end

f = GSL::Vector.alloc(4*Q)

quad = Jac::Quadrature.alloc(Q)
quad.zwd(Jac::GJ, 0.0, 0.0)

for i in 0...Q do
  f[i] = fun(quad.x[i])
end

integr = quad.integrate(f)
exact = 2.0/3.0*Math::sin(3.0)

printf("Integral of cos(3x) from -1 to 1: %f\n", exact);
printf("jac_integrate result: %f\n", integr)
printf("Error: %e\n", integr - exact);

#!/usr/bin/env ruby
require("gsl")

p Jac::jacobi_P1(0.2, 0.2, 0.5)

x = GSL::Vector.linspace(-1, 1, 6)
p Jac::jacobi(x, 1, 0.2, 0.5)

p Jac::jacobi_P1(x, 0.2, 0.5)

p Jac::jacobi_zeros(6, 0.2, 0.5)
#!/usr/bin/env ruby
require("gsl")

if ARGV.size != 1
  puts("Usage: integrate n\nn is the number of quadrature points.")
  exit
end

Q = ARGV[0].to_i
if Q < 1
  puts("Usage: integrate n\nn is the number of quadrature points.")
  exit
end

def fun(x)
  Math::cos(3.0*x)
end

def dfun(x)
  -3.0*Math::sin(3.0*x)
end

f = GSL::Vector.alloc(4*Q)
xp = GSL::Vector.linspace(0.1, 0.9, 9)

quad = Jac::Quadrature.alloc(Q)
quad.zwd(Jac::GJ, 0.0, 0.0)
quad.interpmat_alloc(xp)

for i in 0...Q do
  f[i] = fun(quad.x[i])
end

fout = quad.interpolate(f)

printf("X \t f(x) \t Error\n");

for i in 0...xp.size do
  printf("%f \t %f \t %e\n", xp[i], fout[i], fout[i] - fun(xp[i]));
end

quad.interpmat_free

#!/usr/bin/env ruby
require("gsl")
n = 50
x = GSL::Vector.linspace(0.01, 3, n)
y1 = GSL::Ran::chisq_pdf(x, 1)
y2 = GSL::Ran::chisq_pdf(x, 2)
y3 = GSL::Ran::chisq_pdf(x, 3)
GSL::graph(x, y1, y2, y3, "-T X -g 3 -C -y 0 1 -X x -Y 'p(x)' -L 'Chi^2 distribution, dof=1,2,3' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 5, 100)
y1 = GSL::Ran::flat_pdf(x, 0.5, 2.5)
y2 = GSL::Ran::flat_pdf(x, 1.2, 4.8)
GSL::Vector.graph(x, y1, y2, "-T X -C -g 3  -X x -Y 'p(x)' -y 0 1 -L 'Flat distribution, a = 0.5, b = 2.5' --toggle-rotate-y-label")

#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-5, 10, 100)
y1 = GSL::Ran::landau_pdf(x)
y1.graph(x, "-C -X x -Y 'p(x)' -L 'Landau distribution' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 5, 100)
y1 = GSL::Ran::rayleigh_pdf(x, 1)
y2 = GSL::Ran::rayleigh_pdf(x, 2)
GSL::Vector.graph(x, y1, y2, "-T X -g 3 -C -X x -Y 'p(x)' -x 0 5 -L 'Rayleigh distribution, a = 1' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-2, 2, 100)
y1 = GSL::Ran::gumbel1_pdf(x, 1, 1)
y2 = GSL::Ran::gumbel2_pdf(x, 1, 1)
GSL::graph(x, y1, y2, "-T X -g 3 -C -X x -Y 'p(x)' -L 'Type 1, 2 Gumbel distribution' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 5, 100)
y1 = GSL::Ran::rayleigh_tail_pdf(x, 1, 1)
y2 = GSL::Ran::rayleigh_tail_pdf(x, 0.5, 2)
GSL::Vector.graph(x, y1, y2, "-T X -g 3 -C -X x -Y 'p(x)' -x 0 5 -y 0 1.2 -L 'Rayleigh-tail distribution, a = 1, s = 1' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 5, 100)
y1 = GSL::Ran::gamma_pdf(x, 1, 1)
y2 = GSL::Ran::gamma_pdf(x, 2, 1)
y3 = GSL::Ran::gamma_pdf(x, 3, 1)
GSL::Vector.graph(x, y1, y2, y3, "-T X -C -g 3 -X x -Y 'p(x)' -L 'Gamma distribution, a = 1, 2, 3' --toggle-rotate-y-label")

#!/usr/bin/env ruby
require("gsl")
n = 100
x = GSL::Vector.linspace(0.01, 6, n)
y1 = GSL::Ran::fdist_pdf(x, 10, 20)
y2 = GSL:Ran::fdist_pdf(x, 3, 4)
GSL::graph(x, y1, y2, "-T X -g 3 -C -y 0 1 -X x -Y 'p(x)' -L 'F distribution' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
pp = 0.5
nn = 9
IO.popen("graph -T X -C -g 3 -x 0 10 -y 0 0.3 -L 'Binomial Distribution, p = 0.5, n = 9'", "w") do |io|
  for i in 0..10 do
    y = GSL::Ran::binomial_pdf(i, pp, nn)
    io.printf("%d %e\n%d %e\n", i, y, i+1, y)
  end
end
#!/usr/bin/env ruby
require("gsl")
n = 50
x = GSL::Vector.linspace(0, 3, n)
y1 = GSL::Ran::exponential_pdf(x, 1)
y2 = GSL::Ran::exponential_pdf(x, 2)
GSL::Vector.graph(x, y1, y2, "-T X -C -g 3 -X x -Y 'p(x)' -y 0 1 -L 'Exponential distribution' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-5, 5, 100)
y1 = GSL::Ran::laplace_pdf(x, 1)
y2 = GSL::Ran::laplace_pdf(x, 2)
GSL::Vector.graph(x, y1, y2, "-T X -g 3 -C -X x -Y 'p(x)' -x -5 5 -L 'Laplace distribution, a = 1, 2' --toggle-rotate-y-label")

#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 1, 100)
y1 = GSL::Ran::beta_pdf(x, 2, 2)
y2 = GSL::Ran::beta_pdf(x, 4, 1)
y3 = GSL::Ran::beta_pdf(x, 1, 4)
GSL::graph(x, y1, y2, y3, "-T X -g 3 -C -X x -Y 'p(x)' -L 'Beta distribution' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-4, 4, 100)
y1 = GSL::Ran::tdist_pdf(x, 1)
y2 = GSL::Ran::tdist_pdf(x, 5)
GSL::graph(x, y1, y2, "-T X -C -g 3 -X x -Y 'p(x)' -L 'Student t distribution, n=1' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
n = 100
x = GSL::Vector.linspace(0, 5, n)
y1 = GSL::Ran::pareto_pdf(x, 1, 1)
y2 = GSL::Ran::pareto_pdf(x, 3, 2)
GSL::graph(x, y1, y2, "-T X -g 3 -C -x 0 5 -y 0 2 -X x -Y 'p(x)' -L 'Pareto distribution' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
n1 = 5
n2 = 20
t = 3
IO.popen("graph -T X -C -g 3 -x 0 10 -y 0 0.7 -L 'Hypergeometric Distribution, n1=5, n2=20, t=3'", "w") do |io|
  for i in 0..10 do
    y = GSL::Ran::hypergeometric_pdf(i, n1, n2, t)
    io.printf("%d %e\n%d %e\n", i, y, i+1, y)
  end
end
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-5, 5, 100)
y1 = GSL::Ran::logistic_pdf(x, 1)
y2 = GSL::Ran::logistic_pdf(x, 2)
GSL::graph(x, y1, y2, "-T X -g 3 -C -X x -Y 'p(x)' -x -5 5 -y 0 0.3 -L 'Logistic distribution' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector[0..1]
y = GSL::Ran::bernoulli_pdf(x, 0.7)
y.graph_step(x, "-C -X x -Y 'p(x)' -y 0 1 -L 'Bernoulli distribution, p = 0.7' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector[0..10]
y = GSL::Ran::poisson_pdf(x, 2.5)
y.graph_step(x, "-C -X x -Y 'p(x)' -L 'Poisson distribution, mu = 2.5' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector[0..5]
y = GSL::Ran::geometric_pdf(x, 0.5)
y.graph_step(x, "-C -X x -Y 'p(x)' -y 0 0.7 -L 'Geometric distribution, p = 0.5' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
pp = 0.5
nn = 3
IO.popen("graph -T X -C -g 3 -x 0 10 -y 0 0.3 -L 'Pascal Distribution, p = 0.5, n = 3'", "w") do |io|
  for i in 0..10 do
    y = GSL::Ran::pascal_pdf(i, pp, nn)
    io.printf("%d %e\n%d %e\n", i, y, i+1, y)
  end
end
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 3, 100)
y1 = GSL::Ran::lognormal_pdf(x, 0, 1)
y2 = GSL::Ran::lognormal_pdf(x, 1, 1)
GSL::graph(x, y1, y2, "-T X -g 3 -C -X x -Y 'p(x)' -L 'Lognormal distribution, zeta=0,1, s=1' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 2, 100)
y1 = GSL::Ran::weibull_pdf(x, 1, 1)
y2 = GSL::Ran::weibull_pdf(x, 1, 2)
y3 = GSL::Ran::weibull_pdf(x, 2, 3)
GSL::graph(x, y1, y2, y3,  "-T X -g 3 -C -x 0 2 -y 0 1.5 -X x -Y 'p(x)' -L 'Weibull distribution' --toggle-rotate-y-label")

#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector[0..10]
y = GSL::Ran::logarithmic_pdf(x, 0.7)
y.graph_step(x, "-C -X x -Y 'p(x)' -y 0 0.7 -L 'Logarithmic distribution, p = 0.7' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-5, 5, 100)
y1 = GSL::Ran::gaussian_pdf(x, 1)
y2 = GSL::Ran::gaussian_pdf(x, 2)
GSL::Vector.graph(x, y1, y2, "-T X -C -g 3 -X x -Y 'p(x)' -x -5 5 -y 0 0.5 -L 'Gaussian distribution, sigma = 1, 2' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-5, 5, 100)
y1 = GSL::Ran::exppow_pdf(x, 1, 2.5)
y2 = GSL::Ran::exppow_pdf(x, 1, 0.5)
GSL::Vector.graph(x, y1, y2, "-T X -g 3 -C -X x -Y 'p(x)' -x -5 5 -L 'Exppow distribution, a = 1, b = 2.5, 0' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 5, 100)
y1 = GSL::Ran::gaussian_tail_pdf(x, 1.5, 1)
y1.graph(x, "-C -X x -Y 'p(x)' -x 0 5 -L 'Gaussian-tail distribution, s = 1, a = 1.5' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
pp = 0.5
nn = 3.5
IO.popen("graph -T X -C -g 3 -x 0 10 -y 0 0.3 -L 'Negative Binomial Distribution, p = 0.5, n = 3.5'", "w") do |io|
  for i in 0..10 do
    y = GSL::Ran::negative_binomial_pdf(i, pp, nn)
    io.printf("%d %e\n%d %e\n", i, y, i+1, y)
  end
end
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-5, 5, 100)
y1 = GSL::Ran::cauchy_pdf(x, 1)
y2 = GSL::Ran::cauchy_pdf(x, 2)
GSL::Vector.graph(x, y1, y2, "-T X -g 3 -C -X x -Y 'p(x)' -x -5 5 -y 0 0.4 -L 'Cauchy distribution, a = 1, 2' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
include Math
include GSL

n = 10
xa = Vector[n]
ya = Vector[n]
for i in 0...n do
  a = i.to_f
  xa[i] = i + 0.5*sin(a)
  ya[i] = i + cos(a*a)
end

def spline_compare(type, xa, ya, filename)
  n = xa.size
  spline = Spline.alloc(type, xa, ya)
  p spline.name

  xi = xa[0]
  File.open(filename, "w") do |file|
    while xi < xa[n-1]
      yi = spline.eval(xi)
      file.printf("%e %e\n", xi, yi)
      xi += 0.01
    end
  end
end

types = ["linear", "polynomial", "cspline", "cspline_periodic",
         "akima", "akima_periodic"]

types.each do |t|
  filename = t + ".dat"
  spline_compare(t, xa, ya, filename)
end

#puts("6 interpolation types are examined.")
#puts("Try \"gnuplot -persist spline-compare.gp\"")
system("gnuplot -persist demo.gp")

types.each do |t|
  filename = t + ".dat"
  File.delete(filename)
end
#!/usr/bin/env ruby
require("gsl")
include GSL

x, y = Vector.filescan("points")

#spline = Spline.alloc(Interp::CSPLINE, n)
#spline.init(x, y)
#spline = Spline.alloc(x, y, "cspline")
#spline = Spline.alloc("cspline", x, y)
spline = Spline.alloc(x, y)

x2 = Vector.linspace(x[0], x[-1], 100)
y2 = spline.eval(x2)

graph([x, y], [x2, y2], "-C -g 3 -S 2")

#p spline.name
#p spline.min_size

#!/usr/bin/env ruby
require("gsl")
include GSL

n = 10
x = Vector[n]
y = Vector[n]
#x = NArray.float(n)
#y = NArray.float(n)
File.open("data0.dat", "w") do |f|
  for i in 0...n do
    a = i.to_f
    x[i] = i + 0.5*Math::sin(a)
    y[i] = i + Math::cos(a*a)
    f.printf("%e %e\n", x[i], y[i])
  end
end

interp = Interp.alloc("akima", n)
interp.init(x, y)
#interp = Interp.alloc(x, y)
p interp.class
p interp.name

File.open("data1.dat", "w") do |f|
  xi = x[0]
  while xi < x[9]
    yi = interp.eval(x, y, xi)
    f.printf("%e %e\n", xi, yi)
    xi += 0.01
  end
end

system("graph -T X -g 3 -C -m -1 -S 4 data0.dat -S 1 data1.dat")
File.delete("data0.dat")
File.delete("data1.dat")

#!/usr/bin/env ruby
# Frequency response of a Fabry-Perot Michelson interferometer
#
require("gsl")
CLIGHT = GSL::CONST::MKSA::SPEED_OF_LIGHT

class Michelson
  def initialize(len, wavelength)
    @len = len.to_f
    @laserfreq = 2.0*Math::PI*CLIGHT/wavelength.to_f
  end

  def response(f)
    if f.class != GSL::Vector; f = GSL::Vector[f]; end
    r = GSL::Vector::Complex[f.size]
    f.each_index do |i|
      freq = f[i]
      omega = 2.0*Math::PI*freq
      a = @len*omega/CLIGHT
      #      r[i] = 2.0*@laserfreq/omega*Math::sin(a)*GSL::Complex[0, -a].exp
      r[i] = 2.0*@laserfreq/omega*Math::sin(a)*GSL::Complex::exp(0, -a)
    end
    r
  end
  attr_reader :len, :laserfreq
end

class FabryPerot
  # rF: Reflectance of the front mirror
  # rE: Reflectance of the end mirror
  # tF: Transmittance of the front mirror
  def initialize(len, wavelength, rF, rE)
    @len = len.to_f
    @laserfreq = 2.0*Math::PI*CLIGHT/wavelength.to_f
    @tF = Math::sqrt(1.0 - rF*rF)
    @rF = rF
    @rE = rE
  end
  def response(f)
    if f.class != GSL::Vector; f = GSL::Vector[f]; end
    r = GSL::Vector::Complex[f.size]
    f.each_index do |i|
      freq = f[i]
      omega = 2.0*Math::PI*freq
      a = 2.0*@len*omega/CLIGHT
      r[i] = @tF*@tF*@rE/(1.0 - @rF*@rE)/(1.0 - @rF*@rE*GSL::Complex::exp(0, -a))
    end
    r
  end
  attr_reader :len, :laserfreq, :tF, :rF, :rE
end

class FPMI
  def initialize(len, wavelength, rF, rE)
    @mi = Michelson.new(len, wavelength)
    @fp = FabryPerot.new(len, wavelength, rF, rE)
  end
  def response(f)
    @mi.response(f)*@fp.response(f)
  end
  attr_reader :mi, :fp
end

# Fabry-Perot Michelson IFO of the same length
fpmi = FPMI.new(3000, 1e-6, 0.85, 1.0)

f = GSL::Vector.linspace(10, 100000, 1000)
rmi = fpmi.mi.response(f).amp/1e11
rfpmi = fpmi.response(f).amp/1e11
GSL::graph(f, rmi, rfpmi, "-C -g 3 -l x -l y -y 1e-3 1e2 -L 'Red: MI 3km, Green: FPMI 3km'")
#!/usr/bin/env ruby
# Frequency response of a Michelson interferometer
#
require("gsl")

class Michelson
  CLIGHT = GSL::CONST::MKSA::SPEED_OF_LIGHT

  def initialize(len, wavelength)
    @len = len.to_f
    @laserfreq = 2.0*Math::PI*CLIGHT/wavelength.to_f
  end

  def response(f)
    if f.class != GSL::Vector; f = GSL::Vector[f]; end
    r = GSL::Vector::Complex[f.size]
    f.each_index do |i|
      freq = f[i]
      omega = 2.0*Math::PI*freq
      a = @len*omega/CLIGHT
      r[i] = 2.0*@laserfreq/omega*Math::sin(a)*GSL::Complex::exp([0, -a])
    end
    r
  end
  attr_reader :len, :laserfreq
end

# 3km
mi1 = Michelson.new(3000, 1e-6)
# 75km
mi2 = Michelson.new(75000, 1e-6)

f = GSL::Vector.linspace(10, 100000, 1000)
r1 = mi1.response(f).amp
r2 = mi2.response(f).amp
GSL::graph(f, r2/1e11, r1/1e11, "-C -g 3 -l x -l y -y 1e-2 1e2 -L 'Transfer function of Michelson interferometer'")
#!/usr/bin/env ruby
require 'gsl'

a = GSL::Complex.rect(1, 2)
b = GSL::Complex[3, 4]

p a + b
p a

a += b
p a

p a - b
p a

a -= b
p a

p a + b + a

p a.add(b)
p a

p a.sub(b)
p a

p a + 5
p a.add_real(5)
p a

p a.sub_real(5)
p a

p a.add_real(6).sub_real(6)


#!/usr/bin/env ruby
require("gsl")
include Math

# Test GSL::Complex#sqrt
z = GSL::Complex.alloc(1, 2)
sqrtz = z.sqrt
p sqrtz
d = sqrtz*sqrtz
p z == d
sqrtz = GSL::Complex.sqrt(z)
d = sqrtz*sqrtz
p z == d

# Test GSL::Complex::sqrt_real
a = -2.0
c = GSL::Complex.sqrt_real(a)
p GSL::equal?(a, (c*c).re)

# Test GSL::Complex#exp, log
p f = z.exp
p GSL::Complex.exp(z)
p f.log
p f.log == z

p z.pow(f)  # [1.931e-02 1.752e-02], verified with Octave result

# The results below are verified with the Octave results
p GSL::Complex.sin(z)
p GSL::Complex.cos(z)
p GSL::Complex.tan(z)
p GSL::Complex.sec(z)
p GSL::Complex.csc(z)
p GSL::Complex.cot(z)
p GSL::Complex.arcsin(z)
p GSL::Complex.arcsin_real(2)
p GSL::Complex.arccos(z)
p GSL::Complex.arccos_real(2)
p GSL::Complex.arctan(z)
p GSL::Complex.arcsec(z)
p GSL::Complex.arcsec_real(2)
p GSL::Complex.arccsc(z)
p GSL::Complex.arccsc_real(2)
p GSL::Complex.arccot(z)

p GSL::Complex.sinh(z)
p GSL::Complex.cosh(z)
p GSL::Complex.tanh(z)
p GSL::Complex.sech(z)
p GSL::Complex.csch(z)
p GSL::Complex.coth(z)

p GSL::Complex.arcsinh(z)
p GSL::Complex.arccosh(z)
p GSL::Complex.arccosh_real(2)
p GSL::Complex.arctanh(z)
p GSL::Complex.arctanh_real(2)
p GSL::Complex.arcsech(z)
p GSL::Complex.arccsch(z)
p GSL::Complex.arccoth(z)

p 1/z
p z.inverse
p z.conjugate
p z.negative
p -z
z2 = GSL::Complex.alloc(2, 3)
p z*z2
p z/z2
p z - z2
p z + z2
p z + 1
p 2 + z
p 2 * z
p 2/z
p z/2

#!/usr/bin/env ruby
# Transfer function of a RC low-pass filter
require("gsl")
include GSL::CONST::NUM

class RC_LPF
  def initialize(r, c)
    @r = r
    @c = c
    @fp = 1.0/(2*Math::PI*r*c)
    @omegap = 1.0/(r*c)
    puts("Pole at #{fp} Hz")
  end

  def Vout(f)
    if f.class == GSL::Vector
      out = GSL::Vector::Complex[f.size]
      i = 0
      f.each do |freq|
        a = 1.0/GSL::Complex[1.0, freq/@fp]
        out[i] = a
        i += 1
      end
      return out
    else
      1.0/GSL::Complex(1.0, f/@fp)
    end
  end

  attr_reader :r, :c, :fp
end

# Create RC filter
R = 1*KILO    # 1 [kOhm]
C = 1*MICRO   # 1 [muF]
lpf = RC_LPF.new(R, C)

# Frequency, 1Hz - 10kHz, 100 divisions
f = GSL::Vector.logspace2(1, 10*KILO, 100)

# Transfer function
tf = lpf.Vout(f)

GSL::graph([f, tf.amp.dB], "-C -l x -g 3 -y -100 10 -X 'Frequency [Hz]' -Y 'dB' --toggle-rotate-y-label")
GSL::graph([f, tf.phase/Math::PI], "-C -l x -g 3 -X 'Frequency [Hz]' -Y 'Phase [Pi]' --toggle-rotate-y-label")


#!/usr/bin/env ruby
require("gsl")

m = 1.0
k = 1.0
b = 1.0
mode = GSL::Poly.complex_solve_quadratic(m, b, k)
p mode.class

f = GSL::Vector.linspace(0.01, 100, 1000)
p f.class
tf0 = 1.0/((m*mode[0]*f + b)*mode[0]*f + k)
tf1 = 1.0/((m*mode[1]*f + b)*mode[1]*f + k)
p tf0.class
GSL::graph(f, tf0.amp, tf1.amp, "-C -g 3 -l x -l y -L 'Transfer function: amplitude'")
GSL::graph(f, tf0.phase, tf1.phase, "-C -g 3 -l x -L 'Transfer function: phase'")

#!/usr/bin/env ruby
require 'gsl'

a = GSL::Complex.rect(1, 2)
b = GSL::Complex[3, 4]
c = GSL::Complex.alloc(5, 6)
d = GSL::Complex.alloc([7, 8])
p a
p b
p c
p d

e = GSL::Complex.polar(1, Math::PI/6)
p e

p a.abs
p a.abs2
p a.logabs
p Math::log(a.abs)

p e.abs
p e.arg
p Math::PI/6
exit

#!/usr/bin/env ruby
require 'gsl'

a = GSL::Complex.rect(1, 2)
p a

a.set(5)
p a

a.set(3, 6)
p a

p a.re
p a.im
p a.real
p a.imag
p a.REAL
p a.IMAG

a.re = 7
p a

a.im = 1
p a

a.real = 4
p a

a.imag = 9
p a

a.set_real(2)
p a

a.set_imag(3)
p a

#!/usr/bin/env ruby
require 'gsl'

a = GSL::Complex.rect(1, 2)

p 2 + a
p 2 - a
p 2*a

p a - 3
p a * 3

p 2.0/a  # 0.4 - 0.8i

#!/usr/bin/env ruby
require 'gsl'

a = GSL::Complex.rect(1, 2)
b = GSL::Complex[3, 4]

p a*b  # -5 + 10i
p a.mul(b)
p a

p a.div(b)
p a

a *= b
p a

a /= b
p a

p a.mul(2)
p a.mul_real(2)
p a.div_real(2)

p a.conjugate
p a.inverse
p 1.0/a
p a.negative
p -a
#!/usr/bin/env ruby
require("gsl")

f = GSL::Function.alloc { |x|
  GSL::pow(x, 1.5)
}

printf("f(x) = x^(3/2)\n");

x = 2.0
h = 1e-8
result, abserr, status = f.deriv_central(x, h)
printf("x = 2.0\n");
printf("f'(x) = %.10f +/- %.10f\n", result, abserr);
printf("exact = %.10f\n\n", 1.5 * Math::sqrt(2.0));

x = 0.0
result, abserr, status = GSL::Deriv.forward(f, x, h)
printf("x = 0.0\n");
printf("f'(x) = %.10f +/- %.10f\n", result, abserr);
printf("exact = %.10f\n", 0.0);

f2 = GSL::Function.alloc { |x, a| Math::exp(a*x) }

f2.set_params(2)
p f2.deriv_central(0)

f2.set_params(3)
p f2.deriv_central(0)

f2.set_params(123)
p f2.deriv_central(0, h)

p GSL::Deriv.central(f2, 0)
p GSL::Deriv.forward(f2, 0)
p GSL::Deriv.backward(f2, 0)
#!/usr/bin/env ruby
require("gsl")

f = GSL::Function.alloc { |x| Math::exp(-x) }

puts("f(x) = exp(-x)");
puts("Derivative: -exp(-x)")

h = 1e-8
x = GSL::Vector.linspace(0, 5, 50)
y = f.eval(x)
dy, derr = f.deriv_central(x, h)
GSL::graph(x, y, dy, "-T X -C -g 3 -X x -L 'f(x) = exp(-x), and its derivative'")
#!/usr/bin/env ruby
require("gsl")

f = GSL::Function.alloc { |x|
  GSL::pow(x, 1.5)
}

printf("f(x) = x^(3/2)\n");

x = 2.0
result, abserr,status = f.diff_central(x)
printf("x = 2.0\n");
printf("f'(x) = %.10f +/- %.5f\n", result, abserr);
printf("exact = %.10f\n\n", 1.5 * Math::sqrt(2.0));

x = 0.0
result, abserr, status = f.diff_forward(x)
printf("x = 0.0\n");
printf("f'(x) = %.10f +/- %.5f\n", result, abserr);
printf("exact = %.10f\n", 0.0);

f2 = GSL::Function.alloc { |x, a| Math::exp(a*x) }

f2.set_params(2)
p f2.diff_central(0)

f2.set_params(3)
p f2.diff_central(0)

f2.set_params(123)
p f2.diff_central(0)

p GSL::Diff.central(f2, 0)
p GSL::Diff.forward(f2, 0)
p GSL::Diff.backward(f2, 0)
#!/usr/bin/env ruby
require("gsl")
require("ool/conmin.rb")

def iteration_echo(m)
  f = m.f
  x = m.x
  printf( "f( " );
  for i in 0...3 do
    printf( "%+6.3e, ", x[i])
  end
  printf( "... ) = %+6.3e\n", f )

end

NN = 100

fun = Proc.new { |x, params|
  n = x.size
  f = 0
  for i in 0...n do
    xi = x[i] - i.to_f/10.0
    f += (i + 1.0)*xi*xi
  end
  f
}

fun_df = Proc.new { |x, params, g|
  n = x.size
  for i in 0...n do
    xi = x[i] - i.to_f/10.0
    g[i] = 2.0*(i+1.0)*xi
  end
}

fun_Hv = Proc.new { |x, params, v, hv|
  n = x.size
  for i in 0...n do
    hv[i] = 2.0*(i+1.0)*v[i]
  end
}

a = GSL::Vector.alloc(NN)
for i in 0...NN do
  a[i] = (i.to_f + 1.0)/10.0
end
f = OOL::Conmin::Function.alloc()
f.set(NN, fun, fun_df, nil, fun_Hv, a)

L = GSL::Vector.alloc(NN)
U = GSL::Vector.alloc(NN)
L.set_all(-3.0)
U.set_all(3.0)
c = OOL::Conmin::Constraint.alloc()
c.set(NN, L, U)

m = OOL::Conmin::Minimizer.alloc(OOL::Conmin::Minimizer::Spg, NN)
#m = OOL::Conmin::Minimizer.alloc(OOL::Conmin::Minimizer::Pgrad, NN)
#m = OOL::Conmin::Minimizer.alloc("pgrad", NN)
#m = OOL::Conmin::Minimizer.alloc("spg", NN)

#params = OOL::Conmin::Minimizer::Spg.parameters_default
params = m.parameters_default
p params.class
p params

x = GSL::Vector.alloc(NN)
for i in 0...NN do
  x[i] = 1.0 + i
end
m.set(f, c, x, params)

ii = 0
NMAX = 1000
status = OOL::CONTINUE;

printf( "%4d : ", ii )
iteration_echo ( m )
while ii < NMAX && status == OOL::CONTINUE
  ii+=1
  m.iterate
  status = m.is_optimal

  printf( "%4d : ", ii )
  iteration_echo( m )
end

printf("%s method\n", m.name)
if status == OOL::SUCCESS
  printf("\nConvergence in %i iterations\n\n", ii);
else
  printf("Stopped with %i iterations\n", ii);
end
printf("variables................: %6d\n", NN)
printf("function evaluations.....: %6d\n", m.fcount)
printf("gradient evaluations.....: %6d\n", m.gcount)
printf("function value...........: %.6e\n", m.minimum)
printf("projected gradient norm..: %.6e\n", m.size)


#!/usr/bin/env ruby
require("gsl")
require("ool/conmin.rb")

def iteration_echo(m)
  f = m.f
  x = m.x
  printf( "f( " );
  for i in 0...3 do
    printf( "%+6.3e, ", x[i])
  end
  printf( "... ) = %+6.3e\n", f )

end

NN = 100

fun = Proc.new { |x, params|
  n = x.size
  f = 0
  for i in 0...n do
    xi = x[i] - i.to_f/10.0
    f += (i + 1.0)*xi*xi
  end
  f
}

fun_df = Proc.new { |x, params, g|
  n = x.size
  for i in 0...n do
    xi = x[i] - i.to_f/10.0
    g[i] = 2.0*(i+1.0)*xi
  end
}

fun_Hv = Proc.new { |x, params, v, hv|
  n = x.size
  for i in 0...n do
    hv[i] = 2.0*(i+1.0)*v[i]
  end
}

a = GSL::Vector.alloc(NN)
for i in 0...NN do
  a[i] = (i.to_f + 1.0)/10.0
end
f = OOL::Conmin::Function.alloc()
f.set(NN, fun, fun_df, nil, fun_Hv, a)

L = GSL::Vector.alloc(NN)
U = GSL::Vector.alloc(NN)
L.set_all(-3.0)
U.set_all(3.0)
c = OOL::Conmin::Constraint.alloc()
c.set(NN, L, U)

#m = OOL::Conmin::Minimizer.alloc(OOL::Conmin::Minimizer::Spg, NN)
m = OOL::Conmin::Minimizer.alloc(OOL::Conmin::Minimizer::Pgrad, NN)
#m = OOL::Conmin::Minimizer.alloc("pgrad", NN)
#m = OOL::Conmin::Minimizer.alloc("spg", NN)

#params = OOL::Conmin::Minimizer::Spg.parameters_default
params = m.parameters_default
p params.class
p params

x = GSL::Vector.alloc(NN)
for i in 0...NN do
  x[i] = 1.0 + i
end
m.set(f, c, x, params)

ii = 0
NMAX = 1000
status = OOL::CONTINUE;

printf( "%4d : ", ii )
iteration_echo ( m )
while ii < NMAX && status == OOL::CONTINUE
  ii+=1
  m.iterate
  status = m.is_optimal

  printf( "%4d : ", ii )
  iteration_echo( m )
end

printf("%s method\n", m.name)
if status == OOL::SUCCESS
  printf("\nConvergence in %i iterations\n\n", ii);
else
  printf("Stopped with %i iterations\n", ii);
end
printf("variables................: %6d\n", NN)
printf("function evaluations.....: %6d\n", m.fcount)
printf("gradient evaluations.....: %6d\n", m.gcount)
printf("function value...........: %.6e\n", m.minimum)
printf("projected gradient norm..: %.6e\n", m.size)


#!/usr/bin/env ruby
require("gsl")
require("ool/conmin.rb")

def iteration_echo(m)
  f = m.f
  x = m.x
  printf( "f( " );
  for i in 0...3 do
    printf( "%+6.3e, ", x[i])
  end
  printf( "... ) = %+6.3e\n", f )

end

NN = 100

fun = Proc.new { |x, params|
  n = x.size
  f = 0
  for i in 0...n do
    ai = params[i]
    xi = x[i]
    f += (xi - ai)*(xi - ai)
  end
  f
}

fun_df = Proc.new { |x, params, g|
  n = x.size
  for i in 0...n do
    ai = params[i]
    xi = x[i]
    g[i] = 2.0*(xi - ai)
  end
}

fun_Hv = Proc.new { |x, params, v, hv|
  n = x.size
  for i in 0...n do
    hv[i] = 2.0*v[i]
  end
}

a = GSL::Vector.alloc(NN)
for i in 0...NN do
  a[i] = (i.to_f + 1.0)/10.0
end
f = OOL::Conmin::Function.alloc()
f.set(NN, fun, fun_df, nil, fun_Hv, a)

L = GSL::Vector.alloc(NN)
U = GSL::Vector.alloc(NN)
L.set_all(-3.0)
U.set_all(3.0)
c = OOL::Conmin::Constraint.alloc()
c.set(NN, L, U)

m = OOL::Conmin::Minimizer.alloc(OOL::Conmin::Minimizer::Spg, NN)
#m = OOL::Conmin::Minimizer.alloc(OOL::Conmin::Minimizer::Pgrad, NN)
#m = OOL::Conmin::Minimizer.alloc("pgrad", NN)
#m = OOL::Conmin::Minimizer.alloc("spg", NN)

#params = OOL::Conmin::Minimizer::Spg.parameters_default
params = m.parameters_default
p params.class
p params

x = GSL::Vector.alloc(NN)
x.set_all(1.0)
m.set(f, c, x, params)

ii = 0
NMAX = 10000
status = OOL::CONTINUE;

printf( "%4d : ", ii )
iteration_echo ( m )
while ii < NMAX && status == OOL::CONTINUE
  ii+=1
  m.iterate
  status = m.is_optimal

  printf( "%4d : ", ii )
  iteration_echo( m )
end

printf("%s method\n", m.name)
if status == OOL::SUCCESS
  printf("\nConvergence in %i iterations\n\n", ii);
else
  printf("Stopped with %i iterations\n", ii);
end
printf("variables................: %6d\n", NN)
printf("function evaluations.....: %6d\n", m.fcount)
printf("gradient evaluations.....: %6d\n", m.gcount)
printf("function value...........: %.6e\n", m.minimum)
printf("projected gradient norm..: %.6e\n", m.size)


#!/usr/bin/env ruby
require("gsl")
require("ool/conmin.rb")

def iteration_echo(m)
  f = m.f
  x = m.x
  printf( "f( " );
  for i in 0...3 do
    printf( "%+6.3e, ", x[i])
  end
  printf( "... ) = %+6.3e, ||g||=%6.3e\n", f, m.size)

end

NN = 100

fun = Proc.new { |x, params|
  n = x.size
  f = 0
  for i in 0...n do
    xi = x[i] - (i.to_f+1.0)/10.0
    f += (i + 1.0)*xi*xi
  end
  f
}

fun_df = Proc.new { |x, params, g|
  n = x.size
  for i in 0...n do
    xi = x[i] - (i.to_f+1.0)/10.0
    g[i] = 2.0*(i+1.0)*xi
  end
}

fun_Hv = Proc.new { |x, params, v, hv|
  n = x.size
  for i in 0...n do
    hv[i] = 2.0*(i+1.0)*v[i]
  end
}

a = GSL::Vector.alloc(NN)
for i in 0...NN do
  a[i] = (i.to_f + 1.0)/10.0
end
f = OOL::Conmin::Function.alloc()
f.set(NN, fun, fun_df, nil, fun_Hv, a)

L = GSL::Vector.alloc(NN)
U = GSL::Vector.alloc(NN)
L.set_all(-3.0)
U.set_all(3.0)
c = OOL::Conmin::Constraint.alloc()
c.set(NN, L, U)

#m = OOL::Conmin::Minimizer.alloc(OOL::Conmin::Minimizer::Spg, NN)
#m = OOL::Conmin::Minimizer.alloc(OOL::Conmin::Minimizer::Pgrad, NN)
m = OOL::Conmin::Minimizer.alloc(OOL::Conmin::Minimizer::Gencan, NN)
#m = OOL::Conmin::Minimizer.alloc("pgrad", NN)
#m = OOL::Conmin::Minimizer.alloc("spg", NN)

#params = OOL::Conmin::Minimizer::Spg.parameters_default
params = m.parameters_default

x = GSL::Vector.alloc(NN)
for i in 0...NN do
  x[i] = 1.0 + i
end
m.set(f, c, x, params)

ii = 0
NMAX = 1000
status = OOL::CONTINUE;

printf( "%4d : ", ii )
iteration_echo ( m )
while ii < NMAX && status == OOL::CONTINUE
  ii+=1
  m.iterate
  status = m.is_optimal

  printf( "%4d : ", ii )
  iteration_echo( m )
end

printf("%s method\n", m.name)
if status == OOL::SUCCESS
  printf("\nConvergence in %i iterations\n\n", ii);
else
  printf("Stopped with %i iterations\n", ii);
end
printf("variables................: %6d\n", NN)
printf("function evaluations.....: %6d\n", m.fcount)
printf("gradient evaluations.....: %6d\n", m.gcount)
printf("function value...........: %.6e\n", m.minimum)
printf("projected gradient norm..: %.6e\n", m.size)


#!/usr/bin/env ruby
require("gsl")

v = GSL::Vector.alloc(1, 2, 6, 7, 8, 9, 3, 4, 5)

p v.heapsort { |a, b|
  b <=> a
}
p v

p v.heapsort! { |a, b|
  b <=> a
}
p v

v = GSL::Vector.alloc(1, 2, 6, 7, 8, 9, 3, 4, 5)
p v.heapsort_index { |a, b|
  a <=> b
}

p GSL.heapsort(v) { |a, b|
  b <=> a
}
#!/usr/bin/env ruby
require("gsl")

N = 100000
k = 5

x = GSL::Vector.alloc(N)

GSL::Rng.env_setup()
T = GSL::Rng::DEFAULT
r = GSL::Rng.alloc(T)

for i in 0...N do
  x[i] = r.uniform()
end

small = x.sort_smallest(k)

printf("%d smallest values from %d\n", k, N);

for i in 0...k do
  printf("%d: %.18f\n", i, small[i]);
end
#!/usr/bin/env ruby
require("gsl")

v = GSL::Vector::Complex.alloc(5)
v[0] = [1, 2]
v[1] = [3, 4]
v[2] = [0, 1]
v[3] = [15, 3]
v[4] = [5, 7]

p v.heapsort { |a, b|
  a.abs <=> b.abs
}

p v.heapsort { |a, b|
  b.abs <=> a.abs
}

p GSL.heapsort(v) { |a, b|
  b.abs <=> a.abs
}
#!/usr/bin/env ruby
require("gsl")

v = GSL::Vector.alloc(1, 2, 6, 7, 8, 9, 3, 4, 5)
p v.smallest(5)
p v.largest(3)

p v.smallest_index(3)
p v.largest_index(5)

p v.sort
p v

v.sort!
p v

#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 5, 100)
s = GSL::Sf::synchrotron_1(x)
s.graph(x, "-C -g 3 -X x -L 'Sf::synchrotron_1(x)'")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-10, 10, 100)
a = GSL::Sf::airy_Ai(x)
a.graph(x, "-C -g 3 -L 'GSL::Sf::airy_Ai(x)'")



#!/usr/bin/env ruby
require("gsl")
n = 100
x = GSL::Vector.linspace(0, 10, n)
m1 = GSL::Sf::fermi_dirac_m1(x)
IO.popen("graph -T X -C -g 3 -X x -L 'Fermi-Dirac function'", "w") do |io|
  for i in 0...n do
    io.printf("%e %e\n", x[i], m1[i])
  end
end
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0.01, 14, 50)
y = GSL::Sf::lngamma(x)
GSL::graph(x, y, "-T X -C -g 3 -l y -L 'lngamma(x)'")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 20, 100)
a = GSL::Sf::clausen(x)
GSL::graph(x, a, "-C -g 3 -L 'Sf::clausen(x)'")

#!/usr/bin/env ruby
require("gsl")
n = 100
x = GSL::Vector.linspace(0.01, 4, n)
I0 = GSL::Sf::bessel_I0(x)
I1 = GSL::Sf::bessel_I1(x)
I2 = GSL::Sf::bessel_In(2, x)

y0 = GSL::Sf::bessel_K0(x)
y1 = GSL::Sf::bessel_K1(x)
y2 = GSL::Sf::bessel_Kn(2, x)
GSL::Vector.graph(x, I0, I1, I2, y0, y1, y2, "-T X -C -g 3 -y 0 6 -X x -L 'Bessel functions I0, I1, I2, K0, K1, K2'")
#!/usr/bin/env ruby
require("gsl")
include GSL::Sf

l = 2
x = 0.01
File.open("sphbessel.dat", "w") do |file|
  while x <= 12.0
    j0 = bessel_j0(x)
    j1 = bessel_j1(x)
    j2 = bessel_jl(2, x)
    j3 = bessel_jl(3,x)
    y0 = bessel_y0(x)
    y1 = bessel_y1(x)
    y2 = bessel_y2(x)
    i0 = bessel_i0_scaled(x)
    i1 = bessel_i1_scaled(x)
    i2 = bessel_i2_scaled(x)
    k0 = bessel_k0_scaled(x)
    k1 = bessel_k1_scaled(x)
    k2 = bessel_k2_scaled(x)
    file.printf("%e %e %e %e %e %e %e %e %e %e %e %e %e %e\n",
                x, j0, j1, j2, j3, y0, y1, y2, i0, i1, i2, k0, k1, k2)
    x += 0.1
  end
end

#puts("sphbessel.dat created. Try sphbessel.gp.")
system("gnuplot -persist sphbessel.gp")
File.delete("sphbessel.dat")
#!/usr/bin/env ruby
require("gsl")
n = 100
x = GSL::Vector.linspace(0.01, 20, n)
J0 = GSL::Sf::bessel_J0(x)
J1 = GSL::Sf::bessel_J1(x)
J2 = GSL::Sf::bessel_Jn(2, x)

y0 = GSL::Sf::bessel_Y0(x)
y1 = GSL::Sf::bessel_Y1(x)
y2 = GSL::Sf::bessel_Yn(2, x)

GSL::Vector.graph(x, J0, J1, J2, y0, y1, y2, "-T X -C -g 3 -y -2 1.1 -X x -L 'Bessel functions J0, J1, J2, Y0, Y1, Y2'")
#!/usr/bin/env ruby
require("gsl")
n = 100
x = GSL::Vector.linspace(0, 20, n)
y = GSL::Sf::dilog(x)
y.graph(x, "-T X -C -g 3 -X x -L 'Dilogarithm'")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0.01, 12, 100)
s = GSL::Sf::Shi(x)   # s and c are GSL::Vector
c = GSL::Sf::Chi(x)
GSL::Vector.graph(x, s, c, "-T X -C -g 3 -y -1.5 2 -L 'Hyperbolic integrals Shi(x), Chi(x)'")
#!/usr/bin/env ruby
require("gsl")
n = 50
x = GSL::Vector.linspace(-1, 1, n)
y1 = GSL::Sf::legendre_P1(x)
y2 = GSL::Sf::legendre_P2(x)
y3 = GSL::Sf::legendre_P3(x)
y4 = GSL::Sf::legendre_Pl(4, x)
y5 = GSL::Sf::legendre_Pl(5, x)
GSL::Vector.graph(x, y1, y2, y3, y4, y5, "-T X -C -g 3 -X x -Y 'P(x)' --toggle-rotate-y-label -L 'Legendre P functions'")
#!/usr/bin/env ruby
require("gsl")
n = 50
x = GSL::Vector.linspace(0, 2, n)

y2 = GSL::Sf::transport_2(x)
y3 = GSL::Sf::transport_3(x)
y4 = GSL::Sf::transport_4(x)
y5 = GSL::Sf::transport_5(x)
GSL::Vector.graph(x, y2, y3, y4, y5, "-T X -C -g 3 -X x -Y 'J(x)' --toggle-rotate-y-label -L 'Transport functions'")
#!/usr/bin/env ruby
require("gsl")
n = 100
x = GSL::Vector.linspace(0, 5, n)
y1 = GSL::Sf::gegenpoly_1(0, x)
y2 = GSL::Sf::gegenpoly_2(0, x)
y3 = GSL::Sf::gegenpoly_3(0, x)
GSL::Vector.graph(x, y1, y2, y3, "-T X -C -g 3 -X x -L 'Gegenbauer functions'")
#!/usr/bin/env ruby
require("gsl")
IO.popen("graph -T X -C -g 3 -X x -Y 'psi(x)' --toggle-rotate-y-label -x -3 5 -y -5 15 -L 'Red: Digamma, Green: Trigamma'", "w") do |io|
  x = -2.999
  while x < -2
    y = GSL::Sf::psi(x)
    io.printf("%e %e\n", x, y)
    x += 0.01
  end
  x = -1.999
  while x < -1
    y = GSL::Sf::psi(x)
    io.printf("%e %e\n", x, y)
    x += 0.01
  end
  x = -0.999
  while x < 0
    y = GSL::Sf::psi(x)
    io.printf("%e %e\n", x, y)
    x += 0.01
  end
  x = 0.001
  while x < 5
    y = GSL::Sf::psi(x)
    io.printf("%e %e\n", x, y)
    x += 0.1
  end

  io.printf("\n")
  x = -2.999
  while x < -2
    y = GSL::Sf::psi_1_e(x).val
    io.printf("%e %e\n", x, y)
    x += 0.01
  end
  x = -1.999
  while x < -1
    y = GSL::Sf::psi_1_e(x).val
    io.printf("%e %e\n", x, y)
    x += 0.01
  end
  x = -0.999
  while x < 0
    y = GSL::Sf::psi_1_e(x).val
    io.printf("%e %e\n", x, y)
    x += 0.01
  end
  x = 0.001
  while x < 5
    y = GSL::Sf::psi_1_e(x).val
    io.printf("%e %e\n", x, y)
    x += 0.1
  end
end
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 20, 100)
y = GSL::Sf::dawson(x)
y.graph(x, "-T X -C -g 3 -L 'Dawson integral'")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0.1, 12, 100)
s = GSL::Sf::Si(x) - Math::PI/2.0
c = GSL::Sf::Ci(x)
GSL::Vector.graph(x, s, c, "-T X -C -g 3 -y -1.5 1 -L 'Red: Sine integral, Green: Cosine integral'")
#!/usr/bin/env ruby
require("gsl")
s = GSL::Vector.linspace(1.05, 13, 100)
y = GSL::Sf::zetam1(s)
y.graph(s, "-C -l y -L 'Zeta function z(s)-1' -X s -Y 'z(s)-1' --toggle-rotate-y-label")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 0.9, 100)
k = GSL::Sf::ellint_Kcomp(x)
e = GSL::Sf::ellint_Ecomp(x)
GSL::Vector.graph(x, k, e, "-T X -g 3 -C -L 'Red: Kcomp(x), Green: Ecomp(x)'")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(0, 5, 40)
e = GSL::Sf::exp(-x/2)

a = 0
IO.popen("graph -T X -C -g 3 -L 'Laguerre functions'", "w") do |io|
  for n in 0..5 do
    for i in 0...20 do
      y = GSL::Sf::laguerre_n(n, a, x[i])*e[i]
      io.printf("%e %e\n", x[i], y)
    end
    io.printf("\n")
  end
end




#!/usr/bin/env ruby
require("gsl")
n = 50
x = GSL::Vector.linspace(0.01, 1, n)
y1 = GSL::Sf::beta_inc(0.5, 5.0, x)
y2 = GSL::Sf::beta_inc(1.0, 3.0, x)
y3 = GSL::Sf::beta_inc(8.0, 10.0, x)
y4 = GSL::Sf::beta_inc(5.0, 0.5, x)
GSL::Vector.graph([x, y1], [x, y2], [x, y3], [x, y4], "-T X -C -g 3 -y 0 1.1 -X x -L 'Incomplete beta functions'")
#!/usr/bin/env ruby
require("gsl")
n = 50
x = GSL::Vector.linspace(-0.35, 10, n)
GSL::Sf::lambert_W0(x).graph(x, "-T X -C -g 3 -X x -L 'Lambert W function'")
#!/usr/bin/env ruby
require("gsl")
n = 50
x = GSL::Vector.linspace(0, 20, n)
y1 = GSL::Sf::debye_1(x)
y2 = GSL::Sf::debye_2(x)
y3 = GSL::Sf::debye_3(x)
y4 = GSL::Sf::debye_4(x)
GSL::Vector.graph(x, y1, y2, y3, y4, "-T X -C -g 3 -X x -L 'Debye functions'")
#!/usr/bin/env ruby
require("gsl")
n = 50
x = GSL::Vector.linspace(0.01, 14, n)
y05 = GSL::Sf::gamma_inc_P(0.5, x)
y1 = GSL::Sf::gamma_inc_P(1, x)
y3 = GSL::Sf::gamma_inc_P(3, x)
y10 = GSL::Sf::gamma_inc_P(10, x)
GSL::Vector.graph(x, y05, y1, y3, y10, "-T X -C -g 3 -y 0 1.1 -L 'Incomplete gamma functions'")
#!/usr/bin/env ruby
require("gsl")

p GSL::Sf.hyperg_0F1(2, 3)
r = GSL::Sf.hyperg_0F1_e(2, 3)
p r.val

#!/usr/bin/env ruby
require("gsl")
n = 100
x = GSL::Vector.linspace(0.01, 2, n)
y1 = GSL::Sf::expint_E1(x)
y2 = GSL::Sf::expint_E2(x)
yi = GSL::Sf::expint_Ei(x)
GSL::Vector.graph(x, y1, y2, yi, "-T X -C -g 3 -X x -Y 'E(x)' --toggle-rotate-y-label -L 'Exponential integral E1, E2, Ei'")
#!/usr/bin/env ruby
require("gsl")
x = GSL::Vector.linspace(-1, 4, 50)
a = GSL::Sf::airy_Bi(x)
a.graph(x, "-C -g 3 -L 'Sf::airy_Bi(x)'")



#!/usr/bin/env ruby
require("gsl")

include GSL::CONST::MKSA
puts("In MKSA unit")

c  = SPEED_OF_LIGHT;
au = ASTRONOMICAL_UNIT;
minutes = MINUTE;

# distance stored in meters
r_earth = 1.00 * au;
r_mars  = 1.52 * au;

t_min = (r_mars - r_earth) / c;
t_max = (r_mars + r_earth) / c;

printf("light travel time from Earth to Mars:\n");
printf("c = %e [m/s]\n", c)
printf("AU = %e [m]\n", au)
printf("minutes = %e [s]\n", minutes)
printf("minimum = %.1f minutes\n", t_min / minutes);
printf("maximum = %.1f minutes\n\n", t_max / minutes);


include GSL::CONST::CGSM
puts("In CGSM unit")

c  = SPEED_OF_LIGHT;
au = ASTRONOMICAL_UNIT;
minutes = MINUTE;

# distance stored in meters
r_earth = 1.00 * au;
r_mars  = 1.52 * au;

t_min = (r_mars - r_earth) / c;
t_max = (r_mars + r_earth) / c;

printf("light travel time from Earth to Mars:\n");
printf("c = %e [cm/s]\n", c)
printf("AU = %e [cm]\n", au)
printf("minutes = %e [s]\n", minutes)
printf("minimum = %.1f minutes\n", t_min / minutes);
printf("maximum = %.1f minutes\n", t_max / minutes);
#!/usr/bin/env ruby
require("gsl")
require("curses")

#SUBWIN_H = 20
SUBWIN_W = 50
SUBWIN_Y = 1
SUBWIN_X = 10

print("MKSA/CGSM ? [m/c] : ")
sys = gets
if /^m/ =~ sys
  include GSL::CONST::MKSA
  PREFIX = "MKSA"
else
  include GSL::CONST::CGSM
  PREFIX = "CGSM"
end
include GSL::CONST::NUM

Curses.init_screen
W = Curses.stdscr
Curses.refresh

MAIN_MENU = ["", "Fundamental Constants", "Astronomy and Astrophysics",
             "Atomic and Nuclear Physics", "Measurement of Time",
             "Imperial Units", "Nautical Units", "Printers Units",
             "Volume", "Mass and Weight", "Thermal Energy and Power",
             "Pressure", "Viscosity", "Light and Illumination",
             "Radioactivity", "Force and Energy", "Prefixes"]

MENU = Array.new(MAIN_MENU.size)
MENU[1] = ["", "SPEED_OF_LIGHT", "VACUUM_PERMEABILITY", "VACUUM_PERMITTIVITY",
           "PLANCKS_CONSTANT_H", "PLANCKS_CONSTANT_HBAR", "AVOGADRO",
           "FARADAY", "BOLTZMANN", "MOLAR_GAS", "STANDARD_GAS_VOLUME",
           "STEFAN_BOLTZMANN_CONSTANT", "GAUSS", "MICRON", "HECTARE",
           "MILES_PER_HOUR", "KILOMETERS_PER_HOUR"]

MENU[2] = ["", "ASTRONOMICAL_UNIT", "GRAVITATIONAL_CONSTANT",
           "LIGHT_YEAR", "PARSEC", "GRAV_ACCEL", "SOLAR_MASS"]

MENU[3] = ["", "ELECTRON_CHARGE", "ELECTRON_VOLT", "UNIFIED_ATOMIC_MASS",
           "MASS_ELECTRON", "MASS_MUON", "MASS_PROTON", "MASS_NEUTRON",
           "FINE_STRUCTURE", "RYDBERG", "BOHR_RADIUS", "ANGSTROM",
           "BARN", "BOHR_MAGNETON", "NUCLEAR_MAGNETON",
           "ELECTRON_MAGNETIC_MOMENT", "PROTON_MAGNETIC_MOMENT",
           "THOMSON_CROSS_SECTION"]

MENU[4] = ["", "MINUTE", "HOUR", "DAY", "WEEK"]
MENU[5] = ["", "INCH", "FOOT", "YARD", "MILE", "MIL"]
MENU[6] = ["", "NAUTICAL_MILE", "FATHOM", "KNOT"]
MENU[7] = ["", "POINT", "TEXPOINT"]
MENU[8] = ["", "ACRE", "LITER", "US_GALLON", "CANADIAN_GALLON", "UK_GALLON",
           "QUART", "PINT"]
MENU[9] = ["", "POUND_MASS", "OUNCE_MASS", "TON", "METRIC_TON", "UK_TON",
           "TROY_OUNCE", "CARAT", "GRAM_FORCE", "POUND_FORCE",
           "KILOPOUND_FORCE", "POUNDAL"]
MENU[10] = ["", "CALORIE", "BTU", "THERM", "HORSEPOWER"]
MENU[11] = ["", "BAR", "STD_ATMOSPHERE", "TORR", "METER_OF_MERCURY",
            "INCH_OF_MERCURY", "INCH_OF_WATER", "PSI"]
MENU[12] = ["", "POISE", "STOKES"]
MENU[13] = ["", "STILB", "LUMEN", "LUX", "PHOT", "FOOTCANDLE",
            "LAMBERT", "FOOTLAMBERT"]
MENU[14] = ["", "CURIE", "ROENTGEN", "RAD"]
MENU[15] = ["", "NEWTON", "DYNE", "JOULE", "ERG"]
MENU[16] = ["", "YOTTA", "ZETTA", "EXA", "PETA", "TERA", "GIGA", "MEGA",
            "KILO", "MILLI", "MICRO", "NANO", "PICO", "FEMTO", "ATTO",
            "ZEPTO", "YOCTO"]

def mainmenu
  i = 1
  Curses.clear
  W.setpos(0, 1)
  W.addstr("  GSL-#{GSL::VERSION} Physical Constants:\n")
  MAIN_MENU[1..-1].each do |str|
    W.setpos(i, 1)
    W.addstr(sprintf("  [%2d] %s\n", i, str))
    i+=1
  end
  W.setpos(i, 1)
  str = "  ? ['q' to quit]: "
  W.addstr(str)
  W.setpos(i, str.size+1)
  W.refresh
end

def show_submenu(ind, w)
  w.setpos(1, 0)
  w.addstr(sprintf(" [%2d] %s\n", ind, MAIN_MENU[ind]))
  i = 1
  MENU[ind][1..-1].each do |str|
    w.setpos(i+1, 1)
    w.addstr(sprintf("    [%2d] %s\n", i, str))
    i+=1
  end
  w.setpos(i+=1, 1)
  str = "    ? ['m' to menu]: "
  w.addstr(str)
  w.setpos(i, str.size+1)
  w.box('|', '-')
  w.refresh
end

def show_result(ind, i, w)
  return if i == 0
  return if i > MENU[ind].size-1
  w.setpos(MENU[ind].size+2, 0)
  w.addstr("  #{MENU[ind][i]} = ")
  begin
    val = eval("#{MENU[ind][i]}")
    w.addstr("#{val}\n")
  rescue NameError
    w.addstr("not defined.\n")
  rescue
    return
  ensure
    w.refresh
  end
end

def submenu(ind)
  return unless MENU[ind]
  w = W.subwin(MENU[ind].size+4, SUBWIN_W, SUBWIN_Y, SUBWIN_X)
  while true
    show_submenu(ind, w)
    i = w.getstr
    if /^m/ =~ i
      w.close
      return
    end
    show_result(ind, i.to_i, w)
  end
end

#########

while true
  mainmenu
  i = W.getstr
  W.refresh
  break if /^q/ =~ i
  i = i.to_i
  next if i > MAIN_MENU.size or i < 1
  submenu(i)
end

Curses.close_screen
exit

__END__

require 'mkmf'

def gsl_config_arg(arg)
  yield arg_config("--with-gsl-#{arg}") {
    sh = 'sh ' if RUBY_PLATFORM =~ /mingw/
    IO.popen("#{sh}gsl-config --#{arg}") { |f| f.gets.chomp }
  }, lambda { |val| puts "checking gsl #{arg}... #{val}"; val }
rescue => err
  abort "*** ERROR: missing required library to compile this module: #{err}"
end

# Function derived from NArray's extconf.rb.
def create_conf_h(file) #:nodoc:
  print "creating #{file}\n"
  File.open(file, 'w') do |hfile|
    header_guard = file.upcase.sub(/\s|\./, '_')

    hfile.puts "#ifndef #{header_guard}"
    hfile.puts "#define #{header_guard}"
    hfile.puts

    # FIXME: Find a better way to do this:
    hfile.puts "#define RUBY_2 1" if RUBY_VERSION >= '2.0'
    hfile.puts "#define RUBY_3 1" if RUBY_VERSION >= '3.0'

    for line in $defs
      line =~ /^-D(.*)/
      match_data = $1.dup

      if match_data.match(/GSL_VERSION*/)
        hfile.printf "#define #{match_data.to_s.split('=').join(' ')}\n"
      else
        hfile.printf "#define %s 1\n", match_data
      end
    end

    hfile.puts
    hfile.puts "#endif"
  end
end

def gsl_def(const, value = nil)
  value = "=#{value}" if value
  $defs << "-D#{const}#{value}"
end

def gsl_have_header(library, header)
  have_library(library) if have_header(header)
end

def gsl_have_library(func)
  have_func(func) if have_library('gsl', func)
end

def gsl_dir_config(target, idir = nil, ldir = idir)
  dir_config(target, idir || $sitearchdir, ldir || $sitearchdir)
end

def gsl_gem_config(target, dir = 'ext')
  path = begin
    require 'rubygems'

    # For some weird reason finding narray and nmatrix headers works with specific
    # functions only. Might need to fix nmatrix/narray to place headers in correct
    # locations?
    if target == 'narray'
      gem 'narray'
      spec = Gem::Specification.find_by_path("#{target}")
      File.join(spec.full_gem_path, dir) if spec
    else
      gem 'nmatrix'
      spec = Gem::Specification.find_all_by_name("#{target}").compact
      File.join(spec[0].require_path)
    end

  rescue LoadError
  end

  gsl_dir_config(target, path)

  $LOCAL_LIBS += " -l:#{target}.so" if arg_config("--force-link-#{target}")   ||
                                       $CFLAGS.include?('-Wl,--no-undefined') ||
                                       $LDFLAGS.include?('-Wl,--no-undefined')
end

$CFLAGS += ' -Wall -Iinclude'

gsl_config_arg(:version) { |version, check|
  gsl_def(:GSL_VERSION, check[version])

  ver = version.split('.').map { |x| x.to_i }

  later = lambda { |other|
    ary = other.split('.').map { |x| x.to_i }

    gte = ver[0] > ary[0] ? true  :
          ver[0] < ary[0] ? false :
          ver[1] > ary[1] ? true  :
          ver[1] < ary[1] ? false :
          ver.size < ary.size ? false :
          ver.size == 3 && ary.size == 3 ? ver[2] >= ary[2] : true

    ary.pop && ary[-1] += 1 if ary.last == 90

    gte && gsl_def("GSL_#{ary.join('_')}_LATER")
  }

  raise 'Ruby/GSL requires gsl-1.15 or later.' unless later['1.15']

  %w[1.15 1.16 2.0 2.1].each { |v| later[v] }
}

gsl_config_arg(:cflags) { |cflags, check|
  $CFLAGS += ' ' + check[cflags]
}

gsl_config_arg(:libs) { |libs, check|
  libs.tr!(File::PATH_SEPARATOR, ' ')

  if enable_config('atlas')
    dir_config('cblas')
    dir_config('atlas')

    if have_library('cblas') && have_library('atlas')
      libs.gsub!('-lgslcblas', '-lcblas -latlas')
    end
  end

  $LOCAL_LIBS += ' ' + check[libs]
}

have_func('round')

%w[alf qrngextra rngextra tensor].each { |library|
  gsl_have_header(library, "#{library}/#{library}.h")
}

gsl_have_header('bundle_method', 'gsl/gsl_multimin_fsdf.h')
gsl_have_header('cqp',           'gsl/gsl_cqp.h')
gsl_have_header('jacobi',        'jacobi.h')
gsl_have_header('ndlinear',      'ndlinear/gsl_multifit_ndlinear.h')
gsl_have_header('ool',           'ool/ool_version.h')

gsl_have_library('gsl_eigen_francis')
gsl_have_library('gsl_poly_solve_quartic')

gsl_def(:HAVE_GNU_GRAPH) if find_executable('graph')

external_libs = []
external_libs << 'narray' if ENV['NARRAY']
external_libs << 'nmatrix' if ENV['NMATRIX']

external_libs.each do |library|
  gsl_gem_config(library)
  have_header("#{library}.h")
  have_header("nmatrix_config.h") if library == 'nmatrix'
  have_library(library) if RUBY_PLATFORM =~ /cygwin|mingw/  
end

unless arg_config('--disable-tamu-anova')
  gsl_dir_config('tamu_anova')
  gsl_have_header('tamuanova', 'tamu_anova/tamu_anova.h')
end

have_struct_member('gsl_multifit_fdfsolver', 'J', 'gsl/gsl_multifit_nlin.h')
have_func('gsl_sf_mathieu_a_e',  'gsl/gsl_sf_mathieu.h');
have_func('gsl_sf_mathieu_b_e',  'gsl/gsl_sf_mathieu.h');
have_func('gsl_sf_mathieu_ce_e', 'gsl/gsl_sf_mathieu.h');
have_func('gsl_sf_mathieu_se_e', 'gsl/gsl_sf_mathieu.h');
have_func('gsl_sf_mathieu_Mc_e', 'gsl/gsl_sf_mathieu.h');
have_func('gsl_sf_mathieu_Ms_e', 'gsl/gsl_sf_mathieu.h');

create_conf_h('gsl_config.h')
create_makefile('gsl_native')
require 'test/unit'
begin
  require 'narray'
rescue LoadError => e
end

begin
  require 'nmatrix/nmatrix'
rescue LoadError => e
end
require 'gsl'

GSL::IEEE.env_setup
GSL::Rng.env_setup

class GSL::TestCase < Test::Unit::TestCase

  def assert_factor(result, expected, factor, desc)
    refute result == expected ? false : (
      expected.zero? ? result != expected :
      (u = result / expected; u > factor || u < 1.0 / factor)),
      '%s (%.18g observed vs %.18g expected)' % [desc, result, expected]
  end

  def assert_rel(result, expected, relerr, desc)
    refute((GSL.isnan?(result) || GSL.isnan?(expected)) ?
       GSL.isnan?(result) != GSL.isnan?(expected) :
      (GSL.isinf?(result) || GSL.isinf?(expected)) ?
       GSL.isinf?(result) != GSL.isinf?(expected) :
      expected.zero? ? result.abs > relerr :
      (result - expected).abs / expected.abs > relerr,
      '%s (%.18g observed vs %.18g expected)' % [desc, result, expected])
  end

  def assert_abs(result, expected, abserr, desc)
    refute((GSL.isnan?(result) || GSL.isnan?(expected)) ?
       GSL.isnan?(result) != GSL.isnan?(expected) :
      (GSL.isinf?(result) || GSL.isinf?(expected)) ?
       GSL.isinf?(result) != GSL.isinf?(expected) :
      (result - expected).abs > abserr,
      '%s (%.18g observed vs %.18g expected)' % [desc, result, expected])
  end

  def assert_int(result, expected, desc)
    assert(result == expected, '%s (%d observed vs %d expected)' % [desc, result, expected])
  end

  def assert_tol(a, b, msg)
    assert((a - b).abs < (self.class::EPSREL * GSL.MIN(a.abs, b.abs) + self.class::EPSABS), msg)
  end

  # Assert each element in an enumerable with absolute error.
  def assert_enum_abs(result, expected, abserr, desc)
    assert result.size == expected.size, 'size mismatch.'

    r_enum = result.each
    e_enum = expected.each

    while true
      begin
        res_value = r_enum.next
        exp_value = e_enum.next
        assert_abs res_value, exp_value, abserr, "value mismatch. #{res_value} should be #{exp_value}"
      rescue StopIteration
        break
      end
    end
  end

end
require 'test_helper'

class GSLTest < GSL::TestCase

  def test_expm1
    y = GSL.expm1(0.0)
    y_expected = 0.0
    assert_rel y, y_expected, 1e-15, 'GSL.expm1(0.0)'

    y = GSL.expm1(1e-10)
    y_expected = 1.000000000050000000002e-10
    assert_rel y, y_expected, 1e-15, 'GSL.expm1(1e-10)'

    y = GSL.expm1(-1e-10)
    y_expected = -9.999999999500000000017e-11
    assert_rel y, y_expected, 1e-15, 'GSL.expm1(-1e-10)'

    y = GSL.expm1(0.1)
    y_expected = 0.1051709180756476248117078264902
    assert_rel y, y_expected, 1e-15, 'GSL.expm1(0.1)'

    y = GSL.expm1(-0.1)
    y_expected = -0.09516258196404042683575094055356
    assert_rel y, y_expected, 1e-15, 'GSL.expm1(-0.1)'

    y = GSL.expm1(10.0)
    y_expected = 22025.465794806716516957900645284
    assert_rel y, y_expected, 1e-15, 'GSL.expm1(10.0)'

    y = GSL.expm1(-10.0)
    y_expected = -0.99995460007023751514846440848444
    assert_rel y, y_expected, 1e-15, 'GSL.expm1(-10.0)'
  end

  def test_log1p
    y = GSL.log1p(0.0)
    y_expected = 0.0
    assert_rel y, y_expected, 1e-15, 'GSL.log1p(0.0)'

    y = GSL.log1p(1e-10)
    y_expected = 9.9999999995000000000333333333308e-11
    assert_rel y, y_expected, 1e-15, 'GSL.log1p(1e-10)'

    y = GSL.log1p(0.1)
    y_expected = 0.095310179804324860043952123280765
    assert_rel y, y_expected, 1e-15, 'GSL.log1p(0.1)'

    y = GSL.log1p(10.0)
    y_expected = 2.3978952727983705440619435779651
    assert_rel y, y_expected, 1e-15, 'GSL.log1p(10.0)'
  end

  def test_hypot
    y = GSL.hypot(0.0, 0.0)
    y_expected = 0.0
    assert_rel y, y_expected, 1e-15, 'GSL.hypot(0.0, 0.0)'

    y = GSL.hypot(1e-10, 1e-10)
    y_expected = 1.414213562373095048801688e-10
    assert_rel y, y_expected, 1e-15, 'GSL.hypot(1e-10, 1e-10)'

    y = GSL.hypot(1e-38, 1e-38)
    y_expected = 1.414213562373095048801688e-38
    assert_rel y, y_expected, 1e-15, 'GSL.hypot(1e-38, 1e-38)'

    y = GSL.hypot(1e-10, -1.0)
    y_expected = 1.000000000000000000005
    assert_rel y, y_expected, 1e-15, 'GSL.hypot(1e-10, -1)'

    y = GSL.hypot(-1.0, 1e-10)
    y_expected = 1.000000000000000000005
    assert_rel y, y_expected, 1e-15, 'GSL.hypot(-1, 1e-10)'

    #y = GSL.hypot(1e307, 1e301)
    #y_expected = 1.000000000000499999999999e307
    #assert_rel y, y_expected, 1e-15, 'GSL.hypot(1e307, 1e301)'

    #y = GSL.hypot(1e301, 1e307)
    #y_expected = 1.000000000000499999999999e307
    #assert_rel y, y_expected, 1e-15, 'GSL.hypot(1e301, 1e307)'

    #y = GSL.hypot(1e307, 1e307)
    #y_expected = 1.414213562373095048801688e307
    #assert_rel y, y_expected, 1e-15, 'GSL.hypot(1e307, 1e307)'
  end

  def test_acosh
    y = GSL.acosh(1.0)
    y_expected = 0.0
    assert_rel y, y_expected, 1e-15, 'GSL.acosh(1.0)'

    y = GSL.acosh(1.1)
    y_expected = 4.435682543851151891329110663525e-1
    assert_rel y, y_expected, 1e-15, 'GSL.acosh(1.1)'

    y = GSL.acosh(10.0)
    y_expected = 2.9932228461263808979126677137742e0
    assert_rel y, y_expected, 1e-15, 'GSL.acosh(10.0)'

    y = GSL.acosh(1e10)
    y_expected = 2.3718998110500402149594646668302e1
    assert_rel y, y_expected, 1e-15, 'GSL.acosh(1e10)'
  end

  def test_asinh
    y = GSL.asinh(0.0)
    y_expected = 0.0
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(0.0)'

    y = GSL.asinh(1e-10)
    y_expected = 9.9999999999999999999833333333346e-11
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(1e-10)'

    y = GSL.asinh(-1e-10)
    y_expected = -9.9999999999999999999833333333346e-11
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(1e-10)'

    y = GSL.asinh(0.1)
    y_expected = 9.983407889920756332730312470477e-2
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(0.1)'

    y = GSL.asinh(-0.1)
    y_expected = -9.983407889920756332730312470477e-2
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(-0.1)'

    y = GSL.asinh(1.0)
    y_expected = 8.8137358701954302523260932497979e-1
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(1.0)'

    y = GSL.asinh(-1.0)
    y_expected = -8.8137358701954302523260932497979e-1
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(-1.0)'

    y = GSL.asinh(10.0)
    y_expected = 2.9982229502979697388465955375965e0
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(10)'

    y = GSL.asinh(-10.0)
    y_expected = -2.9982229502979697388465955375965e0
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(-10)'

    y = GSL.asinh(1e10)
    y_expected = 2.3718998110500402149599646668302e1
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(1e10)'

    y = GSL.asinh(-1e10)
    y_expected = -2.3718998110500402149599646668302e1
    assert_rel y, y_expected, 1e-15, 'GSL.asinh(-1e10)'
  end

  def test_atanh
    y = GSL.atanh(0.0)
    y_expected = 0.0
    assert_rel y, y_expected, 1e-15, 'GSL.atanh(0.0)'

    y = GSL.atanh(1e-20)
    y_expected = 1e-20
    assert_rel y, y_expected, 1e-15, 'GSL.atanh(1e-20)'

    y = GSL.atanh(-1e-20)
    y_expected = -1e-20
    assert_rel y, y_expected, 1e-15, 'GSL.atanh(-1e-20)'

    y = GSL.atanh(0.1)
    y_expected = 1.0033534773107558063572655206004e-1
    assert_rel y, y_expected, 1e-15, 'GSL.atanh(0.1)'

    y = GSL.atanh(-0.1)
    y_expected = -1.0033534773107558063572655206004e-1
    assert_rel y, y_expected, 1e-15, 'GSL.atanh(-0.1)'

    y = GSL.atanh(0.9)
    y_expected = 1.4722194895832202300045137159439e0
    assert_rel y, y_expected, 1e-15, 'GSL.atanh(0.9)'

    y = GSL.atanh(-0.9)
    y_expected = -1.4722194895832202300045137159439e0
    assert_rel y, y_expected, 1e-15, 'GSL.atanh(0.9)'
  end

  def test_pow_int
    y = GSL.pow_2(-3.14)
    y_expected = GSL.pow(-3.14, 2.0)
    assert_rel y, y_expected, 1e-15, 'GSL.pow_2(-3.14)'

    y = GSL.pow_3(-3.14)
    y_expected = GSL.pow(-3.14, 3.0)
    assert_rel y, y_expected, 1e-15, 'GSL.pow_3(-3.14)'

    y = GSL.pow_4(-3.14)
    y_expected = GSL.pow(-3.14, 4.0)
    assert_rel y, y_expected, 1e-15, 'GSL.pow_4(-3.14)'

    y = GSL.pow_5(-3.14)
    y_expected = GSL.pow(-3.14, 5.0)
    assert_rel y, y_expected, 1e-15, 'GSL.pow_5(-3.14)'

    y = GSL.pow_6(-3.14)
    y_expected = GSL.pow(-3.14, 6.0)
    assert_rel y, y_expected, 1e-15, 'GSL.pow_6(-3.14)'

    y = GSL.pow_7(-3.14)
    y_expected = GSL.pow(-3.14, 7.0)
    assert_rel y, y_expected, 1e-15, 'GSL.pow_7(-3.14)'

    y = GSL.pow_8(-3.14)
    y_expected = GSL.pow(-3.14, 8.0)
    assert_rel y, y_expected, 1e-15, 'GSL.pow_8(-3.14)'

    y = GSL.pow_9(-3.14)
    y_expected = GSL.pow(-3.14, 9.0)
    assert_rel y, y_expected, 1e-15, 'GSL.pow_9(-3.14)'

    -9.upto(9) { |n|
      y = GSL.pow_int(-3.14, n)
      y_expected = GSL.pow(-3.14, n)
      assert_rel y, y_expected, 1e-15, "GSL.pow_n(-3.14,#{n})"
    }
  end

  def test_ldexp
    y = GSL.ldexp(GSL::M_PI, -2)
    y_expected = GSL::M_PI_4
    assert_rel y, y_expected, 1e-15, 'GSL.ldexp(pi,-2)'

    y = GSL.ldexp(1.0, 2)
    y_expected = 4.000000
    assert_rel y, y_expected, 1e-15, 'GSL.ldexp(1.0,2)'

    y = GSL.ldexp(0.0, 2)
    y_expected = 0.0
    assert_rel y, y_expected, 1e-15, 'GSL.ldexp(0.0,2)'
  end

  def test_frexp
    y, e = GSL.frexp(GSL::M_PI)
    y_expected = GSL::M_PI_4
    e_expected = 2
    assert_rel y, y_expected, 1e-15, 'GSL.frexp(pi) fraction'
    assert_int e, e_expected, 'GSL.frexp(pi) exponent'

    y, e = GSL.frexp(2.0)
    y_expected = 0.5
    e_expected = 2
    assert_rel y, y_expected, 1e-15, 'GSL.frexp(2.0) fraction'
    assert_int e, e_expected, 'GSL.frexp(2.0) exponent'

    y, e = GSL.frexp(1.0 / 4.0)
    y_expected = 0.5
    e_expected = -1
    assert_rel y, y_expected, 1e-15, 'GSL.frexp(0.25) fraction'
    assert_int e, e_expected, 'GSL.frexp(0.25) exponent'

    y, e = GSL.frexp(1.0 / 4.0 - 4.0 * GSL::DBL_EPSILON)
    y_expected = 0.999999999999996447
    e_expected = -2
    assert_rel y, y_expected, 1e-15, 'GSL.frexp(0.25-eps) fraction'
    assert_int e, e_expected, 'GSL.frexp(0.25-eps) exponent'
  end

  def test_gsl
    x = GSL::M_PI
    y = 22.0 / 7.0

    10.times { |i|
      tol = GSL.pow(10, -i)
      res = GSL.fcmp(x, y, tol)
      assert_int res, i >= 4 ? -1 : 0, "GSL.fcmp(#{x},#{y},#{tol})"

      res = GSL.fcmp(y, x, tol)
      assert_int res, i >= 4 ? 1 : 0, "GSL.fcmp(#{y},#{x},#{tol})"
    }

    zero = 0.0
    one = 1.0
    inf = Math.exp(1.0e10)
    nan = inf / inf

    s = GSL.isinf(zero)
    assert_int s, 0, 'GSL.isinf(0)'

    s = GSL.isinf(one)
    assert_int s, 0, 'GSL.isinf(1)'

    s = GSL.isinf(inf)
    assert_int s, 1, 'GSL.isinf(inf)'

    # Commented out 2008/Oct/17 by YT
    # This test fails in (Darwin 9.5.0, gcc4.0.1):
    #  gsl_isinf() returns 1 for -inf
    #s = GSL.isinf(-inf)
    #assert_int s, -1, 'GSL.isinf(-inf)'

    s = GSL.isinf(nan)
    assert_int s, 0, 'GSL.isinf(nan)'

    s = GSL.isnan(zero)
    assert_int s, 0, 'GSL.isnan(0)'

    s = GSL.isnan(one)
    assert_int s, 0, 'GSL.isnan(1)'
    s = GSL.isnan(inf)
    assert_int s, 0, 'GSL.isnan(inf)'

    s = GSL.isnan(nan)
    assert_int s, 1, 'GSL.isnan(nan)'

    s = GSL.finite(zero)
    assert_int s, 1, 'GSL.finite(0)'

    s = GSL.finite(one)
    assert_int s, 1, 'GSL.finite(1)'

    s = GSL.finite(inf)
    assert_int s, 0, 'GSL.finite(inf)'

    s = GSL.finite(nan)
    assert_int s, 0, 'GSL.finite(nan)'
  end

end
require 'test_helper'

class RngTest < GSL::TestCase

  N = 1000
  N2 = 20000

  BINS = 17
  EXTRA = 10

  {
    'rand'       => [[1, 10000, 1910041713]],
    'randu'      => [[1, 10000, 1623524161]],
    'cmrg'       => [[1, 10000, 719452880]],
    'minstd'     => [[1, 10000, 1043618065]],
    'mrg'        => [[1, 10000, 2064828650]],
    'taus'       => [[1, 10000, 2733957125]],
    'taus113'    => [[1, 1000, 1925420673]],
    'transputer' => [[1, 10000, 1244127297]],
    'vax'        => [[1, 10000, 3051034865]],

    'borosh13'  => [[1, 10000, 2513433025]],
    'fishman18' => [[1, 10000, 330402013]],
    'fishman2x' => [[1, 10000, 540133597]],
    'knuthran2' => [[1, 10000, 1084477620]],
    'knuthran'  => [[310952, 1009 * 2009 + 1, 461390032]],
    'lecuyer21' => [[1, 10000, 2006618587]],

    'waterman14' => [[1, 10000, 3776680385]],
    'coveyou'    => [[6, 10000, 1416754246]],
    'fishman20'  => [[6, 10000, 248127575]],
    'ranlux'     => [[314159265, 10000, 12077992]],
    'ranlux389'  => [[314159265, 10000, 165942]],
    'ranlxs0'    => [[1, 10000, 11904320]],

    'ranlxs1' => [[1, 10000, 8734328]],
    'ranlxs2' => [[1, 10000, 6843140]],
    'ranlxd1' => [[1, 10000, 1998227290]],
    'ranlxd2' => [[1, 10000, 3949287736]],
    'slatec'  => [[1, 10000, 45776]],
    'uni'     => [[1, 10000, 9214]],
    'uni32'   => [[1, 10000, 1155229825]],
    'zuf'     => [[1, 10000, 3970]],

    'r250'         => [[1, 10000, 1100653588]],
    'mt19937'      => [[4357, 1000, 1186927261]],
    'mt19937_1999' => [[4357, 1000, 1030650439]],
    'mt19937_1998' => [[4357, 1000, 1309179303]],
    'tt800'        => [[0, 10000, 2856609219]],

    'ran0' => [[0, 10000, 1115320064]],
    'ran1' => [[0, 10000, 1491066076]],
    'ran2' => [[0, 10000, 1701364455]],
    'ran3' => [[0, 10000, 186340785]],

    'ranmar' => [[1, 10000, 14428370]],

    'rand48' => [[0, 10000, 0xDE095043],
                 [1, 10000, 0xEDA54977]],

    'random_glibc2'    => [[0, 10000, 1908609430]],
    'random8_glibc2'   => [[0, 10000, 1910041713]],
    'random32_glibc2'  => [[0, 10000, 1587395585]],
    'random64_glibc2'  => [[0, 10000, 52848624]],
    'random128_glibc2' => [[0, 10000, 1908609430]],
    'random256_glibc2' => [[0, 10000, 179943260]],

    'random_bsd'    => [[0, 10000, 1457025928]],
    'random8_bsd'   => [[0, 10000, 1910041713]],
    'random32_bsd'  => [[0, 10000, 1663114331]],
    'random64_bsd'  => [[0, 10000, 864469165]],
    'random128_bsd' => [[0, 10000, 1457025928]],
    'random256_bsd' => [[0, 10000, 1216357476]],

    'random_libc5'    => [[0, 10000, 428084942]],
    'random8_libc5'   => [[0, 10000, 1910041713]],
    'random32_libc5'  => [[0, 10000, 1967452027]],
    'random64_libc5'  => [[0, 10000, 2106639801]],
    'random128_libc5' => [[0, 10000, 428084942]],
    'random256_libc5' => [[0, 10000, 116367984]],

    'ranf' => [[0, 10000, 2152890433],
               [2, 10000, 339327233]]
  }.each { |type, args|
    args.each_with_index { |(seed, n, result), i|
      define_method("test_#{type}_#{i}") {
        r, k = GSL::Rng.alloc(type), nil
        r.set(seed) if seed != 0

        n.times { k = r.get }

        assert k == result, "#{r.name}, #{n} steps (#{k} observed vs #{result} expected)"
      }
    }
  }

  GSL::Rng.types.each { |type|
    define_method("test_float_#{type}")          { _rng_float_test(type) }
    define_method("test_state_#{type}")          { _rng_state_test(type) }
    define_method("test_parallel_state_#{type}") { _rng_parallel_state_test(type) }
    define_method("test_read_write_#{type}")     { _rng_read_write_test(type) }
    define_method("test_generic_#{type}")        { _generic_rng_test(type) }
  }

  def _rng_float_test(type)
    ri = GSL::Rng.alloc(type)
    rf = GSL::Rng.alloc(type)

    status = k = 0

    begin
      k = ri.get
      u = rf.get
    end while k == 0

    c = k / u

    N2.times {
      k = ri.get
      u = rf.get

      if c * k != u
        status = 1
        break
      end
    }

    assert status.zero?, "#{ri.name}, ratio of int to double (#{c} observed vs #{k/u} expected)"
  end

  def _rng_state_test(type)
    r = GSL::Rng.alloc(type)
    r_save = GSL::Rng.alloc(type)

    N.times { r.get }

    GSL::Rng.memcpy(r_save, r)

    test_a = GSL::Vector.alloc(N)
    test_b = GSL::Vector.alloc(N)

    N.times { |i| test_a[i] = r.get }

    GSL::Rng.memcpy(r, r_save)
    N.times { |i| test_b[i] = r.get }

    assert((0...N).all? { |i| test_b[i] == test_a[i] }, "#{r.name}, random number state consistency")
  end

  def _rng_parallel_state_test(type)
    r1 = GSL::Rng.alloc(type)
    r2 = GSL::Rng.alloc(type)

    test_a = GSL::Vector.alloc(N)
    test_b = GSL::Vector.alloc(N)
    test_c = GSL::Vector.alloc(N)
    test_d = GSL::Vector.alloc(N)
    test_e = GSL::Vector.alloc(N)
    test_f = GSL::Vector.alloc(N)

    N.times { r1.get }

    GSL::Rng.memcpy(r2, r1)

    N.times { |i|
      test_a[i] = r1.get
      test_b[i] = r2.get
      test_c[i] = r1.uniform_int(1234)
      test_d[i] = r2.uniform_int(1234)
      test_e[i] = r1.uniform
      test_f[i] = r2.uniform
    }

    assert((0...N).all? { |i| test_a[i] == test_b[i] }, "#{r1.name}, parallel random number state consistency (a/b)")
    assert((0...N).all? { |i| test_c[i] == test_d[i] }, "#{r1.name}, parallel random number state consistency (c/d)")
    assert((0...N).all? { |i| test_e[i] == test_f[i] }, "#{r1.name}, parallel random number state consistency (e/f)")
  end

  def _rng_read_write_test(type)
    r = GSL::Rng.alloc(type)

    test_a = GSL::Vector.alloc(N)
    test_b = GSL::Vector.alloc(N)

    N.times { r.get }

    r.fwrite('test.dat')
    N.times { |i| test_a[i] = r.get }

    r.fread('test.dat')
    N.times { |i| test_b[i] = r.get }

    assert((0...N).all? { |i| test_b[i] == test_a[i] }, "#{r.name}, random number generator read and write")
  ensure
    File.delete('test.dat') if FileTest.exist?('test.dat')
  end

  def _generic_rng_test(type)
    r = GSL::Rng.alloc(type)

    name, ran_max, ran_min = r.name, r.max, r.min
    kmax, kmin, sigma = 0, 1000, 0.0

    kmax, status = _rng_max_test(r, ran_max)
    assert status.zero?, "#{name}, observed vs theoretical maximum (#{kmax} vs #{ran_max})"

    kmin, status = _rng_min_test(r, ran_min, ran_max)
    assert status.zero?, "#{name}, observed vs theoretical minimum (#{kmin} vs #{ran_min})"

    sigma, status = _rng_sum_test(r)
    assert status.zero?, "#{r.name}, sum test within acceptable sigma (observed #{sigma} sigma)"

    sigma, status = _rng_bin_test(r)
    assert status.zero?, "#{r.name}, bin test within acceptable chisq (observed #{sigma} sigma)"

    r.set(1)
    kmax, status = _rng_max_test(r, ran_max)

    r.set(1)
    kmin, s = _rng_min_test(r, ran_min, ran_max)
    status |= s

    r.set(1)
    sigma, s = _rng_sum_test(r)
    status |= s

    r.set(12345)
    kmax, s = _rng_max_test(r, ran_max)
    status |= s

    r.set(12345)
    kmin, s = _rng_min_test(r, ran_min, ran_max)
    status |= s

    r.set(12345)
    sigma, s = _rng_sum_test(r)
    status |= s

    assert status.zero?, "#{r.name}, maximum and sum tests for non-default seeds"
  end

  def _rng_max_test(r, ran_max)
    max = 0

    N2.times {
      k = r.get
      max = k if k > max
    }

    actual_uncovered = ran_max - max
    expect_uncovered = ran_max.to_f / N2.to_f

    [max, max > ran_max || actual_uncovered > 7 * expect_uncovered ? 1 : 0]
  end

  def _rng_min_test(r, ran_min, ran_max)
    min = 1000000000

    N2.times {
      k = r.get
      min = k if k < min
    }

    actual_uncovered = min - ran_min
    expect_uncovered = ran_max.to_f / N2.to_f

    [min, min < ran_min || actual_uncovered > 7 * expect_uncovered ? 1 : 0]
  end

  def _rng_sum_test(r)
    sum = 0.0

    N2.times {
      x = r.uniform - 0.5
      sum += x
    }

    sum /= N2.to_f
    sigma = sum * Math.sqrt(12.0 * N2)

    [sigma, sigma.abs > 3 || sigma.abs < 0.003 ? 1 : 0]
  end

  def _rng_bin_test(r)
    count = GSL::Vector.calloc(BINS + EXTRA)
    chisq = 0.0

    N2.times { count[r.uniform_int(BINS)] += 1 }

    BINS.times { |i|
      x = N2.to_f / BINS
      d = count[i] - x
      chisq += d * d / x
    }

    BINS.upto(EXTRA - 1) { |i|
      assert count[i].zero?, "#{r.name}, wrote outside range in bin test (#{i} observed vs #{BINS - 1} expected)"
    }

    [sigma = Math.sqrt(chisq / BINS), sigma.abs > 3 || sigma.abs < 0.003 ? 1 : 0]
  end

end
require 'test_helper'

class MultiMinTest < GSL::TestCase

  def _test_fdf(desc, f, x, type)
    s = GSL::MultiMin::FdfMinimizer.alloc(type, f.n)
    s.set(f, x, 0.1 * GSL::Blas.dnrm2(x), 0.1)

    status = iter = 0

    begin
      iter += 1
      s.iterate

      status = GSL::MultiMin.test_gradient(s.gradient, 1e-3)
    end while iter < 5000 and status == GSL::CONTINUE

    status |= s.f.abs > 1e-5 ? 1 : 0
    assert status.zero?, "#{s.name}, on #{desc}: #{iter} iterations, f(x)=#{s.f}"
  end

  def _test_f(desc, f, x)
    step_size = GSL::Vector.alloc(f.n)
    f.n.times { |i| step_size[i] = 1 }

    s = GSL::MultiMin::FMinimizer.alloc('nmsimplex', f.n)
    s.set(f, x, step_size)

    status = iter = 0

    begin
      s.iterate
      status = GSL::MultiMin.test_size(s.size, 1e-3)
    end while iter < 5000 and status == GSL::CONTINUE

    status |= s.fval.abs > 1e-5 ? 1 : 0
    assert status.zero?, "#{s.name}, on #{desc}: #{iter} iterations, f(x)=#{s.fval}"

    s = GSL::MultiMin::FMinimizer.alloc('nmsimplex2rand', f.n)
    s.set(f, x, step_size)

    status = iter = 0

    begin
      s.iterate
      status = GSL::MultiMin.test_size(s.size, 1e-3)
    end while iter < 5000 and status == GSL::CONTINUE

    status |= s.fval.abs > 1e-5 ? 1 : 0
    assert status.zero?, "#{s.name}, on #{desc}: #{iter} iterations, f(x)=#{s.fval}"
  end

  def _roth_initpt
    GSL::Vector.alloc(4.5, 3.5)
  end

  def _wood_initpt
    GSL::Vector.alloc(-3.0, -1.0, -3.0, -1.0)
  end

  def _rosenbrock_initpt
    GSL::Vector.alloc(-1.2, 1.0)
  end

  def _roth_f
    lambda { |x|
      u = x[0]
      v = x[1]
      a = -13.0 + u + ((5.0 - v) * v - 2.0) * v;
      b = -29.0 + u + ((v + 1.0) * v - 14.0) * v;
      a * a + b * b;
    }
  end

  def _wood_f
    lambda { |x|
      u1 = x[0]
      u2 = x[1]
      u3 = x[2]
      u4 = x[3]
      t1 = u1 * u1 - u2
      t2 = u3 * u3 - u4
      100 * t1 * t1 + (1 - u1) * (1 - u1) + 90 * t2 * t2 + (1 - u3) * (1 - u3) + 10.1 * ((1 - u2) * (1 - u2) + (1 - u4) * (1 - u4)) + 19.8 * (1 - u2) * (1 - u4)
    }
  end

  def _rosenbrock_f
    lambda { |x|
      u = x[0]
      v = x[1]
      a = u - 1
      b = u * u - v
      a * a + 10.0 * b * b
    }
  end

  def _rothdf
    GSL::MultiMin::Function_fdf.alloc(_roth_f, lambda { |x, df|
      u = x[0]
      v = x[1]
      a = -13.0 + u + ((5.0 - v) * v - 2.0) * v
      b = -29.0 + u + ((v + 1.0) * v - 14.0) * v
      c = -2 + v * (10 - 3 * v)
      d = -14 + v * (2 + 3 * v)
      df[0] = 2 * a + 2 * b
      df[1] = 2 * a * c + 2 * b * d
    }, 2)
  end

  def _wooddf
    GSL::MultiMin::Function_fdf.alloc(_wood_f, lambda { |x, df|
      u1 = x[0]
      u2 = x[1]
      u3 = x[2]
      u4 = x[3]
      t1 = u1 * u1 - u2
      t2 = u3 * u3 - u4
      df[0] = 400 * u1 * t1 - 2 * (1 - u1)
      df[1] = -200 * t1 - 20.2 * (1 - u2) - 19.8 * (1 - u4)
      df[2] = 360 * u3 * t2 - 2 * (1 - u3)
      df[3] = -180 * t2 - 20.2 * (1 - u4) - 19.8 * (1 - u2)
    }, 4)
  end

  def _rosenbrockdf
    GSL::MultiMin::Function_fdf.alloc(_rosenbrock_f, lambda { |x, df|
      u = x[0]
      v = x[1]
      a = u - 1
      b = u * u - v
      df[0] = 2 * a + 40 * u * b
      df[1] = -20 * b
    }, 2)
  end

  fdfminimizers = %w[steepest_descent conjugate_pr conjugate_fr vector_bfgs]
  fdfminimizers << 'vector_bfgs2' if GSL::GSL_VERSION >= '1.8.90'

  fdfminimizers.each { |type|
    define_method("test_fdf_roth_#{type}") { _test_fdf('Roth', _rothdf, _roth_initpt, type) }
    define_method("test_fdf_wood_#{type}") { _test_fdf('Wood', _wooddf, _wood_initpt, type) }
    define_method("test_fdf_rosenbrock_#{type}") { _test_fdf('Rosenbrock', _rosenbrockdf, _rosenbrock_initpt, type) }
  }

  def test_f_roth
    _test_f('Roth', GSL::MultiMin::Function.alloc(_roth_f, 2), _roth_initpt)
  end

  def test_f_wood
    _test_f('Wood', GSL::MultiMin::Function.alloc(_wood_f, 4), _wood_initpt)
  end

  def test_f_rosenbrock
    _test_f('Rosenbrock', GSL::MultiMin::Function.alloc(_rosenbrock_f, 2), _rosenbrock_initpt)
  end

end
require 'test_helper'

class HistoTest < GSL::TestCase

  def test_histo
    h = GSL::Histogram.alloc(10, [0, 10])

    assert h
    assert h.get_range(2)
    assert h.range
    assert h.bin
  end

end
require 'test_helper'

class ComplexTest < GSL::TestCase

  def test_complex
    10.times { |i|
      r = (i - 5.0) * 0.3
      t = 2.0 * GSL::M_PI * i / 5.0

      z = GSL::Complex.polar(r, t)

      assert_rel z.real, r * Math.cos(t), 10 * GSL::DBL_EPSILON,
        'gsl_complex_polar real part at (r=%g,t=%g)' % [r, t]

      assert_rel z.imag, r * Math.sin(t), 10 * GSL::DBL_EPSILON,
        'gsl_complex_polar imag part at (r=%g,t=%g)' % [r, t]
    }
  end
  
  # Test if it is possible to create a GSL::Complex from ::Complex
  def test_rb_complex_creation
    rb_comp = Complex(rand, rand)
    
    z = GSL::Complex.alloc(rb_comp)
    
    assert_rel z.real, rb_comp.real, GSL::DBL_EPSILON,
      "gsl_complex real part.  Re(#{rb_comp}) = #{z.real}"
    assert_rel z.imag, rb_comp.imag, GSL::DBL_EPSILON,
      "gsl_complex imag part.  Im(#{rb_comp}) = #{z.imag}"
  end
end
require 'test_helper'

class MultifitTest < GSL::TestCase

  def _test_lmder(fdf, x, xx, f, cov)
    s = GSL::MultiFit::FdfSolver.alloc('lmsder', fdf.n, fdf.p)
    s.set(fdf, x)

    20.times { |i|
      s.iterate

      fdf.p.times { |j|
        assert_rel s.x[j], xx[fdf.p * i + j], 1e-5, "lmsder,  iter=#{i}, x#{j}"
      }

      assert_rel GSL::Blas.dnrm2(s.f), f[i], 1e-5, "lmsder, iter=#{i}, f"
    }

    covar = s.covar(0.0)

    fdf.p.times { |i|
      fdf.p.times { |j|
        assert_rel covar[i, j], cov[i * fdf.p + j], 1e-7, "gsl_multifit_covar cov(#{i},#{j})"
      }
    }
  end

  def _test_fdf(name, fdf, x, x_final, f_sumsq, sigma)
    s = GSL::MultiFit::FdfSolver.alloc('lmsder', fdf.n, fdf.p)
    s.set(fdf, x)

    1000.times {
      s.iterate

      status = s.test_delta(0.0, 1e-7)
      break if status != GSL::CONTINUE
    }

    covar = s.covar(0.0)

    fdf.p.times { |i|
      assert_rel s.x[i], x_final[i], 1e-5, "#{name}, lmsder, x#{i}"
    }

    s2 = GSL.pow(GSL::Blas.dnrm2(s.f), 2.0)
    assert_rel s2, f_sumsq, 1e-5, "#{name}, lmsder, |f|^2"

    fdf.p.times { |i|
      ei = Math.sqrt(s2 / (fdf.n - fdf.p)) * Math.sqrt(covar[i, i])
      assert_rel ei, sigma[i], 1e-4, "#{name}, sigma(#{i})"
    }
  end

  def test_2dgauss
    maxiter = 10
    n = 33

    point = Struct.new(:x, :y)

    # model: a * exp(-((x - x0) ** 2 + (y - y0) ** 2) / 2 / sigma ** 2)
    gauss_f = lambda { |x, t, y, s, f|
      # x: parameters as a Vecor
      # t: observed points as an Array
      # y: observed data as a GSL::Vector
      # s: errorbar
      # f: result
      a = x[0]
      x0 = x[1]
      y0 = x[2]
      sigma2 = x[3] ** 2

      y.size.times { |i|
        f.set(i, (a * Math.exp(-((t[i].x - x0) ** 2 + (t[i].y - y0) ** 2) / 2 / sigma2) - y[i]) / s[i])
      }

      GSL::SUCCESS
    }

    gauss_df = lambda { |x, t, y, s, df|
      a = x[0]
      x0 = x[1]
      y0 = x[2]
      sigma = x[3]
      sigma2 = sigma ** 2

      y.size.times { |i|
        dx = t[i].x - x0; dx2 = dx ** 2
        dy = t[i].y - y0; dy2 = dy ** 2

        f = a * Math.exp(-(dx2 + dy2) / 2 / sigma2)

        df.set(i, 0, f / a / s[i])
        df.set(i, 1, f * dx / sigma2 / s[i])
        df.set(i, 2, f * dy / sigma2 / s[i])
        df.set(i, 3, f * (dx2 + dy2) / sigma2 / sigma / s[i])
      }

      GSL::SUCCESS
    }

    # goal
    xgoal = GSL::Vector.alloc([1, 0, 0, 1])
    parname = %w[a x0 y0 si]

    # data
    t = []
    tmin = -10.0
    tmax =  10.0

    n.times { |j|
      n.times { |i|
        t << point.new(tmin + (tmax - tmin) * i / (n - 1), tmin + (tmax - tmin) * j / (n - 1))
      }
    }

    stdev = xgoal[0] * 0.1

    s = GSL::Vector.alloc(Array.new(t.size, stdev))  # error bar of each datum
    r = GSL::Rng.alloc
    e = GSL::Vector.alloc(t.size)

    t.size.times { |i|
      e[i] = -r.gaussian(stdev)  # perturbation to data
    }

    y = GSL::Vector.alloc(t.size)
    n = GSL::Vector.alloc(Array.new(t.size, 1.0))
    gauss_f.call(xgoal, t, e, n, y)  # data: y = model - e

    # fitting
    x = GSL::Vector.alloc([0.5, 0.1, -0.1, 2.0])  # initial guess
    fdf = GSL::MultiFit::Function_fdf.alloc(gauss_f, gauss_df, x.size)
    fdf.set_data(t, y, s)

    solver = GSL::MultiFit::FdfSolver.alloc(GSL::MultiFit::FdfSolver::LMSDER, t.size, x.size)
    solver.set(fdf, x)

    #solver.print_state(0)

    maxiter.times { |i|
      solver.iterate

      status = solver.test_delta(1e-6, 1e-6)
      #solver.print_state(i + 1)

      break if status != GSL::CONTINUE
    }

    # results
    covar = solver.covar(0.0)
    xresult = solver.position
    dof = t.size - xresult.size
    chi2 = GSL.pow_2(solver.f.dnrm2)
    xsigma = GSL::Vector.alloc(xresult.size)

    xresult.size.times { |i|
      xsigma[i] = Math.sqrt(chi2 / dof * covar[i, i]) * 2.0
      # allow resulting parameters to differ two times than standard error
    }

    desc = "a*exp(-((x-x0)**2+(y-y0)**2)/2/si**2), chi2/N:%.3g" % (chi2 / t.size)

    xresult.size.times { |i|
      assert_rel xresult[i], xgoal[i], xsigma[i], '%s: %-2.2s' % [desc, parname[i]]

      refute((xresult[i] - xgoal[i]).abs > xsigma[i],
        '%s: %-2.2s is %s +- %s' % [desc, parname[i], xresult[i], xsigma[i]])
    }
  end

  def test_brown
    brown_N = 20
    brown_P = 4

    brown_X = GSL::Matrix.alloc(
      [24.3485677, 4.71448798, -2.19486633, 2.69405755],
      [22.4116222, 3.93075538, -1.42344852, 2.5233557],
      [17.88886, 2.9290853, 0.125174936, -3.96823353],
      [17.3237176, 2.99606803, 2.03285653, 2.28992327],
      [17.0906508, 3.02485425, 0.296995153, 0.0876226126],
      [16.578006, 3.1036312, -0.18617941, 0.103262914],
      [15.692993, 3.33088442, 0.0706406887, 1.05923955],
      [14.3232177, 3.85604218, -2.3762839, -3.09486813],
      [14.1279266, 3.97896121, 0.446109351, 1.40023753],
      [13.6081961, 4.16435075, -1.51250057, -1.52510626],
      [13.4295245, 4.22697223, -0.196985195, 0.532009293],
      [13.0176117, 4.3579261, -0.353131208, 0.301377627],
      [12.2713535, 4.62398535, -0.00183585584, 0.894170703],
      [11.0316144, 5.13967727, -2.38978772, -2.89510064],
      [10.8807981, 5.24558004, 0.230495952, 1.27315117],
      [10.4029264, 5.41141257, -1.5116632, -1.47615921],
      [10.2574435, 5.46211045, -0.299855732, 0.451893162],
      [9.87863876, 5.57914292, -0.368885288, 0.358086545],
      [9.1894983, 5.82082741, -0.230157969, 0.621476534],
      [8.00589008, 6.27788753, -1.46022815, -1.33468082]
    )

    brown_F = GSL::Vector.alloc(
      2474.05541, 1924.69004, 1280.63194, 1244.81867,
      1190.53739, 1159.34935, 1108.44426, 1090.11073,
      1015.92942, 1002.43533, 971.221084, 949.589435,
      911.359899, 906.522994, 840.525729, 833.950164,
      807.557511, 791.00924, 761.09598, 726.787783
    )

    brown_cov = GSL::Matrix.alloc(
      [ 1.8893186910e-01, -4.7099989571e-02,  5.2154168404e-01,  1.6608168209e-02],
      [-4.7099989571e-02,  1.1761534388e-02, -1.2987843074e-01, -4.1615942391e-03],
      [ 5.2154168404e-01, -1.2987843074e-01,  1.4653936514e+00,  1.5738321686e-02],
      [ 1.6608168209e-02, -4.1615942391e-03,  1.5738321686e-02,  4.2348042340e-02]
    )

    brown_x0 = GSL::Vector.alloc(25, 5, -5, -1)

    brown_f = lambda { |x, t, y, f|
      brown_N.times { |i|
        ti = 0.2 * (i + 1)
        ui = x[0] + x[1] * ti - Math.exp(ti)
        vi = x[2] + x[3] * Math.sin(ti) - Math.cos(ti)
        f[i] = ui * ui + vi * vi
      }

      GSL::SUCCESS
    }

    brown_df = lambda { |x, t, y, df|
      brown_N.times { |i|
        ti = 0.2 * (i + 1)
        ui = x[0] + x[1] * ti - Math.exp(ti)
        vi = x[2] + x[3] * Math.sin(ti) - Math.cos(ti)

        df.set(i, 0, 2.0 * ui)
        df.set(i, 1, 2.0 * ui * ti)
        df.set(i, 2, 2.0 * vi)
        df.set(i, 3, 2.0 * vi * Math.sin(ti))
      }

      GSL::SUCCESS
    }

    fdf = GSL::MultiFit::Function_fdf.alloc(brown_f, brown_df, brown_P)
    fdf.set_data(GSL::Vector.alloc(brown_N), GSL::Vector.alloc(brown_N))

    _test_lmder(fdf, brown_x0, brown_X.vector_view, brown_F, brown_cov.vector_view)
  end

  def test_enso
    enso_N = 168
    enso_P = 9

    enso_x0 = GSL::Vector.alloc(10.0, 3.0, 0.5, 44.0, -1.5, 0.5, 26.0, 0.1, 1.5)

    enso_x = GSL::Vector.alloc(
      1.0510749193E+01,  3.0762128085E+00, 5.3280138227E-01,
      4.4311088700E+01, -1.6231428586E+00, 5.2554493756E-01,
      2.6887614440E+01,  2.1232288488E-01, 1.4966870418E+00
    )

    enso_sumsq = 7.8853978668E+02

    enso_sigma = GSL::Vector.alloc(
      1.7488832467E-01, 2.4310052139E-01, 2.4354686618E-01,
      9.4408025976E-01, 2.8078369611E-01, 4.8073701119E-01,
      4.1612939130E-01, 5.1460022911E-01, 2.5434468893E-01
    )

    enso_F = GSL::Vector.alloc(
      12.90000, 11.30000, 10.60000, 11.20000, 10.90000,  7.50000,  7.70000,
      11.70000, 12.90000, 14.30000, 10.90000, 13.70000, 17.10000, 14.00000,
      15.30000,  8.50000,  5.70000,  5.50000,  7.60000,  8.60000,  7.30000,
       7.60000, 12.70000, 11.00000, 12.70000, 12.90000, 13.00000, 10.90000,
      10.40000, 10.20000,  8.00000, 10.90000, 13.60000, 10.50000,  9.20000,
      12.40000, 12.70000, 13.30000, 10.10000,  7.80000,  4.80000,  3.00000,
       2.50000,  6.30000,  9.70000, 11.60000,  8.60000, 12.40000, 10.50000,
      13.30000, 10.40000,  8.10000,  3.70000, 10.70000,  5.10000, 10.40000,
      10.90000, 11.70000, 11.40000, 13.70000, 14.10000, 14.00000, 12.50000,
       6.30000,  9.60000, 11.70000,  5.00000, 10.80000, 12.70000, 10.80000,
      11.80000, 12.60000, 15.70000, 12.60000, 14.80000,  7.80000,  7.10000,
      11.20000,  8.10000,  6.40000,  5.20000, 12.00000, 10.20000, 12.70000,
      10.20000, 14.70000, 12.20000,  7.10000,  5.70000,  6.70000,  3.90000,
       8.50000,  8.30000, 10.80000, 16.70000, 12.60000, 12.50000, 12.50000,
       9.80000,  7.20000,  4.10000, 10.60000, 10.10000, 10.10000, 11.90000,
      13.60000, 16.30000, 17.60000, 15.50000, 16.00000, 15.20000, 11.20000,
      14.30000, 14.50000,  8.50000, 12.00000, 12.70000, 11.30000, 14.50000,
      15.10000, 10.40000, 11.50000, 13.40000,  7.50000,  0.60000,  0.30000,
       5.50000,  5.00000,  4.60000,  8.20000,  9.90000,  9.20000, 12.50000,
      10.90000,  9.90000,  8.90000,  7.60000,  9.50000,  8.40000, 10.70000,
      13.60000, 13.70000, 13.70000, 16.50000, 16.80000, 17.10000, 15.40000,
       9.50000,  6.10000, 10.10000,  9.30000,  5.30000, 11.20000, 16.60000,
      15.60000, 12.00000, 11.50000,  8.60000, 13.80000,  8.70000,  8.60000,
       8.60000,  8.70000, 12.80000, 13.20000, 14.00000, 13.40000, 14.80000
    )

    enso_f = lambda { |x, t, y, f|
      b = x

      enso_N.times { |i|
        ti, pi = t[i], GSL::M_PI

        yy  = b[0]
        yy += b[1] * Math.cos(2.0 * pi * ti / 12)
        yy += b[2] * Math.sin(2.0 * pi * ti / 12)
        yy += b[4] * Math.cos(2.0 * pi * ti / b[3])
        yy += b[5] * Math.sin(2.0 * pi * ti / b[3])
        yy += b[7] * Math.cos(2.0 * pi * ti / b[6])
        yy += b[8] * Math.sin(2.0 * pi * ti / b[6])

        f[i] = y[i] - yy
      }

      GSL::SUCCESS
    }

    enso_df = lambda { |x, t, y, df|
      b = x

      enso_N.times { |i|
        ti, pi = t[i], GSL::M_PI

        df.set(i, 0, -1.0)
        df.set(i, 1, -Math.cos(2.0 * pi * ti / 12))
        df.set(i, 2, -Math.sin(2.0 * pi * ti / 12))
        df.set(i, 3, -b[4] * (2.0 * pi * ti / (b[3] * b[3])) * Math.sin(2 * pi * ti / b[3]) + b[5] * (2 * pi * ti / (b[3] * b[3])) * Math.cos(2 * pi * ti / b[3]))
        df.set(i, 4, -Math.cos(2 * pi * ti / b[3]))
        df.set(i, 5, -Math.sin(2 * pi * ti / b[3]))
        df.set(i, 6, -b[7] * (2 * pi * ti / (b[6] * b[6])) * Math.sin(2 * pi * ti / b[6]) + b[8] * (2 * pi * ti / (b[6] * b[6])) * Math.cos(2 * pi * ti / b[6]))
        df.set(i, 7, -Math.cos(2 * pi * ti / b[6]))
        df.set(i, 8, -Math.sin(2 * pi * ti / b[6]))
      }

      GSL::SUCCESS
    }

    fdf = GSL::MultiFit::Function_fdf.alloc(enso_f, enso_df, enso_P)

    #fdf.set_data(GSL::Vector.alloc(1..168), enso_F)
    fdf.set_data(GSL::Vector.indgen(168, 1), enso_F)

    _test_fdf('nist-ENSO', fdf, enso_x0, enso_x, enso_sumsq, enso_sigma)
  end

  def test_filip
    filip_n = 82
    filip_p = 11

    filip_x = GSL::Vector.alloc(
      -6.860120914, -4.324130045, -4.358625055, -4.358426747, -6.955852379,
      -6.661145254, -6.355462942, -6.118102026, -7.115148017, -6.815308569,
      -6.519993057, -6.204119983, -5.853871964, -6.109523091, -5.79832982,
      -5.482672118, -5.171791386, -4.851705903, -4.517126416, -4.143573228,
      -3.709075441, -3.499489089, -6.300769497, -5.953504836, -5.642065153,
      -5.031376979, -4.680685696, -4.329846955, -3.928486195, -8.56735134,
      -8.363211311, -8.107682739, -7.823908741, -7.522878745, -7.218819279,
      -6.920818754, -6.628932138, -6.323946875, -5.991399828, -8.781464495,
      -8.663140179, -8.473531488, -8.247337057, -7.971428747, -7.676129393,
      -7.352812702, -7.072065318, -6.774174009, -6.478861916, -6.159517513,
      -6.835647144, -6.53165267,  -6.224098421, -5.910094889, -5.598599459,
      -5.290645224, -4.974284616, -4.64454848,  -4.290560426, -3.885055584,
      -3.408378962, -3.13200249,  -8.726767166, -8.66695597,  -8.511026475,
      -8.165388579, -7.886056648, -7.588043762, -7.283412422, -6.995678626,
      -6.691862621, -6.392544977, -6.067374056, -6.684029655, -6.378719832,
      -6.065855188, -5.752272167, -5.132414673, -4.811352704, -4.098269308,
      -3.66174277,  -3.2644011
    )

    filip_y = GSL::Vector.alloc(
      0.8116, 0.9072, 0.9052, 0.9039, 0.8053, 0.8377, 0.8667, 0.8809, 0.7975,
      0.8162, 0.8515, 0.8766, 0.8885, 0.8859, 0.8959, 0.8913, 0.8959, 0.8971,
      0.9021, 0.909,  0.9139, 0.9199, 0.8692, 0.8872, 0.89,   0.891,  0.8977,
      0.9035, 0.9078, 0.7675, 0.7705, 0.7713, 0.7736, 0.7775, 0.7841, 0.7971,
      0.8329, 0.8641, 0.8804, 0.7668, 0.7633, 0.7678, 0.7697, 0.77,   0.7749,
      0.7796, 0.7897, 0.8131, 0.8498, 0.8741, 0.8061, 0.846,  0.8751, 0.8856,
      0.8919, 0.8934, 0.894,  0.8957, 0.9047, 0.9129, 0.9209, 0.9219, 0.7739,
      0.7681, 0.7665, 0.7703, 0.7702, 0.7761, 0.7809, 0.7961, 0.8253, 0.8602,
      0.8809, 0.8301, 0.8664, 0.8834, 0.8898, 0.8964, 0.8963, 0.9074, 0.9119,
      0.9228
    )

    work = GSL::MultiFit::Workspace.alloc(filip_n, filip_p)

    expected_c = GSL::Vector.alloc(
      -1467.48961422980,      -2772.17959193342, -2316.37108160893,
      -1127.97394098372,       -354.478233703349,  -75.1242017393757,
        -10.8753180355343,       -1.06221498588947, -0.670191154593408e-01,
         -0.246781078275479e-02, -0.402962525080404e-04
    )

    expected_sd = GSL::Vector.alloc(
      298.084530995537,      559.779865474950,  466.477572127796,
      227.204274477751,       71.6478660875927,  15.2897178747400,
        2.23691159816033,      0.221624321934227, 0.142363763154724e-01,
        0.535617408889821e-03, 0.896632837373868e-05
    )

    expected_chisq = 0.795851382172941e-03

    xx = GSL::Matrix.alloc(filip_n, filip_p)

    filip_n.times { |i|
      filip_p.times { |j|
        xx.set(i, j, GSL.pow(filip_x[i], j))
      }
    }

    c, cov, chisq, _ = GSL::MultiFit.linear(xx, filip_y, work)

    assert_rel c[0],  expected_c[0],  1e-7, 'filip gsl_fit_multilinear c0'
    assert_rel c[1],  expected_c[1],  1e-7, 'filip gsl_fit_multilinear c1'
    assert_rel c[2],  expected_c[2],  1e-7, 'filip gsl_fit_multilinear c2'
    assert_rel c[3],  expected_c[3],  1e-7, 'filip gsl_fit_multilinear c3'
    assert_rel c[4],  expected_c[4],  1e-7, 'filip gsl_fit_multilinear c4'
    assert_rel c[5],  expected_c[5],  1e-7, 'filip gsl_fit_multilinear c5'
    assert_rel c[6],  expected_c[6],  1e-7, 'filip gsl_fit_multilinear c6'
    assert_rel c[7],  expected_c[7],  1e-7, 'filip gsl_fit_multilinear c7'
    assert_rel c[8],  expected_c[8],  1e-7, 'filip gsl_fit_multilinear c8'
    assert_rel c[9],  expected_c[9],  1e-7, 'filip gsl_fit_multilinear c9'
    assert_rel c[10], expected_c[10], 1e-7, 'filip gsl_fit_multilinear c10'

    diag = cov.diagonal

    assert_rel diag[0],  GSL.pow(expected_sd[0],2.0),  1e-6, 'filip gsl_fit_multilinear cov00'
    assert_rel diag[1],  GSL.pow(expected_sd[1],2.0),  1e-6, 'filip gsl_fit_multilinear cov11'
    assert_rel diag[2],  GSL.pow(expected_sd[2],2.0),  1e-6, 'filip gsl_fit_multilinear cov22'
    assert_rel diag[3],  GSL.pow(expected_sd[3],2.0),  1e-6, 'filip gsl_fit_multilinear cov33'
    assert_rel diag[4],  GSL.pow(expected_sd[4],2.0),  1e-6, 'filip gsl_fit_multilinear cov44'
    assert_rel diag[5],  GSL.pow(expected_sd[5],2.0),  1e-6, 'filip gsl_fit_multilinear cov55'
    assert_rel diag[6],  GSL.pow(expected_sd[6],2.0),  1e-6, 'filip gsl_fit_multilinear cov66'
    assert_rel diag[7],  GSL.pow(expected_sd[7],2.0),  1e-6, 'filip gsl_fit_multilinear cov77'
    assert_rel diag[8],  GSL.pow(expected_sd[8],2.0),  1e-6, 'filip gsl_fit_multilinear cov88'
    assert_rel diag[9],  GSL.pow(expected_sd[9],2.0),  1e-6, 'filip gsl_fit_multilinear cov99'
    assert_rel diag[10], GSL.pow(expected_sd[10],2.0), 1e-6, 'filip gsl_fit_multilinear cov1010'

    assert_rel chisq, expected_chisq, 1e-7, 'filip gsl_fit_multilinear chisq'

    expected_c = GSL::Vector.alloc(
      -1467.48961422980,      -2772.17959193342,      -2316.37108160893, -1127.97394098372,
       -354.478233703349,       -75.1242017393757,      -10.8753180355343,  -1.06221498588947,
         -0.670191154593408e-01, -0.246781078275479e-02, -0.402962525080404e-04
    )

    expected_cov = GSL::Matrix.alloc(
      [ 7.9269341767252183262588583867942e9,  1.4880416622254098343441063389706e10,
        1.2385811858111487905481427591107e10, 6.0210784406215266653697715794241e9,
        1.8936652526181982747116667336389e9,  4.0274900618493109653998118587093e8,
        5.8685468011819735806180092394606e7,  5.7873451475721689084330083708901e6,
        3.6982719848703747920663262917032e5,  1.3834818802741350637527054170891e4,
        2.301758578713219280719633494302e2 ],
      [ 1.4880416622254098334697515488559e10, 2.7955091668548290835529555438088e10,
        2.3286604504243362691678565997033e10, 1.132895006796272983689297219686e10,
        3.5657281653312473123348357644683e9,  7.5893300392314445528176646366087e8,
        1.1066654886143524811964131660002e8,  1.0921285448484575110763947787775e7,
        6.9838139975394769253353547606971e5,  2.6143091775349597218939272614126e4,
        4.3523386330348588614289505633539e2 ],
      [ 1.2385811858111487890788272968677e10, 2.3286604504243362677757802422747e10,
        1.9412787917766676553608636489674e10, 9.4516246492862131849077729250098e9,
        2.9771226694709917550143152097252e9,  6.3413035086730038062129508949859e8,
        9.2536164488309401636559552742339e7,  9.1386304643423333815338760248027e6,
        5.8479478338916429826337004060941e5,  2.1905933113294737443808429764554e4,
        3.6493161325305557266196635180155e2 ],
      [ 6.0210784406215266545770691532365e9,  1.1328950067962729823273441573365e10,
        9.4516246492862131792040001429636e9,  4.6053152992000107509329772255094e9,
        1.4517147860312147098138030287038e9,  3.0944988323328589376402579060072e8,
        4.5190223822292688669369522708712e7,  4.4660958693678497534529855690752e6,
        2.8599340736122198213681258676423e5,  1.0720394998549386596165641244705e4,
        1.7870937745661967319298031044424e2 ],
      [ 1.8936652526181982701620450132636e9,  3.5657281653312473058825073094524e9,
        2.9771226694709917514149924058297e9,  1.451714786031214708936087401632e9,
        4.5796563896564815123074920050827e8,  9.7693972414561515534525103622773e7,
        1.427717861635658545863942948444e7,   1.4120161287735817621354292900338e6,
        9.0484361228623960006818614875557e4,  3.394106783764852373199087455398e3,
        5.6617406468519495376287407526295e1 ],
      [ 4.0274900618493109532650887473599e8,  7.589330039231444534478894935778e8,
        6.3413035086730037947153564986653e8,  3.09449883233285893390542947998e8,
        9.7693972414561515475770399055121e7,  2.0855726248311948992114244257719e7,
        3.0501263034740400533872858749566e6,  3.0187475839310308153394428784224e5,
        1.9358204633534233524477930175632e4,  7.2662989867560017077361942813911e2,
        1.2129002231061036467607394277965e1 ],
      [ 5.868546801181973559370854830868e7,   1.1066654886143524778548044386795e8,
        9.2536164488309401413296494869777e7,  4.5190223822292688587853853162072e7,
        1.4277178616356585441556046753562e7,  3.050126303474040051574715592746e6,
        4.4639982579046340884744460329946e5,  4.4212093985989836047285007760238e4,
        2.8371395028774486687625333589972e3,  1.0656694507620102300567296504381e2,
        1.7799982046359973175080475654123e0 ],
      [ 5.7873451475721688839974153925406e6,  1.0921285448484575071271480643397e7,
        9.1386304643423333540728480344578e6,  4.4660958693678497427674903565664e6,
        1.4120161287735817596182229182587e6,  3.0187475839310308117812257613082e5,
        4.4212093985989836021482392757677e4,  4.3818874017028389517560906916315e3,
        2.813828775753142855163154605027e2,   1.0576188138416671883232607188969e1,
        1.7676976288918295012452853715408e-1 ],
      [ 3.6982719848703747742568351456818e5,  6.9838139975394768959780068745979e5,
        5.8479478338916429616547638954781e5,  2.8599340736122198128717796825489e5,
        9.0484361228623959793493985226792e4,  1.9358204633534233490579641064343e4,
        2.8371395028774486654873647731797e3,  2.8138287757531428535592907878017e2,
        1.8081118503579798222896804627964e1,  6.8005074291434681866415478598732e-1,
        1.1373581557749643543869665860719e-2 ],
      [ 1.3834818802741350562839757244708e4,  2.614309177534959709397445440919e4,
        2.1905933113294737352721470167247e4,  1.0720394998549386558251721913182e4,
        3.3941067837648523632905604575131e3,  7.2662989867560016909534954790835e2,
        1.0656694507620102282337905013451e2,  1.0576188138416671871337685672492e1,
        6.8005074291434681828743281967838e-1, 2.5593857187900736057022477529078e-2,
        4.2831487599116264442963102045936e-4 ],
      [ 2.3017585787132192669801658674163e2,  4.3523386330348588381716460685124e2,
        3.6493161325305557094116270974735e2,  1.7870937745661967246233792737255e2,
        5.6617406468519495180024059284629e1,  1.2129002231061036433003571679329e1,
        1.7799982046359973135014027410646e0,  1.7676976288918294983059118597214e-1,
        1.137358155774964353146460100337e-2,  4.283148759911626442000316269063e-4,
        7.172253875245080423800933453952e-6 ]
    )

    expected_chisq = 0.795851382172941E-03

    filip_n.times { |i|
      filip_p.times { |j|
        xx.set(i, j, GSL.pow(filip_x[i], j))
      }
    }

    w = GSL::Vector.alloc(filip_n)
    w.set_all(1.0)

    c, cov, _, _ = GSL::MultiFit.wlinear(xx, w, filip_y, work)

    filip_p.times { |i|
      assert_rel c[i], expected_c[i], 1e-7, "filip gsl_fit_multilinear c#{i}"
    }

    filip_p.times { |i|
      filip_p.times { |j|
        assert_rel cov[i, j], expected_cov[i, j], 1e-6, "filip gsl_fit_wmultilinear cov(#{i},#{j})"
      }
    }
  end

  def test_gauss
    maxiter = 10
    n = 1000

    # model: a * exp(-(x - x0) ** 2 / 2 / sigma ** 2)
    gauss_p = 3
    gauss_f = lambda { |x, t, y, s, f|
      # x: parameters as a Vecor
      # t: observed points as a GSL::Vector
      # y: observed data as a GSL::Vector
      # s: errorbar
      # f: result
      a = x[0]
      x0 = x[1]
      sigma2 = x[2] ** 2

      y.size.times { |i|
        f.set(i, (a * Math.exp(-(t[i] - x0) ** 2 / 2 / sigma2) - y[i]) / s[i])
      }

      GSL::SUCCESS
    }

    gauss_df = lambda { |x, t, y, s, df|
      a = x[0]
      x0 = x[1]
      sigma = x[2]
      sigma2 = sigma ** 2

      y.size.times { |i|
        dx = t[i] - x0
        dx2 = dx ** 2
        f = a * Math.exp(-dx2 / 2 / sigma2)

        df.set(i, 0, f / a / s[i])
        df.set(i, 1, f * dx / sigma2 / s[i])
        df.set(i, 2, f * dx2 / sigma2 / sigma / s[i])
      }

      GSL::SUCCESS
    }

    # goal
    xgoal = GSL::Vector.alloc([1, 0, 1])
    parname = %w[a x0 si]

    # data
    t = GSL::Vector.alloc(n)  # positions of data
    tmin = -10.0
    tmax =  10.0

    t.size.times { |i|
      t[i] = tmin + (tmax - tmin) * i / (n - 1)
    }

    stdev = xgoal[0] * 0.1

    s = GSL::Vector.alloc(Array.new(t.size, stdev))  # error bar of each datum
    r = GSL::Rng.alloc
    e = GSL::Vector.alloc(t.size)

    t.size.times { |i|
      e[i] = -r.gaussian(stdev)  # perturbation to data
    }

    y = GSL::Vector.alloc(t.size)
    n = GSL::Vector.alloc(Array.new(t.size, 1.0))
    gauss_f.call(xgoal, t, e, n, y)  # data: y = model - e

    # fitting
    x = GSL::Vector.alloc([0.5, 0.1, 2])  # initial guess

    fdf = GSL::MultiFit::Function_fdf.alloc(gauss_f, gauss_df, gauss_p)
    fdf.set_data(t, y, s)

    solver = GSL::MultiFit::FdfSolver.alloc(GSL::MultiFit::FdfSolver::LMSDER, t.size, gauss_p)
    solver.set(fdf, x)

    #solver.print_state(0)

    maxiter.times { |i|
      solver.iterate

      status = solver.test_delta(1e-6, 1e-6)
      #solver.print_state(i + 1)

      break if status != GSL::CONTINUE
    }

    # results
    covar = solver.covar(0.0)
    xresult = solver.position
    dof = t.size - gauss_p
    chi2 = GSL.pow_2(solver.f.dnrm2)
    xsigma = GSL::Vector.alloc(xresult.size)

    xresult.size.times { |i|
      xsigma[i] = Math.sqrt(chi2 / dof * covar[i, i]) * 2.0
      # resulting parameters to differ two times than standard error
    }

    desc = 'a*exp(-(x-x0)**2/2/si**2), chi2/N:%.3g' % (chi2 / t.size)

    xresult.size.times { |i|
      assert_rel xresult[i], xgoal[i], xsigma[i], '%s: %-2.2s' % [desc, parname[i]]
      refute((xresult[i] - xgoal[i]).abs > xsigma[i], desc)
    }
  end

  def test_longley
    longley_n = 16
    longley_p = 7

    longley_x = GSL::Vector.alloc(
      1,  83.0, 234289, 2356, 1590, 107608, 1947,
      1,  88.5, 259426, 2325, 1456, 108632, 1948,
      1,  88.2, 258054, 3682, 1616, 109773, 1949,
      1,  89.5, 284599, 3351, 1650, 110929, 1950,
      1,  96.2, 328975, 2099, 3099, 112075, 1951,
      1,  98.1, 346999, 1932, 3594, 113270, 1952,
      1,  99.0, 365385, 1870, 3547, 115094, 1953,
      1, 100.0, 363112, 3578, 3350, 116219, 1954,
      1, 101.2, 397469, 2904, 3048, 117388, 1955,
      1, 104.6, 419180, 2822, 2857, 118734, 1956,
      1, 108.4, 442769, 2936, 2798, 120445, 1957,
      1, 110.8, 444546, 4681, 2637, 121950, 1958,
      1, 112.6, 482704, 3813, 2552, 123366, 1959,
      1, 114.2, 502601, 3931, 2514, 125368, 1960,
      1, 115.7, 518173, 4806, 2572, 127852, 1961,
      1, 116.9, 554894, 4007, 2827, 130081, 1962
    )

    longley_y = GSL::Vector.alloc(
      60323, 61122, 60171, 61187, 63221, 63639, 64989, 63761,
      66019, 67857, 68169, 66513, 68655, 69564, 69331, 70551
    )

    work = GSL::MultiFit::Workspace.alloc(longley_n, longley_p)

    x = GSL::Matrix.alloc(longley_x, longley_n, longley_p).view
    y = longley_y.view

    expected_c = GSL::Vector.alloc(
      -3482258.63459582,
            15.0618722713733,
            -0.358191792925910e-01,
            -2.02022980381683,
            -1.03322686717359,
            -0.511041056535807e-01,
          1829.15146461355
    )

    expected_sd = GSL::Vector.alloc(
      890420.383607373,
          84.9149257747669,
           0.334910077722432e-01,
           0.488399681651699,
           0.214274163161675,
           0.226073200069370,
         455.478499142212
    )

    expected_chisq = 836424.055505915

    c, cov, chisq, _ = GSL::MultiFit.linear(x, y, work)

    7.times { |i|
      assert_rel c[i], expected_c[i], 1e-10, "longley gsl_fit_multilinear c#{i}"
    }

    diag = cov.diagonal

    assert_rel diag[0], GSL.pow(expected_sd[0],2.0), 1e-10, 'longley gsl_fit_multilinear cov00'
    assert_rel diag[1], GSL.pow(expected_sd[1],2.0), 1e-10, 'longley gsl_fit_multilinear cov11'
    assert_rel diag[2], GSL.pow(expected_sd[2],2.0), 1e-10, 'longley gsl_fit_multilinear cov22'
    assert_rel diag[3], GSL.pow(expected_sd[3],2.0), 1e-10, 'longley gsl_fit_multilinear cov33'
    assert_rel diag[4], GSL.pow(expected_sd[4],2.0), 1e-10, 'longley gsl_fit_multilinear cov44'
    assert_rel diag[5], GSL.pow(expected_sd[5],2.0), 1e-10, 'longley gsl_fit_multilinear cov55'
    assert_rel diag[6], GSL.pow(expected_sd[6],2.0), 1e-10, 'longley gsl_fit_multilinear cov66'

    assert_rel chisq, expected_chisq, 1e-10, 'longley gsl_fit_multilinear chisq'

    expected_cov = GSL::Matrix.alloc(
      [ 8531122.56783558, -166.727799925578, 0.261873708176346, 3.91188317230983,
        1.1285582054705, -0.889550869422687, -4362.58709870581 ],
      [ -166.727799925578, 0.0775861253030891, -1.98725210399982e-05, -0.000247667096727256,
        -6.82911920718824e-05, 0.000136160797527761, 0.0775255245956248 ],
      [ 0.261873708176346, -1.98725210399982e-05, 1.20690316701888e-08, 1.66429546772984e-07,
        3.61843600487847e-08, -6.78805814483582e-08, -0.00013158719037715 ],
      [ 3.91188317230983, -0.000247667096727256, 1.66429546772984e-07, 2.56665052544717e-06,
        6.96541409215597e-07, -9.00858307771567e-07, -0.00197260370663974 ],
      [ 1.1285582054705, -6.82911920718824e-05, 3.61843600487847e-08, 6.96541409215597e-07,
        4.94032602583969e-07, -9.8469143760973e-08, -0.000576921112208274 ],
      [ -0.889550869422687, 0.000136160797527761, -6.78805814483582e-08, -9.00858307771567e-07,
        -9.8469143760973e-08, 5.49938542664952e-07, 0.000430074434198215 ],
      [ -4362.58709870581, 0.0775255245956248, -0.00013158719037715, -0.00197260370663974,
        -0.000576921112208274, 0.000430074434198215, 2.23229587481535 ]
    )

    expected_chisq = 836424.055505915

    w = GSL::Vector.alloc(longley_n)
    w.set_all(1.0)

    c, cov, chisq, _ = GSL::MultiFit.wlinear(x, w, y, work)

    7.times { |i|
      assert_rel c[i], expected_c[i], 1e-10, "longley gsl_fit_wmultilinear c#{i}"
    }

    longley_p.times { |i|
      longley_p.times { |j|
        assert_rel cov[i, j], expected_cov[i, j], 1e-7, "longley gsl_fit_wmultilinear cov(#{i},#{j})"
      }
    }

    assert_rel chisq, expected_chisq, 1e-10, 'longley gsl_fit_wmultilinear chisq'
  end

end
require 'test_helper'

class FitTest < GSL::TestCase

  def setup
    @x = GSL::Vector.alloc(1000)
    @y = GSL::Vector.alloc(1000)
    @w = GSL::Vector.alloc(1000)

    @x.stride = 2
    @w.stride = 3
    @y.stride = 5
  end

  def test_fit_1
    n = 36

    x = GSL::Vector.alloc(
      0.2, 337.4, 118.2, 884.6, 10.1, 226.5, 666.3, 996.3,
      448.6, 777.0, 558.2, 0.4, 0.6, 775.5, 666.9, 338.0,
      447.5, 11.6, 556.0, 228.1, 995.8, 887.6, 120.2, 0.3,
      0.3, 556.8, 339.1, 887.2, 999.0, 779.0, 11.1, 118.3,
      229.2, 669.1, 448.9, 0.5
    )

    y = GSL::Vector.alloc(
      0.1, 338.8, 118.1, 888.0, 9.2, 228.1, 668.5, 998.5,
      449.1, 778.9, 559.2, 0.3, 0.1, 778.1, 668.8, 339.3,
      448.9, 10.8, 557.7, 228.3, 998.0, 888.8, 119.6, 0.3,
      0.6, 557.6, 339.3, 888.0, 998.5, 778.9, 10.2, 117.6,
      228.9, 668.4, 449.2, 0.2
    )

    n.times { |i|
      @x.set(i, x[i])
      @w.set(i, 1.0)
      @y.set(i, y[i])
    }

    c0, c1, cov00, cov01, cov11, sumsq = GSL::Fit.linear(@x, @y, n)
    assert_rel c0,           -0.262323073774029,           1e-10, 'norris gsl_fit_linear c0'
    assert_rel c1,            1.00211681802045,            1e-10, 'norris gsl_fit_linear c1'
    assert_rel cov00, GSL.pow(0.232818234301152, 2.0),     1e-10, 'norris gsl_fit_linear cov00'
    assert_rel cov01,        -7.74327536339570e-05,        1e-10, 'norris gsl_fit_linear cov01'
    assert_rel cov11, GSL.pow(0.429796848199937E-03, 2.0), 1e-10, 'norris gsl_fit_linear cov11'
    assert_rel sumsq,        26.6173985294224,             1e-10, 'norris gsl_fit_linear sumsq'

    c0, c1, cov00, cov01, cov11, sumsq = GSL::Fit.wlinear(@x, @w, @y, n)
    assert_rel c0,    -0.262323073774029,     1e-10, 'norris gsl_fit_wlinear c0'
    assert_rel c1,     1.00211681802045,      1e-10, 'norris gsl_fit_wlinear c1'
    assert_rel cov00,  6.92384428759429e-02,  1e-10, 'norris gsl_fit_wlinear cov00'
    assert_rel cov01, -9.89095016390515e-05,  1e-10, 'norris gsl_fit_wlinear cov01'
    assert_rel cov11,  2.35960747164148e-07,  1e-10, 'norris gsl_fit_wlinear cov11'
    assert_rel sumsq, 26.6173985294224,       1e-10, 'norris gsl_fit_wlinear sumsq'
  end

  def test_fit_2
    n = 11
    x = GSL::Vector.alloc(60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70)
    y = GSL::Vector.alloc(130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140)

    n.times { |i|
      @x.set(i, x[i])
      @w.set(i, 1.0)
      @y.set(i, y[i])
    }

    c1, cov11, sumsq = GSL::Fit.mul(@x, @y, n)
    assert_rel c1,            2.07438016528926,            1e-10, 'noint1 gsl_fit_mul c1'
    assert_rel cov11, GSL.pow(0.165289256198347E-01, 2.0), 1e-10, 'noint1 gsl_fit_mul cov11'
    assert_rel sumsq,       127.272727272727,              1e-10, 'noint1 gsl_fit_mul sumsq'

    c1, cov11, sumsq = GSL::Fit.wmul(@x, @w, @y, n)
    assert_rel c1,      2.07438016528926,     1e-10, 'noint1 gsl_fit_wmul c1'
    assert_rel cov11,   2.14661371686165e-05, 1e-10, 'noint1 gsl_fit_wmul cov11'
    assert_rel sumsq, 127.272727272727,       1e-10, 'noint1 gsl_fit_wmul sumsq'
  end

  def test_fit_3
    n = 3
    x = GSL::Vector.alloc(4, 5, 6)
    y = GSL::Vector.alloc(3, 4, 4)

    n.times { |i|
      @x.set(i, x[i])
      @w.set(i, 1.0)
      @y.set(i, y[i])
    }

    c1, cov11, sumsq = GSL::Fit.mul(@x, @y, n)
    assert_rel c1,            0.727272727272727,           1e-10, 'noint2 gsl_fit_mul c1'
    assert_rel cov11, GSL.pow(0.420827318078432E-01, 2.0), 1e-10, 'noint2 gsl_fit_mul cov11'
    assert_rel sumsq,         0.272727272727273,           1e-10, 'noint2 gsl_fit_mul sumsq'

    c1, cov11, sumsq = GSL::Fit.wmul(@x, @w, @y, n)
    assert_rel c1,    0.727272727272727,    1e-10, 'noint2 gsl_fit_wmul c1'
    assert_rel cov11, 1.29870129870130e-02, 1e-10, 'noint2 gsl_fit_wmul cov11'
    assert_rel sumsq, 0.272727272727273,    1e-10, 'noint2 gsl_fit_wmul sumsq'
  end

end
require 'test_helper'

class InterpTest < GSL::TestCase

  def test_bsearch
    x_array = GSL::Vector.alloc(0.0, 1.0, 2.0, 3.0, 4.0)

    res = GSL::Interp.bsearch(x_array, 1.5, 0, 4)
    refute res != 1, 'simple bsearch'

    res = x_array.bsearch(4.0, 0, 4)
    refute res != 3, 'upper endpoint bsearch'

    res = GSL::Interp.bsearch(x_array, 0.0, 0, 4)
    refute res != 0, 'lower endpoint bsearch'

    res = GSL::Interp.bsearch(x_array, 2.0, 0, 4)
    refute res != 2, 'degenerate bsearch'

    res = GSL::Interp.bsearch(x_array, 10.0, 0, 4)
    refute res != 3, 'out of bounds bsearch +'

    res = GSL::Interp.bsearch(x_array, -10.0, 0, 4)
    refute res != 0, 'out of bounds bsearch -'
  end

end
require 'test_helper'

class BlasTest < GSL::TestCase

  DBLEPS = 1e-6

  def test_amax
    v = GSL::Vector.alloc(0.537, 0.826)
    assert_int v.idamax, 1, 'damax'

    vz = GSL::Vector::Complex.alloc([0.913, -0.436], [-0.134, 0.129])
    assert_int vz.izamax, 0, 'zmax'
  end

  def test_asum
    v = GSL::Vector.alloc(0.271, -0.012)
    assert_rel v.dasum, 0.283, DBLEPS, 'dasum'

    vz = GSL::Vector::Complex.alloc([-0.046, -0.671], [-0.323, 0.785])
    assert_rel vz.dzasum, 1.825, DBLEPS, 'dzasum'
  end

  def test_axpy
    x = GSL::Vector.alloc(0.029)
    y = GSL::Vector.alloc(-0.992)
    e = GSL::Vector.alloc(-1.0007)

    y2 = GSL::Blas.daxpy(-0.3, x, y)

    assert_rel y2[0], e[0], DBLEPS, 'daxpy'

    x = GSL::Vector::Complex.alloc([[0.776, -0.671]])
    y = GSL::Vector::Complex.alloc([[0.39, 0.404]])
    e = GSL::Vector::Complex.alloc([[1.061, 1.18]])

    y2 = GSL::Blas.zaxpy(GSL::Complex.alloc(0, 1), x, y)

    assert_rel y2[0].re, e[0].re, DBLEPS, 'zaxpy real'
    assert_rel y2[0].im, e[0].im, DBLEPS, 'zaxpy imag'
  end

  def test_copy
    x = GSL::Vector.alloc(0.002)
    y = GSL::Vector.alloc(-0.921)
    e = GSL::Vector.alloc(0.002)

    GSL::Blas.dcopy(x, y)

    assert_rel y[0], e[0], DBLEPS, 'dcopy'

    x = GSL::Vector::Complex.alloc([[ 0.315, -0.324]])
    y = GSL::Vector::Complex.alloc([[-0.312, -0.748]])
    e = GSL::Vector::Complex.alloc([[0.315, -0.324]])

    GSL::Blas.zcopy(x, y)

    assert_rel y[0].re, e[0].re, DBLEPS, 'zcopy real'
    assert_rel y[0].im, e[0].im, DBLEPS, 'zcopy imag'
  end

  def test_dnrm2
    return unless GSL.have_narray?

    e = Math.sqrt((0..4).inject { |m, x| m + x * x })

    v = GSL::Vector.indgen(5)
    v_dnrm2 = GSL::Blas.dnrm2(v)

    assert_rel v_dnrm2, e, DBLEPS, 'GSL::Blas.dnrm2(GSL::Vector)'

    na = NArray.float(5).indgen!
    na_dnrm2 = GSL::Blas.dnrm2(na)

    assert_rel na_dnrm2, e, DBLEPS, 'GSL::Blas.dnrm2(NArray)'

    assert_rel na_dnrm2, v_dnrm2, 0, 'GSL::Blas.dnrm2(NArray) == GSL::Blas.dnrm2(GSL::Vector)'
  end

end
require 'test_helper'

class OperTest < GSL::TestCase

  def test_multiplication_matrix
    matrix = GSL::Matrix.ones(1)

    mul_int   = 2 * matrix
    mul_float = 0.2 * matrix

    assert_equal 2,   mul_int[0, 0]
    assert_equal 0.2, mul_float[0, 0]
  end

  def test_multiplication_matrix_int
    matrix = GSL::Matrix::Int.ones(1)

    mul_int   = 2 * matrix
    mul_float = 0.2 * matrix

    assert_equal 2, mul_int[0, 0]
    assert_equal 0, mul_float[0, 0]
  end

  def test_multiplication_matrix_complex
    matrix = GSL::Matrix::Complex.eye(1)

    result = 0.2 * matrix

    assert_equal 0.2, result[0][0]
  end

  def test_multiplication_vector
    vector = GSL::Vector[1, 2]

    mul_int   = 2 * vector
    mul_float = 0.2 * vector

    assert_equal 2,   mul_int[0]
    assert_equal 0.2, mul_float[0]
  end

  def test_multiplication_vector_int
    vector = GSL::Vector::Int[1, 2]

    mul_int   = 2 * vector
    mul_float = 0.2 * vector

    assert_equal 2, mul_int[0]
    assert_equal 0, mul_float[0]
  end

  def test_multiplication_vector_complex
    re = GSL::Vector[1..4]
    im = GSL::Vector[5..8]

    vector = GSL::Vector::Complex[re, im]

    mul_int   = 2 * vector
    mul_float = 0.2 * vector

    assert_equal 10,  mul_int[0][1]
    assert_equal 1.0, mul_float[0][1]
  end

  def test_division_poly
    poly = GSL::Poly.alloc([2])

    a = GSL::Poly[1]; a[0] = 2

    result   = 2 / poly
    expected = GSL::Rational.new(a, poly)

    assert_equal expected.num, result.num
    assert_equal expected.den, result.den
  end

  def test_division_vector_col
    vector = GSL::Vector[1, 2].col

    result1 = 2 / vector
    result2 = 2 / result1

    assert_in_epsilon 0.4, result1[0]
    assert_equal result2, vector
  end

  def test_division_vector_int_col
    vector = GSL::Vector::Int[1, 2].col

    result1 = 2 / vector
    result2 = 2 / result1

    assert_in_epsilon 0.4, result1[0]
    assert_equal result2.to_a.map(&:to_i), vector.to_a
  end

end
require 'test_helper'

class RootsTest < GSL::TestCase

  EPSREL = 10.0 * GSL::DBL_EPSILON
  EPSABS = 10.0 * GSL::DBL_EPSILON

  MAX_ITERATIONS = 150

  def _test_f(type, desc, f, lower, upper, correct)
    s = GSL::Root::FSolver.alloc(type)
    s.set(f, lower, upper)

    status = iter = 0

    begin
      iter += 1
      s.iterate

      r = s.root
      a = s.x_lower
      b = s.x_upper

      refute a > b, "interval is invalid (#{a},#{b})"
      refute r < a || r > b, "r lies outside interval #{r} (#{a},#{b})"

      status = GSL::Root.test_interval(a, b, EPSABS, EPSREL)
    end while status == GSL::CONTINUE && iter < MAX_ITERATIONS

    assert status.zero?, "#{s.name}, #{desc} (#{s.root} obs vs #{correct} expected)"
    assert iter <= MAX_ITERATIONS, 'exceeded maximum number of iterations'

    assert_tol r, correct, "incorrect precision (#{r} obs vs #{correct} expected)"
  end

  def _test_fdf(type, desc, fdf, root, correct)
    s = GSL::Root::FdfSolver.alloc(type)
    s.set(fdf, root)

    status = iter = 0

    begin
      iter += 1
      prev = s.root

      begin
        s.iterate
      rescue GSL::ERROR::EBADFUNC
        raise unless type == 'secant'
      end

      status = GSL::Root.test_delta(s.root, prev, EPSABS, EPSREL)
    end while status == GSL::CONTINUE && iter < MAX_ITERATIONS

    assert status.zero?, "#{s.name} #{desc} (#{s.root} obs vs #{correct} expected)"
    assert iter <= MAX_ITERATIONS, 'exceeded maximum number of iterations'

    assert_tol r = s.root, correct, "incorrect precision (#{r} obs vs #{correct} expected)"
  end

  def setup
    @func = GSL::Function.alloc { |x| GSL.pow(x, 20.0) - 1 }
    @fdf  = GSL::Function_fdf.alloc(@func.f, lambda { |x| 20.0 * GSL.pow(x, 19.0) })
  end

  %w[bisection brent falsepos].each { |type|
    define_method("test_f_#{type}") {
      _test_f(type, 'x^20 - 1 [0.1, 2]', @func, 0.1, 2.0, 1.0)
    }
  }

  %w[newton secant steffenson].each { |type|
    define_method("test_fdf_#{type}") {
      _test_fdf(type, 'x^{20} - 1 {0.9}', @fdf, 0.9, 1.0)
    }
  }

end
require 'test_helper'

class SfTest < GSL::TestCase

  TEST_TOL = [2.0, 16.0, 256.0, 2048.0, 16384.0, 131072.0, 1048576.0]

  TEST_SQRT_TOL0 = 2.0 * GSL::SQRT_DBL_EPSILON

  TEST_SNGL = 1.0e-06

  TEST_FACTOR = 100.0
  TEST_SIGMA = 1.5

  ERR_INCONS = 'value / expected not consistent within reported error'

  def test_mode
    z = GSL::Complex[1, 0]
    m = GSL::Matrix::Complex.eye(2, z)

    assert_equal z, m[0, 0]
    assert_equal GSL::Complex[0, 0], m[0, 1]
    assert_equal GSL::Complex[0, 0], m[1, 0]
    assert_equal z, m[1, 1]
  end

  def _test_sf(func, args, val, tol)
    r, = GSL::Sf.send(func, *args)

    desc = '%s(%p): %20.16g %22.18g %22.18g %g: ' % [
      func, args, val, r.val, r.err, r.err / (r.val.abs + r.err)
    ]

    if GSL.isnan?(r.val) || GSL.isnan?(val)
      assert GSL.isnan(r.val) == GSL.isnan(val), desc + ERR_INCONS
    elsif GSL.isinf?(r.val) || GSL.isinf?(val)
      assert GSL.isinf(r.val) == GSL.isinf(val), desc + ERR_INCONS
    else
      refute((val - r.val).abs > 2.0 * TEST_SIGMA * r.err, desc + ERR_INCONS)
      refute(r.err < 0.0, desc + 'reported error negative')

      tol = TEST_TOL[tol] * GSL::DBL_EPSILON if tol.integer?

      refute(((val.zero? && r.val.zero?) ? 0.0 :
        (val <= GSL::DBL_MAX && r.val < GSL::DBL_MAX && val + r.val != 0) ?
        ((val - r.val) / (val + r.val)).abs : 1.0) > TEST_FACTOR * tol,
        desc + 'value not within tolerance of expected value')
    end
  end

  {
    :airy => [
      [:airy_Ai_e, [-500.0, GSL::MODE_DEFAULT],              0.0725901201040411396, 4],
      [:airy_Ai_e, [-5.0, GSL::MODE_DEFAULT],                0.3507610090241142,    0],
      [:airy_Ai_e, [-0.3000000000000094, GSL::MODE_DEFAULT], 0.4309030952855831,    0],
      [:airy_Ai_e, [0.6999999999999907, GSL::MODE_DEFAULT],  0.1891624003981519,    0],
      [:airy_Ai_e, [1.649999999999991, GSL::MODE_DEFAULT],   0.05831058618720882,   0],
      [:airy_Ai_e, [1.649999999999991, GSL::MODE_DEFAULT],   0.0583105861872088521,   0],
      [:airy_Ai_e, [2.54999999999999, GSL::MODE_DEFAULT],    0.01446149513295428,   0],
      [:airy_Ai_e, [3.499999999999987, GSL::MODE_DEFAULT],   0.002584098786989702,  1],
      [:airy_Ai_e, [5.39999999999998, GSL::MODE_DEFAULT],    4.272986169411866e-05, 0],
      [:airy_Ai_scaled_e, [-5.0, GSL::MODE_DEFAULT],                  0.3507610090241142, 0],
      [:airy_Ai_scaled_e, [0.6999999999999907, GSL::MODE_DEFAULT], 0.2795125667681217, 0],
      [:airy_Ai_scaled_e, [1.649999999999991, GSL::MODE_DEFAULT],  0.2395493001442741, 0],
      [:airy_Ai_scaled_e, [2.54999999999999, GSL::MODE_DEFAULT],   0.2183658595899388, 0],
      [:airy_Ai_scaled_e, [3.499999999999987, GSL::MODE_DEFAULT],  0.2032920808163519, 0],
      [:airy_Ai_scaled_e, [5.39999999999998, GSL::MODE_DEFAULT],   0.1836050093282229, 0],
      [:airy_Bi_e, [-500.0, GSL::MODE_DEFAULT],             -0.094688570132991028, 4],
      [:airy_Bi_e, [-5.0, GSL::MODE_DEFAULT],               -0.1383691349016005,   1],
      [:airy_Bi_e, [0.6999999999999907, GSL::MODE_DEFAULT],  0.9733286558781599,   0],
      [:airy_Bi_e, [1.649999999999991, GSL::MODE_DEFAULT],   2.196407956850028,    0],
      [:airy_Bi_e, [2.54999999999999, GSL::MODE_DEFAULT],    6.973628612493443,    0],
      [:airy_Bi_e, [3.499999999999987, GSL::MODE_DEFAULT],   33.05550675461069,    1],
      [:airy_Bi_e, [5.39999999999998, GSL::MODE_DEFAULT],    1604.476078241272,    1],
      [:airy_Bi_scaled_e, [-5.0, GSL::MODE_DEFAULT],                  -0.1383691349016005, 1],
      [:airy_Bi_scaled_e, [0.6999999999999907, GSL::MODE_DEFAULT],  0.6587080754582302, 0],
      [:airy_Bi_scaled_e, [1.649999999999991, GSL::MODE_DEFAULT],   0.5346449995597539, 0],
      [:airy_Bi_scaled_e, [2.54999999999999, GSL::MODE_DEFAULT],    0.461835455542297,  0],
      [:airy_Bi_scaled_e, [3.499999999999987, GSL::MODE_DEFAULT],   0.4201771882353061, 1],
      [:airy_Bi_scaled_e, [5.39999999999998, GSL::MODE_DEFAULT],    0.3734050675720473, 0],
      [:airy_Ai_deriv_e, [-5.0, GSL::MODE_DEFAULT],                 0.3271928185544435,       1],
      [:airy_Ai_deriv_e, [-0.5500000000000094, GSL::MODE_DEFAULT], -0.1914604987143629,    0],
      [:airy_Ai_deriv_e, [0.4999999999999906, GSL::MODE_DEFAULT],  -0.2249105326646850,    0],
      [:airy_Ai_deriv_e, [1.899999999999992, GSL::MODE_DEFAULT],   -0.06043678178575718,   0],
      [:airy_Ai_deriv_e, [3.249999999999988, GSL::MODE_DEFAULT],   -0.007792687926790889,  0],
      [:airy_Ai_deriv_e, [5.199999999999981, GSL::MODE_DEFAULT],   -0.0001589434526459543, 1],
      [:airy_Ai_deriv_scaled_e, [-5.0, GSL::MODE_DEFAULT],                0.3271928185544435, 1],
      [:airy_Ai_deriv_scaled_e, [0.5499999999999906, GSL::MODE_DEFAULT], -0.2874057279170166, 0],
      [:airy_Ai_deriv_scaled_e, [1.499999999999991, GSL::MODE_DEFAULT],  -0.3314199796863637, 0],
      [:airy_Ai_deriv_scaled_e, [2.49999999999999, GSL::MODE_DEFAULT],   -0.3661089384751620, 0],
      [:airy_Ai_deriv_scaled_e, [3.649999999999986, GSL::MODE_DEFAULT],  -0.3974033831453963, 0],
      [:airy_Ai_deriv_scaled_e, [6.299999999999977, GSL::MODE_DEFAULT],  -0.4508799189585947, 0],
      [:airy_Bi_deriv_e, [-5.0, GSL::MODE_DEFAULT],                0.778411773001899,  0],
      [:airy_Bi_deriv_e, [-0.5500000000000094, GSL::MODE_DEFAULT], 0.5155785358765014, 0],
      [:airy_Bi_deriv_e, [0.4999999999999906, GSL::MODE_DEFAULT],  0.5445725641405883, 0],
      [:airy_Bi_deriv_e, [1.899999999999992, GSL::MODE_DEFAULT],   3.495165862891568,  0],
      [:airy_Bi_deriv_e, [3.249999999999988, GSL::MODE_DEFAULT],   36.55485149250338,  0],
      [:airy_Bi_deriv_e, [5.199999999999981, GSL::MODE_DEFAULT],   2279.748293583233,  1],
      [:airy_Bi_deriv_scaled_e, [-5.0, GSL::MODE_DEFAULT],               0.778411773001899,  0],
      [:airy_Bi_deriv_scaled_e, [0.5499999999999906, GSL::MODE_DEFAULT], 0.4322811281817566, 0],
      [:airy_Bi_deriv_scaled_e, [1.499999999999991, GSL::MODE_DEFAULT],  0.5542307563918037, 0],
      [:airy_Bi_deriv_scaled_e, [2.49999999999999, GSL::MODE_DEFAULT],   0.6755384441644985, 0],
      [:airy_Bi_deriv_scaled_e, [3.649999999999986, GSL::MODE_DEFAULT],  0.7613959373000228, 0],
      [:airy_Bi_deriv_scaled_e, [6.299999999999977, GSL::MODE_DEFAULT],  0.8852064139737571, 0],
      [:airy_zero_Ai_e, [2],  -4.087949444130970617, 0],
      [:airy_zero_Ai_e, [50], -38.02100867725525443, 0],
      [:airy_zero_Ai_e, [100],  -60.45555727411669871, 0],
      [:airy_zero_Ai_e, [110],  -64.43135670991324811, 0],
      [:airy_zero_Bi_e, [2], -3.271093302836352716, 0],
      [:airy_zero_Bi_e, [50], -37.76583438165180116, 0],
      [:airy_zero_Bi_e, [100], -60.25336482580837088, 0],
      [:airy_zero_Bi_e, [110], -64.2355167606561537,  0],
      [:airy_zero_Bi_e, [111], -64.6268994819519378,  0],
      [:airy_zero_Bi_e, [200], -95.88699147356682665, 0],
      [:airy_zero_Ai_deriv_e, [2], -3.248197582179836561, 0],
      [:airy_zero_Ai_deriv_e, [50], -37.76565910053887108, 0],
      [:airy_zero_Ai_deriv_e, [100], -60.25329596442479317, 0],
      [:airy_zero_Ai_deriv_e, [110], -64.23545617243546956, 0],
      [:airy_zero_Ai_deriv_e, [1000], -280.9378080358935071, 0],
      [:airy_zero_Bi_deriv_e, [2], -4.073155089071828216, 0],
      [:airy_zero_Bi_deriv_e, [50], -38.02083574095788210, 0],
      [:airy_zero_Bi_deriv_e, [100], -60.45548887257140819, 0],
      [:airy_zero_Bi_deriv_e, [110], -64.43129648944845060, 0],
      [:airy_zero_Bi_deriv_e, [111], -64.82208737584206093, 0],
      [:airy_zero_Bi_deriv_e, [200], -96.04731050310324450, 0],
      [:airy_zero_Bi_deriv_e, [1000], -281.0315164471118527, 0]
    ],
    :bessel => [
      [:bessel_J0_e, [0.1],     0.99750156206604003230,    0],
      [:bessel_J0_e, [2.0],     0.22389077914123566805,    0],
      [:bessel_J0_e, [100.0],   0.019985850304223122424,   0],
      [:bessel_J0_e, [1.0e+10], 2.1755917502468917269e-06, TEST_SQRT_TOL0],
      [:bessel_J1_e, [0.1],      0.04993752603624199756,   0],
      [:bessel_J1_e, [2.0],      0.57672480775687338720,   0],
      [:bessel_J1_e, [100.0],   -0.07714535201411215803,   0],
      [:bessel_J1_e, [1.0e+10], -7.676508175684157103e-06, 4],
      [:bessel_Jn_e, [4, 0.1],     2.6028648545684032338e-07, 0],
      [:bessel_Jn_e, [5, 2.0],     0.007039629755871685484,   0],
      [:bessel_Jn_e, [10, 20.0],   0.18648255802394508321,    0],
      [:bessel_Jn_e, [100, 100.0], 0.09636667329586155967,    0],
      [:bessel_Jn_e, [2, 900.0], -0.019974345269680646400, 4],
      [:bessel_Jn_e, [2, 15000.0], -0.0020455820181216382666, 4],
      [:bessel_Jn_e, [0, 1.0e+10], 2.1755917502468917269e-06, TEST_SQRT_TOL0],
      [:bessel_Jn_e, [1, 1.0e+10], -7.676508175684157103e-06, 4],
#     [:bessel_Jn_e, [0, 20000], -7.676508175684157103e-06, 4],
      [:bessel_Y0_e, [0.1],         -1.5342386513503668441,    0],
      [:bessel_Y0_e, [2],            0.5103756726497451196,    0],
      [:bessel_Y0_e, [256.0],       -0.03381290171792454909,  0],
      [:bessel_Y0_e, [4294967296.0], 3.657903190017678681e-06, TEST_SQRT_TOL0],
      [:bessel_Y1_e, [0.1],         -6.45895109470202698800,     0],
      [:bessel_Y1_e, [2],           -0.10703243154093754689,     0],
      [:bessel_Y1_e, [100.0],       -0.020372312002759793305,    0],
      [:bessel_Y1_e, [4294967296.0], 0.000011612249378370766284, 4],
      [:bessel_Yn_e, [4, 0.1],            -305832.29793353160319,    1],
      [:bessel_Yn_e, [5, 2],              -9.935989128481974981,     0],
      [:bessel_Yn_e, [100, 100.0],        -0.16692141141757650654,   0],
      [:bessel_Yn_e, [100, 4294967296.0],  3.657889671577715808e-06, TEST_SQRT_TOL0],
      [:bessel_Yn_e, [1000, 4294967296.0], 3.656551321485397501e-06, 2.0e-05],
      [:bessel_Yn_e, [2, 15000.0], -0.006185217273358617849, 4],
      [:bessel_I0_scaled_e, [1e-10],   0.99999999990000000001,   0],
      [:bessel_I0_scaled_e, [0.1],     0.90710092578230109640,   0],
      [:bessel_I0_scaled_e, [2],       0.30850832255367103953,   0],
      [:bessel_I0_scaled_e, [100.0],   0.03994437929909668265,   0],
      [:bessel_I0_scaled_e, [65536.0], 0.0015583712551952223537, 0],
      [:bessel_I1_scaled_e, [0.1],     0.04529844680880932501,   0],
      [:bessel_I1_scaled_e, [2],       0.21526928924893765916,   0],
      [:bessel_I1_scaled_e, [100.0],   0.03974415302513025267,   0],
      [:bessel_I1_scaled_e, [65536.0], 0.0015583593657207350452, 0],
      [:bessel_In_scaled_e, [  -4,    0.1], 2.3575258620054605307e-07, 0],
      [:bessel_In_scaled_e, [   4,    0.1], 2.3575258620054605307e-07, 0],
      [:bessel_In_scaled_e, [   5,    2.0], 0.0013297610941881578142, 0],
      [:bessel_In_scaled_e, [ 100,  100.0], 1.7266862628167695785e-22, 0],
      [:bessel_I0_e, [0.1], 1.0025015629340956014, 0],
      [:bessel_I0_e, [2.0], 2.2795853023360672674, 0],
      [:bessel_I0_e, [100.0], 1.0737517071310738235e+42, 2],
      [:bessel_I1_e, [0.1], 0.05006252604709269211,      0],
      [:bessel_I1_e, [2.0], 1.59063685463732906340,      0],
      [:bessel_I1_e, [100.0], 1.0683693903381624812e+42, 2],
      [:bessel_In_e, [   4,    0.1], 2.6054690212996573677e-07, 0],
      [:bessel_In_e, [   5,    2.0], 0.009825679323131702321,   0],
      [:bessel_In_e, [ 100,  100.0], 4.641534941616199114e+21,  2],
      [:bessel_K0_scaled_e, [0.1], 2.6823261022628943831, 0],
      [:bessel_K0_scaled_e, [2.0], 0.8415682150707714179, 0],
      [:bessel_K0_scaled_e, [100.0], 0.1251756216591265789, 0],
      [:bessel_K1_scaled_e, [0.1], 10.890182683049696574, 0],
      [:bessel_K1_scaled_e, [2.0], 1.0334768470686885732, 0],
      [:bessel_K1_scaled_e, [100.0], 0.1257999504795785293, 0],
      [:bessel_Kn_scaled_e, [   4,    0.1], 530040.2483725626207, 1],
      [:bessel_Kn_scaled_e, [   5,    2.0], 69.68655087607675118, 0],
      [:bessel_Kn_scaled_e, [ 100,  100.0], 2.0475736731166756813e+19, 1],
      [:bessel_K0_e, [0.1], 2.4270690247020166125, 0],
      [:bessel_K0_e, [2.0], 0.11389387274953343565, 0],
      [:bessel_K0_e, [100.0], 4.656628229175902019e-45, 2],
      [:bessel_K1_e, [0.1], 9.853844780870606135,       0],
      [:bessel_K1_e, [2.0], 0.13986588181652242728,     0],
      [:bessel_K1_e, [100.0], 4.679853735636909287e-45, 2],
      [:bessel_Kn_e, [   4,    0.1], 479600.2497925682849,     1],
      [:bessel_Kn_e, [   5,    2.0], 9.431049100596467443,     0],
      [:bessel_Kn_e, [ 100,  100.0], 7.617129630494085416e-25, 2],
      [:bessel_j0_e, [-10.0], -0.05440211108893698134, 0],
      [:bessel_j0_e, [0.001], 0.9999998333333416667, 0],
      [:bessel_j0_e, [  1.0], 0.84147098480789650670, 0],
      [:bessel_j0_e, [ 10.0], -0.05440211108893698134, 0],
      [:bessel_j0_e, [100.0], -0.005063656411097587937, 1],
      [:bessel_j0_e, [1048576.0], 3.1518281938718287624e-07, 2],
      [:bessel_j1_e, [-10.0], -0.07846694179875154709, 0],
      [:bessel_j1_e, [0.01], 0.003333300000119047399, 0],
      [:bessel_j1_e, [  1.0], 0.30116867893975678925, 0],
      [:bessel_j1_e, [ 10.0], 0.07846694179875154709, 0],
      [:bessel_j1_e, [100.0], -0.008673825286987815220, 0],
      [:bessel_j1_e, [1048576.0], -9.000855242905546158e-07, 0],
      [:bessel_j2_e, [-10.0], 0.07794219362856244547, 0],
      [:bessel_j2_e, [0.01], 6.666619047751322551e-06, 0],
      [:bessel_j2_e, [  1.0], 0.06203505201137386110, 0],
      [:bessel_j2_e, [ 10.0], 0.07794219362856244547, 0],
      [:bessel_j2_e, [100.0], 0.004803441652487953480, 1],
      [:bessel_j2_e, [1048576.0], -3.1518539455252413111e-07, 2],
      [:bessel_jl_e, [0, 0.0], 1.0, 0],
      [:bessel_jl_e, [1,       10.0],   0.07846694179875154709000, 0],
      [:bessel_jl_e, [5,        1.0],   0.00009256115861125816357, 0],
      [:bessel_jl_e, [10,      10.0],   0.06460515449256426427,    0],
      [:bessel_jl_e, [100,    100.0],   0.010880477011438336539,   1],
      [:bessel_jl_e, [2000, 1048576.0], 7.449384239168568534e-07,  TEST_SQRT_TOL0],
      [:bessel_jl_e, [2, 900.0],   -0.0011089115568832940086,  4],
      [:bessel_jl_e, [2, 15000.0], -0.00005955592033075750554, 4],
      [:bessel_y0_e, [0.001], -999.99950000004166670, 0],
      [:bessel_y0_e, [  1.0], -0.5403023058681397174, 0],
      [:bessel_y0_e, [ 10.0], 0.08390715290764524523, 0],
      [:bessel_y0_e, [100.0], -0.008623188722876839341, 0],
      [:bessel_y0_e, [65536.0], 0.000011014324202158573930, 0],
      [:bessel_y0_e, [4294967296.0], 2.0649445131370357007e-10, TEST_SQRT_TOL0],
      [:bessel_y1_e, [ 0.01], -10000.499987500069444, 0],
      [:bessel_y1_e, [  1.0], -1.3817732906760362241, 0],
      [:bessel_y1_e, [ 10.0], 0.06279282637970150586, 0],
      [:bessel_y1_e, [100.0], 0.004977424523868819543, 0],
      [:bessel_y1_e, [4294967296.0], 1.0756463271573404688e-10, TEST_SQRT_TOL0],
      [:bessel_y2_e, [ 0.01], -3.0000500012499791668e+06, 0],
      [:bessel_y2_e, [  1.0], -3.605017566159968955, 0],
      [:bessel_y2_e, [ 10.0], -0.06506930499373479347, 0],
      [:bessel_y2_e, [100.0], 0.008772511458592903927, 0],
      [:bessel_y2_e, [4294967296.0], -2.0649445123857054207e-10, TEST_SQRT_TOL0],
      [:bessel_yl_e, [0,        0.01], -99.995000041666528,    0],
      [:bessel_yl_e, [0,        1.0],  -0.54030230586813972,   0],
      [:bessel_yl_e, [1,       10.0],   0.062792826379701506,   0],
      [:bessel_yl_e, [5,        1.0],  -999.44034339223641,     0],
      [:bessel_yl_e, [10,       0.01], -6.5473079797378378e+30, 0],
      [:bessel_yl_e, [10,      10.0],  -0.172453672088057849,    0],
      [:bessel_yl_e, [100,      1.0],  -6.6830794632586775e+186, 1],
      [:bessel_yl_e, [100,    100.0],  -0.0229838504915622811,   1],
      [:bessel_yl_e, [2000, 1048576.0], 5.9545201447146155e-07,  TEST_SQRT_TOL0],
      [:bessel_i0_scaled_e, [0.1], 0.9063462346100907067, 0],
      [:bessel_i0_scaled_e, [2.0], 0.24542109027781645493, 0],
      [:bessel_i0_scaled_e, [100.0], 0.005000000000000000000, 0],
      [:bessel_i1_scaled_e, [0.1], 0.030191419289002226846, 0],
      [:bessel_i1_scaled_e, [2.0], 0.131868364583275317610, 0],
      [:bessel_i1_scaled_e, [100.0], 0.004950000000000000000, 0],
      [:bessel_i2_scaled_e, [0.1], 0.0006036559400239012567, 0],
      [:bessel_i2_scaled_e, [2.0], 0.0476185434029034785100, 0],
      [:bessel_i2_scaled_e, [100.0], 0.0048515000000000000000, 0],
      [:bessel_il_scaled_e, [   4, 0.001], 1.0571434341190365013e-15, 0],
      [:bessel_il_scaled_e, [   4,   0.1], 9.579352242057134927e-08,  1],
      [:bessel_il_scaled_e, [   5,   2.0], 0.0004851564602127540059,  0],
      [:bessel_il_scaled_e, [   5, 100.0], 0.004300446777500000000,   1],
      [:bessel_il_scaled_e, [ 100, 100.0], 1.3898161964299132789e-23, 0],
      [:bessel_k0_scaled_e, [0.1], 15.707963267948966192, 0],
      [:bessel_k0_scaled_e, [2.0], 0.7853981633974483096, 0],
      [:bessel_k0_scaled_e, [100.0], 0.015707963267948966192, 0],
      [:bessel_k1_scaled_e, [0.1], 172.78759594743862812, 0],
      [:bessel_k1_scaled_e, [2.0], 1.1780972450961724644, 0],
      [:bessel_k1_scaled_e, [100.0], 0.015865042900628455854, 0],
      [:bessel_k2_scaled_e, [0.1], 5199.335841691107810, 0],
      [:bessel_k2_scaled_e, [2.0], 2.5525440310417070063, 0],
      [:bessel_k2_scaled_e, [100.0], 0.016183914554967819868, 0],
      [:bessel_kl_scaled_e, [   4, 1.0 / 256.0], 1.8205599816961954439e+14, 0],
      [:bessel_kl_scaled_e, [   4, 1.0 / 8.0],   6.1173217814406597530e+06, 0],
      [:bessel_kl_scaled_e, [   5,   2.0],     138.10735829492005119,     0],
      [:bessel_kl_scaled_e, [ 100, 100.0],     3.985930768060258219e+18,  1],
      [:bessel_Jnu_e, [0.0001, 1.0],         0.7652115411876708497,  2],
      [:bessel_Jnu_e, [0.0001, 10.0],       -0.2459270166445205,     2],
      [:bessel_Jnu_e, [0.0009765625, 10.0], -0.2458500798634692,     2],
      [:bessel_Jnu_e, [0.75, 1.0],           0.5586524932048917478,  2],
      [:bessel_Jnu_e, [0.75, 10.0],         -0.04968928974751508135, 2],
      [:bessel_Jnu_e, [ 1.0, 0.001], 0.0004999999375000026,     0],
      [:bessel_Jnu_e, [ 1.0,   1.0], 0.4400505857449335160,     0],
      [:bessel_Jnu_e, [ 1.75,  1.0], 0.168593922545763170103,     1],
      [:bessel_Jnu_e, [30.0,   1.0], 3.482869794251482902e-42,  0],
      [:bessel_Jnu_e, [30.0, 100.0], 0.08146012958117222297,    1],
      [:bessel_Jnu_e, [10.0,   1.0], 2.6306151236874532070e-10, 0],
      [:bessel_Jnu_e, [10.0, 100.0], -0.05473217693547201474,   2],
      [:bessel_Jnu_e, [10.2, 100.0], -0.03548919161046526864,   2],
      [:bessel_Jnu_e, [2.0, 900.0],   -0.019974345269680646400,  4],
      [:bessel_Jnu_e, [2.0, 15000.0], -0.0020455820181216382666, 4],
      [:bessel_Ynu_e, [0.0001, 1.0],  0.08813676933044478439,    2],
      [:bessel_Ynu_e, [0.0001,10.0],  0.05570979797521875261,    2],
      [:bessel_Ynu_e, [ 0.75,  1.0], -0.6218694174429746383,     0],
      [:bessel_Ynu_e, [ 0.75, 10.0],  0.24757063446760384953,    0],
      [:bessel_Ynu_e, [ 1.0, 0.001], -636.6221672311394281,      0],
      [:bessel_Ynu_e, [ 1.0,   1.0], -0.7812128213002887165,     0],
      [:bessel_Ynu_e, [30.0,   1.0], -3.0481287832256432162e+39, 0],
      [:bessel_Ynu_e, [30.0, 100.0],  0.006138839212010033452,   2],
      [:bessel_Ynu_e, [10.0,   1.0], -1.2161801427868918929e+08, 0],
      [:bessel_Ynu_e, [10.0, 100.0],  0.05833157423641492875,    2],
      [:bessel_Ynu_e, [10.2, 100.0],  0.07169383985546287091,    2],
      [:bessel_Inu_scaled_e, [0.0001,10.0], 0.12783333709581669672,    0],
      [:bessel_Inu_scaled_e, [ 1.0, 0.001], 0.0004995003123542213370,  0],
      [:bessel_Inu_scaled_e, [ 1.0,   1.0], 0.20791041534970844887,    0],
      [:bessel_Inu_scaled_e, [30.0,   1.0], 1.3021094983785914437e-42, 0],
      [:bessel_Inu_scaled_e, [30.0, 100.0], 0.0004486987756920986146,  3],
      [:bessel_Inu_scaled_e, [10.0,   1.0], 1.0127529864692066036e-10, 0],
      [:bessel_Inu_scaled_e, [10.0, 100.0], 0.024176682718258828365,   3],
      [:bessel_Inu_scaled_e, [10.2, 100.0], 0.023691628843913810043,   3],
      [:bessel_Inu_e, [0.0001,10.0], 2815.7166269770030352,     0],
      [:bessel_Inu_e, [ 1.0, 0.001], 0.0005000000625000026042,  0],
      [:bessel_Inu_e, [ 1.0,   1.0], 0.5651591039924850272,     0],
      [:bessel_Inu_e, [30.0,   1.0], 3.539500588106447747e-42,  0],
      [:bessel_Inu_e, [30.0, 100.0], 1.2061548704498434006e+40, 2],
      [:bessel_Inu_e, [10.0,   1.0], 2.7529480398368736252e-10, 0],
      [:bessel_Inu_e, [10.0, 100.0], 6.498975524720147799e+41,  2],
      [:bessel_Inu_e, [10.2, 100.0], 6.368587361287030443e+41,  2],
      [:bessel_Knu_scaled_e, [0.0001,10.0], 0.3916319346235421817, 0],
      [:bessel_Knu_scaled_e, [ 1.0, 0.001], 1000.9967345590684524, 0],
      [:bessel_Knu_scaled_e, [ 1.0,   1.0], 1.6361534862632582465, 0],
      [:bessel_Knu_scaled_e, [30.0,   1.0], 1.2792629867539753925e+40, 0],
      [:bessel_Knu_scaled_e, [30.0, 100.0], 10.673443449954850040, 0],
      [:bessel_Knu_scaled_e, [10.0,   1.0], 4.912296520990198599e+08, 0],
      [:bessel_Knu_scaled_e, [10.0, 100.0], 0.20578687173955779807, 0],
      [:bessel_Knu_scaled_e, [10.0, 1000.0], 0.04165905142800565788, 0],
      [:bessel_Knu_scaled_e, [10.0, 1.0e+8], 0.00012533147624060789938, 0],
      [:bessel_Knu_scaled_e, [10.2, 100.0], 0.20995808355244385075, 0],
      [:bessel_Knu_e, [0.0001,0.001], 7.023689431812884141,      0],
      [:bessel_Knu_e, [0.0001,10.0], 0.000017780062324654874306, 0],
      [:bessel_Knu_e, [ 1.0, 0.001], 999.9962381560855743,      0],
      [:bessel_Knu_e, [ 1.0,   1.0], 0.6019072301972345747,     0],
      [:bessel_Knu_e, [10.0, 0.001], 1.8579455483904008064e+38, 0],
      [:bessel_Knu_e, [10.0,   1.0], 1.8071328990102945469e+08, 0],
      [:bessel_Knu_e, [10.0, 100.0], 7.655427977388100611e-45,  2],
      [:bessel_Knu_e, [10.2, 100.0], 7.810600225948217841e-45,  2],
      [:bessel_Knu_e, [30.0,   1.0], 4.706145526783626883e+39,  1],
      [:bessel_Knu_e, [30.0, 100.0], 3.970602055959398739e-43,  2],
      [:bessel_lnKnu_e, [0.0001,1.0e-100], 5.439794449319847, 0],
      [:bessel_lnKnu_e, [0.0001,0.0001], 2.232835507214331, 0],
      [:bessel_lnKnu_e, [0.0001,10.0], -10.93743282256098, 0],
      [:bessel_lnKnu_e, [ 1.0, 1.0e-100], 230.2585092994045, 0],
      [:bessel_lnKnu_e, [ 1.0, 1.0e-10], 23.025850929940456840, 0],
      [:bessel_lnKnu_e, [ 1.0, 0.001], 6.907751517131146, 0],
      [:bessel_lnKnu_e, [ 1.0,   1.0], -0.5076519482107523309, 0],
      [:bessel_lnKnu_e, [30.0, 1.0e-100], 6999.113586185543475, 0],
      [:bessel_lnKnu_e, [30.0,   1.0], 91.34968784026325464, 0],
      [:bessel_lnKnu_e, [30.0, 100.0], -97.63224126416760932, 0],
      [:bessel_lnKnu_e, [100.0, 1.0e-100], 23453.606706185466825, 0],
      [:bessel_lnKnu_e, [100.0, 1.0], 427.7532510250188083, 0],
      [:bessel_lnKnu_e, [100.0, 100.0], -55.53422771502921431, 0],
      [:bessel_lnKnu_e, [1000.0, 1.0e-100], 236856.183755993135, 0],
      [:bessel_lnKnu_e, [10000.0, 1.0e-100], 2.39161558914890695e+06, 0],
      [:bessel_zero_J0_e, [ 1],  2.404825557695771, 1],
      [:bessel_zero_J0_e, [ 2],  5.520078110286304, 1],
      [:bessel_zero_J0_e, [20], 62.048469190227081, 1],
      [:bessel_zero_J0_e, [25], 77.756025630388058, 1],
      [:bessel_zero_J0_e, [100], 313.37426607752784, 1],
      [:bessel_zero_J1_e, [ 1], 3.831705970207512, 2],
      [:bessel_zero_J1_e, [ 2], 7.015586669815619, 2],
      [:bessel_zero_J1_e, [20], 63.61135669848124, 2],
      [:bessel_zero_J1_e, [25], 79.32048717547630, 2],
      [:bessel_zero_J1_e, [100], 314.9434728377672, 2],
      [:bessel_zero_Jnu_e, [0.0,  1],  2.404825557695771, 1],
      [:bessel_zero_Jnu_e, [0.0,  2],  5.520078110286304, 1],
      [:bessel_zero_Jnu_e, [0.0, 20], 62.048469190227081, 1],
      [:bessel_zero_Jnu_e, [0.0, 25], 77.756025630388058, 1],
      [:bessel_zero_Jnu_e, [0.0, 100], 313.37426607752784, 1],
      [:bessel_zero_Jnu_e, [ 1.5, 1],  4.4934094579090641, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 1],  8.7714838159599540, 1],
      [:bessel_zero_Jnu_e, [ 1.5, 2],  7.7252518369377072, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 2],  12.338604197466944, 1],
      [:bessel_zero_Jnu_e, [ 1.5, 3],  10.904121659428900, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 3],  15.700174079711671, 1],
      [:bessel_zero_Jnu_e, [ 1.5, 4],  14.066193912831473, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 4],  18.980133875179921, 1],
      [:bessel_zero_Jnu_e, [ 1.5, 5],  17.220755271930768, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 5],  22.217799896561268, TEST_SQRT_TOL0],
      [:bessel_zero_Jnu_e, [ 8.0, 5],  26.266814641176644, TEST_SQRT_TOL0],
      [:bessel_zero_Jnu_e, [20.0, 5],  41.413065513892636, TEST_SQRT_TOL0],
      [:bessel_zero_Jnu_e, [ 1.5, 6],  20.371302959287563, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 6],  25.430341154222704, 1],
      [:bessel_zero_Jnu_e, [ 8.0, 6],  29.545659670998550, 1],
      [:bessel_zero_Jnu_e, [ 1.5, 7],  23.519452498689007, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 7],  28.626618307291138, 1],
      [:bessel_zero_Jnu_e, [ 8.0, 7],  32.795800037341462, 1],
      [:bessel_zero_Jnu_e, [ 1.5, 8],  26.666054258812674, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 8],  31.811716724047763, 1],
      [:bessel_zero_Jnu_e, [10.0, 8],  38.761807017881651, 1],
      [:bessel_zero_Jnu_e, [ 1.5, 9],  29.811598790892959, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 9],  34.988781294559295, 1],
      [:bessel_zero_Jnu_e, [10.0, 9],  42.004190236671805, 1],
      [:bessel_zero_Jnu_e, [ 1.5, 10],  32.956389039822477, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 10],  38.159868561967132, 1],
      [:bessel_zero_Jnu_e, [15.0, 10],  52.017241278881633, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 11], 41.326383254047406, 1],
      [:bessel_zero_Jnu_e, [15.0, 11], 55.289204146560061, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 12], 44.4893191232197314, 1],
      [:bessel_zero_Jnu_e, [15.0, 12], 58.5458289043850856, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 13], 47.6493998066970948, 1],
      [:bessel_zero_Jnu_e, [15.0, 13], 61.7897598959450550, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 14], 50.8071652030063595, 1],
      [:bessel_zero_Jnu_e, [15.0, 14], 65.0230502510422545, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 15], 53.9630265583781707, 1],
      [:bessel_zero_Jnu_e, [15.0, 15], 68.2473219964207837, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 16], 57.1173027815042647, 1],
      [:bessel_zero_Jnu_e, [15.0, 16], 71.4638758850226630, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 17], 60.2702450729428077, 1],
      [:bessel_zero_Jnu_e, [15.0, 17], 74.6737687121404241, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 18], 63.4220540458757799, 1],
      [:bessel_zero_Jnu_e, [15.0, 18], 77.8778689734863729, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 19], 66.5728918871182703, 1],
      [:bessel_zero_Jnu_e, [15.0, 19], 81.0768977206328326, 1],
      [:bessel_zero_Jnu_e, [ 5.0, 20], 69.722891161716742,  1],
      [:bessel_zero_Jnu_e, [15.0, 20], 84.271459069716442,  1],
      [:bessel_zero_Jnu_e, [ 23.0, 11], 65.843393469524653, 6],
      [:bessel_zero_Jnu_e, [ 30.0, 11], 74.797306585175426, 6],
      [:bessel_zero_Jnu_e, [ 32.0, 15], 90.913637691861741, 6],
      [:bessel_zero_Jnu_e, [ 50.0, 15], 113.69747988073942, 6],
      [:bessel_zero_Jnu_e, [  5.0, 22], 76.020793430591605, 2],
      [:bessel_zero_Jnu_e, [ 10.0, 22], 83.439189796105756, 3],
      [:bessel_zero_Jnu_e, [ 12.0, 22], 86.345496520534055, 6],
      [:bessel_zero_Jnu_e, [100.0, 22], 199.82150220122519, 4],
      [:bessel_zero_Jnu_e, [500.0, 22], 649.34132440891735, 2]
    ],
    :coulomb => [
      [:hydrogenicR_1_e, [3.0, 2.0],  0.025759948256148471036,  0],
      [:hydrogenicR_1_e, [3.0, 10.0], 9.724727052062819704e-13, 1],
      [:hydrogenicR_e, [4, 0, 3.0, 2.0], -0.03623182256981820062,  2],
      [:hydrogenicR_e, [4, 1, 3.0, 2.0], -0.028065049083129581005, 2],
      [:hydrogenicR_e, [4, 2, 3.0, 2.0],  0.14583027278668431009,  0],
      [:hydrogenicR_e, [100,  0, 3.0, 2.0], -0.00007938950980052281367, 3],
      [:hydrogenicR_e, [100, 10, 3.0, 2.0],  7.112823375353605977e-12,  2],
      [:hydrogenicR_e, [100, 90, 3.0, 2.0],  5.845231751418131548e-245, 2]
    ],
    :dilog => [
      [:dilog_e, [-3.0],   -1.9393754207667089531,     0],
      [:dilog_e, [-0.5],   -0.4484142069236462024,     0],
      [:dilog_e, [-0.001], -0.0009997501110486510834,  0],
      [:dilog_e, [0.1],     0.1026177910993911,        0],
      [:dilog_e, [0.7],     0.8893776242860387386,     0],
      [:dilog_e, [1.0],     1.6449340668482260,        0],
      [:dilog_e, [1.5],     2.3743952702724802007,     0],
      [:dilog_e, [2.0],     2.4674011002723397,        0],
      [:dilog_e, [ 5.0],    1.7837191612666306277,     0],
      [:dilog_e, [ 11.0],   0.3218540439999117111,     1],
      [:dilog_e, [12.59],   0.0010060918167266208634,  3],
      [:dilog_e, [12.595],  0.00003314826006436236810, 5],
      [:dilog_e, [13.0],   -0.07806971248458575855,    2],
      [:dilog_e, [20.0],   -1.2479770861745251168,     0],
      [:dilog_e, [150.0],  -9.270042702348657270,      0],
      [:dilog_e, [1100.0], -21.232504073931749553,     0]
    ],
    :gamma => [
      [:lngamma_e, [-0.1], 2.368961332728788655, 0],
      [:lngamma_e, [-1.0 / 256.0], 5.547444766967471595, 0],
      [:lngamma_e, [1.0e-08], 18.420680738180208905, 0],
      [:lngamma_e, [0.1], 2.252712651734205, 0],
      [:lngamma_e, [1.0 + 1.0 / 256.0], -0.0022422226599611501448, 0],
      [:lngamma_e, [2.0 + 1.0 / 256.0], 0.0016564177556961728692, 0],
      [:lngamma_e, [100.0], 359.1342053695753, 0],
      [:lngamma_e, [-1.0-1.0 / 65536.0], 11.090348438090047844, 0],
      [:lngamma_e, [-1.0-1.0 / 268435456.0], 19.408121054103474300, 0],
      [:lngamma_e, [-100.5], -364.9009683094273518, 0],
      [:lngamma_e, [-100-1.0 / 65536.0], -352.6490910117097874, 0],
      [:gamma_e, [1.0 + 1.0 / 4096.0], 0.9998591371459403421, 0],
      [:gamma_e, [1.0 + 1.0 / 32.0], 0.9829010992836269148, 0],
      [:gamma_e, [2.0 + 1.0 / 256.0], 1.0016577903733583299, 0],
      [:gamma_e, [9.0], 40320.0, 0],
      [:gamma_e, [10.0], 362880.0, 0],
      [:gamma_e, [100.0], 9.332621544394415268e+155, 2],
      [:gamma_e, [170.0], 4.269068009004705275e+304, 2],
      [:gamma_e, [171.0], 7.257415615307998967e+306, 2],
      [:gamma_e, [-10.5], -2.640121820547716316e-07, 0],
      [:gamma_e, [-1.0 + 1.0 / 65536.0], -65536.42280587818970, 0],
      [:gammastar_e, [1.0e-08], 3989.423555759890865, 1],
      [:gammastar_e, [1.0e-05], 126.17168469882690233, 0],
      [:gammastar_e, [0.001], 12.708492464364073506, 0],
      [:gammastar_e, [1.5], 1.0563442442685598666, 0],
      [:gammastar_e, [3.0], 1.0280645179187893045, 0],
      [:gammastar_e, [9.0], 1.0092984264218189715, 0],
      [:gammastar_e, [11.0], 1.0076024283104962850, 0],
      [:gammastar_e, [100.0], 1.0008336778720121418, 0],
      [:gammastar_e, [1.0e+05], 1.0000008333336805529, 0],
      [:gammastar_e, [1.0e+20], 1.0, 0],
      [:gammainv_e, [1.0], 1.0, 0],
      [:gammainv_e, [2.0], 1.0, 0],
      [:gammainv_e, [3.0], 0.5, 0],
      [:gammainv_e, [4.0], 1.0 / 6.0, 0],
      [:gammainv_e, [10.0], 1.0 / 362880.0, 0],
      [:gammainv_e, [100.0], 1.0715102881254669232e-156, 2],
      [:gammainv_e, [0.0], 0.0, 0],
      [:gammainv_e, [-1.0], 0.0, 0],
      [:gammainv_e, [-2.0], 0.0, 0],
      [:gammainv_e, [-3.0], 0.0, 0],
      [:gammainv_e, [-4.0], 0.0, 0],
      [:gammainv_e, [-10.5], -1.0 / 2.640121820547716316e-07, 2],
      [:gammainv_e, [-11.25], 1.0 / 6.027393816261931672e-08, 1],
      [:gammainv_e, [-1.0 + 1.0 / 65536.0], -1.0 / 65536.42280587818970, 1],
      [:taylorcoeff_e, [10,   1.0 / 1048576.0], 1.7148961854776073928e-67, 0],
      [:taylorcoeff_e, [10,   1.0 / 1024.0], 2.1738891788497900281e-37, 0],
      [:taylorcoeff_e, [10,   1.0], 2.7557319223985890653e-07, 0],
      [:taylorcoeff_e, [10,   5.0], 2.6911444554673721340, 0],
      [:taylorcoeff_e, [10,   500.0], 2.6911444554673721340e+20, 0],
      [:taylorcoeff_e, [100,  100.0], 1.0715102881254669232e+42, 1],
      [:taylorcoeff_e, [1000, 200.0], 2.6628790558154746898e-267, 1],
      [:taylorcoeff_e, [1000, 500.0], 2.3193170139740855074e+131, 1],
      [:fact_e, [0], 1.0, 0],
      [:fact_e, [1], 1.0, 0],
      [:fact_e, [7], 5040.0, 0],
      [:fact_e, [33], 8.683317618811886496e+36, 0],
      [:doublefact_e, [0], 1.0, 0],
      [:doublefact_e, [1], 1.0, 0],
      [:doublefact_e, [7], 105.0, 0],
      [:doublefact_e, [33], 6.332659870762850625e+18, 0],
      [:lnfact_e, [0], 0.0, 0],
      [:lnfact_e, [1], 0.0, 0],
      [:lnfact_e, [7], 8.525161361065414300, 0],
      [:lnfact_e, [33], 85.05446701758151741, 0],
      [:lndoublefact_e, [0], 0.0, 0],
      [:lndoublefact_e, [7], 4.653960350157523371, 0],
      [:lndoublefact_e, [33], 43.292252022541719660, 0],
      [:lndoublefact_e, [34], 45.288575519655959140, 0],
      [:lndoublefact_e, [1034], 3075.6383796271197707, 0],
      [:lndoublefact_e, [1035], 3078.8839081731809169, 0],
      [:lnchoose_e, [7,3], 3.555348061489413680, 0],
      [:lnchoose_e, [5,2], 2.302585092994045684, 0],
      [:choose_e, [7,3], 35.0, 0],
      [:choose_e, [7,4], 35.0, 0],
      [:choose_e, [5,2], 10.0, 0],
      [:choose_e, [5,3], 10.0, 0],
      [:choose_e, [500,495], 255244687600.0, 0],
      [:choose_e, [500,5], 255244687600.0, 0],
      [:choose_e, [500,200], 5.054949849935532221e+144, 5],
      [:choose_e, [500,300], 5.054949849935532221e+144, 5],
      [:lnpoch_e, [5, 1.0 / 65536.0], 0.000022981557571259389129, 0],
      [:lnpoch_e, [5, 1.0 / 256.0],   0.005884960217985189004,    2],
      [:lnpoch_e, [7,3], 6.222576268071368616, 0],
      [:lnpoch_e, [5,2], 3.401197381662155375, 0],
      [:poch_e, [7,3], 504.0, 0],
      [:poch_e, [5,2], 30.0, 1],
      [:poch_e, [5,1.0 / 256.0], 1.0059023106151364982, 0],
      [:pochrel_e, [7,3], 503.0 / 3.0, 0],
      [:pochrel_e, [5,2], 29.0 / 2.0, 1],
      [:pochrel_e, [5,0.01], 1.5186393661368275330, 2],
      [:pochrel_e, [-5.5,0.01], 1.8584945633829063516, 1],
      [:pochrel_e, [-5.5,-1.0 / 8.0], 1.0883319303552135488, 1],
      [:pochrel_e, [-5.5,-1.0 / 256.0], 1.7678268037726177453, 1],
      [:pochrel_e, [-5.5,-11.0], 0.09090909090939652475, 0],
      [:gamma_inc_P_e, [0.001, 1.0], 0.9997803916424144436, 0],
      [:gamma_inc_P_e, [0.001, 10.0], 0.9999999958306921828, 0],
      [:gamma_inc_P_e, [1.0, 0.001], 0.0009995001666250083319, 0],
      [:gamma_inc_P_e, [1.0, 1.01], 0.6357810204284766802, 0],
      [:gamma_inc_P_e, [1.0, 10.0], 0.9999546000702375151, 0],
      [:gamma_inc_P_e, [10.0, 10.01], 0.5433207586693410570, 0],
      [:gamma_inc_P_e, [10.0, 20.0], 0.9950045876916924128, 0],
      [:gamma_inc_P_e, [1000.0, 1000.1], 0.5054666401440661753, 2],
      [:gamma_inc_P_e, [1000.0, 2000.0], 1.0, 0],
      [:gamma_inc_P_e, [34.0, 32.0], 0.3849626436463866776322932129, 2],
      [:gamma_inc_P_e, [37.0, 3.499999999999999289e+01], 0.3898035054195570860969333039, 2],
      [:gamma_inc_P_e, [10, 1e-16], 2.755731922398588814734648067e-167, 2],
      [:gamma_inc_Q_e, [0.001, 0.001], 0.006312353291139709793, 0],
      [:gamma_inc_Q_e, [0.001, 1.0], 0.00021960835758555639171, 1],
      [:gamma_inc_Q_e, [0.001, 2.0], 0.00004897691783098147880, 2],
      [:gamma_inc_Q_e, [0.001, 5.0], 1.1509813397308608541e-06, 1],
      [:gamma_inc_Q_e, [1.0, 0.001], 0.9990004998333749917, 0],
      [:gamma_inc_Q_e, [1.0, 1.01], 0.3642189795715233198, 0],
      [:gamma_inc_Q_e, [1.0, 10.0], 0.00004539992976248485154, 0],
      [:gamma_inc_Q_e, [10.0, 10.01], 0.4566792413306589430, 0],
      [:gamma_inc_Q_e, [10.0, 100.0], 1.1253473960842733885e-31, 2],
      [:gamma_inc_Q_e, [1000.0, 1000.1], 0.4945333598559338247, 2],
      [:gamma_inc_Q_e, [1000.0, 2000.0], 6.847349459614753180e-136, 2],
      [:gamma_inc_Q_e, [100,  99.0], 0.5266956696005394, 2],
      [:gamma_inc_Q_e, [200, 199.0], 0.5188414119121281, 2],
      [:gamma_inc_P_e, [100,  99.0], 0.4733043303994607, 2],
      [:gamma_inc_P_e, [200, 199.0], 0.4811585880878718, 2],
      [:gamma_inc_e, [-1.0 / 1048576.0, 1.0 / 1048576.0], 13.285819596290624271, 0],
      [:gamma_inc_e, [-0.001, 1.0 / 1048576.0], 13.381275128625328858, 0],
      [:gamma_inc_e, [-1.0,   1.0 / 1048576.0], 1.0485617142715768655e+06, 0],
      [:gamma_inc_e, [-0.00001,0.001], 6.3317681434563592142, 0],
      [:gamma_inc_e, [-0.0001,0.001], 6.3338276439767189385, 0],
      [:gamma_inc_e, [-0.001, 0.001], 6.3544709102510843793, 0],
      [:gamma_inc_e, [-0.5,   0.001], 59.763880515942196981, 0],
      [:gamma_inc_e, [-1.0,   0.001], 992.66896046923884234, 0],
      [:gamma_inc_e, [-3.5,   0.001], 9.0224404490639003706e+09, 1],
      [:gamma_inc_e, [-10.5,  0.001], 3.0083661558184815656e+30, 2],
      [:gamma_inc_e, [-0.001, 0.1], 1.8249109609418620068, 0],
      [:gamma_inc_e, [-0.5,   0.1], 3.4017693366916154163, 0],
      [:gamma_inc_e, [-10.0,  0.1], 8.9490757483586989181e+08, 1],
      [:gamma_inc_e, [-10.5,  0.1], 2.6967403834226421766e+09, 1],
      [:gamma_inc_e, [-0.001, 1.0], 0.21928612679072766340, 1],
      [:gamma_inc_e, [-0.5,   1.0], 0.17814771178156069019, 1],
      [:gamma_inc_e, [-1.0,   1.0], 0.14849550677592204792, 1],
      [:gamma_inc_e, [-2.5,   1.0], 0.096556648631275160264, 1],
      [:gamma_inc_e, [-1.0,   10.0], 3.8302404656316087616e-07, 1],
      [:gamma_inc_e, [-0.001, 10.0], 4.1470562324807320961e-06, 1],
      [:gamma_inc_e, [-0.5,   10.0], 1.2609042613241570681e-06, 0],
      [:gamma_inc_e, [-1.0,   10.0], 3.8302404656316087616e-07, 1],
      [:gamma_inc_e, [-10.5,  10.0], 6.8404927328441566785e-17, 1],
      [:gamma_inc_e, [-100.0, 10.0], 4.1238327669858313997e-107, 2],
      [:gamma_inc_e, [-200.0, 10.0], 2.1614091830529343423e-207, 2],
      [:gamma_inc_e, [  0.0,     0.001], 6.3315393641361493320, 0],
      [:gamma_inc_e, [  0.001,   0.001], 6.3087159394864007261, 0],
      [:gamma_inc_e, [  1.0,     0.001], 0.99900049983337499167, 0],
      [:gamma_inc_e, [ 10.0,     0.001], 362880.0, 0],
      [:gamma_inc_e, [  0.0,     1.0], 0.21938393439552027368, 0],
      [:gamma_inc_e, [  0.001,   1.0], 0.21948181320730279613, 1],
      [:gamma_inc_e, [  1.0,     1.0], 0.36787944117144232160, 0],
      [:gamma_inc_e, [ 10.0,     1.0], 362879.95956592242045, 0],
      [:gamma_inc_e, [100.0,     1.0], 9.3326215443944152682e+155, 0],
      [:gamma_inc_e, [  0.0,   100.0], 3.6835977616820321802e-46, 2],
      [:gamma_inc_e, [  0.001, 100.0], 3.7006367674063550631e-46, 2],
      [:gamma_inc_e, [  1.0,   100.0], 3.7200759760208359630e-44, 2],
      [:gamma_inc_e, [ 10.0,   100.0], 4.0836606309106112723e-26, 2],
      [:gamma_inc_e, [100.0,   100.0], 4.5421981208626694294e+155, 1],
      [:lnbeta_e, [1.0e-8, 1.0e-8],  19.113827924512310617, 0],
      [:lnbeta_e, [1.0e-8, 0.01],  18.420681743788563403, 0],
      [:lnbeta_e, [1.0e-8, 1.0],  18.420680743952365472, 0],
      [:lnbeta_e, [1.0e-8, 10.0],  18.420680715662683009, 0],
      [:lnbeta_e, [1.0e-8, 1000.0],  18.420680669107656949, 0],
      [:lnbeta_e, [0.1, 0.1], 2.9813614810376273949, 1],
      [:lnbeta_e, [0.1, 1.0],  2.3025850929940456840, 1],
      [:lnbeta_e, [0.1, 100.0],  1.7926462324527931217, 0],
      [:lnbeta_e, [0.1, 1000],  1.5619821298353164928, 0],
      [:lnbeta_e, [1.0, 1.00025],  -0.0002499687552073570, 4],
      [:lnbeta_e, [1.0, 1.01],  -0.009950330853168082848, 3],
      [:lnbeta_e, [1.0, 1000.0],  -6.907755278982137052, 0],
      [:lnbeta_e, [100.0, 100.0],  -139.66525908670663927, 2],
      [:lnbeta_e, [100.0, 1000.0],  -336.4348576477366051, 0],
      [:lnbeta_e, [100.0, 1.0e+8],  -1482.9339185256447309, 0],
      [:beta_e, [1.0,   1.0], 1.0, 0],
      [:beta_e, [1.0, 1.001], 0.9990009990009990010, 0],
      [:beta_e, [1.0,   5.0], 0.2, 1],
      [:beta_e, [1.0,  100.0], 0.01, 1],
      [:beta_e, [10.0, 100.0], 2.3455339739604649879e-15, 2],
      [:beta_inc_e, [1.0, 1.0, 0.0], 0.0, 2],
      [:beta_inc_e, [1.0, 1.0, 1.0], 1.0, 2],
      [:beta_inc_e, [0.1, 0.1, 1.0], 1.0, 2],
      [:beta_inc_e, [ 1.0,  1.0, 0.5], 0.5, 2],
      [:beta_inc_e, [ 0.1,  1.0, 0.5], 0.9330329915368074160, 2],
      [:beta_inc_e, [10.0,  1.0, 0.5], 0.0009765625000000000000, 2],
      [:beta_inc_e, [50.0,  1.0, 0.5], 8.881784197001252323e-16, 2],
      [:beta_inc_e, [ 1.0,  0.1, 0.5], 0.06696700846319258402, 2],
      [:beta_inc_e, [ 1.0, 10.0, 0.5], 0.99902343750000000000, 2],
      [:beta_inc_e, [ 1.0, 50.0, 0.5], 0.99999999999999911180, 2],
      [:beta_inc_e, [ 1.0,  1.0, 0.1], 0.10, 2],
      [:beta_inc_e, [ 1.0,  2.0, 0.1], 0.19, 2],
      [:beta_inc_e, [ 1.0,  2.0, 0.9], 0.99, 2],
      [:beta_inc_e, [50.0, 60.0, 0.5], 0.8309072939016694143, 2],
      [:beta_inc_e, [90.0, 90.0, 0.5], 0.5, 2],
      [:beta_inc_e, [ 500.0,  500.0, 0.6], 0.9999999999157549630, 2],
      [:beta_inc_e, [5000.0, 5000.0, 0.4], 4.518543727260666383e-91, 5],
      [:beta_inc_e, [5000.0, 5000.0, 0.6], 1.0, 2],
      [:beta_inc_e, [5000.0, 2000.0, 0.6], 8.445388773903332659e-89, 5]
    ],
    :hyperg => [
      [:hyperg_0F1_e, [1, 0.5],     1.5660829297563505373, 0],
      [:hyperg_0F1_e, [5, 0.5],     1.1042674404828684574, 1],
      [:hyperg_0F1_e, [100, 30],    1.3492598639485110176, 2],
      [:hyperg_0F1_e, [-0.5, 3],   -39.29137997543434276,  1],
      [:hyperg_0F1_e, [-100.5, 50], 0.6087930289227538496, 3],
      [:hyperg_0F1_e, [1, -5.0],   -0.3268752818235339109, 0],
      [:hyperg_0F1_e, [-0.5, -5.0],-4.581634759005381184,  1],
      [:hyperg_1F1_int_e, [1, 1, 0.5], 1.6487212707001281468, 0],
      [:hyperg_1F1_int_e, [1, 2, 500.0], 2.8071844357056748215e+214, 2],
      [:hyperg_1F1_int_e, [1, 2, -500.0], 0.002, 0],
      [:hyperg_1F1_int_e, [8, 1, 0.5], 13.108875178030540372, 0],
      [:hyperg_1F1_int_e, [10, 1, 1.0],  131.63017574352619931, 0],
      [:hyperg_1F1_int_e, [10, 1, 10.0], 8.514625476546280796e+09, 0],
      [:hyperg_1F1_int_e, [10, 1, 100.0],  1.5671363646800353320e+56, 2],
      [:hyperg_1F1_int_e, [10, 20, 1.0],  1.6585618002669675465, 2],
      [:hyperg_1F1_int_e, [10, 20, 10.0],  265.26686430340188871, 2],
      [:hyperg_1F1_int_e, [10, 20, 100.0], 3.640477355063227129e+34, 2],
      [:hyperg_1F1_int_e, [10, 100, 1.0],  1.1056660194025527099, 0],
      [:hyperg_1F1_int_e, [10, 100, 10.0],  2.8491063634727594206, 0],
      [:hyperg_1F1_int_e, [10, 100, 40.0],  133.85880835831230986, 0],
      [:hyperg_1F1_int_e, [10, 100, 80.0],  310361.16228011433406, 0],
      [:hyperg_1F1_int_e, [10, 100, 100.0],  8.032171336754168282e+07, 2],
      [:hyperg_1F1_int_e, [10, 100, 500.0],  7.633961202528731426e+123, 2],
      [:hyperg_1F1_int_e, [100, 1, 1.0],  6.892842729046469965e+07, 1],
      [:hyperg_1F1_int_e, [100, 1, 10.0],  2.4175917112200409098e+28, 1],
      [:hyperg_1F1_int_e, [100, 1, 100.0],  1.9303216896309102993e+110, 2],
      [:hyperg_1F1_int_e, [100, 200, 1.0],  1.6497469106162459226, 2],
      [:hyperg_1F1_int_e, [100, 200, 10.0],  157.93286197349321981, 2],
      [:hyperg_1F1_int_e, [100, 200, 100.0],  2.1819577501255075240e+24, 2],
      [:hyperg_1F1_int_e, [100, 200, 400.0],  3.728975529926573300e+119, 2],
      [:hyperg_1F1_int_e, [100, 400, 10.0],  12.473087623658878813, 0],
      [:hyperg_1F1_int_e, [100, 400, 100.0],  9.071230376818550241e+11, 1],
      [:hyperg_1F1_int_e, [100, 400, 150.0],  7.160949515742170775e+18, 0],
      [:hyperg_1F1_int_e, [100, 400, 200.0],   2.7406690412731576823e+26, 2],
      [:hyperg_1F1_int_e, [100, 400, 300.0],  6.175110613473276193e+43, 2],
      [:hyperg_1F1_int_e, [100, 400, 400.0],  1.1807417662711371440e+64, 3],
      [:hyperg_1F1_int_e, [100, 400, 600.0],  2.4076076354888886030e+112, 3],
      [:hyperg_1F1_int_e, [10, 1, -1.0],      0.11394854824644542810,   0],
      [:hyperg_1F1_int_e, [10, 1, -10.0],     0.0006715506365396127863, 1],
      [:hyperg_1F1_int_e, [10, 1, -100.0],   -4.208138537480269868e-32, 2],
      [:hyperg_1F1_int_e, [10, 50, -1.0],     0.820006196079380,        0],
      [:hyperg_1F1_int_e, [10, 100, -10.0],   0.38378859043466243,      0],
      [:hyperg_1F1_int_e, [10, 100, -100.0],  0.0008460143401464189061, 0],
      [:hyperg_1F1_int_e, [10, 100, -500.0],  1.1090822141973655929e-08, 0],
      [:hyperg_1F1_int_e, [10, 100, -10000.0], 5.173783508088272292e-21, 2],
      [:hyperg_1F1_int_e, [50, 1, -90.0],    -1.6624258547648311554e-21, 2],
      [:hyperg_1F1_int_e, [50, 1, -100.0],    4.069661775122048204e-24, 2],
      [:hyperg_1F1_int_e, [50, 1, -110.0],    1.0072444993946236025e-25, 2],
      [:hyperg_1F1_int_e, [100, 10, -100.0], -2.7819353611733941962e-37, 2],
      [:hyperg_1F1_int_e, [100, 1, -90.0],  7.501705041159802854e-22, 2],
      [:hyperg_1F1_int_e, [100, 1, -100.0],  6.305128893152291187e-25, 3],
      [:hyperg_1F1_int_e, [100, 1, -110.0],  -7.007122115422439755e-26, 3],
      [:hyperg_1F1_int_e, [100, 10, -100.0],  -2.7819353611733941962e-37, 2],
      [:hyperg_1F1_int_e, [200, 50, -1.0],  0.016087060191732290813, 1],
      [:hyperg_1F1_int_e, [200, 50, -300.0],  -4.294975979706421471e-121, 2],
      [:hyperg_1F1_int_e, [200, 100, -1.0],  0.13397521083325179687, 0],
      [:hyperg_1F1_int_e, [200, 100, -10.0],  5.835134393749807387e-10, 1],
      [:hyperg_1F1_int_e, [200, 100, -100.0],  4.888460453078914804e-74, 2],
      [:hyperg_1F1_int_e, [200, 100, -500.0],  -1.4478509059582015053e-195, 2],
      [:hyperg_1F1_int_e, [-1, 1, 2.0],  -1.0, 0],
      [:hyperg_1F1_int_e, [-1, -2, 2.0],  2.0, 0],
      [:hyperg_1F1_int_e, [-2, -3, 2.0],  3.0, 0],
      [:hyperg_1F1_int_e, [-10, 1, 1.0],  0.4189459325396825397, 0],
      [:hyperg_1F1_int_e, [-10, 1, 10.0],  27.984126984126984127, 0],
      [:hyperg_1F1_int_e, [-10, 1, 100.0],  9.051283795429571429e+12, 0],
      [:hyperg_1F1_int_e, [-100, 20, 1.0],  0.0020203016320697069566, 0],
      [:hyperg_1F1_int_e, [-10, -20, 1.0],  1.6379141878548080173, 0],
      [:hyperg_1F1_int_e, [-10, -20, 10.0],  78.65202404521289970, 0],
      [:hyperg_1F1_int_e, [-10, -20, 100.0],  4.416169713262624315e+08, 0],
      [:hyperg_1F1_int_e, [-10, -100, 1.0],  1.1046713999681950919, 0],
      [:hyperg_1F1_int_e, [-10, -100, 10.0],  2.6035952191039006838, 0],
      [:hyperg_1F1_int_e, [-10, -100, 100.0],  1151.6852040836932392, 0],
      [:hyperg_1F1_int_e, [-100, -200, 1.0],  1.6476859702535324743, 0],
      [:hyperg_1F1_int_e, [-100, -200, 10.0],  139.38026829540687270, 0],
      [:hyperg_1F1_int_e, [-100, -200, 100.0],  1.1669433576237933752e+19, 1],
      [:hyperg_1F1_int_e, [-10, -20, -1.0],  0.6025549561148035735, 0],
      [:hyperg_1F1_int_e, [-10, -20, -10.0],  0.00357079636732993491, 1],
      [:hyperg_1F1_int_e, [-10, -20, -100.0],  1.64284868563391159e-35, 2],
      [:hyperg_1F1_int_e, [-10, -100, -1.0],  0.90442397250313899, 0],
      [:hyperg_1F1_int_e, [-10, -100, -10.0],  0.35061515251367215, 1],
      [:hyperg_1F1_int_e, [-10, -100, -100.0],  8.19512187960476424e-09, 2],
      [:hyperg_1F1_int_e, [-100, -200, -1.0],  0.6061497939628952629, 0],
      [:hyperg_1F1_int_e, [-100, -200, -10.0],  0.0063278543908877674, 1],
      [:hyperg_1F1_int_e, [-100, -200, -100.0],  4.34111795007336552e-25, 2],
      [:hyperg_1F1_e, [1, 1.5, 1], 2.0300784692787049755, 0],
      [:hyperg_1F1_e, [1, 1.5, 10],  6172.859561078406855, 0],
      [:hyperg_1F1_e, [1, 1.5, 100],  2.3822817898485692114e+42, 1],
      [:hyperg_1F1_e, [1, 1.5, 500],  5.562895351723513581e+215, 2],
      [:hyperg_1F1_e, [1.5, 2.5, 1], 1.8834451238277954398, 0],
      [:hyperg_1F1_e, [1.5, 2.5, 10],  3128.7352996840916381, 1],
      [:hyperg_1F1_e, [10, 1.1, 1],  110.17623733873889579, 1],
      [:hyperg_1F1_e, [10, 1.1, 10],  6.146657975268385438e+09, 1],
      [:hyperg_1F1_e, [10, 1.1, 100], 9.331833897230312331e+55, 2],
      [:hyperg_1F1_e, [10, 1.1, 500],  4.519403368795715843e+235, 2],
      [:hyperg_1F1_e, [10, 50.1, 2],  1.5001295507968071788, 0],
      [:hyperg_1F1_e, [10, 50.1, 10],  8.713385849265044908, 0],
      [:hyperg_1F1_e, [10, 50.1, 100],  5.909423932273380330e+18, 2],
      [:hyperg_1F1_e, [10, 50.1, 500],  9.740060618457198900e+165, 2],
      [:hyperg_1F1_e, [100, 1.1, 1],  5.183531067116809033e+07, 2],
      [:hyperg_1F1_e, [100, 1.1, 10],  1.6032649110096979462e+28, 2],
      [:hyperg_1F1_e, [100, 1.1, 100],  1.1045151213192280064e+110, 2],
      [:hyperg_1F1_e, [100, 50.1, 1],  7.222953133216603757, 1],
      [:hyperg_1F1_e, [100, 50.1, 10],  1.0998696410887171538e+08, 1],
      [:hyperg_1F1_e, [100, 50.1, 100],  7.235304862322283251e+63, 2],
      [:hyperg_1F1_e, [1, 1.5, -1], 0.5380795069127684191, 0],
      [:hyperg_1F1_e, [1, 1.5, -10],  0.05303758099290164485, 1],
      [:hyperg_1F1_e, [1, 1.5, -100], 0.005025384718759852803, 1],
      [:hyperg_1F1_e, [1, 1.5, -500], 0.0010010030151059555322, 1],
      [:hyperg_1F1_e, [1, 1.1, -500], 0.00020036137599690208265, 1],
      [:hyperg_1F1_e, [10, 1.1, -1],     0.07227645648935938168, 1],
      [:hyperg_1F1_e, [10, 1.1, -10],    0.0003192415409695588126, 1],
      [:hyperg_1F1_e, [10, 1.1, -500],  -3.400379216707701408e-23, 2],
      [:hyperg_1F1_e, [50, 1.1, -100],   4.632883869540640460e-24, TEST_SQRT_TOL0],
      [:hyperg_1F1_e, [50, 1.1, -110.0], 5.642684651305310023e-26, 0.03],
      [:hyperg_1F1_e, [100, 1.1, -1],    0.0811637344096042096, 2],
      [:hyperg_1F1_e, [100, 1.1, -10],   0.00025945610092231574387, 2],
      [:hyperg_1F1_e, [100, 1.1, -50],   2.4284830988994084452e-13, 2],
      [:hyperg_1F1_e, [100, 1.1, -90],   2.4468224638378426461e-22, 2],
      [:hyperg_1F1_e, [100, 1.1, -99],   1.0507096272617608461e-23, 2],
      [:hyperg_1F1_e, [100, 1.1, -100],  1.8315497474210138602e-24, 2],
#     [:hyperg_1F1_e, [100, 1.1, -101], -2.3916306291344452490e-24, 0.04],
#     [:hyperg_1F1_e, [100, 1.1, -110], -4.517581986037732280e-26, 0],
#     [:hyperg_1F1_e, [100, 10.1, -220], -4.296130300021696573e-64, 1],
      [:hyperg_1F1_e, [-10, -10.1, 10.0], 10959.603204633058116, 1],
      [:hyperg_1F1_e, [-10, -10.1, 1000.0], 2.0942691895502242831e+23, 2],
      [:hyperg_1F1_e, [-10, -100.1, 10.0],  2.6012036337980078062, 1],
      [:hyperg_1F1_e, [-1000, -1000.1, 10.0],  22004.341698908631636, 3],
      [:hyperg_1F1_e, [-1000, -1000.1, 200.0], 7.066514294896245043e+86, 3],
      [:hyperg_1F1_e, [-8.1, -10.1, -10.0],    0.00018469685276347199258, 0],
      [:hyperg_1F1_e, [-10, -5.1, 1],  16.936141866089601635, 2],
      [:hyperg_1F1_e, [-10, -5.1, 10],  771534.0349543820541, 2],
      [:hyperg_1F1_e, [-10, -5.1, 100],  2.2733956505084964469e+17, 2],
      [:hyperg_1F1_e, [-100, -50.1, -1],  0.13854540373629275583, 3],
      [:hyperg_1F1_e, [-100, -50.1, -10],  -9.142260314353376284e+19, 3],
      [:hyperg_1F1_e, [-100, -50.1, -100],  -1.7437371339223929259e+87, 3],
      [:hyperg_1F1_e, [-100, -50.1, 1],  7.516831748170351173, 3],
      [:hyperg_1F1_e, [-100, -50.1, 10],  1.0551632286359671976e+11, TEST_SQRT_TOL0],
#     [:hyperg_1F1_e, [-100, -50.1, 50],  -7.564755600940346649e+36, 3],
#     [:hyperg_1F1_e, [-100, -50.1, 100],  4.218776962675977e+55, 3],
      [:hyperg_1F1_e, [-10.5, -8.1, 0.1],  1.1387201443786421724, 0],
      [:hyperg_1F1_e, [-10.5, -11.1, 1],  2.5682766147138452362, 1],
      [:hyperg_1F1_e, [-100.5, -80.1, 10],  355145.4517305220603, 3],
      [:hyperg_1F1_e, [-100.5, -102.1, 10],  18678.558725244365016, 1],
      [:hyperg_1F1_e, [-100.5, -500.1, 10],  7.342209011101454, 0],
      [:hyperg_1F1_e, [-100.5, -500.1, 100],  1.2077443075367177662e+8, 1],
      [:hyperg_1F1_e, [-500.5, -80.1, 2],  774057.8541325341699, 4],
      [:hyperg_1F1_e, [100, -10.1, 1],  -2.1213846338338567395e+12, 0],
      [:hyperg_1F1_e, [100, -10.1, 10],  -6.624849346145112398e+39, 0],
      [:hyperg_1F1_e, [100, -10.1, 100],  -1.2413466759089171904e+129, 0],
#     [:hyperg_1F1_e, [100, -10.1, -1],  34456.29405305551691, 0],
#     [:hyperg_1F1_e, [100, -10.1, -10],  -7.809224251467710833e+07, 0],
#     [:hyperg_1F1_e, [100, -10.1, -100],   -5.214065452753988395e-07, 0],
      [:hyperg_1F1_e, [-100, 1.1, 1],  0.21519810496314438414, 2],
      [:hyperg_1F1_e, [-100, 1.1, 10],  8.196123715597869948, 1],
      [:hyperg_1F1_e, [-100, 1.1, 100],  -1.4612966715976530293e+20, 1],
      [:hyperg_1F1_e, [-100, 20.1, 1],  0.0021267655527278456412, 2],
      [:hyperg_1F1_e, [-100, 20.1, 10],   2.0908665169032186979e-11, 2],
      [:hyperg_1F1_e, [-100, 20.1, 100],  -0.04159447537001340412, 2],
      [:hyperg_1F1_e, [-100, 1.1, -1],  2.1214770215694685282e+07, 3],
      [:hyperg_1F1_e, [-100, 1.1, -10],  1.0258848879387572642e+24, 3],
      [:hyperg_1F1_e, [-100, 1.1, -100],  1.1811367147091759910e+67, 3],
      [:hyperg_1F1_e, [-100, 50.1, -1],  6.965259317271427390, 3],
      [:hyperg_1F1_e, [-100, 50.1, -10],  1.0690052487716998389e+07, 3],
      [:hyperg_1F1_e, [-100, 50.1, -100],  6.889644435777096248e+36, 3],
      [:hyperg_1F1_e, [-2.05, 1.0, 5.05], 3.79393389516785e+00, 3],
      [:hyperg_U_int_e, [1, 1, 0.0001],  8.634088070212725330, 0],
      [:hyperg_U_int_e, [1, 1, 0.01],  4.078511443456425847, 0],
      [:hyperg_U_int_e, [1, 1, 0.5],  0.9229106324837304688, 0],
      [:hyperg_U_int_e, [1, 1, 2.0],  0.3613286168882225847, 0],
      [:hyperg_U_int_e, [1, 1, 100],  0.009901942286733018406, 0],
      [:hyperg_U_int_e, [1, 1, 1000],  0.0009990019940238807150, 0],
      [:hyperg_U_int_e, [1, 8, 0.01],  7.272361203006010000e+16, 0],
      [:hyperg_U_int_e, [1, 8, 1],  1957.0, 0],
      [:hyperg_U_int_e, [1, 8, 5],  1.042496, 1],
      [:hyperg_U_int_e, [1, 8, 8],  0.3207168579101562500, 0],
      [:hyperg_U_int_e, [1, 8, 50],  0.022660399001600000000, 0],
      [:hyperg_U_int_e, [1, 8, 100],  0.010631236727200000000, 0],
      [:hyperg_U_int_e, [1, 8, 1000],  0.0010060301203607207200, 0],
      [:hyperg_U_int_e, [1, 20, 1],  1.7403456103284421000e+16, 0],
      [:hyperg_U_int_e, [1, 20, 20],  0.22597813610531052969, 0],
      [:hyperg_U_int_e, [1, 50, 1],  3.374452117521520758e+61, 0],
      [:hyperg_U_int_e, [1, 50, 50],  0.15394136814987651785, 0],
      [:hyperg_U_int_e, [1, 100, 0.1],  1.0418325171990852858e+253, 2],
      [:hyperg_U_int_e, [1, 100, 1],  2.5624945006073464385e+154, 2],
      [:hyperg_U_int_e, [1, 100, 50],  3.0978624160896431391e+07, 2],
      [:hyperg_U_int_e, [1, 100, 100],  0.11323192555773717475, 0],
      [:hyperg_U_int_e, [1, 100, 200],  0.009715680951406713589, 0],
      [:hyperg_U_int_e, [1, 100, 1000],  0.0011085142546061528661, 0],
      [:hyperg_U_int_e, [1, 1000, 2000],  0.0009970168547036318206, 0],
      [:hyperg_U_int_e, [1, -1, 1],  0.29817368116159703717, 1],
      [:hyperg_U_int_e, [1, -1, 10],  0.07816669698940409380, 1],
      [:hyperg_U_int_e, [1, -10, 1],  0.08271753756946041959, 1],
      [:hyperg_U_int_e, [1, -10, 5],  0.06127757419425055261, 2],
      [:hyperg_U_int_e, [1, -10, 10],  0.04656199948873187212, 2],
      [:hyperg_U_int_e, [1, -10, 20],  0.031606421847946077709, 1],
      [:hyperg_U_int_e, [1, -100, 0.01],  0.009900000099999796950, 2],
      [:hyperg_U_int_e, [1, -100, 1],  0.009802970197050404429, 2],
      [:hyperg_U_int_e, [1, -100, 10],  0.009001648897173103447, 2],
      [:hyperg_U_int_e, [1, -100, 20],  0.008253126487166557546, 2],
      [:hyperg_U_int_e, [1, -100, 50],  0.006607993916432051008, 2],
      [:hyperg_U_int_e, [1, -100, 90],  0.005222713769726871937, 2],
      [:hyperg_U_int_e, [1, -100, 110],  0.004727658137692606210, 2],
      [:hyperg_U_int_e, [1, -1000, 1010],  0.0004971408839859245170, 4],
      [:hyperg_U_int_e, [8, 1, 0.001],  0.0007505359326875706975, 0],
      [:hyperg_U_int_e, [8, 1, 0.5],  6.449509938973479986e-06, 3],
      [:hyperg_U_int_e, [8, 1, 8],  6.190694573035761284e-10, 0],
      [:hyperg_U_int_e, [8, 1, 20],  3.647213845460374016e-12, 0],
      [:hyperg_U_int_e, [8, 8, 1],  0.12289755012652317578, 1],
      [:hyperg_U_int_e, [8, 8, 10],  5.687710359507564272e-09, 1],
      [:hyperg_U_int_e, [8, 8, 20],  2.8175404594901039724e-11, 1],
      [:hyperg_U_int_e, [100, 100, 0.01],  1.0099979491941914867e+196, 2],
      [:hyperg_U_int_e, [100, 100, 0.1],  1.0090713562719862833e+97, 2],
      [:hyperg_U_int_e, [100, 100, 1],  0.009998990209084729106, 2],
      [:hyperg_U_int_e, [100, 100, 20],  1.3239363905866130603e-131, 2],
      [:hyperg_U_int_e, [-10, 1, 0.01],  3.274012540759009536e+06, 0],
      [:hyperg_U_int_e, [-10, 1, 1],  1.5202710000000000000e+06, 0],
      [:hyperg_U_int_e, [-10, 1, 10],  1.0154880000000000000e+08, 0],
      [:hyperg_U_int_e, [-10, 1, 100],  3.284529863685482880e+19, 0],
      [:hyperg_U_int_e, [-10, 10, 1],  1.1043089864100000000e+11, 0],
      [:hyperg_U_int_e, [-10, 100, 1],  1.3991152402448957897e+20, 0],
      [:hyperg_U_int_e, [-10, 100, 10],  5.364469916567136000e+19, 0],
      [:hyperg_U_int_e, [-10, 100, 100],  3.909797568000000000e+12, 0],
      [:hyperg_U_int_e, [-10, 100, 500],  8.082625576697984130e+25, 0],
      [:hyperg_U_int_e, [-50, 1, 0.01],  1.6973422555823855798e+64, 2],
      [:hyperg_U_int_e, [-50, 1, 1],  7.086160198304780325e+63, 1],
      [:hyperg_U_int_e, [-50, 1, 10],  5.332862895528712200e+65, 1],
      [:hyperg_U_int_e, [-50, 10, 1],  -7.106713471565790573e+71, 1],
      [:hyperg_U_int_e, [-50, 100, 1],  2.4661377199407186476e+104, 1],
      [:hyperg_U_int_e, [-50, 10, 10],  5.687538583671241287e+68, 1],
      [:hyperg_U_int_e, [-50, 100, 10],  1.7880761664553373445e+102, 1],
      [:hyperg_U_int_e, [-90, 1, 0.01],  4.185245354032917715e+137, 2],
      [:hyperg_U_int_e, [-90, 1, 0.1],  2.4234043408007841358e+137, 3],
      [:hyperg_U_int_e, [-90, 1, 10],  -1.8987677149221888807e+139, 1],
      [:hyperg_U_int_e, [-90, 10, 10],  -5.682999988842066677e+143, 1],
      [:hyperg_U_int_e, [-90, 100, 10],  2.3410029853990624280e+189, 2],
      [:hyperg_U_int_e, [-90, 1000, 10],  1.9799451517572225316e+271, 3],
      [:hyperg_U_int_e, [-50, -1, 10],  -9.083195466262584149e+64, 1],
      [:hyperg_U_int_e, [-50, -10, 10],  -1.4418257327071634407e+62, 1],
      [:hyperg_U_int_e, [-50, -100, 0.01],  3.0838993811468983931e+93, 2],
      [:hyperg_U_int_e, [-50, -100, 10],  4.014552630378340665e+95, 2],
      [:hyperg_U_int_e, [-100, -100, 10],  2.0556466922347982030e+162, 2],
      [:hyperg_U_int_e, [-100, -200, 10],  1.1778399522973555582e+219, 2],
      [:hyperg_U_int_e, [-100, -200, 100],  9.861313408898201873e+235, 3],
      [:hyperg_U_e, [0.0001, 0.0001, 0.0001], 1.0000576350699863577, 1],
      [:hyperg_U_e, [0.0001, 0.0001, 1.0], 0.9999403679233247536, 0],
      [:hyperg_U_e, [0.0001, 0.0001, 100.0], 0.9995385992657260887, 0],
      [:hyperg_U_e, [0.0001, 1, 0.0001], 1.0009210608660065989, 2],
      [:hyperg_U_e, [0.0001, 1.0, 1.0], 0.9999999925484179084, 2],
      [:hyperg_U_e, [0.0001, 10, 1], 13.567851006281412726, 3],
      [:hyperg_U_e, [0.0001, 10, 10], 0.9999244381454633265, 0],
      [:hyperg_U_e, [0.0001, 100, 98], 0.9998517867411840044, 2],
      [:hyperg_U_e, [0.0001, 1000, 999], 0.9997195294193261604, 2],
      [:hyperg_U_e, [0.0001, 1000, 1100],  0.9995342990014584713, 1],
      [:hyperg_U_e, [0.5, 1000, 800], 9.103916020464797207e+08, 2],
      [:hyperg_U_e, [0.5, 1000, 998], 0.21970269691801966806, 2],
      [:hyperg_U_e, [0.5, 0.5, 1.0], 0.7578721561413121060, 2],
      [:hyperg_U_e, [1, 0.0001, 0.0001], 0.9992361337764090785, 1],
      [:hyperg_U_e, [1, 0.0001, 1], 0.4036664068111504538, 2],
      [:hyperg_U_e, [1, 0.0001, 100], 0.009805780851264329587, 1],
      [:hyperg_U_e, [1, 1.2, 2.0], 0.3835044780075602550, 1],
      [:hyperg_U_e, [1, -0.0001, 1], 0.4036388693605999482, 1],
      [:hyperg_U_e, [8, 10.5, 1],  27.981926466707438538, 1],
      [:hyperg_U_e, [8, 10.5, 10],  2.4370135607662056809e-8, 0],
      [:hyperg_U_e, [8, 10.5, 100],  1.1226567526311488330e-16, 2],
      [:hyperg_U_e, [10, -2.5, 10],  6.734690720346560349e-14, 1],
      [:hyperg_U_e, [10, 2.5, 10],  6.787780794037971638e-13, 0],
      [:hyperg_U_e, [10, 2.5, 50],  2.4098720076596087125e-18, 0],
      [:hyperg_U_e, [-10.5, 1.1, 1],  -3.990841457734147e+6, 2],
      [:hyperg_U_e, [-10.5, 1.1, 10],  1.307472052129343e+8, 1],
      [:hyperg_U_e, [-10.5, 1.1, 50],  3.661978424114088e+16, 0],
      [:hyperg_U_e, [-10.5, 1.1, 90],  8.09469542130868e+19, 1],
      [:hyperg_U_e, [-10.5, 1.1, 99],  2.546328328942063e+20, 1],
      [:hyperg_U_e, [-10.5, 1.1, 100],  2.870463201832814e+20, 1],
      [:hyperg_U_e, [-10.5, 1.1, 200],  8.05143453769373e+23, 2],
      [:hyperg_U_e, [-10.5, 10.1, 0.1],  -3.043016255306515e+20, 2],
      [:hyperg_U_e, [-10.5, 10.1, 1],  -3.194745265896115e+12, 1],
      [:hyperg_U_e, [-10.5, 10.1, 4],  -6.764203430361954e+07, 2],
      [:hyperg_U_e, [-10.5, 10.1, 10],  -2.067399425480545e+09, 1],
      [:hyperg_U_e, [-10.5, 10.1, 50],  4.661837330822824e+14, 1],
      [:hyperg_U_e, [-10.5, 100.4, 10],  -6.805460513724838e+66, 1],
      [:hyperg_U_e, [-10.5, 100.4, 50],  -2.081052558162805e+18, 1],
      [:hyperg_U_e, [-10.5, 100.4, 80],  2.034113191014443e+14, 2],
      [:hyperg_U_e, [-10.5, 100.4, 100],  6.85047268436107e+13, 1],
      [:hyperg_U_e, [-10.5, 100.4, 200],  1.430815706105649e+20, 2],
      [:hyperg_U_e, [-19.5, 82.1, 10],  5.464313196201917432e+60, 2],
      [:hyperg_U_e, [-50.5, 100.1, 10],  -5.5740216266953e+126, 1],
      [:hyperg_U_e, [-50.5, 100.1, 40],  5.937463786613894e+91, 1],
      [:hyperg_U_e, [-50.5, 100.1, 50],  -1.631898534447233e+89, 1],
      [:hyperg_U_e, [-50.5, 100.1, 70],  3.249026971618851e+84, 2],
      [:hyperg_U_e, [-50.5, 100.1, 100],  1.003401902126641e+85, 1],
      [:hyperg_2F1_e, [1, 1, 1, 0.5], 2.0, 0],
      [:hyperg_2F1_e, [8, 8, 1, 0.5], 12451584.0, 0],
      [:hyperg_2F1_e, [8, -8, 1, 0.5], 0.13671875, 0],
#     [:hyperg_2F1_e, [8, -8.1, 1, 0.5], 0.14147385378899930422, 4],
      [:hyperg_2F1_e, [8, -8, 1, -0.5], 4945.136718750000000, 0],
      [:hyperg_2F1_e, [8, -8, -5.5, 0.5],  -906.6363636363636364, 0],
      [:hyperg_2F1_e, [8, -8, -5.5, -0.5], 24565.363636363636364, 0],
      [:hyperg_2F1_e, [8, 8, 1, -0.5], -0.006476312098196747669, 2],
      [:hyperg_2F1_e, [8, 8, 5, 0.5], 4205.714285714285714, 0],
      [:hyperg_2F1_e, [8, 8, 5, -0.5], 0.0028489656290296436616, 2],
      [:hyperg_2F1_e, [9, 9, 1, 0.99], 1.2363536673577259280e+38, 2],
      [:hyperg_2F1_e, [9, 9, -1.5, 0.99], 3.796186436458346579e+46, 2],
      [:hyperg_2F1_e, [9, 9, -1.5, -0.99], 0.14733409946001025146, 1],
      [:hyperg_2F1_e, [9, 9, -8.5, 0.99], -1.1301780432998743440e+65, 2],
      [:hyperg_2F1_e, [9, 9, -8.5, -0.99], -8.856462606575344483, 1],
      [:hyperg_2F1_e, [9, 9, -21.5, 0.99], 2.0712920991876073253e+95, 3],
      [:hyperg_2F1_e, [9, 9, -21.5, -0.99], -74.30517015382249216, 2],
      [:hyperg_2F1_e, [9, 9, -100.5, 0.99],  -3.186778061428268980e+262, 3],
      [:hyperg_2F1_e, [9, 9, -100.5, -0.99],  2.4454358338375677520, 1],
      [:hyperg_2F1_e, [25, 25, 1, -0.5], -2.9995530823639545027e-06, TEST_SQRT_TOL0],
      [:hyperg_2F1_e, [1.5, 0.5, 2.0, 1.0-1.0 / 64.0], 3.17175539044729373926, 3],
      [:hyperg_2F1_e, [1.5, 0.5, 2.0, 1.0-1.0 / 128.0], 3.59937243502024563424, 2],
      [:hyperg_2F1_e, [1.5, 0.5, 2.0, 1.0-1.0 / 256.0], 4.03259299524392504369, 1],
      [:hyperg_2F1_e, [1.5, 0.5, 2.0, 1.0-1.0 / 1024.0], 4.90784159359675398250, 1],
      [:hyperg_2F1_e, [1.5, 0.5, 2.0, 1.0-1.0 / 65536.0], 7.552266033399683914, 1],
      [:hyperg_2F1_e, [1.5, 0.5, 2.0, 1.0-1.0 / 16777216.0], 11.08235454026043830363, 1],
      [:hyperg_2F1_e, [1.5, 0.5, 2.0, -1.0 + 1.0 / 1024.0], 0.762910940909954974527, 0],
      [:hyperg_2F1_e, [1.5, 0.5, 2.0, -1.0 + 1.0 / 65536.0], 0.762762124908845424449, 0],
      [:hyperg_2F1_e, [1.5, 0.5, 2.0, -1.0 + 1.0 / 1048576.0], 0.762759911089064738044, 0],
      [:hyperg_2F1_conj_e, [1, 1, 1, 0.5], 3.352857095662929028, 0],
      [:hyperg_2F1_conj_e, [8, 8, 1, 0.5], 1.7078067538891293983e+09, 0],
      [:hyperg_2F1_conj_e, [8, 8, 5, 0.5], 285767.15696901140627, 1],
      [:hyperg_2F1_conj_e, [8, 8, 1, -0.5], 0.007248196261471276276, 3],
      [:hyperg_2F1_conj_e, [8, 8, 5, -0.5], 0.00023301916814505902809, 3],
      [:hyperg_2F1_conj_e, [25, 25, 1, -0.5], 5.1696944096e-06, TEST_SQRT_TOL0],
#     [:hyperg_2F0_e, [0.01, 1.0, -0.02], 0.999803886708565, 0],
#     [:hyperg_2F0_e, [0.1,  0.5, -0.02], 0.999015947934831, 0],
#     [:hyperg_2F0_e, [1,   1, -0.02], 0.980755496569062, 0],
#     [:hyperg_2F0_e, [8,   8, -0.02], 0.3299059284994299, 0],
#     [:hyperg_2F0_e, [50, 50, -0.02], 2.688995263773233e-13, 0],
      [:hyperg_2F1_renorm_e, [1, 1, 1, 0.5], 2.0, 0],
      [:hyperg_2F1_renorm_e, [8, 8, 1, 0.5], 12451584.0, 0],
      [:hyperg_2F1_renorm_e, [8, -8, 1, 0.5], 0.13671875, 0],
      [:hyperg_2F1_renorm_e, [8, -8, 1, -0.5], 4945.13671875, 0],
      [:hyperg_2F1_renorm_e, [8, -8, -5.5, 0.5], -83081.19167659493609, 2],
      [:hyperg_2F1_renorm_e, [8, -8, -5.5, -0.5], 2.2510895952730178518e+06, 2],
      [:hyperg_2F1_renorm_e, [8, 8, 5, 0.5], 175.2380952380952381, 1],
      [:hyperg_2F1_renorm_e, [9, 9, -1.5, 0.99], 1.6063266334913066551e+46, 2],
      [:hyperg_2F1_renorm_e, [9, 9, -1.5, -0.99], 0.06234327316254516616, 2],
      [:hyperg_2F1_renorm_e, [5, 5, -1, 0.5], 4949760.0, 1],
      [:hyperg_2F1_renorm_e, [5, 5, -10, 0.5], 139408493229637632000.0, 2],
      [:hyperg_2F1_renorm_e, [5, 5, -100, 0.5], 3.0200107544594411315e+206, 3],
      [:hyperg_2F1_conj_renorm_e, [9, 9, -1.5, 0.99], 5.912269095984229412e+49, 2],
      [:hyperg_2F1_conj_renorm_e, [9, 9, -1.5, -0.99], 0.10834020229476124874, 2],
      [:hyperg_2F1_conj_renorm_e, [5, 5, -1, 0.5], 1.4885106335357933625e+08, 2],
      [:hyperg_2F1_conj_renorm_e, [5, 5, -10, 0.5], 7.968479361426355095e+21, 2],
      [:hyperg_2F1_conj_renorm_e, [5, 5, -100, 0.5], 3.1113180227052313057e+208, 3]
    ],
    :legendre => [
      [:legendre_P1_e, [-0.5], -0.5, 0],
      [:legendre_P1_e, [ 0.5], 0.5, 0],
      [:legendre_P2_e, [0.0], -0.5, 0],
      [:legendre_P2_e, [0.5], -0.125, 0],
      [:legendre_P2_e, [1.0], 1.0, 0],
      [:legendre_P2_e, [100.0], 14999.5, 0],
      [:legendre_P3_e, [ -0.5], 0.4375, 0],
      [:legendre_P3_e, [  0.5], -0.4375, 0],
      [:legendre_P3_e, [  1.0], 1.0, 0],
      [:legendre_P3_e, [100.0], 2.49985e+06, 0],
      [:legendre_Pl_e, [1, -0.5], -0.5, 0],
      [:legendre_Pl_e, [1,  1.0e-8], 1.0e-08, 0],
      [:legendre_Pl_e, [1,  0.5], 0.5, 0],
      [:legendre_Pl_e, [1,  1.0], 1.0, 0],
      [:legendre_Pl_e, [10, -0.5], -0.1882286071777345, 0],
      [:legendre_Pl_e, [10,  1.0e-8], -0.24609374999999864648, 0],
      [:legendre_Pl_e, [10,  0.5], -0.18822860717773437500, 0],
      [:legendre_Pl_e, [10,  1.0], 1.0, 0],
      [:legendre_Pl_e, [99, -0.5], 0.08300778172138770477, 0],
      [:legendre_Pl_e, [99,  1.0e-8], -7.958923738716563193e-08, 0],
      [:legendre_Pl_e, [99,  0.5], -0.08300778172138770477, 0],
      [:legendre_Pl_e, [99,  0.999], -0.3317727359254778874, 2],
      [:legendre_Pl_e, [99,  1.0], 1.0, 0],
      [:legendre_Pl_e, [1000, -0.5],   -0.019168251091650277878, 2],
      [:legendre_Pl_e, [1000,  1.0e-8], 0.02522501817709828,     2],
      [:legendre_Pl_e, [1000,  0.5],   -0.019168251091650277878, 2],
      [:legendre_Pl_e, [1000,  1.0],    1.0,                     0],
      [:legendre_Pl_e, [4000, -0.5], -0.009585404456573080972, 2],
      [:legendre_Pl_e, [4000,  0.5], -0.009585404456573080972, 2],
      [:legendre_Pl_e, [4000,  1.0], 1.0, 0],
      [:legendre_Plm_e, [10, 0, -0.5], -0.18822860717773437500, 0],
      [:legendre_Plm_e, [10, 0, 1.0e-08], -0.24609374999999864648, 0],
      [:legendre_Plm_e, [10, 0, 0.5], -0.18822860717773437500, 0],
      [:legendre_Plm_e, [10, 1, -0.5], -2.0066877394361256516, 0],
      [:legendre_Plm_e, [10, 1, 1.0e-08], -2.7070312499999951725e-07, 0],
      [:legendre_Plm_e, [10, 1, 0.5], 2.0066877394361256516, 0],
      [:legendre_Plm_e, [10, 5, -0.5],    -30086.169706116174977,    0],
      [:legendre_Plm_e, [10, 5, 1.0e-08], -0.0025337812499999964949, 0],
      [:legendre_Plm_e, [10, 5, 0.5],      30086.169706116174977,    0],
      [:legendre_Plm_e, [10, 5, 0.999],   -0.5036411489013270406,    1],
      [:legendre_Plm_e, [100, 5, -0.5], -6.617107444248382171e+08, 0],
      [:legendre_Plm_e, [100, 5, 1.0e-08], 817.8987598063712851, 0],
      [:legendre_Plm_e, [100, 5, 0.5], 6.617107444248382171e+08, 0],
      [:legendre_Plm_e, [100, 5, 0.999], -1.9831610803806212189e+09, 2],
      [:legendre_sphPlm_e, [10, 0, -0.5], -0.24332702369300133776, 0],
      [:legendre_sphPlm_e, [10, 0, 0.5], -0.24332702369300133776, 0],
      [:legendre_sphPlm_e, [10, 0, 0.999], 1.2225754122797385990, 1],
      [:legendre_sphPlm_e, [10, 5, -0.5],    -0.3725739049803293972,     0],
      [:legendre_sphPlm_e, [10, 5, 1.0e-08], -3.1377233589376792243e-08, 0],
      [:legendre_sphPlm_e, [10, 5, 0.5],      0.3725739049803293972,     0],
      [:legendre_sphPlm_e, [10, 5, 0.999],   -6.236870674727370094e-06,  2],
      [:legendre_sphPlm_e, [10, 10, -0.5], 0.12876871185785724117, 1],
      [:legendre_sphPlm_e, [10, 10, 0.5], 0.12876871185785724117,  1],
      [:legendre_sphPlm_e, [10, 10, 0.999], 1.7320802307583118647e-14, 2],
      [:legendre_sphPlm_e, [200, 1, -0.5],   0.3302975570099492931, 1],
      [:legendre_sphPlm_e, [200, 1, 0.5],   -0.3302975570099492931, 1],
      [:legendre_sphPlm_e, [200, 1, 0.999], -1.4069792055546256912, 2],
      [:conicalP_half_e, [0.0, -0.5],   0.8573827581049917129, 0],
      [:conicalP_half_e, [0.0,  0.5],   0.8573827581049917129, 0],
      [:conicalP_half_e, [0.0,  2.0],   0.6062611623284649811, 0],
      [:conicalP_half_e, [0.0,  100.0], 0.07979045091636735635, 0],
      [:conicalP_half_e, [10.0, -0.5],    5.345484922591867188e+08, 1],
      [:conicalP_half_e, [10.0,  0.5],    15137.910380385258370, 1],
      [:conicalP_half_e, [10.0,  2.0],    0.4992680691891618544, 1],
      [:conicalP_half_e, [10.0,  100.0], -0.07272008163718195685, 2],
      [:conicalP_half_e, [200.0, -1.0e-3],  1.3347639529084185010e+136, 2],
      [:conicalP_half_e, [200.0,  1.0e-8],  1.0928098010940058507e+136, 2],
      [:conicalP_half_e, [200.0,  0.5],     3.895546021611205442e+90,   2],
      [:conicalP_half_e, [200.0,  10.0],   -0.04308567180833581268,     3],
      [:conicalP_half_e, [200.0,  100.0],  -0.04694669186576399194,     3],
      [:conicalP_half_e, [200.0,  1000.0],  0.023698140704121273277,    3],
      [:conicalP_half_e, [200.0,  1.0e+8], -0.00006790983312124277891,  3],
      [:conicalP_half_e, [1.0e+8,  1.1],   1.1599311133054742944,  TEST_SQRT_TOL0],
      [:conicalP_half_e, [1.0e+8,  100.0], 0.07971967557381557875, TEST_SQRT_TOL0],
      [:conicalP_mhalf_e, [0.0, -0.5],  1.7956982494514644808, 0],
      [:conicalP_mhalf_e, [0.0,  0.5],  0.8978491247257322404, 0],
      [:conicalP_mhalf_e, [0.0,  2.0],  0.7984204253272901551, 0],
      [:conicalP_mhalf_e, [0.0,  100.0],  0.4227531369388072584, 0],
      [:conicalP_mhalf_e, [10.0, -0.5],  5.345484922591867181e+07, 1],
      [:conicalP_mhalf_e, [10.0,  0.5],  1513.7910356104985334, 1],
      [:conicalP_mhalf_e, [10.0,  2.0],  0.03439243987215615642, 1],
      [:conicalP_mhalf_e, [10.0,  100.0],  0.003283756665952609624, 2],
      [:conicalP_mhalf_e, [200.0, -0.5],  1.7699538115312304280e+179, 2],
      [:conicalP_mhalf_e, [200.0,  1.0e-8],  5.464049005470029253e+133, 2],
      [:conicalP_mhalf_e, [200.0,  0.5],  1.9477730108056027211e+88, 2],
      [:conicalP_mhalf_e, [200.0,  10.0],  0.0012462575917716355362, 2],
      [:conicalP_mhalf_e, [200.0,  100.0],  -0.0003225881344802625149, 2],
      [:conicalP_mhalf_e, [200.0,  1000.0], -0.00004330652890886567623, 3],
      [:conicalP_mhalf_e, [200.0,  1.0e+8],  2.0943091278037078483e-07, 3],
      [:conicalP_mhalf_e, [1.0e+8,  1.1], 2.092320445620989618e-09, 16.0 * TEST_SQRT_TOL0],
      [:conicalP_mhalf_e, [1.0e+8,  100.0],  -3.359967833599016923e-11, 256.0 * TEST_SQRT_TOL0],
      [:conicalP_0_e, [0.0, -0.5],  1.3728805006183501647, 0],
      [:conicalP_0_e, [0.0,  0.5],  1.0731820071493643751, 0],
      [:conicalP_0_e, [0.0,  2.0],  0.9012862993604472987, 0],
      [:conicalP_0_e, [0.0,  100.0],  0.30091748588199264556, 0],
      [:conicalP_0_e, [10.0, -0.5],  1.6795592815421804669e+08, 1],
      [:conicalP_0_e, [10.0,  0.5],  4826.034132009618240,      1],
      [:conicalP_0_e, [10.0,  2.0],  0.18798468917758716146,    2],
      [:conicalP_0_e, [10.0,  100.0], -0.008622130749987962529, 2],
      [:conicalP_0_e, [200.0,  -0.5], 2.502194818646823e+180, 4],
      [:conicalP_0_e, [1000.0,  100.0],   0.0017908817653497715844, 3],
      [:conicalP_0_e, [1000.0,  1000.0], -0.0006566893804926284301, 3],
      [:conicalP_0_e, [1000.0,  1.0e+8],  2.3167213561756390068e-06, 4],
      [:conicalP_1_e, [0.0, -0.5],    0.4939371126656998499,  1],
      [:conicalP_1_e, [0.0,  0.5],    0.14933621085538265636, 1],
      [:conicalP_1_e, [0.0,  2.0],   -0.13666874968871549533, 1],
      [:conicalP_1_e, [0.0,  100.0], -0.10544528203156629098, 2],
      [:conicalP_1_e, [10.0, -0.5],    1.7253802958788312520e+09, 2],
      [:conicalP_1_e, [10.0,  0.5],    46781.02294059967988,      1],
      [:conicalP_1_e, [10.0,  2.0],    0.26613342643657444400,    2],
      [:conicalP_1_e, [10.0,  100.0], -0.23281959695501029796,    2],
      [:conicalP_1_e, [200.0, -0.999], 2.71635193199341135e+270, 2],
      [:conicalP_1_e, [200.0, -0.9],   4.2952493176812905e+234,  2],
      [:conicalP_1_e, [200.0, -0.5],   5.01159205956053439e+182, 3],
      [:conicalP_1_e, [200.0,  0.999], 195733.0396081538,        2],
      [:conicalP_1_e, [200.0,  10.0], -2.9272610662414349553,    2],
      [:conicalP_1_e, [1000.0, 100.0],  -1.7783258105862399857,    6],
      [:conicalP_1_e, [1000.0, 1000.0],  0.4535161075156427179,    4],
      [:conicalP_1_e, [1000.0, 1.0e+8],  0.0009983414549874888478, TEST_SQRT_TOL0],
      [:conicalP_sph_reg_e, [2,  1.0, -0.5],  1.6406279287008789526,      0],
      [:conicalP_sph_reg_e, [10, 1.0, -0.5],  0.000029315266725049129448, 1],
      [:conicalP_sph_reg_e, [20, 1.0, -0.5],  7.335769429462034431e-15,   1],
      [:conicalP_sph_reg_e, [30, 1.0, -0.5],  1.3235612394267378871e-26,  2],
      [:conicalP_sph_reg_e, [10, 1.0, 0.5],  2.7016087199857873954e-10, 1],
      [:conicalP_sph_reg_e, [20, 1.0, 0.5],  1.1782569701435933399e-24, 1],
      [:conicalP_sph_reg_e, [30, 1.0, 0.5],  3.636240588303797919e-41,  1],
      [:conicalP_sph_reg_e, [10, 1.0, 2.0],  2.4934929626284934483e-10, 1],
      [:conicalP_sph_reg_e, [20, 1.0, 2.0],  1.1284762488012616191e-24, 2],
      [:conicalP_sph_reg_e, [30, 100.0, 100.0],  -1.6757772087159526048e-64, 6],
      [:conicalP_cyl_reg_e, [2, 1.0, -0.5],   2.2048510472375258708,       0],
      [:conicalP_cyl_reg_e, [10, 1.0, -0.5],  0.00007335034531618655690,   1],
      [:conicalP_cyl_reg_e, [20, 1.0, -0.5],  2.5419860619212164696e-14,   1],
      [:conicalP_cyl_reg_e, [30, 1.0, -0.5],  5.579714972260536827e-26,    2],
      [:conicalP_cyl_reg_e, [10, 1.0, 0.5],  1.1674078819646475282e-09,    0],
      [:conicalP_cyl_reg_e, [20, 1.0, 0.5],  7.066408031229072207e-24,     1],
      [:conicalP_cyl_reg_e, [30, 1.0, 0.5],  2.6541973286862588488e-40,    1],
      [:conicalP_cyl_reg_e, [10, 1.0, 2.0],  1.0736109751890863051e-09,    2],
      [:conicalP_cyl_reg_e, [20, 1.0, 2.0],  6.760965304863386741e-24,     2],
      [:conicalP_cyl_reg_e, [30, 100.0, 100.0], -4.268753482520651007e-63, 4],
      [:legendre_H3d_0_e, [1.0e-06, 1.0e-06], 0.9999999999998333333, 0],
      [:legendre_H3d_0_e, [1.0, 0.0], 1.0, 0],
      [:legendre_H3d_0_e, [1.0, 1.0], 0.7160229153604338713, 0],
      [:legendre_H3d_0_e, [1.0, 100.0], -3.767437313149604566e-44, 2],
      [:legendre_H3d_0_e, [1.0, 500.0], -6.665351935878582205e-218, 2],
      [:legendre_H3d_0_e, [100.0, 1.0], -0.004308757035378200029, 0],
      [:legendre_H3d_0_e, [100.0, 10.0], 7.508054627912986427e-07, 0],
      [:legendre_H3d_0_e, [1000.0, 1.0], 0.0007036067909088818319, 0],
      [:legendre_H3d_0_e, [1.0e+08, 1.0], 7.927485371429105968e-09, 3],
      [:legendre_H3d_0_e, [1.0e+08, 100.0], -3.627118904186918957e-52, 32.0 * TEST_SQRT_TOL0],
      [:legendre_H3d_1_e, [1.0e-06, 1.0e-06], 3.333333333334222222e-07, 0],
      [:legendre_H3d_1_e, [1.0, 1.0e-10], 4.714045207910316829e-11,     0],
      [:legendre_H3d_1_e, [1.0, 1.0], 0.3397013994799344639,           0],
      [:legendre_H3d_1_e, [1.0, 100.0], -7.200624449531811272e-44,     2],
      [:legendre_H3d_1_e, [1.0, 500.0], 4.192260336821728677e-218,     2],
      [:legendre_H3d_1_e, [100.0, 0.01], 0.30117664944267412324, 1],
      [:legendre_H3d_1_e, [100.0, 1.0], -0.007393833425336299309, 0],
      [:legendre_H3d_1_e, [100.0, 10.0], -5.031062029821254982e-07, 0],
      [:legendre_H3d_1_e, [1000.0, 0.001], 0.30116875865090396421, 0],
      [:legendre_H3d_1_e, [1000.0, 1.0], -0.0004776144516074971885, 0],
      [:legendre_H3d_1_e, [1.0e+08, 1.0e-08], 0.30116867893975679722, 1],
      [:legendre_H3d_1_e, [1.0e+08, 1.0], 3.0921097047369081582e-09, 4],
      [:legendre_H3d_1_e, [1.0e+08, 100.0], -6.496142701296286936e-52, 32.0 * TEST_SQRT_TOL0],
      [:legendre_H3d_e, [5, 1.0e-06, 1.0e-06],  1.1544011544013627977e-32, 2],
      [:legendre_H3d_e, [5, 1.0, 1.0e-10],      2.0224912016958766992e-52, 2],
      [:legendre_H3d_e, [5, 1.0, 1.0],          0.011498635037491577728,   1],
      [:legendre_H3d_e, [5, 1.0, 5.0],          0.0020696945662545205776,  4],
      [:legendre_H3d_e, [5, 1.0, 7.0],     -0.0017555303787488993676,   4],
      [:legendre_H3d_e, [5, 1.0, 10.0],     0.00008999979724504887101,  2],
      [:legendre_H3d_e, [5, 1.0, 100.0],   -4.185397793298567945e-44,   2],
      [:legendre_H3d_e, [5, 1.0, 500.0],    1.4235113901091961263e-217, 3],
      [:legendre_H3d_e, [5, 100.0, 0.001],  9.642762597222417946e-10,   2],
      [:legendre_H3d_e, [5, 100.0, 0.002],  3.0821201254308036109e-08,  2],
      [:legendre_H3d_e, [5, 100.0, 0.01],   0.00009281069019005840532,  1],
      [:legendre_H3d_e, [5, 100.0, 1.0],   -0.008043100696178624653,    2],
      [:legendre_H3d_e, [5, 100.0, 10.0],  -3.927678432813974207e-07,   3],
      [:legendre_H3d_e, [5, 1000.0, 0.001],  0.00009256365284253254503, 1],
      [:legendre_H3d_e, [5, 1000.0, 0.01],  -0.05553733815473079983, 0],
      [:legendre_H3d_e, [5, 1.0e+08, 1.0e-08],   0.00009256115861125841299, 2],
      [:legendre_H3d_e, [5, 1.0e+08, 100.0],    -6.496143209092860765e-52, 128.0 * TEST_SQRT_TOL0],
      [:legendre_Q0_e, [-0.9999847412109375], -5.8917472200477175158028143531855, 4],
      [:legendre_Q0_e, [-0.5], -0.5493061443340548457, 0],
      [:legendre_Q0_e, [-1e-10], -1.000000000000000000e-10, 0],
      [:legendre_Q0_e, [0.0], 0.0, 0],
      [:legendre_Q0_e, [1e-10], 1.000000000000000000e-10, 0],
      [:legendre_Q0_e, [0.9999847412109375], 5.8917472200477175158028143531855, 4],
      [:legendre_Q0_e, [ 1.0000152587890625], 5.8917548494422489138325509750429, 4],
      [:legendre_Q0_e, [ 1.5], 0.8047189562170501873, 0],
      [:legendre_Q0_e, [ 9.99], 0.1004364599660005447, 0],
      [:legendre_Q0_e, [ 10.0], 0.1003353477310755806, 0],
      [:legendre_Q0_e, [ 10.01], 0.1002344395571710243, 0],
      [:legendre_Q0_e, [ 100], 0.010000333353334762015, 0],
      [:legendre_Q0_e, [ 1e10], 1.000000000000000000e-10, 0],
      [:legendre_Q1_e, [-0.9999847412109375], 4.8916573191196772369, 4],
      [:legendre_Q1_e, [-0.5], -0.7253469278329725772, 0],
      [:legendre_Q1_e, [-0.01], -0.9998999966664666524, 0],
      [:legendre_Q1_e, [-1e-10], -0.999999999999999999, 0],
      [:legendre_Q1_e, [0.0], -1.0, 0],
      [:legendre_Q1_e, [1e-10], -0.999999999999999999, 0],
      [:legendre_Q1_e, [0.0001], -0.9999999899999999667, 0],
      [:legendre_Q1_e, [0.01], -0.9998999966664666524, 0],
      [:legendre_Q1_e, [0.5], -0.7253469278329725772, 0],
      [:legendre_Q1_e, [0.9999847412109375], 4.8916573191196772369, 4],
      [:legendre_Q1_e, [1.0000152587890625], 4.8918447504867045145, 4],
      [:legendre_Q1_e, [ 1.5], 0.20707843432557528095, 0],
      [:legendre_Q1_e, [ 9.99], 3.360235060345441639e-3, 0],
      [:legendre_Q1_e, [ 10.0], 3.353477310755806357e-3, 0],
      [:legendre_Q1_e, [ 10.01], 3.346739967281953346e-3, 0],
      [:legendre_Q1_e, [ 100.0], 3.333533347620158821e-5, 0],
      [:legendre_Q1_e, [ 1e10], 3.333333333333333333e-21, 0],
      [:legendre_Ql_e, [10, -0.5], -0.29165813966586752393,    0],
      [:legendre_Ql_e, [10,  0.5], 0.29165813966586752393,     0],
      [:legendre_Ql_e, [10,  1.5], 0.000014714232718207477406, 0],
      [:legendre_Ql_e, [100, -0.5], -0.09492507395207282096,   1],
      [:legendre_Ql_e, [100,  0.5], 0.09492507395207282096,    1],
      [:legendre_Ql_e, [100,  1.5], 1.1628163435044121988e-43, 2],
      [:legendre_Ql_e, [1000, -0.5], -0.030105074974005303500, 1],
      [:legendre_Ql_e, [1000,  0.5], 0.030105074974005303500,  1],
      [:legendre_Ql_e, [1000,  1.1], 1.0757258447825356443e-194, 3]
    ],
    :mathieu => [
      [:mathieu_ce_e, [0, 0.0, 0.0], 0.7071067811865475, TEST_SNGL],
      [:mathieu_ce_e, [0, 0.0, GSL::M_PI_2], 0.7071067811865475, TEST_SNGL],
      [:mathieu_ce_e, [0, 5.0, 0.0], 0.04480018165188902, TEST_SNGL],
      [:mathieu_ce_e, [0, 5.0, GSL::M_PI_2], 1.334848674698019, TEST_SNGL],
      [:mathieu_ce_e, [0, 10.0, 0.0], 0.007626517570935782, TEST_SNGL],
      [:mathieu_ce_e, [0, 10.0, GSL::M_PI_2], 1.468660470712856, TEST_SNGL],
      [:mathieu_ce_e, [0, 15.0, 0.0], 0.001932508315204592, TEST_SNGL],
      [:mathieu_ce_e, [0, 15.0, GSL::M_PI_2], 1.550108146686649, TEST_SNGL],
      [:mathieu_ce_e, [0, 20.0, 0.0], 0.0006037438292242197, TEST_SNGL],
      [:mathieu_ce_e, [0, 20.0, GSL::M_PI_2], 1.609890857395926, TEST_SNGL],
      [:mathieu_ce_e, [0, 25.0, 0.0], 0.0002158630184146612, TEST_SNGL],
      [:mathieu_ce_e, [0, 25.0, GSL::M_PI_2], 1.657510298323475, TEST_SNGL],
      [:mathieu_ce_e, [1, 0.0, 0.0], 1.00000000, TEST_SNGL],
      [:mathieu_ce_e, [1, 5.0, 0.0], 0.2565428793223637, TEST_SNGL],
      [:mathieu_ce_e, [1, 10.0, 0.0], 0.05359874774717657, TEST_SNGL],
      [:mathieu_ce_e, [1, 15.0, 0.0], 0.01504006645382623, TEST_SNGL],
      [:mathieu_se_e, [5, 0.0, GSL::M_PI_2], 1.0000000, TEST_SNGL],
      [:mathieu_se_e, [5, 5.0, GSL::M_PI_2], 0.9060779302023551, TEST_SNGL],
      [:mathieu_se_e, [5, 10.0, GSL::M_PI_2], 0.8460384335355106, TEST_SNGL],
      [:mathieu_se_e, [5, 15.0, GSL::M_PI_2], 0.837949340012484, TEST_SNGL],
      [:mathieu_se_e, [5, 20.0, GSL::M_PI_2], 0.8635431218533667, TEST_SNGL],
      [:mathieu_se_e, [5, 25.0, GSL::M_PI_2], 0.8992683245108413, TEST_SNGL],
      [:mathieu_ce_e, [10, 0.0, 0.0], 1.00000000, TEST_SNGL],
      [:mathieu_ce_e, [10, 0.0, GSL::M_PI_2], -1.00000000, TEST_SNGL]
    ],
    :sf => [
      [:clausen_e, [GSL::M_PI / 20.0], 0.4478882448133546, 0],
      [:clausen_e, [GSL::M_PI / 6.0], 0.8643791310538927, 0],
      [:clausen_e, [GSL::M_PI / 3.0], 1.0149416064096535, 0],
      [:clausen_e, [  2.0 * GSL::M_PI + GSL::M_PI / 3.0], 1.0149416064096535, 0],
      [:clausen_e, [100.0 * GSL::M_PI + GSL::M_PI / 3.0], 1.0149416064096535, 0],
      [:coupling_3j_e, [0, 1, 1, 0,  1, -1], Math.sqrt(1.0 / 2.0), 0],
      [:coupling_3j_e, [1, 1, 2, 1, -1,  0], Math.sqrt(1.0 / 6.0), 0],
      [:coupling_3j_e, [2, 4, 6, 0,  2, -2], Math.sqrt(8.0 / 105.0), 0],
      [:coupling_3j_e, [4, 4, 8, 0,  0,  0], Math.sqrt(2.0 / 35.0), 0],
      [:coupling_3j_e, [4, 4, 8, 2, -2,  0], 2.0 / 3.0 * Math.sqrt(2.0 / 35.0), 2],
      [:coupling_3j_e, [4, 4, 8, 4, -4,  0], 1.0 / (3.0 * Math.sqrt(70.0)), 2],
#     [:coupling_3j_e, [-1, 1, 2, 1, -1, 0], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_3j_e, [1, -1, 2, 1, -1, 0], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_3j_e, [1, 1, -2, 1, -1, 0], GSL::NAN, GSL::NAN, GSL::EDOM],
      [:coupling_3j_e, [1, 1, 2, 2, -1, 0], 0, 0.0],
      [:coupling_3j_e, [1, 1, 2, 1, -2, 0], 0, 0.0],
      [:coupling_3j_e, [1, 1, 2, 1, -1, 3], 0, 0.0],
      [:coupling_3j_e, [1, 1, 3, 1, -1, 0], 0, 0.0],
      [:coupling_3j_e, [1, 4, 2, 1, -1, 0], 0, 0.0],
      [:coupling_3j_e, [4, 1, 2, 1, -1, 0], 0, 0.0],
      [:coupling_6j_e, [2, 2, 4, 2, 2, 2],  1.0 / 6.0, 0],
      [:coupling_6j_e, [4, 4, 2, 4, 4, 4], -1.0 / 10.0, 0],
      [:coupling_6j_e, [4, 4, 2, 4, 4, 2],  1.0 / 6.0, 0],
      [:coupling_6j_e, [4, 4, 2, 2, 2, 2], -0.5 / Math.sqrt(5.0), 0],
      [:coupling_6j_e, [4, 4, 4, 2, 2, 2],  Math.sqrt(7.0 / 3.0) / 10.0, 0],
      [:coupling_6j_e, [6, 6, 6, 4, 4, 4], -Math.sqrt(3.0 / 5.0) / 14.0, 0],
      [:coupling_6j_e, [6, 6, 6, 4, 4, 2], -Math.sqrt(3.0 / 5.0) / 7.0, 0],
#     [:coupling_6j_e, [-2, 2, 4, 2, 2, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_6j_e, [2, -2, 4, 2, 2, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_6j_e, [2, 2, -4, 2, 2, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_6j_e, [2, 2, 4, -2, 2, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_6j_e, [2, 2, 4, 2, -2, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_6j_e, [2, 2, 4, 2, 2, -2], GSL::NAN, GSL::NAN, GSL::EDOM],
      [:coupling_6j_e, [2, 2, 4, 2, 2, 7], 0, 0.0],
      [:coupling_6j_e, [2, 2, 4, 2, 7, 2], 0, 0.0],
      [:coupling_6j_e, [2, 2, 4, 7, 2, 2], 0, 0.0],
      [:coupling_6j_e, [2, 2, 7, 2, 2, 2], 0, 0.0],
      [:coupling_6j_e, [2, 7, 4, 2, 2, 2], 0, 0.0],
      [:coupling_6j_e, [7, 2, 4, 2, 2, 2], 0, 0.0],
      [:coupling_9j_e, [4, 2,  4, 3, 3, 2, 1, 1, 2], -Math.sqrt(1.0 / 6.0) / 10.0, 2],
      [:coupling_9j_e, [8, 4, 10, 7, 3, 8, 1, 1, 2],  Math.sqrt(7.0 / 3.0) / 60.0, 2],
#     [:coupling_9j_e, [-4, 2, 4, 3, 3, 2, 1, 1, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_9j_e, [4, -2, 4, 3, 3, 2, 1, 1, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_9j_e, [4, 2, -4, 3, 3, 2, 1, 1, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_9j_e, [4, 2, 4, -3, 3, 2, 1, 1, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_9j_e, [4, 2, 4, 3, -3, 2, 1, 1, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_9j_e, [4, 2, 4, 3, 3, -2, 1, 1, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_9j_e, [4, 2, 4, 3, 3, 2, -1, 1, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_9j_e, [4, 2, 4, 3, 3, 2, 1, -1, 2], GSL::NAN, GSL::NAN, GSL::EDOM],
#     [:coupling_9j_e, [4, 2, 4, 3, 3, 2, 1, 1, -2], GSL::NAN, GSL::NAN, GSL::EDOM],
      [:coupling_9j_e, [10, 2, 4, 3, 3, 2, 1, 1, 2], 0, 0.0],
      [:coupling_9j_e, [4, 10, 4, 3, 3, 2, 1, 1, 2], 0, 0.0],
      [:coupling_9j_e, [4, 2, 10, 3, 3, 2, 1, 1, 2], 0, 0.0],
      [:coupling_9j_e, [4, 2, 4, 10, 3, 2, 1, 1, 2], 0, 0.0],
      [:coupling_9j_e, [4, 2, 4, 3, 10, 2, 1, 1, 2], 0, 0.0],
      [:coupling_9j_e, [4, 2, 4, 3, 3, 10, 1, 1, 2], 0, 0.0],
      [:coupling_9j_e, [4, 2, 4, 3, 3, 2, 10, 1, 2], 0, 0.0],
      [:coupling_9j_e, [4, 2, 4, 3, 3, 2, 1, 10, 2], 0, 0.0],
      [:coupling_9j_e, [4, 2, 4, 3, 3, 2, 1, 1, 10], 0, 0.0],
      [:dawson_e, [1.0e-15], 1.0e-15, 0],
      [:dawson_e, [0.5], 0.4244363835020222959, 0],
      [:dawson_e, [2.0], 0.30134038892379196603, 0],
      [:dawson_e, [1000.0], 0.0005000002500003750009, 0],
      [:debye_1_e, [0.1],  0.975277750004723276, 0],
      [:debye_1_e, [1.0],  0.777504634112248239, 0],
      [:debye_1_e, [10.0], 0.164443465679946027, 0],
      [:debye_2_e, [0.1],  0.967083287045302664,  0],
      [:debye_2_e, [1.0],  0.70787847562782924,   0],
      [:debye_2_e, [10.0], 0.0479714980201218708, 0],
      [:debye_3_e, [0.1],  0.962999940487211048,  0],
      [:debye_3_e, [1.0],  0.674415564077814667,  0],
      [:debye_3_e, [10.0], 0.0192957656903454886, 0],
      [:debye_4_e, [0.1],  0.960555486124335944,   0],
      [:debye_4_e, [1.0],  0.654874068886737049,   0],
      [:debye_4_e, [10.0], 0.00967367556027115896, 0],
      [:multiply_e, [-3.0,2.0], -6.0,          0],
      [:multiply_e, [0.2 * GSL::DBL_MAX, 1.0 / (0.2 * GSL::DBL_MAX)],  1.0,          0],
      [:multiply_e, [0.2 * GSL::DBL_MAX, 0.2],    0.04 * GSL::DBL_MAX, 1],
      [:multiply_e, [0.2 * GSL::DBL_MAX, 4.0],    0.8 * GSL::DBL_MAX,  1],
      [:ellint_Kcomp_e, [ 0.99, GSL::MODE_DEFAULT], 3.3566005233611923760, 0],
      [:ellint_Kcomp_e, [ 0.50, GSL::MODE_DEFAULT], 1.6857503548125960429, 0],
      [:ellint_Kcomp_e, [0.010, GSL::MODE_DEFAULT], 1.5708355989121522360, 0],
      [:ellint_Ecomp_e, [0.99, GSL::MODE_DEFAULT], 1.0284758090288040010, 0],
      [:ellint_Ecomp_e, [0.50, GSL::MODE_DEFAULT], 1.4674622093394271555, 0],
      [:ellint_Ecomp_e, [0.01, GSL::MODE_DEFAULT], 1.5707570561503852873, 0],
      [:ellint_F_e, [GSL::M_PI / 3.0, 0.99, GSL::MODE_DEFAULT], 1.3065333392738766762, 0],
      [:ellint_F_e, [GSL::M_PI / 3.0, 0.50, GSL::MODE_DEFAULT], 1.0895506700518854093, 0],
      [:ellint_F_e, [GSL::M_PI / 3.0, 0.01, GSL::MODE_DEFAULT], 1.0472129063770918952, 0],
      [:ellint_E_e, [GSL::M_PI / 3.0, 0.99, GSL::MODE_DEFAULT], 0.8704819220377943536, 0],
      [:ellint_E_e, [GSL::M_PI / 3.0, 0.50, GSL::MODE_DEFAULT], 1.0075555551444720293, 0],
      [:ellint_E_e, [GSL::M_PI / 3.0, 0.01, GSL::MODE_DEFAULT], 1.0471821963889481104, 0],
      [:ellint_P_e, [GSL::M_PI / 3.0, 0.99, 0.5, GSL::MODE_DEFAULT], 1.1288726598764099882, 0],
      [:ellint_P_e, [GSL::M_PI / 3.0, 0.50, 0.5, GSL::MODE_DEFAULT], 0.9570574331323584890, 0],
      [:ellint_P_e, [GSL::M_PI / 3.0, 0.01, 0.5, GSL::MODE_DEFAULT], 0.9228868127118118465, 0],
      [:ellint_RF_e, [5.0e-11, 1.0e-10, 1.0, GSL::MODE_DEFAULT], 12.36441982979439, 0],
      [:ellint_RF_e, [1.0, 2.0, 3.0, GSL::MODE_DEFAULT], 0.7269459354689082, 0],
      [:ellint_RD_e, [5.0e-11, 1.0e-10, 1.0, GSL::MODE_DEFAULT], 34.0932594919337362, 0],
      [:ellint_RD_e, [1.0, 2.0, 3.0, GSL::MODE_DEFAULT], 0.2904602810289906, 0],
      [:ellint_RC_e, [1.0, 2.0, GSL::MODE_DEFAULT], 0.7853981633974482, 0],
      [:ellint_RJ_e, [2.0, 3.0, 4.0, 5.0, GSL::MODE_DEFAULT], 0.1429757966715675, 0],
      [:erfc_e, [-10.0], 2.0, 0],
      [:erfc_e, [-5.0000002], 1.9999999999984625433, 0],
      [:erfc_e, [-5.0], 1.9999999999984625402, 0],
      [:erfc_e, [-1.0], 1.8427007929497148693, 0],
      [:erfc_e, [-0.5], 1.5204998778130465377, 0],
      [:erfc_e, [1.0], 0.15729920705028513066, 0],
      [:erfc_e, [3.0], 0.000022090496998585441373, 1],
      [:erfc_e, [7.0], 4.183825607779414399e-23, 2],
      [:erfc_e, [10.0], 2.0884875837625447570e-45, 2],
      [:log_erfc_e, [-1.0], Math.log(1.842700792949714869), 0],
      [:log_erfc_e, [-0.1], 0.106576400586522485015, 0],
      [:log_erfc_e, [-1e-10],  1.1283791670318505967e-10, 0],
      [:log_erfc_e, [0.0], Math.log(1.0), 0],
      [:log_erfc_e, [1e-10], -1.128379167159174551e-10, 0],
      [:log_erfc_e, [0.001], -0.0011290158896213548027, 0],
      [:log_erfc_e, [0.1], -0.119304973737395598329, 0],
      [:log_erfc_e, [1.0], Math.log(0.15729920705028513066), 0],
      [:log_erfc_e, [10.0], Math.log(2.0884875837625447570e-45), 0],
      [:erf_e, [-10.0], -1.0000000000000000000, 0],
      [:erf_e, [0.5], 0.5204998778130465377, 0],
      [:erf_e, [1.0], 0.8427007929497148693, 0],
      [:erf_e, [10.0], 1.0000000000000000000, 0],
      [:erf_Z_e, [1.0],  0.24197072451914334980,   0],
      [:erf_Q_e, [10.0], 7.619853024160526066e-24, 2],
      [:hazard_e, [-20.0], 5.5209483621597631896e-88, 2],
      [:hazard_e, [-10.0], 7.6945986267064193463e-23, 2],
      [:hazard_e, [-1.0], 0.28759997093917836123, 0],
      [:hazard_e, [ 0.0], 0.79788456080286535588, 0],
      [:hazard_e, [ 1.0], 1.5251352761609812091, 0],
      [:hazard_e, [10.0], 10.098093233962511963, 2],
      [:hazard_e, [20.0], 20.049753068527850542, 2],
      [:hazard_e, [30.0], 30.033259667433677037, 2],
      [:hazard_e, [50.0], 50.019984031905639809, 0],
      [:hazard_e, [80.0], 80.012496096798234468, 0],
      [:hazard_e, [150.0], 150.00666607420571802, 0],
      [:hazard_e, [300.0], 300.00333325926337415, 0],
      [:hazard_e, [900.0], 900.00111110836764382, 0],
      [:hazard_e, [1001.0], 1001.0009989990049990, 0],
      [:hazard_e, [2000.0], 2000.0004999997500003, 0],
      [:exp_e, [-10.0], Math.exp(-10.0), 0],
      [:exp_e, [ 10.0], Math.exp( 10.0), 0],
      [:exp_err_e, [-10.0, TEST_TOL[1]], Math.exp(-10.0), 1],
      [:exp_err_e, [ 10.0, TEST_TOL[1]], Math.exp( 10.0), 1],
      [:exp_mult_e, [-10.0,  1.0e-06], 1.0e-06 * Math.exp(-10.0), 0],
      [:exp_mult_e, [-10.0,  2.0],     2.0 * Math.exp(-10.0),     0],
      [:exp_mult_e, [-10.0, -2.0],    -2.0 * Math.exp(-10.0),     0],
      [:exp_mult_e, [ 10.0,  1.0e-06], 1.0e-06 * Math.exp( 10.0), 0],
      [:exp_mult_e, [ 10.0, -2.0],    -2.0 * Math.exp( 10.0),     0],
      [:exp_mult_e, [  0.0, 1.00001],      1.00001 * Math.exp(0),     3],
      [:exp_mult_e, [  0.0, 1.000001],     1.000001 * Math.exp(0),    3],
      [:exp_mult_e, [  0.0, 1.000000001],  1.000000001 * Math.exp(0), 3],
      [:exp_mult_e, [  0.0, 100.0],        100.0 * Math.exp(0),       3],
      [:exp_mult_e, [  0.0, 1.0e+20],      1.0e+20 * Math.exp(0),     3],
      [:exp_mult_e, [  0.0, Math.exp(0) * Math.exp(GSL::M_LN2)],  2.0, 4],
      [:exp_mult_err_e, [-10.0, TEST_SQRT_TOL0, 2.0, TEST_SQRT_TOL0], 2.0 * Math.exp(-10.0), TEST_SQRT_TOL0],
      [:exp_mult_err_e, [  0.0, 0, Math.exp(0) * Math.exp(GSL::M_LN2), 0],  2.0, TEST_SQRT_TOL0],
      [:expm1_e, [-10.0], Math.exp(-10.0)-1.0, 0],
      [:expm1_e, [-0.001], -0.00099950016662500845, 0],
      [:expm1_e, [-1.0e-8], -1.0e-08 + 0.5e-16, 0],
      [:expm1_e, [ 1.0e-8], 1.0e-08 + 0.5e-16, 0],
      [:expm1_e, [ 0.001], 0.0010005001667083417, 0],
      [:expm1_e, [ 10.0], Math.exp(10.0)-1.0, 0],
      [:exprel_e, [-10.0], 0.0999954600070237515, 0],
      [:exprel_e, [-0.001], 0.9995001666250084, 0],
      [:exprel_e, [-1.0e-8], 1.0 - 0.5e-08, 0],
      [:exprel_e, [ 1.0e-8], 1.0 + 0.5e-08, 0],
      [:exprel_e, [ 0.001], 1.0005001667083417, 0],
      [:exprel_e, [ 10.0], 2202.5465794806716517, 0],
      [:exprel_2_e, [-10.0], 0.18000090799859524970, 0],
      [:exprel_2_e, [-0.001], 0.9996667499833361107, 0],
      [:exprel_2_e, [-1.0e-8], 0.9999999966666666750, 0],
      [:exprel_2_e, [ 1.0e-8], 1.0000000033333333417, 0],
      [:exprel_2_e, [ 0.001], 1.0003334166833361115, 0],
      [:exprel_2_e, [ 10.0], 440.3093158961343303, 0],
      [:exprel_n_e, [3, -1000.0], 0.00299400600000000000, 0],
      [:exprel_n_e, [3, -100.0], 0.02940600000000000000, 0],
      [:exprel_n_e, [3, -10.0], 0.24599972760042142509, 0],
      [:exprel_n_e, [3, -3.0], 0.5444917625849191238, 0],
      [:exprel_n_e, [3, -0.001], 0.9997500499916678570, 0],
      [:exprel_n_e, [3, -1.0e-8], 0.9999999975000000050, 0],
      [:exprel_n_e, [3,  1.0e-8], 1.0000000025000000050, 0],
      [:exprel_n_e, [3,  0.001], 1.0002500500083345240, 0],
      [:exprel_n_e, [3,  3.0], 2.5745637607083706091, 0],
      [:exprel_n_e, [3,  3.1], 2.6772417068460206247, 0],
      [:exprel_n_e, [3,  10.0], 131.79279476884029910, 1],
      [:exprel_n_e, [3,  100.0], 1.6128702850896812690e+38, 2],
      [:exprel_n_e, [50, -1000.0], 0.04766231609253975959, 0],
      [:exprel_n_e, [50, -100.0], 0.3348247572345889317, 0],
      [:exprel_n_e, [50, -10.0], 0.8356287051853286482, 0],
      [:exprel_n_e, [50, -3.0], 0.9443881609152163615, 0],
      [:exprel_n_e, [50, -1.0], 0.980762245565660617, 0],
      [:exprel_n_e, [50, -1.0e-8], 1.0 - 1.0e-8 / 51.0, 0],
      [:exprel_n_e, [50,  1.0e-8], 1.0 + 1.0e-8 / 51.0, 0],
      [:exprel_n_e, [50,  1.0], 1.01999216583666790, 0],
      [:exprel_n_e, [50,  3.0], 1.0624205757460368307, 0],
      [:exprel_n_e, [50,  48.0], 7.499573876877194416, 0],
      [:exprel_n_e, [50,  50.1], 9.311803306230992272, 4],
      [:exprel_n_e, [50,  100.0], 8.175664432485807634e+07, 4],
      [:exprel_n_e, [50,  500.0], 4.806352370663185330e+146, 3],
      [:exprel_n_e, [500, -1000.0], 0.3334815803127619256, 0],
      [:exprel_n_e, [500, -100.0], 0.8335646217536183909, 0],
      [:exprel_n_e, [500, -10.0], 0.9804297803131823066, 0],
      [:exprel_n_e, [500, -3.0], 0.9940475488850672997, 0],
      [:exprel_n_e, [500, -1.0], 0.9980079602383488808, 0],
      [:exprel_n_e, [500, -1.0e-8], 1.0 - 1.0e-8 / 501.0, 0],
      [:exprel_n_e, [500,  1.0e-8], 1.0 + 1.0e-8 / 501.0, 0],
      [:exprel_n_e, [500,  1.0], 1.0019999920160634252, 0],
      [:exprel_n_e, [500,  3.0], 1.0060240236632444934, 0],
      [:exprel_n_e, [500,  48.0], 1.1059355517981272174, 0],
      [:exprel_n_e, [500,  100.0], 1.2492221464878287204, 1],
      [:exprel_n_e, [500,  500.0], 28.363019877927630858, 2],
      [:exprel_n_e, [500,  1000.0], 2.4037563160335300322e+68, 4],
      [:exprel_n_e, [500,  1600.0], 7.899293535320607403e+226, 4],
      [:expint_E1_e, [-1.0], -1.8951178163559367555, 0],
      [:expint_E1_e, [1.0e-10], 22.448635265138923980, 0],
      [:expint_E1_e, [1.0e-05], 10.935719800043695615, 0],
      [:expint_E1_e, [0.1], 1.82292395841939066610, 0],
      [:expint_E1_e, [1.0], 0.21938393439552027368, 0],
      [:expint_E1_e, [10.0], 4.156968929685324277e-06, 1],
      [:expint_E1_e, [50.0], 3.783264029550459019e-24, 2],
      [:expint_E1_e, [300.0], 1.710384276804510115e-133, 2],
      [:expint_E2_e, [-1.0], 0.8231640121031084799, 1],
      [:expint_E2_e, [1.0 / 4294967296.0], 0.9999999947372139168, 0],
      [:expint_E2_e, [1.0 / 65536.0], 0.9998243233207178845, 0],
      [:expint_E2_e, [0.1], 0.7225450221940205066, 0],
      [:expint_E2_e, [1.0], 0.14849550677592204792, 0],
      [:expint_E2_e, [10.0], 3.830240465631608762e-06, 1],
      [:expint_E2_e, [50.0], 3.711783318868827367e-24, 2],
      [:expint_E2_e, [300.0], 1.7047391998483433998e-133, 2],
    #if GSL::GSL_VERSION >= '1.9.90'
      [:expint_En_e, [1, -1.0], -1.8951178163559367555, 2],
      [:expint_En_e, [1, 1.0e-10],  22.448635265138923980, 2],
      [:expint_En_e, [1, 1.0e-5], 10.93571980004369561, 2],
      [:expint_En_e, [1,0.1], 1.82292395841939066610, 0],
      [:expint_En_e, [1,1.0], 0.21938393439552027368, 0],
      [:expint_En_e, [1,10.0], 4.156968929685324277e-06, 1],
      [:expint_En_e, [1,50.0], 3.783264029550459019e-24, 2],
      [:expint_En_e, [1,300.0], 1.710384276804510115e-133, 2],

      [:expint_En_e, [2,-1.0], 0.8231640121031084799, 1],
      [:expint_En_e, [2,0.0], 1.0, 0],
      [:expint_En_e, [2,1.0 / 4294967296.0], 0.9999999947372139168, 0],
      [:expint_En_e, [2,1.0 / 65536.0], 0.9998243233207178845, 0],
      [:expint_En_e, [2,0.1], 0.7225450221940205066, 0],
      [:expint_En_e, [2,1.0], 0.14849550677592204792, 0],
      [:expint_En_e, [2,10.0], 3.830240465631608762e-06, 1],
      [:expint_En_e, [2,50.0], 3.711783318868827367e-24, 2],
      [:expint_En_e, [2,300.0], 1.7047391998483433998e-133, 2],

      [:expint_En_e, [3,0.0], 0.5, 0],
      [:expint_En_e, [3,1.0 / 4294967296.0], 0.499999999767169356972, 1],
      [:expint_En_e, [3,1.0 / 65536.0], 0.4999847426094515610, 0],
      [:expint_En_e, [3,0.1], 0.4162914579082787612543, 0],
      [:expint_En_e, [3,1.0], 0.10969196719776013683858, 1],
      [:expint_En_e, [3,10.0],0.000003548762553084381959981, 1],
      [:expint_En_e, [3,50.0], 3.6429094264752049812e-24, 2],
      [:expint_En_e, [3,300.0],1.699131143349179084e-133, 2],

      [:expint_En_e, [10,0.0], 0.111111111111111111, 0],
      [:expint_En_e, [10,1.0 / 4294967296.0], 0.111111111082007280658, 2],
      [:expint_En_e, [10,1.0 / 65536.0], 0.11110920377910896018606, 1],
      [:expint_En_e, [10,0.1], 0.099298432000896813567905, 1],
      [:expint_En_e, [10,1.0], 0.036393994031416401634164534, 1],
      [:expint_En_e, [10,10.0], 0.00000232530265702821081778968, 1],
      [:expint_En_e, [10,50.0], 3.223296586749110919572e-24, 2],
      [:expint_En_e, [10,300.0], 1.6608815083360041367294736e-133, 2],
    #end
      [:expint_Ei_e, [-1.0],   -0.21938393439552027368, 0],
      [:expint_Ei_e, [1.0 / 4294967296.0], -21.603494112783886397, 0],
      [:expint_Ei_e, [1.0], 1.8951178163559367555, 0],
      [:expint_E1_scaled_e, [-10000.0], -0.00010001000200060024012, 0],
      [:expint_E1_scaled_e, [-1000.0], -0.0010010020060241207251, 0],
      [:expint_E1_scaled_e, [-10.0], -0.11314702047341077803, 0],
      [:expint_E1_scaled_e, [-1.0], -0.69717488323506606877, 0],
      [:expint_E1_scaled_e, [1.0e-10], 22.448635267383787506, 0],
      [:expint_E1_scaled_e, [1.0e-05], 10.935829157788483865, 0],
      [:expint_E1_scaled_e, [0.1], 2.0146425447084516791, 0],
      [:expint_E1_scaled_e, [1.0], 0.59634736232319407434, 0],
      [:expint_E1_scaled_e, [10.0], 0.091563333939788081876, 0],
      [:expint_E1_scaled_e, [50.0], 0.019615109930114870365, 0],
      [:expint_E1_scaled_e, [300.0], 0.0033222955652707070644, 0],
      [:expint_E1_scaled_e, [1000.0], 0.00099900199402388071500, 0],
      [:expint_E1_scaled_e, [10000.0], 0.000099990001999400239880, 0],
      [:expint_E2_scaled_e, [-10000.0], -0.00010002000600240120072, 3],
      [:expint_E2_scaled_e, [-1000.0], -0.0010020060241207250807, 3],
      [:expint_E2_scaled_e, [-10.0], -0.13147020473410778034, 1],
      [:expint_E2_scaled_e, [-1.0], 0.30282511676493393123, 1],
      [:expint_E2_scaled_e, [1.0 / 4294967296.0], 0.99999999497004455927, 0],
      [:expint_E2_scaled_e, [1.0 / 65536.0], 0.99983957954556245453, 0],
      [:expint_E2_scaled_e, [0.1], 0.79853574552915483209, 0],
      [:expint_E2_scaled_e, [1.0], 0.40365263767680592566, 0],
      [:expint_E2_scaled_e, [10.0], 0.084366660602119181239, 1],
      [:expint_E2_scaled_e, [50.0], 0.019244503494256481735, 2],
      [:expint_E2_scaled_e, [300.0], 0.0033113304187878806691, 0],
      [:expint_E2_scaled_e, [1000.0], 0.00099800597611928500004, 0],
      [:expint_E2_scaled_e, [10000.0], 0.000099980005997601199281, 0],
      [:expint_Ei_scaled_e, [-1000.0], -0.00099900199402388071500, 0],
      [:expint_Ei_scaled_e, [-1.0], -0.59634736232319407434, 0],
      [:expint_Ei_scaled_e, [1.0 / 4294967296.0], -21.603494107753930958, 0],
      [:expint_Ei_scaled_e, [1.0], 0.69717488323506606877, 0],
      [:expint_Ei_scaled_e, [1000.0], 0.0010010020060241207251, 0],
      [:Shi_e, [-1.0], -1.0572508753757285146, 0],
      [:Shi_e, [1.0 / 4294967296.0], 2.3283064365386962891e-10, 0],
      [:Shi_e, [1.0 / 65536.0], 0.00001525878906269737298, 0],
      [:Shi_e, [0.1], 0.1000555722250569955, 0],
      [:Shi_e, [1.0], 1.0572508753757285146, 0],
      [:Shi_e, [10.0], 1246.1144901994233444, 1],
      [:Shi_e, [50.0], 5.292818448565845482e+19, 2],
      [:Shi_e, [300.0], 3.248241254044332895e+127, 2],
      [:Chi_e, [-1.0], 0.8378669409802082409, 0],
      [:Chi_e, [1.0 / 4294967296.0], -21.603494113016717041, 0],
      [:Chi_e, [1.0 / 65536.0], -10.513139223999384429, 0],
      [:Chi_e, [1.0 / 8.0], -1.4983170827635760646, 0],
      [:Chi_e, [1.0], 0.8378669409802082409, 0],
      [:Chi_e, [10.0], 1246.1144860424544147, 1],
      [:Chi_e, [50.0], 5.292818448565845482e+19, 2],
      [:Chi_e, [300.0], 3.248241254044332895e+127, 2],
      [:expint_3_e, [1.0e-10], 1.0e-10, 0],
      [:expint_3_e, [1.0e-05], 9.9999999999999975e-06, 0],
      [:expint_3_e, [0.1], 0.09997500714119079665122, 0],
      [:expint_3_e, [0.5], 0.48491714311363971332427, 0],
      [:expint_3_e, [1.0], 0.80751118213967145285833, 0],
      [:expint_3_e, [2.0], 0.89295351429387631138208, 0],
      [:expint_3_e, [5.0], 0.89297951156924921121856, 0],
      [:expint_3_e, [10.0], 0.89297951156924921121856, 0],
      [:expint_3_e, [100.0], 0.89297951156924921121856, 0],
      [:Si_e, [-1.0], -0.9460830703671830149, 0],
      [:Si_e, [1.0e-10], 1.0e-10, 0],
      [:Si_e, [1.0e-05], 9.999999999944444444e-06, 0],
      [:Si_e, [0.1], 0.09994446110827695016, 0],
      [:Si_e, [1.0], 0.9460830703671830149, 0],
      [:Si_e, [10.0], 1.6583475942188740493, 0],
      [:Si_e, [50.0], 1.5516170724859358947, 0],
      [:Si_e, [300.0], 1.5708810882137495193, 0],
      [:Si_e, [1.0e+20], 1.5707963267948966192, 0],
      [:Ci_e, [1.0 / 4294967296.0], -21.603494113016717041, 0],
      [:Ci_e, [1.0 / 65536.0], -10.513139224115799751, 0],
      [:Ci_e, [1.0 / 8.0], -1.5061295845296396649, 0],
      [:Ci_e, [1.0], 0.3374039229009681347, 0],
      [:Ci_e, [10.0], -0.04545643300445537263, 0],
      [:Ci_e, [50.0], -0.005628386324116305440, 0],
      [:Ci_e, [300.0], -0.003332199918592111780, 0],
      [:Ci_e, [65536.0], 0.000010560248837656279453, 0],
      [:Ci_e, [4294967296.0], -1.0756463261957757485e-10, TEST_SQRT_TOL0],
      [:Ci_e, [1099511627776.0], -3.689865584710764214e-13, 1024.0 * TEST_SQRT_TOL0],
      [:atanint_e, [1.0e-10], 1.0e-10, 0],
      [:atanint_e, [1.0e-05], 9.99999999988888888889e-06, 0],
      [:atanint_e, [0.1], 0.09988928686033618404, 0],
      [:atanint_e, [1.0], 0.91596559417721901505, 0],
      [:atanint_e, [2.0], 1.57601540344632342236, 0],
      [:atanint_e, [10.0], 3.71678149306806859029, 0],
      [:atanint_e, [50.0], 6.16499047850274874222, 0],
      [:atanint_e, [300.0], 8.96281388924518959990, 0],
      [:atanint_e, [1.0e+5], 18.084471031038661920, 0],
      [:fermi_dirac_m1_e, [-10.0], 0.00004539786870243439450, 0],
      [:fermi_dirac_m1_e, [ -1.0], 0.26894142136999512075, 0],
      [:fermi_dirac_m1_e, [  1.0], 0.7310585786300048793, 0],
      [:fermi_dirac_m1_e, [ 10.0], 0.9999546021312975656, 0],
      [:fermi_dirac_0_e, [-10.0], 0.00004539889921686464677, 0],
      [:fermi_dirac_0_e, [ -1.0], 0.31326168751822283405, 0],
      [:fermi_dirac_0_e, [  1.0], 1.3132616875182228340, 0],
      [:fermi_dirac_0_e, [ 10.0], 10.000045398899216865, 0],
      [:fermi_dirac_1_e, [-10.0], 0.00004539941448447633524, 0],
      [:fermi_dirac_1_e, [ -2.0], 0.13101248471442377127, 0],
      [:fermi_dirac_1_e, [ -1.0], 0.3386479964034521798, 0],
      [:fermi_dirac_1_e, [ -0.4], 0.5825520806897909028, 0],
      [:fermi_dirac_1_e, [  0.4], 1.1423819861584355337, 0],
      [:fermi_dirac_1_e, [  1.0], 1.8062860704447742567, 0],
      [:fermi_dirac_1_e, [  1.5], 2.5581520872227806402, 0],
      [:fermi_dirac_1_e, [  2.5], 4.689474797599761667, 0],
      [:fermi_dirac_1_e, [ 10.0], 51.64488866743374196, 0],
      [:fermi_dirac_1_e, [ 12.0], 73.64492792264531092, 0],
      [:fermi_dirac_1_e, [ 20.0], 201.64493406478707282, 0],
      [:fermi_dirac_1_e, [ 50.0], 1251.6449340668482264, 0],
      [:fermi_dirac_2_e, [-10.0], 0.00004539967212174776662, 0],
      [:fermi_dirac_2_e, [ -2.0], 0.13313272938565030508, 0],
      [:fermi_dirac_2_e, [ -1.0], 0.3525648792978077590, 0],
      [:fermi_dirac_2_e, [ -0.4], 0.6229402647001272120, 0],
      [:fermi_dirac_2_e, [  0.4], 1.2915805581060844533, 0],
      [:fermi_dirac_2_e, [  1.0], 2.1641656128127008622, 0],
      [:fermi_dirac_2_e, [  1.5], 3.247184513920792475, 0],
      [:fermi_dirac_2_e, [  2.5], 6.797764392735056317, 0],
      [:fermi_dirac_2_e, [ 10.0], 183.11605273482105278, 0],
      [:fermi_dirac_2_e, [ 12.0], 307.73921494638635166, 0],
      [:fermi_dirac_2_e, [ 20.0], 1366.2320146723590157, 0],
      [:fermi_dirac_2_e, [ 50.0], 20915.580036675744655, 0],
      [:fermi_dirac_2_e, [200.0], 1.3336623201467029786e+06, 0],
      [:fermi_dirac_mhalf_e, [-10.0], 0.00004539847236080549532, 0],
      [:fermi_dirac_mhalf_e, [ -2.0], 0.12366562180120994266, 0],
      [:fermi_dirac_mhalf_e, [ -1.0], 0.29402761761145122022, 0],
      [:fermi_dirac_mhalf_e, [ -0.4], 0.4631755336886027800, 0],
      [:fermi_dirac_mhalf_e, [  0.4], 0.7654084737661656915, 0],
      [:fermi_dirac_mhalf_e, [  1.0], 1.0270571254743506890, 0],
      [:fermi_dirac_mhalf_e, [  1.5], 1.2493233478527122008, 0],
      [:fermi_dirac_mhalf_e, [  2.5], 1.6663128834358313625, 0],
      [:fermi_dirac_mhalf_e, [ 10.0], 3.552779239536617160, 0],
      [:fermi_dirac_mhalf_e, [ 12.0], 3.897268231925439359, 0],
      [:fermi_dirac_mhalf_e, [ 20.0], 5.041018507535328603, 0],
      [:fermi_dirac_mhalf_e, [ 50.0], 7.977530858581869960, 1],
      [:fermi_dirac_half_e, [-10.0], 0.00004539920105264132755, 1],
      [:fermi_dirac_half_e, [ -2.0], 0.12929851332007559106, 0],
      [:fermi_dirac_half_e, [ -1.0], 0.3277951592607115477, 0],
      [:fermi_dirac_half_e, [ -0.4], 0.5522452153690688947, 0],
      [:fermi_dirac_half_e, [  0.4], 1.0386797503389389277, 0],
      [:fermi_dirac_half_e, [  1.0], 1.5756407761513002308, 0],
      [:fermi_dirac_half_e, [  1.5], 2.1448608775831140360, 0],
      [:fermi_dirac_half_e, [  2.5], 3.606975377950373251, 0],
      [:fermi_dirac_half_e, [ 10.0], 24.084656964637653615, 0],
      [:fermi_dirac_half_e, [ 12.0], 31.540203287044242593, 0],
      [:fermi_dirac_half_e, [ 20.0], 67.49151222165892049, 0],
      [:fermi_dirac_half_e, [ 50.0], 266.09281252136259343, 1],
      [:fermi_dirac_3half_e, [-10.0], 0.00004539956540456176333, 0],
      [:fermi_dirac_3half_e, [ -2.0], 0.13224678225177236685, 0],
      [:fermi_dirac_3half_e, [ -1.0], 0.3466747947990574170, 0],
      [:fermi_dirac_3half_e, [ -0.4], 0.6056120213305040910, 0],
      [:fermi_dirac_3half_e, [  0.4], 1.2258236403963668282, 0],
      [:fermi_dirac_3half_e, [  1.0], 2.0022581487784644573, 0],
      [:fermi_dirac_3half_e, [  1.5], 2.9277494127932173068, 0],
      [:fermi_dirac_3half_e, [  2.5], 5.768879312210516582, 0],
      [:fermi_dirac_3half_e, [ 10.0], 101.00510084332600020, 2],
      [:fermi_dirac_3half_e, [ 12.0], 156.51518642795728036, 1],
      [:fermi_dirac_3half_e, [ 20.0], 546.5630100657601959, 1],
      [:fermi_dirac_3half_e, [ 50.0], 5332.353566687145552, 1],
      [:fermi_dirac_int_e, [3,  -2.0], 0.1342199155038680215, 0],
      [:fermi_dirac_int_e, [3,   0.0], 0.9470328294972459176, 0],
      [:fermi_dirac_int_e, [3,   0.1], 1.0414170610956165759, 0],
      [:fermi_dirac_int_e, [3,   1.0], 2.3982260822489407070, 0],
      [:fermi_dirac_int_e, [3,   3.0], 12.621635313399690724, 1],
      [:fermi_dirac_int_e, [3, 100.0], 4.174893231066566793e+06, 1],
      [:fermi_dirac_int_e, [3, 500.0], 2.604372285319088354e+09, 1],
      [:fermi_dirac_int_e, [5,  -2.0], 0.13505242246823676478, 0],
      [:fermi_dirac_int_e, [5,   0.0], 0.9855510912974351041, 0],
      [:fermi_dirac_int_e, [5,   0.1], 1.0876519750101492782, 0],
      [:fermi_dirac_int_e, [5,   1.0], 2.6222337848692390539, 0],
      [:fermi_dirac_int_e, [5,   3.0], 17.008801618012113022, 1],
      [:fermi_dirac_int_e, [5, 100.0], 1.3957522531334869874e+09, 1],
      [:fermi_dirac_int_e, [5, 500.0], 2.1705672808114817955e+13, 2],
      [:fermi_dirac_int_e, [7,  -2.0], 0.1352641105671255851, 0],
      [:fermi_dirac_int_e, [7,   0.0], 0.9962330018526478992, 0],
      [:fermi_dirac_int_e, [7,   0.1], 1.1005861815180315485, 0],
      [:fermi_dirac_int_e, [7,   1.0], 2.6918878172003129203, 0],
      [:fermi_dirac_int_e, [7,   3.0], 19.033338976999367642, 2],
      [:fermi_dirac_int_e, [7,  10.0], 5654.530932873610014, 1],
      [:fermi_dirac_int_e, [7,  50.0], 1.005005069985066278e+09, 2],
      [:fermi_dirac_int_e, [7, 500.0], 9.691690268341569514e+16, 3],
      [:fermi_dirac_int_e, [9,  -2.0], 0.1353174385330242691, 0],
      [:fermi_dirac_int_e, [9,   0.0], 0.9990395075982715656, 0],
      [:fermi_dirac_int_e, [9,   0.1], 1.1039997234712941212, 0],
      [:fermi_dirac_int_e, [9,   1.0], 2.7113648898129249947, 0],
      [:fermi_dirac_int_e, [9,   3.0], 19.768544008138602223, 2],
      [:fermi_dirac_int_e, [9,  10.0], 10388.990167312912478, 2],
      [:fermi_dirac_int_e, [9,  50.0], 2.85466960802601649e+10, 1],
      [:fermi_dirac_int_e, [9, 500.0], 2.69273849842695876e+20, 2 * 1],
      [:fermi_dirac_int_e, [10,  -2.0], 0.13532635396712288092, 0],
      [:fermi_dirac_int_e, [10,   0.0], 0.9995171434980607541, 0],
      [:fermi_dirac_int_e, [10,   0.1], 1.1045818238852612296, 0],
      [:fermi_dirac_int_e, [10,   1.0], 2.7147765350346120647, 0],
      [:fermi_dirac_int_e, [10,   3.0], 19.917151938411675171, 1],
      [:fermi_dirac_int_e, [10,  10.0], 12790.918595516495955, 2],
      [:fermi_dirac_int_e, [10,  50.0], 1.3147703201869657654e+11, 2],
      [:fermi_dirac_int_e, [10, 500.0], 1.2241331244469204398e+22, 2],
      [:fermi_dirac_int_e, [11,  -2.0], 0.1353308162894847149, 0],
      [:fermi_dirac_int_e, [11,   0.0], 0.9997576851438581909, 0],
      [:fermi_dirac_int_e, [11,   0.1], 1.1048751811565850418, 0],
      [:fermi_dirac_int_e, [11,   1.0], 2.7165128749007313436, 0],
      [:fermi_dirac_int_e, [11,   3.0], 19.997483022044603065, 2],
      [:fermi_dirac_int_e, [11,  10.0], 14987.996005901818036, 2],
      [:fermi_dirac_int_e, [11,  50.0], 5.558322924078990628e+11, 2],
      [:fermi_dirac_int_e, [11, 500.0], 5.101293089606198280e+23, 2],
      [:fermi_dirac_int_e, [20,  -2.0], 0.13533527450327238373, 0],
      [:fermi_dirac_int_e, [20,   0.0], 0.9999995232582155428, 0],
      [:fermi_dirac_int_e, [20,   0.1], 1.1051703357941368203, 0],
      [:fermi_dirac_int_e, [20,   1.0], 2.7182783069905721654, 0],
      [:fermi_dirac_int_e, [20,   3.0], 20.085345296028242734, 2],
      [:fermi_dirac_int_e, [20,  10.0], 21898.072920149606475, 2],
      [:fermi_dirac_int_e, [20,  50.0], 1.236873256595717618e+16, 2],
      [:fermi_dirac_int_e, [20, 500.0], 9.358938204369557277e+36, 2],
      [:gegenpoly_1_e, [-0.2,   1.0], -0.4, 0],
      [:gegenpoly_1_e, [ 0.0,   1.0], 2.0, 0],
      [:gegenpoly_1_e, [ 1.0,   1.0], 2.0, 0],
      [:gegenpoly_1_e, [ 1.0,   0.5], 1.0, 0],
      [:gegenpoly_1_e, [ 5.0,   1.0], 10.0, 0],
      [:gegenpoly_1_e, [ 100.0, 0.5], 100.0, 0],
      [:gegenpoly_2_e, [-0.2,   0.5], 0.12, 0],
      [:gegenpoly_2_e, [ 0.0,   1.0], 1.00, 0],
      [:gegenpoly_2_e, [ 1.0,   1.0], 3.00, 0],
      [:gegenpoly_2_e, [ 1.0,   0.1], -0.96, 0],
      [:gegenpoly_2_e, [ 5.0,   1.0], 55.0, 0],
      [:gegenpoly_2_e, [ 100.0, 0.5], 4950.0, 0],
      [:gegenpoly_3_e, [-0.2,   0.5], 0.112, 0],
      [:gegenpoly_3_e, [ 0.0,   1.0], -2.0 / 3.0, 0],
      [:gegenpoly_3_e, [ 1.0,   1.0], 4.000, 0],
      [:gegenpoly_3_e, [ 1.0,   0.1], -0.392, 0],
      [:gegenpoly_3_e, [ 5.0,   1.0], 220.000, 0],
      [:gegenpoly_3_e, [ 100.0, 0.5], 161600.000, 0],
      [:gegenpoly_n_e, [1,       1.0, 1.0], 2.000, 0],
      [:gegenpoly_n_e, [10,      1.0, 1.0], 11.000, 0],
      [:gegenpoly_n_e, [10,      1.0, 0.1], -0.4542309376, 0],
      [:gegenpoly_n_e, [10,      5.0, 1.0], 9.23780e+4, 0],
      [:gegenpoly_n_e, [10,    100.0, 0.5], 1.5729338392690000e+13, 0],
      [:gegenpoly_n_e, [1000,  100.0, 1.0], 3.3353666135627322e+232, 1],
      [:gegenpoly_n_e, [100,  2000.0, 1.0], 5.8753432034937579e+202, 0],
      [:gegenpoly_n_e, [103,   207.0, 2.0], 1.4210272202235983e+145, 0],
      [:gegenpoly_n_e, [103,    -0.4, 0.3], -1.64527498094522e-04, 1],
      [:laguerre_1_e, [0.5, -1.0], 2.5, 0],
      [:laguerre_1_e, [0.5,  1.0], 0.5, 0],
      [:laguerre_1_e, [1.0,  1.0], 1.0, 0],
      [:laguerre_2_e, [ 0.5, -1.0], 4.875,  0],
      [:laguerre_2_e, [ 0.5,  1.0], -0.125, 0],
      [:laguerre_2_e, [ 1.0,  1.0],  0.5, 0],
      [:laguerre_2_e, [-1.0,  1.0], -0.5, 0],
      [:laguerre_2_e, [-2.0,  1.0],  0.5, 0],
      [:laguerre_2_e, [-3.0,  1.0],  2.5, 0],
      [:laguerre_3_e, [0.5, -1.0], 8.479166666666666667,    0],
      [:laguerre_3_e, [0.5,  1.0], -0.6041666666666666667,  0],
      [:laguerre_3_e, [1.0,  1.0], -0.16666666666666666667, 1],
      [:laguerre_3_e, [ 2.0,  1.0], 2.3333333333333333333,  0],
      [:laguerre_3_e, [-2.0,  1.0], 1.0 / 3.0,  0],
      [:laguerre_3_e, [-3.0,  1.0], -1.0 / 6.0, 0],
      [:laguerre_3_e, [-4.0,  1.0], -8.0 / 3.0, 0],
      [:laguerre_n_e, [1, 0.5, 1.0], 0.5, 0],
      [:laguerre_n_e, [2, 1.0, 1.0], 0.5, 1],
      [:laguerre_n_e, [3, 2.0, 1.0], 2.3333333333333333333,   1],
      [:laguerre_n_e, [4, 2.0, 0.5], 6.752604166666666667,    1],
      [:laguerre_n_e, [90, 2.0,  0.5], -48.79047157201507897, 1],
      [:laguerre_n_e, [90, 2.0, -100.0], 2.5295879275042410902e+63, 2],
      [:laguerre_n_e, [90, 2.0,  100.0], -2.0929042259546928670e+20, 1],
      [:laguerre_n_e, [100, 2.0, -0.5], 2.2521795545919391405e+07,  2],
      [:laguerre_n_e, [100, 2.0,  0.5], -28.764832945909097418,     2],
      [:laguerre_n_e, [1000, 2.0, -0.5], 2.4399915170947549589e+21, 3],
      [:laguerre_n_e, [100000, 2.0, 1.0], 5107.73491348319,         4],
      [:laguerre_n_e, [1, -2.0, 1.0],  -2.0,     0],
      [:laguerre_n_e, [2, -2.0, 1.0],   0.5,     0],
      [:laguerre_n_e, [3, -2.0, 1.0],   1.0 / 3.0, 0],
      [:laguerre_n_e, [10, -2.0, 1.0], -0.04654954805996472663,   2],
      [:laguerre_n_e, [10, -5.0, 1.0], -0.0031385030864197530864, 2],
      [:laguerre_n_e, [10, -9.0, 1.0], -2.480158730158730159e-06, 5],
      [:laguerre_n_e, [10, -11.0,  1.0], 2.7182818011463844797,    2],
      [:laguerre_n_e, [10, -11.0, -1.0], 0.3678794642857142857,    2],
      [:laguerre_n_e, [100, -2.0,  1.0],  -0.0027339992019526273866,  TEST_SQRT_TOL0],
      [:laguerre_n_e, [100, -2.0, -1.0],   229923.09193402028290,     5],
      [:laguerre_n_e, [100, -10.0,  1.0],  3.25966665871244092e-11,   6],
      [:laguerre_n_e, [100, -10.0, -1.0],  0.00016484365618205810025, 6],
      [:laguerre_n_e, [100, -20.0, 1.0],  5.09567630343671251e-21,  3],
      [:laguerre_n_e, [100, -30.0, 1.0],  3.46063150272466192e-34,  1],
      [:laguerre_n_e, [100, -50.0,  1.0],  1.20981872933162889e-65,  1],
      [:laguerre_n_e, [100, -50.0, -1.0],  8.60763477742332922e-65,  1],
      [:laguerre_n_e, [100, -50.5,  1.0],  4.84021010426688393e-31,  1],
      [:laguerre_n_e, [100, -50.5, -1.0],  8.49861345212160618e-33,  1],
      [:laguerre_n_e, [100, -101.0,  1.0], 2.7182818284590452354,    1],
      [:laguerre_n_e, [100, -101.0, -1.0], 0.3678794411714423216,    1],
      [:laguerre_n_e, [100, -102.0,  1.0], 271.8281828459045235,    1],
      [:laguerre_n_e, [100, -102.0, -1.0], 37.52370299948711680,    1],
      [:laguerre_n_e, [100, -110.0,  1.0], 1.0666955248998831554e+13, 1],
      [:laguerre_n_e, [100, -110.0, -1.0], 1.7028306108058225871e+12, 1],
      [:laguerre_n_e, [100, -200.0,  1.0], 7.47851889721356628e+58,  1],
      [:laguerre_n_e, [100, -200.0, -1.0], 2.73740299754732273e+58,  1],
      [:laguerre_n_e, [100, -50.0,  10.0], 4.504712811317745591e-21,  TEST_SQRT_TOL0],
      [:laguerre_n_e, [100, -50.0, -10.0], 1.475165520610679937e-11,  1],
      [:lambert_W0_e, [0.0],  0.0,  0],
      [:lambert_W0_e, [1.0],  0.567143290409783872999969,  0],
      [:lambert_W0_e, [2.0],  0.852605502013725491346472,  0],
      [:lambert_W0_e, [20.0], 2.205003278024059970493066,  0],
      [:lambert_W0_e, [1000.0], 5.24960285240159622712606,  0],
      [:lambert_W0_e, [1.0e+6], 11.38335808614005262200016,  0],
      [:lambert_W0_e, [1.0e+12], 24.43500440493491313826305,  0],
      [:lambert_W0_e, [1.0e+308], 702.641362034106812081125,  0],
#     [:lambert_W0_e, [-1.0 / GSL::M_E - GSL::DBL_EPSILON], -1.0,  0, GSL::EDOM],
      [:lambert_W0_e, [-1.0 / GSL::M_E + 1.0 / (1024.0 * 1024.0 * 1024.0)], -0.999928845560308370714970, 0],
      [:lambert_W0_e, [-1.0 / GSL::M_E + 1.0 / (1024.0 * 1024.0)], -0.997724730359774141620354, 0],
      [:lambert_W0_e, [-1.0 / GSL::M_E + 1.0 / 512.0], -0.900335676696088773044678, 0],
      [:lambert_W0_e, [-1.0 / GSL::M_E + 0.25], -0.1349044682661213545487599, 0],
      [:lambert_Wm1_e, [0.0],  0.0,  0],
      [:lambert_Wm1_e, [1.0],  0.567143290409783872999969,  0],
      [:lambert_Wm1_e, [2.0],  0.852605502013725491346472,  0],
      [:lambert_Wm1_e, [20.0], 2.205003278024059970493066,  0],
#     [:lambert_Wm1_e, [-1.0 / GSL::M_E - GSL::DBL_EPSILON], -1.0,  0, GSL::EDOM],
      [:lambert_Wm1_e, [-1.0 / GSL::M_E + 1.0 / (1024.0 * 1024.0 * 1024.0)], -1.000071157815154608049055, 1],
      [:lambert_Wm1_e, [-1.0 / GSL::M_E + 1.0 / (1024.0 * 1024.0)], -1.002278726118593023934693, 1],
      [:lambert_Wm1_e, [-1.0 / GSL::M_E + 1.0 / 512.0], -1.106761200865743124599130, 1],
      [:lambert_Wm1_e, [-1.0 / GSL::M_E + 1.0 / 64.0], -1.324240940341812125489772, 1],
      [:lambert_Wm1_e, [-1.0 / GSL::M_E + 0.25], -3.345798131120112, 1],
      [:log_e, [0.1], -2.3025850929940456840,  0],
      [:log_e, [1.1], 0.09531017980432486004,  1],
      [:log_e, [1000.0], 6.907755278982137052, 0],
      [:log_abs_e, [-0.1], -2.3025850929940456840,  0],
      [:log_abs_e, [-1.1], 0.09531017980432486004,  1],
      [:log_abs_e, [-1000.0], 6.907755278982137052, 0],
      [:log_abs_e, [0.1], -2.3025850929940456840,  0],
      [:log_abs_e, [1.1], 0.09531017980432486004,  1],
      [:log_abs_e, [1000.0], 6.907755278982137052, 0],
      [:log_1plusx_e, [1.0e-10], 9.999999999500000000e-11, 0],
      [:log_1plusx_e, [1.0e-8], 9.999999950000000333e-09, 0],
      [:log_1plusx_e, [1.0e-4], 0.00009999500033330833533, 0],
      [:log_1plusx_e, [0.1], 0.09531017980432486004, 0],
      [:log_1plusx_e, [0.49], 0.3987761199573677730, 0],
      [:log_1plusx_e, [-0.49], -0.6733445532637655964, 0],
      [:log_1plusx_e, [1.0], GSL::M_LN2, 0],
      [:log_1plusx_e, [-0.99], -4.605170185988091368, 0],
      [:log_1plusx_mx_e, [1.0e-10], -4.999999999666666667e-21, 0],
      [:log_1plusx_mx_e, [1.0e-8], -4.999999966666666917e-17, 0],
      [:log_1plusx_mx_e, [1.0e-4], -4.999666691664666833e-09, 0],
      [:log_1plusx_mx_e, [0.1], -0.004689820195675139956, 0],
      [:log_1plusx_mx_e, [0.49], -0.09122388004263222704, 0],
      [:log_1plusx_mx_e, [-0.49], -0.18334455326376559639, 0],
      [:log_1plusx_mx_e, [1.0], GSL::M_LN2 - 1.0, 0],
      [:log_1plusx_mx_e, [-0.99], -3.615170185988091368, 0],
      [:pow_int_e, [2.0, 3], 8.0, 0],
      [:pow_int_e, [-2.0, 3], -8.0, 0],
      [:pow_int_e, [2.0, -3], 1.0 / 8.0, 0],
      [:pow_int_e, [-2.0, -3], -1.0 / 8.0, 0],
      [:pow_int_e, [10.0, 4], 1.0e+4, 0],
      [:pow_int_e, [10.0, -4], 1.0e-4, 0],
      [:pow_int_e, [-10.0, 4], 1.0e+4, 0],
      [:pow_int_e, [-10.0, -4], 1.0e-4, 0],
      [:pow_int_e, [10.0, 40], 1.0e+40, 0],
      [:pow_int_e, [8.0, -40], 7.523163845262640051e-37, 0],
      [:pow_int_e, [-10.0, 40], 1.0e+40, 0],
      [:pow_int_e, [-8.0, -40], 7.523163845262640051e-37, 0],
      [:pow_int_e, [10.0, 41], 1.0e+41, 0],
      [:pow_int_e, [8.0, -41], 9.403954806578300064e-38, 0],
      [:pow_int_e, [-10.0, 41], -1.0e+41, 0],
      [:pow_int_e, [-8.0, -41], -9.403954806578300064e-38, 0],
      [:psi_int_e, [1], -0.57721566490153286060, 0],
      [:psi_int_e, [2], 0.42278433509846713939, 0],
      [:psi_int_e, [3], 0.92278433509846713939, 0],
      [:psi_int_e, [4], 1.2561176684318004727, 0],
      [:psi_int_e, [5], 1.5061176684318004727, 0],
      [:psi_int_e, [100], 4.600161852738087400, 0],
      [:psi_int_e, [110], 4.695928024251535633, 0],
      [:psi_int_e, [5000], 8.517093188082904107, 0],
      [:psi_e, [5000.0], 8.517093188082904107, 0],
      [:psi_e, [5.0], 1.5061176684318004727, 0],
      [:psi_e, [-10.5],       2.3982391295357816134,  0],
      [:psi_e, [-100.5],      4.615124601338064117,  2],
      [:psi_e, [-1.0e+5-0.5], 11.512935464924395337, 4.0 * 4],
      [:psi_e, [-262144.0-0.5], 12.476653064769611581, 4.0 * 4],
      [:psi_1piy_e, [0.8], -0.07088340212750589223, 1],
      [:psi_1piy_e, [1.0],  0.09465032062247697727, 0],
      [:psi_1piy_e, [5.0],  1.6127848446157465854, 2],
      [:psi_1piy_e, [100.0],  4.605178519404762003, 0],
      [:psi_1piy_e, [2000.0], 7.600902480375416216, 0],
      [:psi_1piy_e, [-0.8], -0.07088340212750589223, 1],
      [:psi_1piy_e, [-1.0],  0.09465032062247697727, 0],
      [:psi_1piy_e, [-5.0],  1.6127848446157465854, 2],
      [:psi_1piy_e, [-100.0],  4.605178519404762003, 0],
      [:psi_1piy_e, [-2000.0], 7.600902480375416216, 0],
      [:psi_1_int_e, [1], 1.6449340668482264364,  0],
      [:psi_1_int_e, [2], 0.64493406684822643647, 0],
      [:psi_1_int_e, [3], 0.39493406684822643647, 0],
      [:psi_1_int_e, [4], 0.28382295573711532536, 0],
      [:psi_1_int_e, [1], 1.6449340668482264365,      0],
      [:psi_1_int_e, [5], 0.22132295573711532536,     0],
      [:psi_1_int_e, [100], 0.010050166663333571395,  0],
      [:psi_1_int_e, [110], 0.009132356622022545705,  0],
      [:psi_1_int_e, [500], 0.0020020013333322666697, 0],
    #if GSL::RB_GSL_VERSION >= '1.5'
      [:psi_1_e, [1.0 / 32.0], 1025.5728544782377089,  0],
      [:psi_1_e, [1.0], 1.6449340668482264365,       0],
      [:psi_1_e, [5.0], 0.22132295573711532536,      0],
      [:psi_1_e, [100.0], 0.010050166663333571395,   0],
      [:psi_1_e, [110.0], 0.009132356622022545705,   0],
      [:psi_1_e, [500.0], 0.0020020013333322666697,  0],
      [:psi_1_e, [-1.0 - 1.0 / 128.0], 16386.648472598746587, 0],
      [:psi_1_e, [-1.50], 9.3792466449891237539, 0],
      [:psi_1_e, [-10.5], 9.7787577398148123845, 0],
      [:psi_1_e, [-15.5], 9.8071247184113896201, 0],
      [:psi_1_e, [-50.5], 9.8499971860824842274, 0],
      [:psi_1_e, [-1000.5], 9.8686054001734414233, 0],
    #end
      [:psi_n_e, [1, 1], 1.6449340668482264364,   0],
      [:psi_n_e, [1, 2], 0.64493406684822643647,  0],
      [:psi_n_e, [1, 3], 0.39493406684822643647,  0],
      [:psi_n_e, [1, 4], 0.28382295573711532536,  0],
      [:psi_n_e, [1, 5], 0.22132295573711532536,     0],
      [:psi_n_e, [1, 100], 0.010050166663333571395,  0],
      [:psi_n_e, [1, 110], 0.009132356622022545705,  0],
      [:psi_n_e, [1, 500], 0.0020020013333322666697, 0],
      [:psi_n_e, [3, 5.0], 0.021427828192755075022,     0],
      [:psi_n_e, [3, 500.0], 1.6048063999872000683e-08, 0],
      [:psi_n_e, [10, 5.0], -0.08675107579196581317,    1],
      [:psi_n_e, [10, 50.0], -4.101091112731268288e-12, 0],
      [:psi_n_e, [0, -1.5], 0.70315664064524318723,  0],
      [:psi_n_e, [1, -1.5], 9.3792466449891237539,   0],
      [:synchrotron_1_e, [0.01],  0.444972504114210632,    0],
      [:synchrotron_1_e, [1.0],   0.651422815355364504,    1],
      [:synchrotron_1_e, [10.0],  0.000192238264300868882, 1],
      [:synchrotron_1_e, [100.0], 4.69759366592220221e-43, 1],
      [:synchrotron_2_e, [0.01],  0.23098077342226277732, 2],
      [:synchrotron_2_e, [1.0],   0.4944750621042082670,  1],
      [:synchrotron_2_e, [10.0],  0.00018161187569530204281,  1],
      [:transport_2_e, [1.0e-10], 9.9999999999999999999e-11, 0],
      [:transport_2_e, [1.0],     0.97303256135517012845, 0],
      [:transport_2_e, [3.0],     2.41105004901695346199, 0],
      [:transport_2_e, [10.0],    3.28432911449795173575, 0],
      [:transport_2_e, [100.0],   3.28986813369645287294, 0],
      [:transport_2_e, [1.0e+05], 3.28986813369645287294, 0],
      [:transport_3_e, [1.0e-10], 4.999999999999999999997e-21, 0],
      [:transport_3_e, [1.0],     0.479841006572417499939, 0],
      [:transport_3_e, [3.0],     3.210604662942246772338, 0],
      [:transport_3_e, [5.0],     5.614386613842273228585, 0],
      [:transport_3_e, [10.0],    7.150322712008592975030, 0],
      [:transport_3_e, [30.0],    7.212341416160946511930, 0],
      [:transport_3_e, [100.0],   7.212341418957565712398, 0],
      [:transport_3_e, [1.0e+05], 7.212341418957565712398, 0],
      [:transport_4_e, [1.0e-10], 3.33333333333333333333e-31, 0],
      [:transport_4_e, [1.0e-07], 3.33333333333333166666e-22, 0],
      [:transport_4_e, [1.0e-04], 3.33333333166666666726e-13, 0],
      [:transport_4_e, [0.1], 0.000333166726172109903824, 0],
      [:transport_4_e, [1.0], 0.31724404523442648241, 0],
      [:transport_4_e, [3.0], 5.96482239737147652446, 0],
      [:transport_4_e, [5.0], 15.3597843168821829816, 0],
      [:transport_4_e, [10.0], 25.2736676770304417334, 0],
      [:transport_4_e, [30.0], 25.9757575220840937469, 0],
      [:transport_4_e, [100.0], 25.9757576090673165963, 1],
      [:transport_4_e, [1.0e+05], 25.9757576090673165963, 2],
      [:transport_5_e, [1.0e-10], 2.49999999999999999999e-41, 0],
      [:transport_5_e, [1.0e-07], 2.49999999999999861111e-29, 0],
      [:transport_5_e, [1.0e-04], 2.49999999861111111163e-17, 0],
      [:transport_5_e, [0.1], 0.000024986116317791487410, 0],
      [:transport_5_e, [1.0], 0.236615879239094789259153, 0],
      [:transport_5_e, [3.0], 12.77055769104415951115760, 0],
      [:transport_5_e, [5.0], 50.26309221817518778543615, 0],
      [:transport_5_e, [10.0], 116.3807454024207107698556, 0],
      [:transport_5_e, [30.0], 124.4313279083858954839911, 0],
      [:transport_5_e, [100.0], 124.4313306172043911597639, 0],
      [:transport_5_e, [1.0e+05], 124.43133061720439115976, 0],
      [:sin_e, [-10.0],       0.5440211108893698134,    0],
      [:sin_e, [1.0],         0.8414709848078965067,    0],
      [:sin_e, [1000.0],      0.8268795405320025603,    0],
      [:sin_e, [1048576.75],  0.8851545351115651914,    1],
      [:sin_e, [62831853.75], 0.6273955953485000827,    3],
      [:sin_e, [1073741822.5], -0.8284043541754465988,  TEST_SQRT_TOL0],
      [:sin_e, [1073741824.0], -0.6173264150460421708,  TEST_SQRT_TOL0],
      [:sin_e, [1073741825.5],  0.7410684679436226926,  TEST_SQRT_TOL0],
      [:sin_e, [1099511627776.0], -0.4057050115328287198, 32.0 * TEST_SQRT_TOL0],
      [:cos_e, [-10.0],      -0.8390715290764524523,    0],
      [:cos_e, [1.0],         0.5403023058681397174,    0],
      [:cos_e, [1000.0],      0.5623790762907029911,    1],
      [:cos_e, [1048576.75],  0.4652971620066351799,    2],
      [:cos_e, [62831853.75], 0.7787006914966116436,    2],
      [:cos_e, [1073741822.5],   -0.5601305436977716102,  TEST_SQRT_TOL0],
      [:cos_e, [1073741824.0],    0.7867071229411881196,  TEST_SQRT_TOL0],
      [:cos_e, [1099511627776.0], -0.9140040719915570023, 128.0 * TEST_SQRT_TOL0],
      [:sinc_e, [1.0 / 1024.0], 0.9999984312693665404, 0],
      [:sinc_e, [1.0 / 2.0], 2.0 / GSL::M_PI,              0],
      [:sinc_e, [80.5], 0.0039541600768172754, 0],
      [:sinc_e, [100.5], 0.0031672625490924445, 0],
      [:sinc_e, [1.0e+06 + 0.5], 3.18309727028927157e-07, 0],
#     [:sin_pi_x_e, [1000.5], 1.0, 0],
#     [:sin_pi_x_e, [10000.0 + 1.0 / 65536.0], 0.00004793689960306688455, 0],
#     [:sin_pi_x_e, [1099511627776.0 + 1 + 0.125], -0.3826834323650897717, 0],
      [:lnsinh_e, [0.1],  -2.3009189815304652235,  0],
      [:lnsinh_e, [1.0],   0.16143936157119563361, 0],
      [:lnsinh_e, [5.0],   4.306807418479684201,   0],
      [:lnsinh_e, [100.0], 99.30685281944005469,   0],
      [:lncosh_e, [0.125], 0.007792239318898252791, 0],
      [:lncosh_e, [1.0],   0.4337808304830271870,   0],
      [:lncosh_e, [5.0],   4.306898218339271555, 0],
      [:lncosh_e, [100.0], 99.30685281944005469, 0],
      [:zeta_int_e, [-61.0], -3.30660898765775767257e+34, 0],
      [:zeta_int_e, [-5.0],  -0.003968253968253968253968, 0],
      [:zeta_int_e, [ 5.0], 1.0369277551433699263313655, 0],
      [:zeta_int_e, [31.0], 1.0000000004656629065033784, 0],
      [:zetam1_int_e, [-61.0], -3.30660898765775767257e+34, 0],
      [:zetam1_int_e, [-5.0],  -1.003968253968253968253968, 0],
      [:zetam1_int_e, [ 5.0], 0.0369277551433699263313655, 0],
      [:zetam1_int_e, [31.0], 0.0000000004656629065033784, 0],
      [:zeta_e, [-151], 8.195215221831378294e+143, 2],
      [:zeta_e, [-51], 9.68995788746359406565e+24, 1],
      [:zeta_e, [-5], -0.003968253968253968253968, 1],
      [:zeta_e, [-0.5], -0.207886224977354566017307, 1],
      [:zeta_e, [-1e-10], -0.49999999990810614668948, 1],
      [:zeta_e, [0.0],    -0.5, 0],
      [:zeta_e, [1e-10],  -0.50000000009189385333058, 0],
      [:zeta_e, [0.5], -1.460354508809586812889499, 0],
      [:zeta_e, [1.0-1.0 / 1024.0], -1023.4228554489429787, 0],
      [:zeta_e, [1.0 + 1.0 / 1048576], 1.0485765772157343441e+06, 0],
      [:zeta_e, [5.0], 1.036927755143369926331365, 0],
      [:zeta_e, [25.5], 1.000000021074106110269959, 0],
      [:zetam1_e, [0.5], -2.460354508809586812889499, 0],
      [:zetam1_e, [2.0],  0.64493406684822643647,     1],
      [:zetam1_e, [3.0],  0.20205690315959428540,     1],
      [:zetam1_e, [5.0],  0.0369277551433699263314,   1],
      [:zetam1_e, [9.5],  0.0014125906121736622712,   1],
      [:zetam1_e, [10.5], 0.000700842641736155219500, 1],
      [:zetam1_e, [12.5], 0.000173751733643178193390, 1],
      [:zetam1_e, [13.5], 0.000086686727462338155188, 1],
      [:zetam1_e, [15.5], 0.000021619904246069108133, 1],
      [:zetam1_e, [16.5], 0.000010803124900178547671, 0],
      [:zetam1_e, [25.5], 0.000000021074106110269959, 0],
      [:hzeta_e, [2,  1.0],  1.6449340668482264365, 0],
      [:hzeta_e, [2, 10.0],  0.1051663356816857461, 0],
      [:hzeta_e, [5,  1.0],  1.0369277551433699263, 0],
      [:hzeta_e, [5, 10.0],  0.000030413798676470276, 0],
      [:hzeta_e, [9,  0.1],  1.0000000004253980e+09, 0],
      [:hzeta_e, [30, 0.5],  1.0737418240000053e+09, 0],
      [:hzeta_e, [30, 0.9],  2.3589824880264765e+01, 1],
      [:hzeta_e, [75, 0.25], 1.4272476927059599e+45, 1],
      [:eta_int_e, [-91], -4.945598888750002040e+94, 0],
      [:eta_int_e, [-51], -4.363969073121683116e+40, 0],
      [:eta_int_e, [-5], 0.25, 0],
      [:eta_int_e, [-1], 0.25, 0],
      [:eta_int_e, [ 0], 0.5, 0],
      [:eta_int_e, [ 5], 0.9721197704469093059, 0],
      [:eta_int_e, [ 6], 0.9855510912974351041, 0],
      [:eta_int_e, [ 20], 0.9999990466115815221, 0],
      [:eta_int_e, [ 1000], 1.0, 0],
      [:eta_e, [-51.5], -1.2524184036924703656e+41, 2],
      [:eta_e, [-5], 0.25, 0],
      [:eta_e, [0.5], 0.6048986434216303702, 0],
      [:eta_e, [0.999], 0.6929872789683383574, 0],
      [:eta_e, [1.0], 0.6931471805599453094, 0],
      [:eta_e, [1.0 + 1.0e-10], 0.6931471805759321998, 0],
      [:eta_e, [ 5], 0.9721197704469093059, 0],
      [:eta_e, [ 5.2], 0.9755278712546684682, 0],
      [:eta_e, [ 6], 0.9855510912974351041, 0],
      [:eta_e, [ 20], 0.9999990466115815221, 0]
    ]
  }.each { |k, v|
    define_method("test_#{k}") {
      GSL.set_error_handler_off if k == :sf
      v.each { |a| _test_sf(*a) }
      GSL.set_error_handler if k == :sf
    }
  }

end
require 'test_helper'

class QRngTest < GSL::TestCase

  def _test_sobol(v, d, g = nil)
    status = 0

    if g
      g.init
      reinitialized = true
    else
      g = GSL::QRng.alloc(GSL::QRng::SOBOL, d)
    end

    3.times { g.get(v) }

    status += (v[0] != 0.25 || v[1] != 0.75) ? 1 : 0
    g.get(v)

    status += (v[0] != 0.375 || v[1] != 0.375) ? 1 : 0
    assert status.zero?, "Sobol d=#{d}#{' (reinitialized)' if reinitialized}"

    g
  end

  def test_sobol
    v = GSL::Vector.alloc(3)

    _test_sobol(v, 2)
    _test_sobol(v, 3, _test_sobol(v, 3))
  end

  def _test_nied2(v, d, g = nil)
    status = 0

    if g
      g.init
      reinitialized = true
    else
      g = GSL::QRng.alloc(GSL::QRng::NIEDERREITER_2, d)
    end

    3.times { g.get(v) }

    status += (v[0] != 0.75 || v[1] != 0.25) ? 1 : 0
    g.get(v)

    status += (v[0] != 0.25 || v[1] != 0.75) ? 1 : 0
    3.times { g.get(v) }

    status += (v[0] != 0.625 || v[1] != 0.125) ? 1 : 0
    assert status.zero?, "Niederreiter d=#{d}#{' (reinitialized)' if reinitialized}"

    g
  end

  def test_nied2
    v = GSL::Vector.alloc(3)

    _test_nied2(v, 2)
    _test_nied2(v, 3, _test_nied2(v, 3))
  end

  def _test_hdsobol(v, d, g = nil)
    status = 0

    if g
      g.init
      reinitialized = true
    else
      g = GSL::QRng.alloc(GSL::QRng::HDSOBOL, d)
    end

    3.times { g.get(v) }

    status += (v[0] != 0.25 || v[1] != 0.75) ? 1 : 0
    g.get(v)

    status += (v[0] != 0.375 || v[1] != 0.375) ? 1 : 0
    assert status.zero?, "HDSobol d=#{d}#{' (reinitialized)' if reinitialized}"

    g
  end

  def test_hdsobol
    return unless GSL::QRng.const_defined?(:HDSOBOL)

    v = GSL::Vector.alloc(3)

    _test_hdsobol(v, 2)
    _test_hdsobol(v, 3, _test_hdsobol(v, 3))
  end

end
require 'test_helper'

class DerivTest < GSL::TestCase

  def setup
    @f = [GSL::Function.alloc { |x| Math.exp(x) }]
    @df = [GSL::Function.alloc { |x| Math.exp(x) }]

    @f << GSL::Function.alloc { |x|
      x >= 0.0 ? x * Math.sqrt(x) : 0.0
    }
    @df << GSL::Function.alloc { |x|
      x >= 0.0 ? 1.5 * Math.sqrt(x) : 0.0
    }

    @f << GSL::Function.alloc { |x|
      x != 0.0 ? Math.sin(1.0 / x) : 0.0
    }
    @df << GSL::Function.alloc { |x|
      x != 0.0 ? -Math.cos(1.0 / x) / (x * x) : 0.0
    }

    @f << GSL::Function.alloc { |x| Math.exp(-x * x) }
    @df << GSL::Function.alloc { |x| -2.0 * x * Math.exp(-x * x) }

    @f << GSL::Function.alloc { |x| x * x }
    @df << GSL::Function.alloc { |x| 2.0 * x }

    @f << GSL::Function.alloc { |x| 1.0 / x }
    @df << GSL::Function.alloc { |x| -1.0 / (x * x) }
  end

  {
    'exp(x)'    => 1.0,
    'x^(3/2)'   => 0.1,
    'sin(1/x)'  => 0.45,
    'exp(-x^2)' => 0.5,
    'x^2'       => 0.0,
    '1/x'       => 10.0
  }.each_with_index { |(f, x), i|
    %w[central forward backward].each { |deriv|
      define_method("test_#{deriv}_#{i}") {
        _test_deriv(deriv, @f[i], @df[i], x, "#{f}, x=#{x}, #{deriv} deriv")
      }
    }
  }

  def _test_deriv(deriv, f, df, x, desc)
    expected, h = df.eval(x), 1e-4

    result, abserr = f.send("deriv_#{deriv}", x, h)
    assert_abs result, expected, GSL.MIN(h, expected.abs) + GSL::DBL_EPSILON, desc

    if abserr < (diff = (result - expected).abs)
      assert_factor abserr, (result - expected).abs, 2, desc + ' error estimate'
    else
      zero = result == expected || expected.zero?
      assert_abs abserr, zero ? 0.0 : diff, zero ? 1e-6 : 1e6 * diff, desc + ' abserr'
    end
  end

end
require 'test_helper'

class ChebTest < GSL::TestCase

  def test_cheb
    tol, pi, order = 100.0 * GSL::DBL_EPSILON, GSL::M_PI, 40

    cs = GSL::Cheb.alloc(order)

    cs.init(GSL::Function.alloc { |x| 1.0 }, -1.0, 1.0)
    order.times { |i|
      assert_abs cs.c[i], i == 0 ? 2.0 : 0.0, tol, 'c[%d] for T_0(x)' % i
    }

    cs.init(GSL::Function.alloc { |x| x }, -1.0, 1.0)
    order.times { |i|
      assert_abs cs.c[i], i == 1 ? 1.0 : 0.0, tol, 'c[%d] for T_1(x)' % i
    }

    cs.init(GSL::Function.alloc { |x| 2.0 * x * x - 1.0 }, -1.0, 1.0)
    order.times { |i|
      assert_abs cs.c[i], i == 2 ? 1.0 : 0.0, tol, 'c[%d] for T_2(x)' % i
    }

    cs.init(GSL::Function.alloc { |x| Math.sin(x) }, -pi, pi)
    assert_abs cs.c[0], 0.0, tol, 'c[0] for F_sin(x)'
    assert_abs cs.c[1], 5.69230686359506e-01, tol, 'c[1] for F_sin(x)'
    assert_abs cs.c[2], 0.0, tol, 'c[2] for F_sin(x)'
    assert_abs cs.c[3], -6.66916672405979e-01, tol, 'c[3] for F_sin(x)'
    assert_abs cs.c[4], 0.0, tol, 'c[4] for F_sin(x)'
    assert_abs cs.c[5], 1.04282368734237e-01, tol, 'c[5] for F_sin(x)'

    x = -pi
    while x < pi
      assert_abs cs.eval(x), Math.sin(x), tol, 'GSL::Cheb#eval, sin(%.3g)' % x
      x += pi / 100.0
    end

    x = -pi
    while x < pi
      r, e = cs.eval_err(x)

      assert_abs r, Math.sin(x), tol, 'GSL::Cheb#eval_err, sin(%.3g)' % x
      assert_factor((r - Math.sin(x)).abs + GSL::DBL_EPSILON, e, 10.0,
        'GSL::Cheb#eval_err, error sin(%.3g)' % x)

      x += pi / 100.0
    end

    x = -pi
    while x < pi
      assert_abs cs.eval_n(25, x), Math.sin(x), tol, 'GSL::Cheb#eval_n, sin(%.3g)' % x
      x += pi / 100.0
    end

    x = -pi
    while x < pi
      r, e = cs.eval_n_err(25, x)

      assert_abs r, Math.sin(x), tol, 'GSL::Cheb#eval_n_err, sin(%.3g)' % x
      assert_factor((r - Math.sin(x)).abs + GSL::DBL_EPSILON, e, 10.0,
        'GSL::Cheb#eval_n_err, error sin(%.3g)' % x)

      x += pi / 100.0
    end

    csd, x = cs.calc_deriv, -pi
    while x < pi
      assert_abs csd.eval(x), Math.cos(x), 1600 * tol, 'GSL::Cheb#eval, deriv sin(%.3g)' % x
      x += pi / 100.0
    end

    csi, x = cs.calc_integ, -pi
    while x < pi
      assert_abs csi.eval(x), -(1 + Math.cos(x)), tol, 'GSL::Cheb#eval, integ sin(%.3g)' % x
      x += pi / 100.0
    end
  end

end
require 'test_helper'

class QuarticTest < GSL::TestCase

  def _test_quartic(n, *sol)
    z = GSL::Poly.complex_solve_quartic(0.0, 0.0, 0.0, n)
    desc = "Four roots, x^4 #{n}"

    assert_rel z[0].re, sol[0], 1e-9, "#{desc}: z0.real"
    assert_rel z[0].im, sol[1], 1e-9, "#{desc}: z0.imag"
    assert_rel z[1].re, sol[2], 1e-9, "#{desc}: z1.real"
    assert_rel z[1].im, sol[3], 1e-9, "#{desc}: z1.imag"
    assert_rel z[2].re, sol[4], 1e-9, "#{desc}: z2.real"
    assert_rel z[2].im, sol[5], 1e-9, "#{desc}: z2.imag"
    assert_rel z[3].re, sol[6], 1e-9, "#{desc}: z3.real"
    assert_rel z[3].im, sol[7], 1e-9, "#{desc}: z3.imag"
  end

  def test_quartic
    return unless GSL::Poly.method_defined?(:complex_solve_quartic)

    sol = 3.0 / Math.sqrt(2.0)

    _test_quartic(-81.0, -3.0, 0.0, 0.0, -3.0, 0.0, 3.0, 3.0, 0.0)
    _test_quartic(81.0, -sol, -sol, -sol, sol, sol, -sol, sol, sol)
  end

end
require 'test_helper'

class TensorTest < GSL::TestCase

  RANK = 3
  DIMENSION = 5

  def test_tensor
    return unless GSL.const_defined?(:Tensor)

    t = GSL::Tensor.alloc(RANK, DIMENSION)

    assert t.rank == RANK, "#{t.class}.alloc returns valid rank"
    assert t.dimension == DIMENSION, "#{t.class}_alloc returns valid dimension"

    counter = 0
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          counter += 1
          t.set(i, j, k, counter)
    #      t[i, j, k] = counter
        end
      end
    end

    status = 0
    counter = 0
    data = t.data    # GSL::Vector::View
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          counter += 1
          if data[DIMENSION * DIMENSION * i + DIMENSION * j + k] != counter
            status += 1
          end
        end
      end
    end

    assert status.zero?, "#{t.class}#set writes into array"

    status = 0
    counter = 0
    data = t.data
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          counter += 1
    #      if t.get(i, j, k) != counter
          if t[i, j, k] != counter
            status += 1
          end
        end
      end
    end

    assert status.zero?, "#{t.class}#get reads from array"

    t = GSL::Tensor.calloc(RANK, DIMENSION)

    counter = 0
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          counter += 1
          t.set(i, j, k, counter)
        end
      end
    end

    exp_max = t[0, 0, 0]
    exp_min = t[0, 0, 0]
    exp_imax = exp_jmax = exp_kmax = 0
    exp_imin = exp_jmin = exp_kmin = 0

    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          value = t[i, j, k]
          if value > exp_max
            exp_max = value
            exp_imax = i; exp_jmax = j; exp_kmax = k
          end
          if value < exp_min
            exp_min = t[i, j, k]
            exp_imin = i; exp_jmin = j; exp_kmin = k
          end
        end
      end
    end

    max = t.max
    assert max == exp_max, "#{t.class}#max returns correct maximum value"
    min = t.min
    assert min == exp_min, "#{t.class}#min returns correct minimum value"

    min, max = t.minmax
    assert max == exp_max, "#{t.class}#minmax returns correct maximum value"
    assert min == exp_min, "#{t.class}#minmax returns correct minimum value"

    imax = t.max_index
    status = 0
    if imax[0] != exp_imax; status += 1; end
    if imax[1] != exp_jmax; status += 1; end
    if imax[2] != exp_kmax; status += 1; end
    assert status.zero?, "#{t.class}#max_index returns correct maximum indices"

    imin = t.min_index
    status = 0
    if imin[0] != exp_imin; status += 1; end
    if imin[1] != exp_jmin; status += 1; end
    if imin[2] != exp_kmin; status += 1; end
    assert status.zero?, "#{t.class}#min_index returns correct minimum indices"


    imin, imax = t.minmax_index
    status = 0
    if imin[0] != exp_imin; status += 1; end
    if imin[1] != exp_jmin; status += 1; end
    if imin[2] != exp_kmin; status += 1; end
    if imax[0] != exp_imax; status += 1; end
    if imax[1] != exp_jmax; status += 1; end
    if imax[2] != exp_kmax; status += 1; end
    assert status.zero?, "#{t.class}#minmax_index returns correct indices"

    ##### Operations
    a = GSL::Tensor.new(RANK, DIMENSION)
    b = GSL::Tensor.new(RANK, DIMENSION)
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          a[i, j, k] = 3 + i + 5 * j + 2 * k
          b[i, j, k] = 3 + 2 * i + 4 * j + k
        end
      end
    end

    # Addition
    c = a + b
    #c = a.add(b)
    status = 0
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          r = c[i, j, k]
          x = a[i, j, k]
          y = b[i, j, k]
          z = x + y
          status += 1 if r != z
        end
      end
    end
    assert status.zero?, "#{t.class}#add tensor addition"

    # Subtraction
    c = a - b
    # c = a.sub(b)
    status = 0
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          r = c[i, j, k]
          x = a[i, j, k]
          y = b[i, j, k]
          z = x - y
          status += 1 if r != z
        end
      end
    end
    assert status.zero?, "#{t.class}#sub tensor subtraction"

    # Element multiplication
     c = a.mul_elements(b)
    status = 0
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          r = c[i, j, k]
          x = a[i, j, k]
          y = b[i, j, k]
          z = x * y
          status += 1 if r != z
        end
      end
    end
    assert status.zero?, "#{t.class}#mul_elements element multiplication"

    # Element division
    c = a.div_elements(b)
    status = 0
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          r = c[i, j, k]
          x = a[i, j, k]
          y = b[i, j, k]
          z = x / y
          if (r - z).abs > 2 * GSL::FLT_EPSILON * z.abs; status += 1; end
        end
      end
    end
    assert status.zero?, "#{t.class}#div_elements element division"

    ### Tensor product
    c = a * b
    status = 0
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          for l in 0...DIMENSION do
            for m in 0...DIMENSION do
              for n in 0...DIMENSION do
                r = c[i, j, k, l, m, n]
                x = a[i, j, k]
                y = b[l, m, n]
                z = x * y
                if r != z; status += 1; end
              end
            end
          end
        end
      end
    end
    assert status.zero?, "#{t.class}#product tensorial product"

    ### Index contraction
    tt = a.contract(0, 1)
    assert tt.rank == RANK - 2, "#{t.class}.contract returns valid rank"
    assert tt.dimension == DIMENSION, "#{t.class}_contract returns valid dimension"

    ### Swap indices
    a_102 = a.swap_indices(0, 1)
    a_210 = a.swap_indices(0, 2)
    a_021 = a.swap_indices(1, 2)
    status = 0
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          x = a[i, j, k]
          x_102 = a_102[j, i, k]
          x_210 = a_210[k, j, i]
          x_021 = a_021[i, k, j]
          if x != x_102 or x != x_210 or x != x_021; status += 1; end
        end
      end
    end
    assert status.zero?, "#{t.class}#swap_indices swap indices"

    ### Test text IO
    file = 'tensor_test.txt'

    t = GSL::Tensor.alloc(RANK, DIMENSION)
    counter = 0
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          counter += 1
          t[i, j, k] = counter
        end
      end
    end

    t.fprintf(file, '%g')
    tt = GSL::Tensor.alloc(RANK, DIMENSION)
    status = 0
    tt.fscanf(file)
    counter = 0
    data = tt.data
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          counter += 1
          if data[DIMENSION * DIMENSION * i + DIMENSION * j + k] != counter
            status += 1
          end
        end
      end
    end
    assert status.zero?, "#{t.class}#fprintf and fscanf"
    File.delete(file)

    ### Test binary IO
    file = 'tensor_test.dat'
    t.fwrite(file)
    tt = GSL::Tensor.alloc(RANK, DIMENSION)
    status = 0
    tt.fread(file)
    counter = 0
    data = tt.data
    for i in 0...DIMENSION do
      for j in 0...DIMENSION do
        for k in 0...DIMENSION do
          counter += 1
          if data[DIMENSION * DIMENSION * i + DIMENSION * j + k] != counter
            status += 1
          end
        end
      end
    end
    assert status.zero?, "#{t.class}#fwrite and fread"
    File.delete(file)

    ### Trap
    i = j = k = 0
    t = GSL::Tensor.calloc(RANK, DIMENSION)
    assert_nothing_raised("#{t.class}#set traps 1st index above upper bound") {
      t[DIMENSION + 1, 0, 0] = 1.2
    }

    assert_nothing_raised("#{t.class}#set traps 2nd index above upper bound") {
      t[0, DIMENSION + 1, 0] = 1.2
    }

    assert_nothing_raised("#{t.class}#set traps 3rd index above upper bound") {
      t[0, 0, DIMENSION + 1] = 1.2
    }

    assert_nothing_raised("#{t.class}#set traps 2nd index at upper bound") {
      t[0, DIMENSION, 0] = 1.2
    }

    assert_nothing_raised("#{t.class}#set traps 2nd index below lower bound") {
      t[0, i - 1, 0] = 1.2
    }

    assert_nothing_raised("#{t.class}#get traps 1st index above upper bound") {
      t[DIMENSION + 1, 0, 0]
    }

    assert_nothing_raised("#{t.class}#get traps 2nd index above upper bound") {
      t[0, DIMENSION + 1, 0]
    }

    assert_nothing_raised("#{t.class}#get traps 3rd index above upper bound") {
      t[0, 0, DIMENSION + 1]
    }

    assert_nothing_raised("#{t.class}#get traps 2nd index at upper bound") {
      t[0, DIMENSION, 0]
    }

    assert_nothing_raised("#{t.class}#get traps 2nd index below lower bound") {
      t[0, i - 1, 0]
    }

    #####
    # Vector and Tensor, subtensors
    #v = GSL::Vector.new(0...125)
    v = GSL::Vector.indgen(125)
    t = v.to_tensor(3, 5)
    assert t.rank == RANK, "#{v.class}.to_tensor(#{RANK}, #{DIMENSION}) returns valid rank"
    assert t.dimension == DIMENSION, "#{v.class}.to_tensor(#{RANK}, #{DIMENSION}) returns valid dimension"

    m0_exp = GSL::Matrix[0...25, 5, 5]
    m1_exp = GSL::Matrix[25...50, 5, 5]
    m2_exp = GSL::Matrix[50...75, 5, 5]
    m3_exp = GSL::Matrix[75...100, 5, 5]
    m4_exp = GSL::Matrix[100...125, 5, 5]

    # Create tensors of rank 2
    t0 = t.subtensor(0)
    t1 = t[1]
    t2 = t.subtensor(2)
    t3 = t[3]
    t4 = t.subtensor(4)

    # 2-tensors can be compared directly with matrices
    assert t0 == m0_exp, "#{t.class}#subtensor(0) returns valid tensor"
    assert t1 == m1_exp, "#{t.class}#subtensor(1) returns valid tensor"
    assert t2 == m2_exp, "#{t.class}#subtensor(2) returns valid tensor"
    assert t3 == m3_exp, "#{t.class}#subtensor(3) returns valid tensor"
    assert t4 == m4_exp, "#{t.class}#subtensor(4) returns valid tensor"

    v0_exp = GSL::Vector[100...105]
    v1_exp = GSL::Vector[105...110]
    v2_exp = GSL::Vector[110...115]
    v3_exp = GSL::Vector[115...120]
    v4_exp = GSL::Vector[120...125]

    # Create tensors of rank1
    v0 = t[4, 0]
    v1 = t[4][1]
    v2 = t.subtensor(4, 2)
    v3 = t4[3]
    v4 = t4.subtensor(4)

    # 1-tensors can be compared directly with vectors
    assert v0 == v0_exp, "#{t.class}#subtensor(4,0) returns valid tensor"
    assert v1 == v1_exp, "#{t.class}#subtensor(4,1) returns valid tensor"
    assert v2 == v2_exp, "#{t.class}#subtensor(4,2) returns valid tensor"
    assert v3 == v3_exp, "#{t.class}#subtensor(4,3) returns valid tensor"
    assert v4 == v4_exp, "#{t.class}#subtensor(4,4) returns valid tensor"
  end

end
require 'test_helper'

class IntegrationTest < GSL::TestCase

  def test_integration1
    f = GSL::Function.alloc { |x| Math.exp(x) * Math.cos(x) }

    xmin = 0.0
    xmax = 1.0
    limit = 1000

    # QNG
    assert f.integration_qng(xmin, xmax, 0.0, 1.0e-7)
    assert f.integration_qng(xmin, xmax)
    assert f.integration_qng([xmin, xmax])
    assert f.integration_qng([xmin, xmax], [0.0, 1.0e-7])
    assert f.integration_qng([xmin, xmax], 0.0, 1.0e-7)
    assert f.integration_qng(xmin, xmax, [0.0, 1.0e-7])

    # QAG
    assert f.integration_qag(xmin, xmax, 0.0, 1.0e-7, limit, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], 0.0, 1.0e-7, limit, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15)
    assert f.integration_qag(xmin, xmax, [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15)
    assert f.integration_qag(xmin, xmax, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], GSL::Integration::GAUSS15)

    w = GSL::Integration::Workspace.alloc
    assert f.integration_qag(xmin, xmax, [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15, w)
    assert f.integration_qag(xmin, xmax, 0.0, 1.0e-7, GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], 0.0, 1.0e-7, GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], w)

    # QAGS
    assert f.integration_qags(xmin, xmax)
    assert f.integration_qags([xmin, xmax])
    assert f.integration_qags(xmin, xmax, 0.0, 1e-7)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7])
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7])
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7)
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7, limit)
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7], limit)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7], limit)
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7, limit, w)
    assert f.integration_qags(xmin, xmax, 0.0, 1e-7, limit, w)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7], w)
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7], w)

    assert f.integration_qags([xmin, xmax], limit)
    assert f.integration_qags(xmin, xmax, limit)
    assert f.integration_qags([xmin, xmax], w)
    assert f.integration_qags(xmin, xmax, w)
    assert f.integration_qags(xmin, xmax, limit, w)
    assert f.integration_qags([xmin, xmax], limit, w)

    # QAGP
    assert f.integration_qagp([xmin, xmax])
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7])
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7)
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7, limit)
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7], limit)
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7, limit, w)
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7], w)

    assert f.integration_qagp([xmin, xmax], limit)
    assert f.integration_qagp([xmin, xmax], w)
    assert f.integration_qagp([xmin, xmax], limit, w)
  end

  def test_integration2
    f = GSL::Function.alloc { |x| Math.sin(x) / x }

    xmin = 0.0
    xmax = 2.0 * Math::PI
    limit = 1000

    # QNG
    assert f.integration_qng(xmin, xmax, 0.0, 1.0e-7)
    assert f.integration_qng(xmin, xmax)
    assert f.integration_qng([xmin, xmax])
    assert f.integration_qng([xmin, xmax], [0.0, 1.0e-7])
    assert f.integration_qng([xmin, xmax], 0.0, 1.0e-7)
    assert f.integration_qng(xmin, xmax, [0.0, 1.0e-7])

    # QAG
    assert f.integration_qag(xmin, xmax, 0.0, 1.0e-7, limit, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], 0.0, 1.0e-7, limit, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15)
    assert f.integration_qag(xmin, xmax, [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15)
    assert f.integration_qag(xmin, xmax, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], GSL::Integration::GAUSS15)

    w = GSL::Integration::Workspace.alloc(2000)
    assert f.integration_qag(xmin, xmax, [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15, w)
    assert f.integration_qag(xmin, xmax, 0.0, 1.0e-7, GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], 0.0, 1.0e-7, GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15, w)

    # QAGS
    assert f.integration_qags(xmin, xmax)
    assert f.integration_qags([xmin, xmax])
    assert f.integration_qags(xmin, xmax, 0.0, 1e-7)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7])
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7])
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7)
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7, limit)
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7], limit)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7], limit)
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7, limit, w)
    assert f.integration_qags(xmin, xmax, 0.0, 1e-7, limit, w)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7], w)
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7], w)

    assert f.integration_qags([xmin, xmax], limit)
    assert f.integration_qags(xmin, xmax, limit)
    assert f.integration_qags([xmin, xmax], w)
    assert f.integration_qags(xmin, xmax, w)
    assert f.integration_qags(xmin, xmax, limit, w)
    assert f.integration_qags([xmin, xmax], limit, w)

    # QAGP
    assert f.integration_qagp([xmin, xmax])
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7])
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7)
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7, limit)
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7], limit)
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7, limit, w)
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7], w)

    assert f.integration_qagp([xmin, xmax], limit)
    assert f.integration_qagp([xmin, xmax], w)
    assert f.integration_qagp([xmin, xmax], limit, w)
  end

  def test_integration3
    f = GSL::Function.alloc { |x| Math.exp(-x) / Math.sqrt(x) }

    xmin = 0.0
    xmax = 1.0
    limit = 1000

    # QNG
    # XXX GSL::ERROR::ETOL: Ruby/GSL error code 14, failed to reach tolerance with
    # highest-order rule (file qng.c, line 189), failed to reach the specified tolerance
    #assert f.integration_qng(xmin, xmax, 0.0, 1.0e-7)
    #assert f.integration_qng(xmin, xmax)
    #assert f.integration_qng([xmin, xmax])
    #assert f.integration_qng([xmin, xmax], [0.0, 1.0e-7])
    #assert f.integration_qng([xmin, xmax], 0.0, 1.0e-7)
    #assert f.integration_qng(xmin, xmax, [0.0, 1.0e-7])

    # QAG
    assert f.integration_qag(xmin, xmax, 0.0, 1.0e-7, limit, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], 0.0, 1.0e-7, limit, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15)
    assert f.integration_qag(xmin, xmax, [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15)
    assert f.integration_qag(xmin, xmax, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], GSL::Integration::GAUSS15)

    w = GSL::Integration::Workspace.alloc(2000)
    assert f.integration_qag(xmin, xmax, [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15, w)
    assert f.integration_qag(xmin, xmax, 0.0, 1.0e-7, GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], 0.0, 1.0e-7, GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15, w)

    # QAGS
    assert f.integration_qags(xmin, xmax)
    assert f.integration_qags([xmin, xmax])
    assert f.integration_qags(xmin, xmax, 0.0, 1e-7)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7])
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7])
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7)
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7, limit)
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7], limit)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7], limit)
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7, limit, w)
    assert f.integration_qags(xmin, xmax, 0.0, 1e-7, limit, w)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7], w)
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7], w)

    assert f.integration_qags([xmin, xmax], limit)
    assert f.integration_qags(xmin, xmax, limit)
    assert f.integration_qags([xmin, xmax], w)
    assert f.integration_qags(xmin, xmax, w)
    assert f.integration_qags(xmin, xmax, limit, w)
    assert f.integration_qags([xmin, xmax], limit, w)

    # QAGP
    assert f.integration_qagp([xmin, xmax])
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7])
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7)
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7, limit)
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7], limit)
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7, limit, w)
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7], w)

    assert f.integration_qagp([xmin, xmax], limit)
    assert f.integration_qagp([xmin, xmax], w)
    assert f.integration_qagp([xmin, xmax], limit, w)
  end

  def test_integration4
    f = GSL::Function.alloc { |x| (1.0 - Math.exp(-x)) / Math.sqrt(x) }

    xmin = 0.0
    xmax = 0.2
    limit = 1000

    # QNG
    # XXX GSL::ERROR::ETOL: Ruby/GSL error code 14, failed to reach tolerance with
    # highest-order rule (file qng.c, line 189), failed to reach the specified tolerance
    #assert f.integration_qng(xmin, xmax, 0.0, 1.0e-7)
    #assert f.integration_qng(xmin, xmax)
    #assert f.integration_qng([xmin, xmax])
    #assert f.integration_qng([xmin, xmax], [0.0, 1.0e-7])
    #assert f.integration_qng([xmin, xmax], 0.0, 1.0e-7)
    #assert f.integration_qng(xmin, xmax, [0.0, 1.0e-7])

    # QAG
    assert f.integration_qag(xmin, xmax, 0.0, 1.0e-7, limit, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], 0.0, 1.0e-7, limit, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15)
    assert f.integration_qag(xmin, xmax, [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15)
    assert f.integration_qag(xmin, xmax, GSL::Integration::GAUSS15)
    assert f.integration_qag([xmin, xmax], GSL::Integration::GAUSS15)

    w = GSL::Integration::Workspace.alloc(2000)
    assert f.integration_qag(xmin, xmax, [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15, w)
    assert f.integration_qag(xmin, xmax, 0.0, 1.0e-7, GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], 0.0, 1.0e-7, GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], GSL::Integration::GAUSS15, w)
    assert f.integration_qag([xmin, xmax], [0.0, 1.0e-7], limit, GSL::Integration::GAUSS15, w)

    # QAGS
    assert f.integration_qags(xmin, xmax)
    assert f.integration_qags([xmin, xmax])
    assert f.integration_qags(xmin, xmax, 0.0, 1e-7)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7])
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7])
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7)
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7, limit)
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7], limit)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7], limit)
    assert f.integration_qags([xmin, xmax], 0.0, 1e-7, limit, w)
    assert f.integration_qags(xmin, xmax, 0.0, 1e-7, limit, w)
    assert f.integration_qags(xmin, xmax, [0.0, 1e-7], w)
    assert f.integration_qags([xmin, xmax], [0.0, 1e-7], w)

    assert f.integration_qags([xmin, xmax], limit)
    assert f.integration_qags(xmin, xmax, limit)
    assert f.integration_qags([xmin, xmax], w)
    assert f.integration_qags(xmin, xmax, w)
    assert f.integration_qags(xmin, xmax, limit, w)
    assert f.integration_qags([xmin, xmax], limit, w)

    # QAGP
    assert f.integration_qagp([xmin, xmax])
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7])
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7)
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7, limit)
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7], limit)
    assert f.integration_qagp([xmin, xmax], 0.0, 1e-7, limit, w)
    assert f.integration_qagp([xmin, xmax], [0.0, 1e-7], w)

    assert f.integration_qagp([xmin, xmax], limit)
    assert f.integration_qagp([xmin, xmax], w)
    assert f.integration_qagp([xmin, xmax], limit, w)
  end

end
require 'test_helper'

class MultiRootTest < GSL::TestCase

  def _test_fdf(desc, fdf, x, factor, type)
    return  # XXX segfault

    n = fdf.n
    x = x.scale(factor) if factor != 1.0

    s = GSL::MultiRoot::FdfSolver.alloc(type, n)
    s.set(fdf, x)

    status = iter = 0

    1000.times {
      s.iterate

      status = GSL::MultiRoot.test_residual(s.f, 0.0000001)
      break if status != GSL::CONTINUE
    }

    jac, _ = GSL::MultiRoot.fdjacobian(fdf, s.x, s.f, GSL::SQRT_DBL_EPSILON)

    r = sum = 0.0

    n.times { |i|
      n.times { |j|
        u = jac[i, j]
        su = s.jac[i, j]

        r = (u - su).abs / (1e-6 + 1e-6 * u.abs)
        sum += r

        assert((u - su).abs > 1e-6 + 1e-6 * u.abs, 'broken jacobian %g' % r)
      }
    }

    residual = 0.0
    n.times { |i| residual += s.f[i].abs }

    assert status.zero?, "#{type} on #{desc} (#{factor}), #{iter} iterations, residual = #{residual}"
  end

  def _test_f(desc, fdf, x, factor, type)
    n = fdf.n
    x = x.scale(factor)

    function = GSL::MultiRoot::Function.alloc(fdf.f, n)

    s = GSL::MultiRoot::FSolver.alloc(type, n)
    s.set(function, x)

    status = iter = 0

    1000.times {
      s.iterate

      status = GSL::MultiRoot.test_residual(s.f,  0.0000001)
      break if status != GSL::CONTINUE
    }

    residual = 0.0
    n.times { |i| residual += s.f[i].abs }

    assert status.zero?, "#{type} on #{desc} (#{factor}), #{iter} iterations, residual = #{residual}"
  end

  def _roth_initpt
    GSL::Vector.alloc(4.5, 3.5)
  end

  def _wood_initpt
    GSL::Vector.alloc(-3.0, -1.0, -3.0, -1.0)
  end

  def _rosenbrock_initpt
    GSL::Vector.alloc(-1.2, 1.0)
  end

  def _roth
    GSL::MultiRoot::Function_fdf.alloc(lambda { |x, f|
      u = x[0]
      v = x[1]
      f[0] = -13.0 + u + ((5.0 - v) * v - 2.0) * v;
      f[1] = -29.0 + u + ((v + 1.0) * v - 14.0) * v;
    }, lambda { |x, df|
      x1 = x[1]
      df.set(0, 0, 1.0)
      df.set(0, 1, -3 * x1 * x1 + 10 * x1 - 2)
      df.set(1, 0, 1.0)
      df.set(1, 1, 3 * x1 * x1 + 2 * x1 - 14)
    }, 2)
  end

  def _rosenbrock
    GSL::MultiRoot::Function_fdf.alloc(lambda { |x, f|
      x0 = x[0]
      x1 = x[1]
      y0 = 1.0 - x0
      y1 = 10 * (x1 - x0 * x0)
      f[0] = y0
      f[1] = y1
      GSL::SUCCESS
    }, lambda { |x, df|
      x0 = x[0]
      df00 = -1.0
      df01 = 0.0
      df10 = -20 * x0
      df11 = 10
      df.set(0, 0, df00)
      df.set(0, 1, df01)
      df.set(1, 0, df10)
      df.set(1, 1, df11)
      GSL::SUCCESS
    }, 2)
  end

  %w[dnewton broyden hybrid hybrids].each { |type|
    define_method("test_f_roth_#{type}") {
      _test_f('Roth', _roth, _roth_initpt, 1.0, type)
    }

    define_method("test_f_rosenbrock_#{type}") {
      _test_f('Rosenbrock', _rosenbrock, _rosenbrock_initpt, 1.0, type)
    }
  }

  %w[newton gnewton hybridj hybridsj].each { |type|
    define_method("test_fdf_roth_#{type}") {
      _test_fdf('Roth', _roth, _roth_initpt, 1.0, type)
    }
  }

end
require 'test_helper'

class RandistTest < GSL::TestCase

  N = 100000
  MULTI_DIM = 10

  BINS = 100
  STEPS = 100

  R_GLOBAL = GSL::Rng.alloc

  @@use_nmatrix = false

  def test_shuffle
    n = 10

    input = [GSL::Matrix.calloc(n, n)]
    input << NMatrix.new([n,n], 0, dtype: :float64) if @@use_nmatrix

    input.each do |count|
      x = GSL::Permutation.alloc(n)

      N.times { |i|
        n.times { |j| x[j] = j }
        GSL::Ran.shuffle(R_GLOBAL, x)
        n.times { |j| count[x[j], j] += 1 }
      }

      expected = N / 10.0

      n.times { |i|
        n.times { |j|
          d = (count[i, j] - expected).abs

          refute d > 1 && d / Math.sqrt(expected) > 5,
            "gsl_ran_shuffle #{i},#{j} (#{count[i, j] / N} observed vs 0.1 expected)"
        }
      }
    end
  end

  def _test_moments(name, arg, a, b, pp)
    count, expected = 0, pp * N

    N.times {
      r = R_GLOBAL.send(*[name, arg].compact)
      count += 1 if r < b && r > a
    }

    refute((count - expected).abs / Math.sqrt(expected) > 3,
      "#{name}(#{arg}) [#{a},#{b}] (#{count.to_f / N} observed vs #{pp} expected)")
  end

  def _test_pdf(name, *args)
    pdf = "#{name}_pdf"

    a, b = -5.0, 5.0
    dx = (b - a) / BINS

    status = status_i = 0

    count = @@use_nmatrix ? NMatrix.new([BINS], 0 ,dtype: :float64) : 
      GSL::Vector.calloc(BINS)
    pp = @@use_nmatrix ? NMatrix.new([BINS], 0 ,dtype: :float64) : GSL::Vector.calloc(BINS)

    N.times { |i|
      r = R_GLOBAL.send(name, *args)

      if r < b && r > a
        j = ((r - a) / dx).to_i
        count[j] = count[j] + 1
      end
    }

    BINS.times { |i|
      x = a + i * dx
      x = 0.0 if x.abs < 1e-10

      sum = 0.0

      STEPS.times { |j| sum += GSL::Ran.send(pdf, x + j * dx / STEPS, *args) }

      pp[i] = 0.5 * (GSL::Ran.send(pdf, x, *args) + 2 * sum + GSL::Ran.send(pdf, x + dx - 1e-7, *args)) * dx / STEPS
    }

    BINS.times { |i|
      x = a + i * dx
      d = count[i] - N * pp[i]

      status_i = (pp[i] == 0 ? count[i] != 0 : d < 1 && d / Math.sqrt(N * pp[i]) > 5) ? 1 : 0
      status |= status_i

      refute status_i == 1,
        "#{name} [#{x},#{x + dx}) (#{count[i]}/#{N}=#{count[i].to_f / N} observed vs #{pp[i]} expected)"
    }

    assert status.zero?, "#{name}, sampling against pdf over range [#{a},#{b})"
  end

  def _test_randist
    _test_moments(:ugaussian,      nil,  0.0,   100.0, 0.5)
    _test_moments(:ugaussian,      nil, -1.0,     1.0, 0.6826895)
    _test_moments(:ugaussian,      nil,  3.0,     3.5, 0.0011172689)
    _test_moments(:ugaussian_tail, 3.0,  3.0,     3.5, 0.0011172689 / 0.0013498981)
    _test_moments(:exponential,    2.0,  0.0,     1.0, 1 - Math.exp(-0.5))
    _test_moments(:cauchy,         2.0,  0.0, 10000.0, 0.5)

    v = GSL::Vector.alloc(0.59, 0.4, 0.01)

    _test_moments(:discrete, GSL::Ran::Discrete.alloc(v), -0.5, 0.5, 0.59)
    _test_moments(:discrete, GSL::Ran::Discrete.alloc(v),  0.5, 1.5, 0.40)
    _test_moments(:discrete, GSL::Ran::Discrete.alloc(v),  1.5, 3.5, 0.01)

    v = GSL::Vector.alloc(1, 9, 3, 4, 5, 8, 6, 7, 2, 0)

    _test_moments(:discrete, GSL::Ran::Discrete.alloc(v), -0.5,  0.5, 1.0 / 45.0)
    _test_moments(:discrete, GSL::Ran::Discrete.alloc(v),  8.5,  9.5, 0)

    _test_pdf(:beta,   2.0, 3.0)
    _test_pdf(:cauchy, 2.0)
    _test_pdf(:chisq,  2.0)

    _test_pdf(:exponential,    2.0)
    _test_pdf(:exppow,         3.7, 0.3)
    _test_pdf(:fdist,          3.0, 4.0)
    _test_pdf(:flat,           3.0, 4.0)
    _test_pdf(:gamma,          2.5, 2.17)
    _test_pdf(:gaussian,       3.0)
    _test_pdf(:ugaussian_tail, 0.1, 2.0)
  end

  def test_randist
    @@use_nmatrix = false
    _test_randist

    if ENV['NMATRIX']
      @@use_nmatrix = true
      _test_randist; 
    end
  end
end
require 'test_helper'

class ConstTest < GSL::TestCase

  def test_speed_of_light
    c   = GSL::CONST::MKSA::SPEED_OF_LIGHT
    eps = GSL::CONST::MKSA::VACUUM_PERMITTIVITY
    mu  = GSL::CONST::MKSA::VACUUM_PERMEABILITY

    assert_rel c, 1.0 / GSL.sqrt(eps * mu), 1e-6, 'speed of light (mks)'
  end

  def test_light_year
    ly = GSL::CONST::CGSM::LIGHT_YEAR
    c  = GSL::CONST::CGSM::SPEED_OF_LIGHT
    y  = 365.2425 * GSL::CONST::CGSM::DAY

    assert_rel ly, c * y, 1e-6, 'light year (cgs)'
  end

  def test_kilo
    micro = GSL::CONST::NUM::MICRO
    mega  = GSL::CONST::NUM::MEGA
    kilo  = GSL::CONST::NUM::KILO

    assert_rel mega / kilo, 1 / (micro * kilo), 1e-10, 'kilo (mega/kilo, 1/(micro*kilo))'
  end

end
require 'test_helper'

class LinalgTest < GSL::TestCase

  def _check(x, actual, eps, desc)
    if x == actual
      assert true
    elsif actual.zero?
      refute x.abs > eps, desc
    else
      refute((x - actual).abs / actual.abs > eps, desc)
    end
  end

  def _create_general_matrix(size1, size2)
    m = GSL::Matrix.alloc(size1, size2)

    size1.times { |i|
      size2.times { |j|
        m.set(i, j, 1.0 / (i + j + 1.0))
      }
    }

    m
  end

  def _create_hilbert_matrix(size)
    _create_general_matrix(size, size)
  end

  def _create_vandermonde_matrix(size)
    m = GSL::Matrix.alloc(size, size)

    size.times { |i|
      size.times { |j|
        m.set(i, j, GSL.pow(i + 1.0, size - j - 1.0))
      }
    }

    m
  end

  def setup
    @hilb2    = _create_hilbert_matrix(2)
    @hilb3    = _create_hilbert_matrix(3)
    @hilb4    = _create_hilbert_matrix(4)
    @hilb12   = _create_hilbert_matrix(12)
    @vander2  = _create_vandermonde_matrix(2)
    @vander3  = _create_vandermonde_matrix(3)
    @vander4  = _create_vandermonde_matrix(4)
    @vander12 = _create_vandermonde_matrix(12)

    @hilb2_solution  = GSL::Vector.alloc(-8.0, 18.0)
    @hilb3_solution  = GSL::Vector.alloc(27.0, -192.0, 210.0)
    @hilb4_solution  = GSL::Vector.alloc(-64.0, 900.0, -2520.0, 1820.0)
    @hilb12_solution = GSL::Vector.alloc(
      -1728.0, 245388.0, -8528520.0,
       127026900.0, -1009008000.0, 4768571808.0,
      -14202796608.0, 27336497760.0, -33921201600.0,
       26189163000.0, -11437874448.0, 2157916488.0
    )

    @vander2_solution  = GSL::Vector.alloc(1.0, 0.0)
    @vander3_solution  = GSL::Vector.alloc(0.0, 1.0, 0.0)
    @vander4_solution  = GSL::Vector.alloc(0.0, 0.0, 1.0, 0.0)
    @vander12_solution = GSL::Vector.alloc(0.0, 0.0, 0.0, 0.0,
                                           0.0, 0.0, 0.0, 0.0,
                                           0.0, 0.0, 1.0, 0.0)
  end

  def test_matmult
    a = GSL::Matrix.alloc([10.0, 5.0, 1.0, 20.0], 2, 2)
    b = GSL::Matrix.alloc([10.0, 5.0, 2.0, 1.0, 3.0, 2.0], 2, 3)
    c = a * b

    refute((c[0, 0] - 105.0).abs > GSL::DBL_EPSILON)
    refute((c[0, 1] -  65.0).abs > GSL::DBL_EPSILON)
    refute((c[0, 2] -  30.0).abs > GSL::DBL_EPSILON)
    refute((c[1, 0] -  30.0).abs > GSL::DBL_EPSILON)
    refute((c[1, 1] -  65.0).abs > GSL::DBL_EPSILON)
    refute((c[1, 2] -  42.0).abs > GSL::DBL_EPSILON)
  end

  def _test_bidiag_decomp_dim(m, eps, desc)
    eps *= 2 * GSL::DBL_EPSILON

    mm = m.size1
    nn = m.size2

    a = m.duplicate
    b = GSL::Matrix.calloc(nn, nn)

    u, v, d, sd = GSL::Linalg::Bidiag.unpack(*GSL::Linalg::Bidiag.decomp(a))

    b.set_diagonal(d)
    (nn - 1).times { |i| b[i, i + 1] = sd[i] }

    a = u * b * v.trans

    mm.times { |i|
      nn.times { |j|
        _check(aij = a[i, j], mij = m[i, j], eps,
          '%s: (%d,%d)[%d,%d]: %22.18g %22.18g' % [desc, mm, nn, i, j, aij, mij])
      }
    }
  end

  def test_bidiag_decomp
    m53 = _create_general_matrix(5, 3)
    m97 = _create_general_matrix(9, 7)

    _test_bidiag_decomp_dim(m53,       64.0, 'bidiag_decomp m(5,3)')
    _test_bidiag_decomp_dim(m97,       64.0, 'bidiag_decomp m(9,7)')
    _test_bidiag_decomp_dim(@hilb2,     8.0, 'bidiag_decomp hilbert(2)')
    _test_bidiag_decomp_dim(@hilb3,    64.0, 'bidiag_decomp hilbert(3)')
    _test_bidiag_decomp_dim(@hilb4,  1024.0, 'bidiag_decomp hilbert(4)')
    _test_bidiag_decomp_dim(@hilb12, 1024.0, 'bidiag_decomp hilbert(12)')
  end

  def test_cholesky
    m = GSL::Matrix.pascal(6)

    c_exp = GSL::Matrix[[1, 0, 0, 0, 0, 0],
                   [1, 1, 0, 0, 0, 0],
                   [1, 2, 1, 0, 0, 0],
                   [1, 3, 3, 1, 0, 0],
                   [1, 4, 6, 4, 1, 0],
                   [1, 5, 10, 10, 5, 1]]

    c = m.cholesky_decomp
    a = c.lower

    assert a == c_exp, "#{m.class}#cholesky_decomp"
    assert a * a.trans == m, "#{m.class}#cholesky_decomp"
  end

  def _test_HH_solve_dim(m, actual, eps, desc)
    eps *= GSL::DBL_EPSILON if eps > 1

    dim = m.size1

    x = GSL::Vector.indgen(dim) + 1
    GSL::Linalg::HH.svx(m.duplicate, x)

    dim.times { |i|
      _check(si = x[i], ai = actual[i], eps,
        '%s: %d[%d]: %22.18g %22.18g' % [desc, dim, i, si, ai])
    }
  end

  def test_HH_solve
    _test_HH_solve_dim(@hilb2,    @hilb2_solution,       8.0,  'HH_solve Hilbert(2)')
    _test_HH_solve_dim(@hilb3,    @hilb3_solution,     128.0,  'HH_solve Hilbert(3)')
    _test_HH_solve_dim(@hilb4,    @hilb4_solution,    2048.0,  'HH_solve Hilbert(4)')
    _test_HH_solve_dim(@hilb12,   @hilb12_solution,      0.5,  'HH_solve Hilbert(12)')
    _test_HH_solve_dim(@vander2,  @vander2_solution,     8.0,  'HH_solve Vander(2)')
    _test_HH_solve_dim(@vander3,  @vander3_solution,    64.0,  'HH_solve Vander(3)')
    _test_HH_solve_dim(@vander4,  @vander4_solution,  1024.0,  'HH_solve Vander(4)')
    _test_HH_solve_dim(@vander12, @vander12_solution,    0.05, 'HH_solve Vander(12)')
  end

  def test_LU
    m = GSL::Matrix.alloc([0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                          [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85])

    a = m.clone
    assert m == a, "#{a.class}#LU_decomp: matrix not destroyed"

    lu_exp = GSL::Matrix.alloc([0.51,              0.13,              0.19,              0.85],
                               [0.352941176470588, 0.554117647058823, 0.502941176470588, 0.66],
                               [0.803921568627451, 0.244515215852796, 0.71427813163482, -0.264713375796178],
                               [0.274509803921569, 0.476999292285916, 0.949126848480345, 0.363093705877982])

    x_exp = GSL::Vector[-4.05205022957397, -12.6056113959069, 1.66091162670884, 8.69376692879523]

    lu, perm, _sign = m.LU_decomp
    assert lu == lu_exp, "#{a.class}#LU_decomp"

    b = GSL::Vector[1, 2, 3, 4]
    x = GSL::Linalg::LU.solve(lu, perm, b)
    assert x == x_exp, "#{a.class}.LU_solve"

    x = lu.solve(perm, b)
    assert x == x_exp, "#{lu.class}#solve"

    perm, _sign = m.LU_decomp!
    assert m == lu_exp, "#{a.class}#LU_decomp!"

    m = a.clone

    x = GSL::Linalg::LU.solve(m, perm, b)
    assert x == x_exp, "#{a.class}.LU_solve"

    x = m.LU_solve(perm, b)
    assert x == x_exp, "#{a.class}#LU_solve"
    assert m == a, "#{a.class}#LU_solve: matrix not destroyed"

    h    = GSL::Matrix.hilbert(5)
    invh = GSL::Matrix.invhilbert(5)
    lu, perm, _sign = h.LU_decomp

    a = GSL::Linalg::LU.invert(lu, perm)
    assert a.equal?(invh, 1e-6), "#{h.class}#LU_invert, Hilbert matrix of order 5"

    a = lu.invert(perm)
    assert a.equal?(invh, 1e-6), "#{h.class}#LU_invert, Hilbert matrix of order 5"

    a = h.inv
    assert a.equal?(invh, 1e-6), "#{h.class}#LU_invert, Hilbert matrix of order 5"
  end

  def test_QR
    m = GSL::Matrix.alloc([0.18, 0.60, 0.57, 0.96], [0.41, 0.24, 0.99, 0.58],
                          [0.14, 0.30, 0.97, 0.66], [0.51, 0.13, 0.19, 0.85])

    a = m.clone
    assert m == a, "#{m.class}#QR_decomp: matrix not destroyed"

    x_exp = GSL::Vector[-4.05205022957397, -12.6056113959069, 1.66091162670884, 8.69376692879523]
    b = GSL::Vector[1, 2, 3, 4]

    qr, tau = m.QR_decomp

    x = m.QR_solve(b)
    assert x == x_exp, "#{m.class}#QR_solve(b)"

    x = GSL::Linalg::QR.solve(m, b)
    assert x == x_exp, 'GSL::Linalg::QR::solve(b)'

    tau = m.QR_decomp!
    assert m != a, "#{m.class}#QR_decomp: matrix destroyed"

    x = m.QR_solve(tau, b)
    assert x == x_exp, "#{m.class}#QR_solve(tau, b)"

    x = qr.solve(tau, b)
    assert x == x_exp, "#{qr.class}#solve(tau, b)"

    assert_raises(ArgumentError) { m.QR_solve(b) }
    assert_raises(ArgumentError) { m.solve(b) }

    x = m.solve(tau, b)
    assert x == x_exp, "#{m.class}#solve(tau, b)"

    m = a.clone
    bb = b.clone
    m.QR_svx(bb)
    assert bb == x_exp, "#{m.class}#QR_svx(b)"

    tau = GSL::Linalg::QR.decomp!(m)
    bb = b.clone
    m.QR_svx(tau, bb)
    assert bb == x_exp, "#{m.class}#QR_svx(tau, b)"
    assert_raises(ArgumentError) { m.QR_svx(bb) }

    m = a.clone
    qr, tau = m.QR_decomp
    assert m == a, "#{m.class}#QR_decomp: matrix not destroyed"

    x, r = m.QR_lssolve(b)
    assert x == x_exp, "#{m.class}#QR_lssolve(b)"

    r = m.QR_lssolve(b, x)
    assert x == x_exp, "#{qr.class}#QR_lssolve(b, x)"

    m.QR_lssolve(b, x, r)
    assert x == x_exp, "#{qr.class}#QR_lssolve(b, x, r)"

    x, r = qr.QR_lssolve(tau, b)
    assert x == x_exp, "#{qr.class}#QR_lssolve(tau, b)"

    r = qr.QR_lssolve(tau, b, x)
    assert x == x_exp, "#{qr.class}#QR_lssolve(tau, b, x)"

    qr.QR_lssolve(tau, b, x, r)
    assert x == x_exp, "#{qr.class}#QR_lssolve(tau, b, x, r)"
    assert_raises(ArgumentError) { qr.QR_lssolve(bb) }
  end

  def test_SV
    a = GSL::Matrix.alloc([1, 2, 3, 4], 2, 2)
    i = GSL::Matrix.identity(2)
    ainv = a.inv

    u, v, s = a.SV_decomp
    sm = s.to_m_diagonal
    sinv = s.map { |x| 1.0 / x }.to_m_diagonal

    assert u * sm * v.trans == a, "#{a.class}#SV_decomp"
    assert v * sinv * u.trans == ainv, "#{a.class}#SV_decomp"

    assert u.trans * u == i, "#{a.class}#SV_decomp"
    assert v.trans * v == i, "#{a.class}#SV_decomp"

    assert a * v == u * sm, "#{a.class}#SV_decomp"
    assert a.trans * u == v * sm, "#{a.class}#SV_decomp"
  end

  def _test_TDN_solve_dim(dim, d, a, b, actual, eps, desc)
    eps *= GSL::DBL_EPSILON

    abovediag = GSL::Vector.alloc(dim - 1)
    belowdiag = GSL::Vector.alloc(dim - 1)

    diag = GSL::Vector.alloc(dim)
    diag.set_all(d)

    rhs = GSL::Vector.indgen(dim) + 1

    abovediag.set_all(a)
    belowdiag.set_all(b)

    x = GSL::Linalg.solve_tridiag(diag, abovediag, belowdiag, rhs)

    dim.times { |i|
      _check(si = x[i], ai = actual[i], eps,
        '%s: %d[%d]: %22.18g %22.18g' % [desc, dim, i, si, ai])
    }
  end

  def test_TDN_solve
    actual = GSL::Vector.alloc(5)

    actual[0] = -7.0 / 3.0
    actual[1] =  5.0 / 3.0
    actual[2] =  4.0 / 3.0
    _test_TDN_solve_dim(3, 1.0, 2.0, 1.0, actual, 2.0, 'solve_TDN dim=2 A')

    actual[0] = 0.75
    actual[1] = 0.75
    actual[2] = 2.625
    _test_TDN_solve_dim(3, 1.0, 1.0 / 3.0, 1.0 / 2.0, actual, 2.0, 'solve_TDN dim=2 B')

    actual[0] =   99.0 / 140.0
    actual[1] =   41.0 /  35.0
    actual[2] =   19.0 /  10.0
    actual[3] =   72.0 /  35.0
    actual[4] =  139.0 /  35.0
    _test_TDN_solve_dim(5, 1.0, 1.0 / 4.0, 1.0 / 2.0, actual, 35.0 / 8.0, 'solve_TDN dim=5')
  end

  def _test_TDN_cyc_solve_dim(dim, d, a, b, actual, eps, desc)
    eps *= GSL::DBL_EPSILON

    abovediag = GSL::Vector.alloc(dim)
    belowdiag = GSL::Vector.alloc(dim)

    diag = GSL::Vector.alloc(dim)
    rhs = GSL::Vector.indgen(dim) + 1

    abovediag.set_all(a)
    belowdiag.set_all(b)

    diag.set_all(d)

    x = GSL::Linalg.solve_cyc_tridiag(diag, abovediag, belowdiag, rhs)
    dim.times { |i|
      _check(si = x[i], ai = actual[i], eps,
        '%s: %d[%d]: %22.18g %22.18g' % [desc, dim, i, si, ai])
    }
  end

  def test_TDN_cyc_solve
    actual = GSL::Vector.alloc(5)

    actual[0] =  3.0 / 2.0
    actual[1] = -1.0 / 2.0
    actual[2] =  1.0 / 2.0
    _test_TDN_cyc_solve_dim(3, 1.0, 2.0, 1.0, actual, 32.0, 'solve_TDN_cyc dim=2')

    actual[0] =  -5.0 / 22.0
    actual[1] =  -3.0 / 22.0
    actual[2] =  29.0 / 22.0
    actual[3] =  -9.0 / 22.0
    actual[4] =  43.0 / 22.0
    _test_TDN_cyc_solve_dim(5, 3.0, 2.0, 1.0, actual, 66.0, 'solve_TDN_cyc dim=5')
  end

  def _test_TDS_solve_dim(dim, d, od, actual, eps, desc)
    eps *= GSL::DBL_EPSILON

    diag = GSL::Vector.alloc(dim)
    diag.set_all(d)

    rhs = GSL::Vector.indgen(dim) + 1

    offdiag = GSL::Vector.alloc(dim - 1)
    offdiag.set_all(od)

    x = GSL::Linalg.solve_symm_tridiag(diag, offdiag, rhs)
    dim.times { |i|
      _check(si = x[i], ai = actual[i], eps,
        '%s: %d[%d]: %22.18g %22.18g' % [desc, dim, i, si, ai])
    }
  end

  def test_TDS_solve
    actual = GSL::Vector[0.0, 2.0]
    _test_TDS_solve_dim(2, 1.0, 0.5, actual, 8.0, 'solve_TDS dim=2 A')

    actual = GSL::Vector[3.0 / 8.0, 15.0 / 8.0]
    _test_TDS_solve_dim(2, 1.0, 1.0 / 3.0, actual, 8.0, 'solve_TDS dim=2 B')

    actual = GSL::Vector[5.0 / 8.0, 9.0 / 8.0, 2.0, 15.0 / 8.0, 35.0 / 8.0]
    _test_TDS_solve_dim(5, 1.0, 1.0 / 3.0, actual, 8.0, 'solve_TDS dim=5')
  end

  def _test_TDS_cyc_solve_one(dim, d, od, r, actual, eps, desc)
    eps *= GSL::DBL_EPSILON

    diag = d.duplicate
    offdiag = od.duplicate
    rhs = r.duplicate

    x = GSL::Linalg.solve_symm_cyc_tridiag(diag, offdiag, rhs)
    dim.times { |i|
      _check(si = x[i], ai = actual[i], eps,
        '%s: %d[%d]: %22.18g %22.18g' % [desc, dim, i, si, ai])
    }
  end

  def test_TDS_cyc_solve
    diag = GSL::Vector.alloc(1)
    diag[0] = 2

    offdiag = GSL::Vector.alloc(1)
    offdiag[0] = 3

    rhs = GSL::Vector.alloc(1)
    rhs[0] = 7

    actual = GSL::Vector.alloc(1)
    actual[0] = 3.5

    # XXX GSL::ERROR::EBADLEN: Ruby/GSL error code 19, size of cyclic system must be
    # 3 or more (file tridiag.c, line 531), matrix/vector sizes are not conformant
    #_test_TDS_cyc_solve_one(1, diag, offdiag, rhs, actual, 28.0, 'solve_TDS_cyc dim=1')

    diag = GSL::Vector[1, 2]
    offdiag = GSL::Vector[3, 4]
    rhs = GSL::Vector[7, -7]
    actual = GSL::Vector[-5, 4]

    # XXX GSL::ERROR::EBADLEN: Ruby/GSL error code 19, size of cyclic system must be
    # 3 or more (file tridiag.c, line 531), matrix/vector sizes are not conformant
    #_test_TDS_cyc_solve_one(2, diag, offdiag, rhs, actual, 28.0, 'solve_TDS_cyc dim=2')

    diag = GSL::Vector[1, 1, 1]
    offdiag = GSL::Vector[3, 3, 3]
    rhs = GSL::Vector[7, -7, 7]
    actual = GSL::Vector[-2, 5, -2]

    _test_TDS_cyc_solve_one(3, diag, offdiag, rhs, actual, 28.0, 'solve_TDS_cyc dim=3')

    diag = GSL::Vector[4, 2, 1, 2, 4]
    offdiag = GSL::Vector[1, 1, 1, 1, 1]
    rhs = GSL::Vector[30, -24, 3, 21, -30]
    actual = GSL::Vector[12, 3, -42, 42, -21]

    _test_TDS_cyc_solve_one(5, diag, offdiag, rhs, actual, 35.0, 'solve_TDS_cyc dim=5')
  end

end
require 'test_helper'

class SumTest < GSL::TestCase

  N = 50

  def setup
    @t = GSL::Vector.alloc(N)
    N.times { |n| @t[n] = 1.0 / (n + 1.0) ** 2 }
  end

  def _fill_vector(x = 1.0)
    @t[0] = x
    1.upto(N - 1) { |n| @t[n] = yield n, @t[n - 1] }
  end

  def _test_sum(expected, desc)
    sum_accel, _ = GSL::Sum::Levin_utrunc.alloc(N).accel(@t)
    assert_rel sum_accel, expected, 1e-8, 'trunc result, %s' % desc

    sum_accel, err_est, = GSL::Sum::Levin_u.alloc(N).accel(@t)
    assert_rel sum_accel, expected, 1e-8, 'full result, %s' % desc

    sd_est = -Math.log10(err_est / sum_accel.abs)
    sd_actual = -Math.log10(GSL::DBL_EPSILON + ((sum_accel - expected) / expected).abs)

    refute sd_est > sd_actual + 1.0,
      'full significant digits, %s (%g vs %g)' % [desc, sd_est, sd_actual]
  end

  def test_zeta_2
    _test_sum(GSL::M_PI ** 2 / 6.0, 'zeta(2)')
  end

  def test_exp_10(x = 10.0)
    _fill_vector { |n, t| t * (x / n) }
    _test_sum(Math.exp(x), 'exp(%d)' % x)
  end

  def test_exp_neg_10
    test_exp_10(-10.0)
  end

  def test_log(x = 0.5)
    _fill_vector(x) { |n, t| t * (x * n) / (n + 1.0) }
    _test_sum(-Math.log(1 - x), "-log(#{1 - x})")
  end

  def test_log2
    test_log(-1.0)
  end

  def test_asymptotic_series
    m = GSL::M_PI ** 2
    _fill_vector(3.0 / m) { |n, t| -t * (4.0 * (n + 1.0) - 1.0) / m }
    _test_sum(0.192594048773, 'asymptotic series')
  end

  def test_eulers_constant
    _fill_vector { |n, _| 1 / (n + 1.0) + Math.log(n / (n + 1.0)) }
    _test_sum(0.5772156649015328606065120900824, "Euler's constant")
  end

  def test_eta
    N.times { |n| @t[n] = (n % 2 == 1 ? -1 : 1) * 1.0 / GSL.sqrt(n + 1.0) }
    _test_sum(0.6048986434216305, 'eta(1/2)')
  end

end
require 'test_helper'

class DiffTest < GSL::TestCase

  def setup
    @f = [GSL::Function.alloc { |x| Math.exp(x) }]
    @df = [GSL::Function.alloc { |x| Math.exp(x) }]

    @f << GSL::Function.alloc { |x|
      x >= 0.0 ? x * Math.sqrt(x) : 0.0
    }
    @df << GSL::Function.alloc { |x|
      x >= 0.0 ? 1.5 * Math.sqrt(x) : 0.0
    }

    @f << GSL::Function.alloc { |x|
      x != 0.0 ? Math.sin(1.0 / x) : 0.0
    }
    @df << GSL::Function.alloc { |x|
      x != 0.0 ? -Math.cos(1.0 / x) / (x * x) : 0.0
    }

    @f << GSL::Function.alloc { |x| Math.exp(-x * x) }
    @df << GSL::Function.alloc { |x| -2.0 * x * Math.exp(-x * x) }

    @f << GSL::Function.alloc { |x| x * x }
    @df << GSL::Function.alloc { |x| 2.0 * x }

    @f << GSL::Function.alloc { |x| 1.0 / x }
    @df << GSL::Function.alloc { |x| -1.0 / (x * x) }
  end

  {
    'exp(x)'    => 1.0,
    'x^(3/2)'   => 0.1,
    'sin(1/x)'  => 0.45,
    'exp(-x^2)' => 0.5,
    'x^2'       => 0.0,
    '1/x'       => 10.0
  }.each_with_index { |(f, x), i|
    %w[central forward backward].each { |diff|
      define_method("test_#{diff}_#{i}") {
        expected = @df[i].eval(x)

        result, abserr = @f[i].send("diff_#{diff}", x)
        assert_abs result, expected, abserr, desc = "#{f}, x=#{x}, #{diff} diff"

        refute((result - expected).abs > abserr, '%s, valid error estimate' % desc)
      }
    }
  }

end
require 'test_helper'

class MonteTest < GSL::TestCase

  DIM = 1

  def test_miser
    return unless GSL::Monte::Miser.method_defined?(:params_get)

    miser = GSL::Monte::Miser.alloc(DIM)
    params = miser.params_get

    params.estimate_frac = 99
    miser.params_set(params)
    assert_abs miser.estimate_frac, 99, 1e-5, 'miser_estimate_frac'

    params.min_calls = 9
    miser.params_set(params)
    assert_int miser.min_calls, 9, 'miser_min_calls'

    params.min_calls_per_bisection = 7
    miser.params_set(params)
    assert_int miser.min_calls_per_bisection, 7, 'miser_min_calls_per_bisection'

    params.alpha = 3
    miser.params_set(params)
    assert_abs miser.alpha, 3, 1e-5, 'miser_alpha'

    params.dither = 4
    miser.params_set(params)
    assert_abs miser.dither, 4, 1e-5, 'miser_dither'
  end

  def test_vegas
    return unless GSL::Monte::Vegas.method_defined?(:params_get)

    vegas = GSL::Monte::Vegas.alloc(DIM)
    params = vegas.params_get

    params.alpha = 1
    vegas.params_set(params)
    assert_abs vegas.alpha, 1, 1e-5, 'vegas_alpha'

    params.iterations = 4
    vegas.params_set(params)
    assert_int vegas.iterations, 4, 'vegas_iterations'

    params.stage = 3
    vegas.params_set(params)
    assert_int vegas.stage, 3, 'vegas_stage'

    params.mode = GSL::Monte::Vegas::MODE_IMPORTANCE
    vegas.params_set(params)
    assert_int vegas.mode, GSL::Monte::Vegas::MODE_IMPORTANCE, 'vegas_mode MODE_IMPORTANCE'

    params.mode = GSL::Monte::Vegas::MODE_IMPORTANCE_ONLY
    vegas.params_set(params)
    assert_int vegas.mode, GSL::Monte::Vegas::MODE_IMPORTANCE_ONLY, 'vegas_mode MODE_IMPORTANCE_ONLY'

    params.mode = GSL::Monte::Vegas::MODE_STRATIFIED
    vegas.params_set(params)
    assert_int vegas.mode, GSL::Monte::Vegas::MODE_STRATIFIED, 'vegas_mode MODE_STRATIFIED'

    params.verbose = 0
    vegas.params_set(params)
    assert_int vegas.verbose, 0, 'vegas_verbose 0'

    params.verbose = 1
    vegas.params_set(params)
    assert_int vegas.verbose, 1, 'vegas_verbose 1'

    params.verbose = -1
    vegas.params_set(params)
    assert_int vegas.verbose, -1, 'vegas_verbose -1'
  end

end
require 'test_helper'

class Interp2dTest < GSL::TestCase

  def setup
    x_samples =(-20..20).map(&:to_f).to_a
    y_samples = (-20..20).map(&:to_f).to_a
    z_samples = []
    x_samples.each do |x|
      y_samples.each do |y|
        z_samples << saddle(x,y) 
      end
    end

    @x_array = GSL::Vector.alloc(x_samples)
    @y_array = GSL::Vector.alloc(y_samples)
    @z_array = GSL::Vector.alloc(z_samples)

    tolerance = 0.05 # 5% inaccuracy is tolerated in tests below

    
    @i2d_bicubic = GSL::Interp2d.alloc(GSL::Interp2d::BICUBIC,
      @x_array, @y_array, @z_array)

    @i2d_bilinear = GSL::Interp2d.alloc(GSL::Interp2d::BILINEAR,
      @x_array, @y_array, @z_array)
  end

  def saddle(x,y)
    x*x - y*y
  end

  def test_constants
    assert_equal 0, GSL::Interp2d::BICUBIC
    assert_equal 1, GSL::Interp2d::BILINEAR
  end

  def test_alloc_alternate_arg_construct
    i2d = GSL::Interp2d.alloc(GSL::Interp2d::BICUBIC, 10, 10)

    assert_equal GSL::Interp2d, i2d.class
  end

  def test_alloc
    assert_equal GSL::Interp2d, @i2d_bicubic.class
    assert_equal GSL::Interp2d, @i2d_bilinear.class
  end

  def test_alloc_init
    i2d = GSL::Interp2d.alloc(GSL::Interp2d::BICUBIC, @x_array.size, @y_array.size)
    i2d.init(@x_array, @y_array, @z_array)

    assert_equal GSL::Interp2d, i2d.class
  end

  def test_info
    str = <<-EOF
Class:      GSL::Interp2d
SuperClass: GSL::Object
Type:       bilinear
xmin:       -20.000000
xmax:       20.000000
ymin:       -20.000000
ymax:       20.000000
xsize:       41
ysize:       41
    EOF
    assert_equal str, @i2d_bilinear.info
  end

  def test_use_case_saddle_interpolation
    tolerance = 0.05 # 5% inaccuracy is tolerated in tests below
    interpolator_type = GSL::Interp2d::BICUBIC

    i2d = GSL::Interp2d.alloc(interpolator_type, @x_array, @y_array, @z_array)

    # confirm that the fit passes very close to the sampled data points
    @x_array.each do |x|
      @y_array.each do |y|
        expected_z = saddle(x,y)
        z = i2d.eval(@x_array, @y_array, @z_array, x, y)
        error = (z - expected_z).abs
        max_error = (expected_z.abs)*tolerance
        if max_error == 0
          max_error = tolerance
        end
        refute error > max_error, "error @ sample #{x},#{y} z: #{z} expected_z: #{expected_z}"
      end
    end

    interstitial_x_values = @x_array.to_a.first(@x_array.size-1).map {|v| v+ 0.5}
    interstitial_y_values = @y_array.to_a.first(@y_array.size-1).map {|v| v+ 0.3}

    # confirm that interstitial values are interpolated accurately 
    interstitial_x_values.each do |x|
      interstitial_y_values.each do |y|
        expected_z = saddle(x,y)
        z = i2d.eval(@x_array, @y_array, @z_array, x,y)
        error = (z - expected_z).abs
        max_error = (expected_z.abs)*tolerance
        if max_error == 0
          max_error = tolerance
        end
        refute error > max_error, "error @ interstitial #{x},#{y}"
      end
    end
  end
end if GSL::GSL_VERSION >= '2.0'require 'test_helper'

class MatrixNmfTest < GSL::TestCase

  def setup
    @m1 = GSL::Matrix.alloc([6, 7, 8], [2, 3, 4], [3, 4, 5])
    @m2 = GSL::Matrix.alloc([6, 7, 8], [2, 3, 4], [3, 4, 7])
  end

  def test_difcost
    assert_equal 0, GSL::Matrix::NMF.difcost(@m1, @m1)
    assert_equal 4, GSL::Matrix::NMF.difcost(@m1, @m2)
  end

  def test_nmf
    [2, 3, 4, 5].each { |cols|
      res = GSL::Matrix::NMF.nmf(@m1, cols)
      assert_equal [3, cols], res[0].size
      assert_equal [cols, 3], res[1].size

      cost = GSL::Matrix::NMF.difcost(@m1, res[0] * res[1])
      assert cost <= 0.0001, "Cols: #{cols}, Delta: #{cost}"
    }
  end

  def test_matrix_nmf
    [2, 3, 4, 5].each { |cols|
      res = @m1.nmf(cols)
      assert_equal [3, cols], res[0].size
      assert_equal [cols, 3], res[1].size

      cost = GSL::Matrix::NMF.difcost(@m1, res[0] * res[1])
      assert cost <= 0.0001, "Cols: #{cols}, Delta: #{cost}"
    }
  end

end
require 'test_helper'

class IndexTest < GSL::TestCase

  # helper(s)

  def _create_index array
    i = GSL::Index.alloc(array.size)
    array.each_with_index { |e, j| i[j] = e }
    i
  end

  # tests

  def test_get_int
    i = GSL::Index.alloc(5)
    assert_equal 2, i.get(2)
    assert_equal 4, i.get(4)
    assert_equal 3, i.get(-2)
    assert_equal 0, i.get(-5)
  end

  def test_get_array
    i = GSL::Index.alloc(5)
    assert_equal _create_index([2, 3]), i.get([2, 3])
    assert_equal _create_index([4, 2]), i.get([-1, 2])
    assert_equal _create_index([4, 3, 1]), i.get([4, -2, 1])
    assert_equal _create_index([0, 4, 4, 0]), i.get([0, 4, -1, -5])
  end

  def test_get_range
    i = GSL::Index.alloc(5)
    assert_equal _create_index([2, 3]), i.get(2..3)
    assert_equal _create_index([0, 1, 2, 3, 4]), i.get(0..4)
    assert_equal _create_index([0, 1, 2, 3, 4]), i.get(0..5)
    assert_equal _create_index([0, 1, 2, 3, 4]), i.get(-5..-1)
    assert_equal _create_index([0]), i.get(0..-5)
    assert_equal _create_index([0]), i.get(-5..0)
    assert_equal _create_index([3]), i.get(-2..3)
    assert_equal _create_index([3, 4]), i.get(-2..4)
    assert_equal _create_index([1, 2, 3]), i.get(-4...-1) # note the exclusive range operator!
  end

  def test_get_failure
    i = GSL::Index.alloc(5)
    assert_raises(RangeError) { i.get(5) }
    assert_raises(RangeError) { i.get(-6) }
    assert_raises(RangeError) { i.get(1_000_000) }
    assert_raises(ArgumentError) { i.get(10**100) }

    assert_raises(RangeError) { i.get([5]) }
    assert_raises(RangeError) { i.get([-6]) }
    assert_raises(RangeError) { i.get([-6, 0, 5]) }

    assert_raises(RangeError) { i.get(-6..-1) }
    assert_raises(RangeError) { i.get(3..-5) }
    assert_raises(RangeError) { i.get(-2..-3) }
    assert_raises(RangeError) { i.get(-2..1) }
  end

end
require 'test_helper'

class EigenTest < GSL::TestCase

  def _create_random_symm_matrix(size1, size2, rng, lower, upper)
    m = GSL::Matrix.alloc(size1, size2)

    size1.times { |i|
      size2.times { |j|
        x = rng.uniform * (upper - lower) + lower
        m[i, j] = x
        m[j, i] = x
      }
    }

    m
  end

  def _create_random_herm_matrix(size1, size2, rng, lower, upper)
    m = GSL::Matrix::Complex.alloc(size1, size2)

    size1.times { |i|
      size2.times { |j|
        z = GSL::Complex.alloc(rng.uniform * (upper - lower) + lower,
          i == j ? 0.0 : rng.uniform * (upper - lower) + lower)

        m[i, j] = z
        m[j, i] = z.conjugate
      }
    }

    m
  end

  def _create_random_posdef_matrix(size1, size2, rng)
    m = GSL::Matrix.alloc(size1, size2)
    x = rng.uniform

    size1.times { |i|
      i.upto(size2 - 1) { |j|
        a = GSL.pow(x, (j - i).to_f)
        m[i, j] = a
        m[j, i] = a
      }
    }

    m
  end

  def _create_random_complex_posdef_matrix(size1, size2, rng)
    m = GSL::Matrix::Complex.calloc(size1, size2)
    n = size1

    n.times { |i| m[i, i] = GSL::Complex.alloc(rng.uniform, 0.0) }

    work = GSL::Vector::Complex.alloc(n)

    n.times { |i|
      tau = GSL::Linalg::Complex.householder_transform(work)
      GSL::Linalg::Complex.householder_hm(tau, work, m)
      GSL::Linalg::Complex.householder_mh(tau.conjugate, work, m)
    }

    m
  end

  def _create_random_nonsymm_matrix(size1, size2, rng, lower, upper)
    m = GSL::Matrix.alloc(size1, size2)

    size1.times { |i|
      size2.times { |j|
        m[i, j] = rng.uniform * (upper - lower) + lower
      }
    }

    m
  end

  def _test_eigen_results(n, m, e_val, e_vec, desc, desc2)
    x = GSL::Vector.alloc(n)
    y = GSL::Vector.alloc(n)

    n.times { |i|
      ei = e_val[i]

      GSL::Vector.memcpy(x, e_vec.col(i))
      y = GSL::Blas.dgemv(GSL::Blas::NoTrans, 1.0, m, x, 0.0, y)

      n.times { |j|
        assert_rel y[j], ei * x[j], 1e8 * GSL::DBL_EPSILON,
          '%s, eigenvalue(%d,%d), %s' % [desc, i, j, desc2]
      }
    }

    n.times { |i|
      assert_rel GSL::Blas.dnrm2(e_vec.col(i)), 1.0, n * GSL::DBL_EPSILON,
        '%s, normalized(%d), %s' % [desc, i, desc2]
    }

    n.times { |i|
      vi = e_vec.col(i)

      (i + 1).upto(n - 1) { |j|
        assert_abs GSL::Blas.ddot(vi, e_vec.col(j)), 0.0, n * GSL::DBL_EPSILON,
          '%s, orthogonal(%d,%d), %s' % [desc, i, j, desc2]
      }
    }
  end

  def _test_eigen_complex_results(n, m, e_val, e_vec, desc, desc2)
    x = GSL::Vector::Complex.alloc(n)
    y = GSL::Vector::Complex.alloc(n)

    n.times { |i|
      ei = e_val[i]
      GSL::Vector::Complex.memcpy(x, e_vec.col(i))

      c1 = GSL::Complex.alloc(1.0, 0.0)
      c0 = GSL::Complex.alloc(0.0, 0.0)
      y = GSL::Blas.zgemv(GSL::Blas::NoTrans, c1, m, x, c0, y)

      n.times { |j|
        xj = x[j]
        yj = y[j]

        assert_rel yj.re, ei * xj.re, 1e8 * GSL::DBL_EPSILON,
          '%s, eigenvalue(%d,%d), real, %s' % [desc, i, j, desc2]
        assert_rel yj.im, ei * xj.im, 1e8 * GSL::DBL_EPSILON,
          '%s, eigenvalue(%d,%d), imag, %s' % [desc, i, j, desc2]
      }
    }

    n.times { |i|
      assert_rel GSL::Blas.dznrm2(e_vec.col(i)), 1.0, n * GSL::DBL_EPSILON,
        '%s, normalized(%d), %s' % [desc, i, desc2]
    }

    n.times { |i|
      vi = e_vec.col(i)

      (i + 1).upto(n - 1) { |j|
        assert_abs GSL::Blas.zdotc(vi, e_vec.col(j)).abs, 0.0, n * GSL::DBL_EPSILON,
          '%s, orthogonal(%d,%d), %s' % [desc, i, j, desc2]
      }
    }
  end

  def _test_eigenvalues(n, e_val, e_val2, desc, desc2)
    n.times { |i|
      assert_rel e_val[i], e_val2[i], GSL::DBL_EPSILON,
        '%s, direct eigenvalue(%d), %s' % [desc, i, desc2]
    }
  end

  def _test_eigenvalues_real(e_val, e_val2, desc, desc2)
    n, emax = e_val.size, 0

    n.times { |i|
      e = e_val[i].abs
      emax = e if e > emax
    }

    n.times { |i|
      e2i = e_val2[i]
      assert_abs e_val[i], e2i.abs < GSL::DBL_MIN ? 0 : e2i, emax * 1e8 * GSL::DBL_EPSILON,
        "#{desc}, direct eigenvalue(#{i}), #{desc2}"
    }
  end

  def _test_eigenvalues_complex(e_val, e_val2, desc, desc2)
    n = e_val.size

    n.times { |i|
      assert_rel e_val[i].real, e_val2[i].real, 10 * n * GSL::DBL_EPSILON,
        "#{desc}, direct eigenvalue(#{i}) real, #{desc2}"
      assert_rel e_val[i].imag, e_val2[i].imag, 10 * n * GSL::DBL_EPSILON,
        "#{desc}, direct eigenvalue(#{i}) imag, #{desc2}"
    }
  end

  def _test_eigen_schur(a, s, q, z, count, desc, desc2)
    n = a.size1

    t1 = a * z
    t2 = q * s

    n.times { |i|
      n.times { |j|
        assert_abs t1[i, j], t2[i, j], 1.0e8 * GSL::DBL_EPSILON,
          "#{desc}(N=#{n},cnt=#{count}), #{desc2}, schur(#{i},#{j})"
      }
    }
  end

  def _test_eigen_genherm_results(a, b, e_val, e_vec, count, desc, desc2)
    n = a.size1

    n.times { |i|
      vi = e_vec.column(i)

      assert_rel vi.nrm2, 1.0, n * GSL::DBL_EPSILON,
        "genherm(N=#{n},cnt=#{count}), #{desc}, normalized(#{i}), #{desc2}"

      y = a * vi
      x = (b * vi) * e_val[i]

      n.times { |j|
        assert_rel y[j].real, x[j].real, 1e9 * GSL::DBL_EPSILON,
          "genherm(N=#{n},cnt=#{count}), #{desc}, eigenvalue(#{i},#{j}), real, #{desc2}"
        assert_rel y[j].imag, x[j].imag, 1e9 * GSL::DBL_EPSILON,
          "genherm(N=#{n},cnt=#{count}), #{desc}, eigenvalue(#{i},#{j}), imag, #{desc2}"
      }
    }
  end

  def test_eigen_genherm
    rng = GSL::Rng.alloc

    1.upto(20) { |n|
      w = GSL::Eigen::Genherm.alloc(n)
      wv = GSL::Eigen::Genhermv.alloc(n)

      5.times { |i|
        a = _create_random_herm_matrix(n, n, rng, -10, 10)
        b = _create_random_complex_posdef_matrix(n, n, rng)

        e_valv, e_vec = GSL::Eigen.genhermv(a, b, wv)
        _test_eigen_genherm_results(a, b, e_valv, e_vec, i, 'random', 'unsorted')

        e_val = GSL::Eigen.genherm(a, b, w)

        x = e_val.sort
        y = e_valv.sort

        _test_eigenvalues_real(y, x, 'genherm, random', 'unsorted')

        GSL::Eigen.genhermv_sort(e_valv, e_vec, GSL::EIGEN_SORT_VAL_ASC)
        _test_eigen_genherm_results(a, b, e_valv, e_vec, i, 'random', 'val/asc')

        GSL::Eigen.genhermv_sort(e_valv, e_vec, GSL::EIGEN_SORT_VAL_DESC)
        _test_eigen_genherm_results(a, b, e_valv, e_vec, i, 'random', 'val/desc')

        GSL::Eigen.genhermv_sort(e_valv, e_vec, GSL::EIGEN_SORT_ABS_ASC)
        _test_eigen_genherm_results(a, b, e_valv, e_vec, i, 'random', 'abs/asc')
        GSL::Eigen.genhermv_sort(e_valv, e_vec, GSL::EIGEN_SORT_ABS_DESC)
        _test_eigen_genherm_results(a, b, e_valv, e_vec, i, 'random', 'abs/desc')
      }
    }
  end

  def _test_eigen_gen_results(a, b, alpha, beta, e_vec, count, desc, desc2)
    n = a.size1

    ma = a.to_complex
    mb = b.to_complex

    n.times { |i|
      vi = e_vec.column(i)

      x = (mb * vi) * alpha[i]
      y = (ma * vi) * beta[i]

      n.times { |j|
        assert_abs y[j].real, x[j].real, 1e8 * GSL::DBL_EPSILON,
          "gen(N=#{n},cnt=#{count}), #{desc}, eigenvalue(#{i},#{j}), real, #{desc2}"
        assert_abs y[j].imag, x[j].imag, 1e8 * GSL::DBL_EPSILON,
          "gen(N=#{n},cnt=#{count}), #{desc}, eigenvalue(#{i},#{j}), imag, #{desc2}"
      }
    }
  end

  def _test_eigen_gen_pencil(a, b, count, desc, test_schur, w, wv)
    n = a.size1

    aa = a.clone
    bb = b.clone

    if test_schur == 1
      alphav, betav, e_vec, q, z = GSL::Eigen.genv_QZ(aa, bb, wv)
      _test_eigen_schur(a, aa, q, z, count, 'genv/A', desc)
      _test_eigen_schur(b, bb, q, z, count, 'genv/B', desc)
    else
      alphav, betav, e_vec = GSL::Eigen.genv(aa, bb, wv)
    end

    _test_eigen_gen_results(a, b, alphav, betav, e_vec, count, desc, 'unsorted')

    aa = a.clone
    bb = b.clone

    if test_schur == 1
      GSL::Eigen.gen_params(1, 1, 0, w)

      alpha, beta, q, z = GSL::Eigen.gen_QZ(aa, bb, w)
      _test_eigen_schur(a, aa, q, z, count, 'gen/A', desc)
      _test_eigen_schur(b, bb, q, z, count, 'gen/B', desc)
    else
      GSL::Eigen.gen_params(0, 0, 0, w)
      alpha, beta = GSL::Eigen.gen(aa, bb, w)
    end

    e_val = GSL::Vector::Complex.alloc(n)
    e_valv = GSL::Vector::Complex.alloc(n)

    n.times { |i|
      ai = alpha[i]
      bi = beta[i]
      e_val[i] = GSL::Complex.alloc(ai.real / bi, ai.imag / bi)

      ai = alphav[i]
      bi = betav[i]
      e_valv[i] = GSL::Complex.alloc(ai.real / bi, ai.imag / bi)
    }

    GSL::Eigen.nonsymmv_sort(e_val, nil, GSL::EIGEN_SORT_ABS_ASC)
    GSL::Eigen.nonsymmv_sort(e_valv, nil, GSL::EIGEN_SORT_ABS_ASC)
    _test_eigenvalues_complex(e_valv, e_val, 'gen', desc)

    GSL::Eigen.genv_sort(alphav, betav, e_vec, GSL::EIGEN_SORT_ABS_ASC)
    _test_eigen_gen_results(a, b, alphav, betav, e_vec, count, desc, 'abs/asc')
    GSL::Eigen.genv_sort(alphav, betav, e_vec, GSL::EIGEN_SORT_ABS_DESC)
    _test_eigen_gen_results(a, b, alphav, betav, e_vec, count, desc, 'abs/desc')
  end

  def test_eigen_gen
    rng = GSL::Rng.alloc

    1.upto(20) { |n|
      w = GSL::Eigen::Gen.alloc(n)
      wv = GSL::Eigen::Genv.alloc(n)

      5.times { |i|
        a = _create_random_nonsymm_matrix(n, n, rng, -10, 10)
        b = _create_random_nonsymm_matrix(n, n, rng, -10, 10)
        _test_eigen_gen_pencil(a, b, i, 'random', 0, w, wv)
        _test_eigen_gen_pencil(a, b, i, 'random', 1, w, wv)
      }
    }

    ma = GSL::Matrix.alloc([1, 1, 0, 0, 0, -1, 1, 0, 0], 3, 3)
    mb = GSL::Matrix.alloc([-1, 0, -1, 0, -1, 0, 0, 0, -1], 3, 3)

    w = GSL::Eigen::Gen.alloc(3)
    wv = GSL::Eigen::Genv.alloc(3)

    _test_eigen_gen_pencil(ma, mb, 0, 'integer', 0, w, wv)
    _test_eigen_gen_pencil(ma, mb, 0, 'integer', 1, w, wv)
  end

  def _test_eigen_gensymm_results(a, b, e_val, e_vec, count, desc, desc2)
    n = a.size1

    n.times { |i|
      vi = e_vec.column(i)

      assert_rel vi.dnrm2, 1.0, n * GSL::DBL_EPSILON,
        "gensymm(N=#{n},cnt=#{count}), #{desc}, normalized(#{i}), #{desc2}"

      y = a * vi
      x = (b * vi) * e_val[i]

      n.times { |j|
        assert_rel y[j], x[j], 1e9 * GSL::DBL_EPSILON,
          "gensymm(N=#{n},cnt=#{count}), #{desc}, eigenvalue(#{i},#{j}), #{desc2}"
      }
    }
  end

  def test_eigen_gensymm
    rng = GSL::Rng.alloc

    1.upto(20) { |n|
      w  = GSL::Eigen::Gensymm::Workspace.alloc(n)
      wv = GSL::Eigen::Gensymmv::Workspace.alloc(n)

      5.times { |i|
        a = _create_random_symm_matrix(n, n, rng, -10, 10)
        b = _create_random_posdef_matrix(n, n, rng)

        e_valv, e_vec = GSL::Eigen.gensymmv(a.clone, b.clone, wv)
        _test_eigen_gensymm_results(a, b, e_valv, e_vec, i, 'random', 'unsorted')

        x = GSL::Eigen.gensymm(a.clone, b.clone, w).sort
        y = e_valv.sort

        _test_eigenvalues_real(y, x, 'gensymm, random', 'unsorted')

        GSL::Eigen::Gensymmv.sort(e_valv, e_vec, GSL::EIGEN_SORT_VAL_ASC)
        _test_eigen_gensymm_results(a, b, e_valv, e_vec, i, 'random', 'val/asc')

        GSL::Eigen::Gensymmv.sort(e_valv, e_vec, GSL::EIGEN_SORT_VAL_DESC)
        _test_eigen_gensymm_results(a, b, e_valv, e_vec, i, 'random', 'val/desc')

        GSL::Eigen::Gensymmv.sort(e_valv, e_vec, GSL::EIGEN_SORT_ABS_ASC)
        _test_eigen_gensymm_results(a, b, e_valv, e_vec, i, 'random', 'abs/asc')
        GSL::Eigen::Gensymmv.sort(e_valv, e_vec, GSL::EIGEN_SORT_ABS_DESC)
        _test_eigen_gensymm_results(a, b, e_valv, e_vec, i, 'random', 'abs/desc')
      }
    }
  end

  def test_nonsymm
    m = GSL::Matrix[[1, 2], [3, 2]]
    e_val = m.eigen_nonsymm.real.sort
    assert_abs e_val[0], -1, 0, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[1], 4, 0, 'GSL::Matrix::eigen_nonsymm'

    m = GSL::Matrix[[1, 4, 2, 3], 2, 2]
    e_val = m.eigen_nonsymm.real.sort
    assert_abs e_val[0], -1, 0, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[1], 5, 0, 'GSL::Matrix::eigen_nonsymm'

    m = GSL::Matrix[[2, 4], [3, 1]]
    e_val = m.eigen_nonsymm.real.sort
    assert_abs e_val[0], -2, 0, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[1], 5, 0, 'GSL::Matrix::eigen_nonsymm'

    m = GSL::Matrix[[5, 6, 3, 2], 2, 2]
    e_val = m.eigen_nonsymm.real.sort
    assert_abs e_val[0], -1, 0, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[1], 8, 0, 'GSL::Matrix::eigen_nonsymm'

    m = GSL::Matrix[[4, 1, -1, 2, 5, -2, 1, 1, 2], 3, 3]
    e_val = m.eigen_nonsymm.real.sort
    assert_abs e_val[0], 3, 1e-10, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[1], 3, 0, 'GSL::Matrix::eigen_nonsymm'
    # 2008/Oct/17 YT
    # This test fails in Darwin9.5.0-gcc4.0.1
    #   expected: 5
    #   obtained: 4.99999999999999911
    #assert_abs e_val[2], 5, 0, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[2], 4.99999999999999911, 0, 'GSL::Matrix::eigen_nonsymm'

    m = GSL::Matrix[[-3, 1, -1], [-7, 5, -1], [-6, 6, -2]]
    e_val = m.eigen_nonsymm.real.sort
    assert_abs e_val[0], -2, 1e-6, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[1], -2, 1e-6, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[2], 4, 1e-10, 'GSL::Matrix::eigen_nonsymm'

    m = GSL::Matrix[[11, -8, 4, -8, -1, -2, 4, -2, -4], 3, 3]
    e_val = m.eigen_nonsymm.real.sort
    assert_abs e_val[0], -5, 1e-10, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[1], -5, 1e-10, 'GSL::Matrix::eigen_nonsymm'
    assert_abs e_val[2], 16, 1e-10, 'GSL::Matrix::eigen_nonsymm'
  end

  def _test_nonsymmv2(m, eps)
    m2 = m.clone

    e_val, e_vec = m2.eigen_nonsymmv
    e_valre = e_val.real
    e_vecre = e_vec.real

    a = e_vecre.inv * m * e_vecre

    assert_abs a[0, 0], e_valre[0], eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[1, 1], e_valre[1], eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[0, 1], 0, eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[1, 0], 0, eps, 'GSL::Matrix::eigen_nonsymmv'
  end

  def _test_nonsymmv3(m, eps)
    m2 = m.clone

    e_val, e_vec = m2.eigen_nonsymmv
    e_valre = e_val.real
    e_vecre = e_vec.real

    a = e_vecre.inv * m * e_vecre

    assert_abs a[0, 0], e_valre[0], eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[1, 1], e_valre[1], eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[2, 2], e_valre[2], eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[0, 1], 0, eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[0, 2], 0, eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[1, 0], 0, eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[1, 2], 0, eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[2, 0], 0, eps, 'GSL::Matrix::eigen_nonsymmv'
    assert_abs a[2, 1], 0, eps, 'GSL::Matrix::eigen_nonsymmv'
  end

  def test_nonsymmv
    m = GSL::Matrix[[1, 2], [3, 2]]
    _test_nonsymmv2(m, 1e-10)

    m = GSL::Matrix[[4, 2, 3, -1], 2, 2]
    _test_nonsymmv2(m, 1e-10)

    m = GSL::Matrix[[2, 2, -5], [3, 7, -15], [1, 2, -4]]
    _test_nonsymmv3(m, 1e-10)

    m = GSL::Matrix[[4, 1, -1], [2, 5, -2], [1, 1, 2]]
    _test_nonsymmv3(m, 1e-10)

    m = GSL::Matrix[[-3, 1, -1], [-7, 5, -1], [-6, 6, -2]]
    _test_nonsymmv3(m, 1e-6)

    m = GSL::Matrix[[11, -8, 4], [-8, -1, -2], [4, -2, -4]]
    _test_nonsymmv3(m, 1e-10)
  end

  def _test_eigen_symm(desc, m)
    n = m.size1
    a = GSL::Matrix.alloc(n, n)

    w1 = GSL::Eigen::Symm::Workspace.alloc(n)
    w2 = GSL::Eigen::Symmv::Workspace.alloc(n)

    GSL::Matrix.memcpy(a, m)
    e_val, e_vec = a.eigen_symmv(w2)
    _test_eigen_results(n, m, e_val, e_vec, desc, 'unsorted')

    GSL::Matrix.memcpy(a, m)
    e_val2 = a.eigen_symm(w1)
    _test_eigenvalues(n, e_val, e_val2, desc, 'unsorted')

    GSL::Eigen::Symmv.sort(e_val, e_vec, GSL::Eigen::SORT_VAL_ASC)
    _test_eigen_results(n, m, e_val, e_vec, desc, 'val/asc')
    GSL::Eigen::Symmv.sort(e_val, e_vec, GSL::Eigen::SORT_VAL_DESC)
    _test_eigen_results(n, m, e_val, e_vec, desc, 'val/desc')
    GSL::Eigen::Symmv.sort(e_val, e_vec, GSL::Eigen::SORT_ABS_ASC)
    _test_eigen_results(n, m, e_val, e_vec, desc, 'abs/asc')
    GSL::Eigen::Symmv.sort(e_val, e_vec, GSL::Eigen::SORT_ABS_DESC)
    _test_eigen_results(n, m, e_val, e_vec, desc, 'abs/desc')
  end

  def _test_eigen_herm(desc, m)
    n = m.size1
    a = GSL::Matrix::Complex.alloc(n, n)

    w1 = GSL::Eigen::Herm::Workspace.alloc(n)
    w2 = GSL::Eigen::Hermv::Workspace.alloc(n)

    GSL::Matrix::Complex.memcpy(a, m)
    e_val, e_vec = a.eigen_hermv(w2)
    _test_eigen_complex_results(n, m, e_val, e_vec, desc, 'unsorted')

    GSL::Matrix::Complex.memcpy(a, m)
    e_val2 = a.eigen_herm(w1)
    _test_eigenvalues(n, e_val, e_val2, desc, 'unsorted')

    GSL::Eigen::Hermv.sort(e_val, e_vec, GSL::Eigen::SORT_VAL_ASC)
    _test_eigen_complex_results(n, m, e_val, e_vec, desc, 'val/asc')
    GSL::Eigen::Hermv.sort(e_val, e_vec, GSL::Eigen::SORT_VAL_DESC)
    _test_eigen_complex_results(n, m, e_val, e_vec, desc, 'val/desc')
    GSL::Eigen::Hermv.sort(e_val, e_vec, GSL::Eigen::SORT_ABS_ASC)
    _test_eigen_complex_results(n, m, e_val, e_vec, desc, 'abs/asc')
    GSL::Eigen::Hermv.sort(e_val, e_vec, GSL::Eigen::SORT_ABS_DESC)
    _test_eigen_complex_results(n, m, e_val, e_vec, desc, 'abs/desc')
  end

  def test_symm_herm
    r = GSL::Matrix.alloc([0, 0, -1, 0], [0, 1, 0, 1], [-1, 0, 0, 0], [0, 1, 0, 0])
    _test_eigen_symm('symm(4)', r)
    _test_eigen_herm('herm(4)', r.to_complex)

    r = GSL::Matrix.alloc(4, 4)
    r.set_diagonal([1, 2, 3, 4])
    _test_eigen_symm('symm(4) diag', r)
    _test_eigen_herm('herm(4) diag', r.to_complex)
  end

end
require 'test_helper'

class MinTest < GSL::TestCase

  EPSABS = 0.001
  EPSREL = 0.001

  MAX_ITERATIONS = 100

  def _test_f(type, desc, f, x_lower, mid, x_upper, min)
    s = GSL::Min::FMinimizer.alloc(type)
    s.set(@f[f], mid, x_lower, x_upper)

    status = iterations = 0

    begin
      iterations += 1
      status = s.iterate

      m = s.x_minimum
      a = s.x_lower
      b = s.x_upper

      refute a > b, 'interval is invalid (%g,%g)' % [a, b]
      refute m < a || m > b, 'm lies outside interval %g (%g,%g)' % [m, a, b]

      break if status == 1

      status = GSL::Min.test_interval(a, b, EPSABS, EPSREL)
    end while status == GSL::CONTINUE && iterations < MAX_ITERATIONS

    assert status.zero?, '%s, %s (%g obs vs %g expected)' % [s.name, desc, s.x_minimum, min]

    assert_tol m, min, 'incorrect precision (%g obs vs %g expected)' % [m, min]
  end

  def _test_f_e(type, desc, f, x_lower, mid, x_upper, min)
    s = GSL::Min::FMinimizer.alloc(type)

    assert_raises(GSL::ERROR::EINVAL, '%s, %s' % [s.name, desc]) {
      s.set(@f[f], mid, x_lower, x_upper)
    }

    status = iterations = 0

    begin
      iterations += 1
      s.iterate

      _ = s.x_minimum
      a = s.x_lower
      b = s.x_upper

      status = GSL::Min.test_interval(a, b, EPSABS, EPSREL)
    rescue
    end while status == GSL::CONTINUE && iterations < MAX_ITERATIONS

    assert status.zero?, '%s, %s' % [s.name, desc]
  end

  def setup
    @f = [GSL::Function.alloc { |x| Math.cos(x) }]
    @f << GSL::Function.alloc { |x| GSL.pow(x, 4.0) - 1 }
    @f << GSL::Function.alloc { |x| Math.sqrt(x.abs) }
    @f << GSL::Function.alloc { |x| x < 1.0 ? 1 : -Math.exp(-x) }
    @f << GSL::Function.alloc { |x| x - 30.0 / (1.0 + 1e5 * GSL.pow(x - 0.8, 2.0)) }
  end

  %w[goldensection brent quad_golden].each { |type|
    {
      'cos(x) [0 (3) 6]'        => [0,  0.0,  3.0,   6.0, GSL::M_PI],
      'x^4 - 1 [-3 (-1) 17]'    => [1, -3.0, -1.0,  17.0, 0.0],
      'sqrt(|x|) [-2 (-1) 1.5]' => [2, -2.0, -1.0,   1.5, 0.0],
      'func3(x) [-2 (3) 4]'     => [3, -2.0,  3.0,   4.0, 1.0],
      'func4(x) [0 (0.782) 1]'  => [4,  0,    0.782, 1.0, 0.8]
    }.each_with_index { |(desc, args), i|
      define_method("test_f_#{type}_#{i}") { _test_f(type, desc, *args) }
    }

    {
      'invalid range check [4, 0]'  => [0,  4.0, 3.0, 0.0, GSL::M_PI],
      'invalid range check [1, 1]'  => [0,  1.0, 1.0, 1.0, GSL::M_PI],
      'invalid range check [-1, 1]' => [0, -1.0, 0.0, 1.0, GSL::M_PI]
    }.each_with_index { |(desc, args), i|
      define_method("test_f_e_#{type}_#{i}") { _test_f_e(type, desc, *args) }
    }
  }

end
require 'test_helper'

class CdfTest < GSL::TestCase

  TEST_TOL = [2.0, 16.0, 256.0, 2048.0, 16384.0, 131072.0, 1048576.0]

  {
    ugaussian_P: [
      [0, 0.5, 0.0],
      [0, 0.5, 1e-32],
      [0, 0.6914624612740131036377046105, 0.5],
      [0, 0.7580363477769269852506495717, 0.7],
    ],
    ugaussian_Q: [
      [0, 0.5, 0.0],
      [0, 0.5, 1e-32],
      [0, 0.3085375387259868963622953894, 0.5],
      [0, 0.2419636522230730147493504282, 0.7],
      [0, 0.0000002866515718791939116737523329, 5.0],
    ],
    ugaussian_Pinv: [
      [1e-4, 5.0, 0.9999997133],
      [1e-4, 0.1, 0.539827837277029],
    ],
    ugaussian_Qinv: [
      [1e-4, 5.0, 2.86648e-7],
      [1e-14, 2.0, 2.2750131948179e-2],
      [1, 0.1, 4.60172162722971e-1],
    ],
    exponential_P: [
      [0, 1.33122100249818372e-1, 0.1, 0.7],
    ],
    exponential_Q: [
      [0, 8.66877899750181628e-1, 0.1, 0.7],
    ],
    exponential_Pinv: [
      [0, 9.74834471334553546e-2, 0.13, 0.7],
    ],
    exponential_Qinv: [
      [0, 1.05576022814208545e-1, 0.86, 0.7],
    ],
    beta_P: [
      [6, 0.0, 0.0, 1.3, 2.7],
      [6, 3.329258013904e-13, 1.0e-10, 1.3, 2.7],
      [6, 6.642743046207e-12, 1.0e-09, 1.3, 2.7],
      [6, 1.32540147535e-10, 1.0e-08, 1.3, 2.7],
      [6, 2.644523387276e-09, 1.0e-07, 1.3, 2.7],
      [6, 5.276513292646e-08, 1.0e-06, 1.3, 2.7],
      [6, 1.052793708285e-06, 1.0e-05, 1.3, 2.7],
      [6, 2.100417958505e-05, 0.0001, 1.3, 2.7],
      [6, 0.00041872612184, 0.001, 1.3, 2.7],
      [6, 0.008282559388393, 0.01, 1.3, 2.7],
      [6, 0.151219457801, 0.1, 1.3, 2.7],
      [6, 0.3358123280407, 0.2, 1.3, 2.7],
      [6, 0.5104163996495, 0.3, 1.3, 2.7],
      [6, 0.662068239941, 0.4, 1.3, 2.7],
      [6, 0.7852786981833, 0.5, 1.3, 2.7],
      [6, 0.878400587895, 0.6, 1.3, 2.7],
      [6, 0.9801824171406, 0.8, 1.3, 2.7],
      [6, 0.9968736852365, 0.9, 1.3, 2.7],
      [6, 0.9999936324464, 0.99, 1.3, 2.7],
      [6, 0.9999999872699, 0.999, 1.3, 2.7],
      [6, 0.9999999999746, 0.9999, 1.3, 2.7],
      [6, 0.9999999999999, 0.99999, 1.3, 2.7],
      [6, 1.0, 1.0, 1.3, 2.7],
    ],
    beta_Q: [
      [6, 0.0, 1.0, 1.3, 2.7],
      [6, 5.069044353228e-14, 0.99999, 1.3, 2.7],
      [6, 2.540490259443e-11, 0.9999, 1.3, 2.7],
      [6, 1.273010336738e-08, 0.999, 1.3, 2.7],
      [6, 6.367553598351e-06, 0.99, 1.3, 2.7],
      [6, 0.003126314763488, 0.9, 1.3, 2.7],
      [6, 0.01981758285937, 0.8, 1.3, 2.7],
      [6, 0.121599412105, 0.6, 1.3, 2.7],
      [6, 0.2147213018167, 0.5, 1.3, 2.7],
      [6, 0.337931760059, 0.4, 1.3, 2.7],
      [6, 0.4895836003505, 0.3, 1.3, 2.7],
      [6, 0.6641876719593, 0.2, 1.3, 2.7],
      [6, 0.848780542199, 0.1, 1.3, 2.7],
      [6, 0.9917174406116, 0.01, 1.3, 2.7],
      [6, 0.9995812738782, 0.001, 1.3, 2.7],
      [6, 0.9999789958204, 0.0001, 1.3, 2.7],
      [6, 0.9999989472063, 1.0e-05, 1.3, 2.7],
      [6, 0.9999999472349, 1.0e-06, 1.3, 2.7],
      [6, 0.9999999973555, 1.0e-07, 1.3, 2.7],
      [6, 0.9999999998675, 1.0e-08, 1.3, 2.7],
      [6, 0.9999999999934, 1.0e-09, 1.3, 2.7],
      [6, 0.9999999999997, 1.0e-10, 1.3, 2.7],
      [6, 1.0, 0.0, 1.3, 2.7],
    ],
    fdist_P: [
      [6, 3.14130045246195449e-1, 0.325, 1.2, 1.3],
      [6, 0.0, 0.0, 5.3, 2.7],
      [6, 3.23138066309e-26, 1.0e-10, 5.3, 2.7],
      [6, 1.443404714791e-23, 1.0e-09, 5.3, 2.7],
      [6, 6.447451698511e-21, 1.0e-08, 5.3, 2.7],
      [6, 2.879969407315e-18, 1.0e-07, 5.3, 2.7],
      [6, 1.286428479993e-15, 1.0e-06, 5.3, 2.7],
      [6, 5.745970138195e-13, 1.0e-05, 5.3, 2.7],
      [6, 2.565314230632e-10, 0.0001, 5.3, 2.7],
      [6, 1.14002620376e-07, 0.001, 5.3, 2.7],
      [6, 4.840333162527e-05, 0.01, 5.3, 2.7],
      [6, 0.01360698992545, 0.1, 5.3, 2.7],
      [6, 0.4532720490874, 1.0, 5.3, 2.7],
      [6, 0.9461328174717, 10.0, 5.3, 2.7],
      [6, 0.9973356976994, 100.0, 5.3, 2.7],
      [6, 0.999879733805, 1000.0, 5.3, 2.7],
      [6, 0.9999946222456, 10000.0, 5.3, 2.7],
      [6, 0.9999997597592, 100000.0, 5.3, 2.7],
      [6, 0.9999999892687, 1000000.0, 5.3, 2.7],
      [6, 0.9999999995207, 10000000.0, 5.3, 2.7],
      [6, 0.9999999999786, 100000000.0, 5.3, 2.7],
      [6, 0.999999999999, 1000000000.0, 5.3, 2.7],
      [6, 1.0, 10000000000.0, 5.3, 2.7],
    ],
    fdist_Q: [
      [6, 6.85869954753804551e-1, 0.325, 1.2, 1.3],
      [6, 4.272202262298e-14, 10000000000.0, 5.3, 2.7],
      [6, 9.56426950277e-13, 1000000000.0, 5.3, 2.7],
      [6, 2.141173208523e-11, 100000000.0, 5.3, 2.7],
      [6, 4.793489218238e-10, 10000000.0, 5.3, 2.7],
      [6, 1.07312743344e-08, 1000000.0, 5.3, 2.7],
      [6, 2.402407758939e-07, 100000.0, 5.3, 2.7],
      [6, 5.377754447932e-06, 10000.0, 5.3, 2.7],
      [6, 0.0001202661950234, 1000.0, 5.3, 2.7],
      [6, 0.002664302300604, 100.0, 5.3, 2.7],
      [6, 0.05386718252832, 10.0, 5.3, 2.7],
      [6, 0.5467279509126, 1.0, 5.3, 2.7],
      [6, 0.9863930100746, 0.1, 5.3, 2.7],
      [6, 0.9999515966684, 0.01, 5.3, 2.7],
      [6, 0.9999998859974, 0.001, 5.3, 2.7],
      [6, 0.9999999997435, 0.0001, 5.3, 2.7],
      [6, 0.9999999999994, 1.0e-05, 5.3, 2.7],
      [6, 1.0, 1.0e-06, 5.3, 2.7],
      [6, 1.0, 1.0e-07, 5.3, 2.7],
      [6, 1.0, 1.0e-08, 5.3, 2.7],
      [6, 1.0, 1.0e-09, 5.3, 2.7],
      [6, 1.0, 1.0e-10, 5.3, 2.7],
      [6, 1.0, 0.0, 5.3, 2.7],
    ],
    cauchy_P: [
      [6, 4.138028520389e-11, -10000000000.0, 1.3],
      [6, 4.138028520389e-10, -1000000000.0, 1.3],
      [6, 4.138028520389e-09, -100000000.0, 1.3],
      [6, 4.138028520389e-08, -10000000.0, 1.3],
      [6, 4.138028520387e-07, -1000000.0, 1.3],
      [6, 4.138028520156e-06, -100000.0, 1.3],
      [6, 4.138028497078e-05, -10000.0, 1.3],
      [6, 0.0004138026189302, -1000.0, 1.3],
      [6, 0.004137795435084, -100.0, 1.3],
      [6, 0.04114951182497, -10.0, 1.3],
      [6, 0.2912855998398, -1.0, 1.3],
      [6, 0.4755627480278, -0.1, 1.3],
      [6, 0.4975515107069, -0.01, 1.3],
      [6, 0.4997551462897, -0.001, 1.3],
      [6, 0.4999755146242, -0.0001, 1.3],
      [6, 0.4999975514624, -1.0e-05, 1.3],
      [6, 0.4999997551462, -1.0e-06, 1.3],
      [6, 0.4999999755146, -1.0e-07, 1.3],
      [6, 0.4999999975515, -1.0e-08, 1.3],
      [6, 0.4999999997551, -1.0e-09, 1.3],
      [6, 0.4999999999755, -1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000245, 1.0e-10, 1.3],
      [6, 0.5000000002449, 1.0e-09, 1.3],
      [6, 0.5000000024485, 1.0e-08, 1.3],
      [6, 0.5000000244854, 1.0e-07, 1.3],
      [6, 0.5000002448538, 1.0e-06, 1.3],
      [6, 0.5000024485376, 1.0e-05, 1.3],
      [6, 0.5000244853758, 0.0001, 1.3],
      [6, 0.5002448537103, 0.001, 1.3],
      [6, 0.5024484892931, 0.01, 1.3],
      [6, 0.5244372519722, 0.1, 1.3],
      [6, 0.7087144001602, 1.0, 1.3],
      [6, 0.958850488175, 10.0, 1.3],
      [6, 0.9958622045649, 100.0, 1.3],
      [6, 0.9995861973811, 1000.0, 1.3],
      [6, 0.999958619715, 10000.0, 1.3],
      [6, 0.9999958619715, 100000.0, 1.3],
      [6, 0.9999995861971, 1000000.0, 1.3],
      [6, 0.9999999586197, 10000000.0, 1.3],
      [6, 0.999999995862, 100000000.0, 1.3],
      [6, 0.9999999995862, 1000000000.0, 1.3],
      [6, 0.9999999999586, 10000000000.0, 1.3],
    ],
    cauchy_Pinv: [
      [6, -10000000000.0, 4.138028520389278e-11, 1.3],
      [6, -1000000000.0, 4.138028520389279e-10, 1.3],
      [6, -100000000.0, 4.138028520389279e-09, 1.3],
      [6, -10000000.0, 4.1380285203892555e-08, 1.3],
      [6, -1000000.0, 4.138028520386949e-07, 1.3],
      [6, -100000.0, 4.138028520156169e-06, 1.3],
      [6, -10000.0, 4.1380284970783855e-05, 1.3],
      [6, -1000.0, 0.00041380261893022424, 1.3],
      [6, -100.0, 0.004137795435083691, 1.3],
      [6, -10.0, 0.041149511824973506, 1.3],
      [6, -1.0, 0.29128559983984725, 1.3],
      [6, -0.1, 0.4755627480278025, 1.3],
      [6, -0.01, 0.49755151070688325, 1.3],
      [6, -0.001, 0.4997551462896916, 1.3],
      [6, 0.0, 0.5000000000000001, 1.3],
      [6, 0.001, 0.5002448537103084, 1.3],
      [6, 0.01, 0.5024484892931167, 1.3],
      [6, 0.1, 0.5244372519721975, 1.3],
      [6, 1.0, 0.7087144001601527, 1.3],
      [6, 10.0, 0.9588504881750265, 1.3],
      [6, 100.0, 0.9958622045649164, 1.3],
      [6, 1000.0, 0.9995861973810698, 1.3],
    ],
    cauchy_Q: [
      [6, 4.138028520389e-11, 10000000000.0, 1.3],
      [6, 4.138028520389e-10, 1000000000.0, 1.3],
      [6, 4.138028520389e-09, 100000000.0, 1.3],
      [6, 4.138028520389e-08, 10000000.0, 1.3],
      [6, 4.138028520387e-07, 1000000.0, 1.3],
      [6, 4.138028520156e-06, 100000.0, 1.3],
      [6, 4.138028497078e-05, 10000.0, 1.3],
      [6, 0.0004138026189302, 1000.0, 1.3],
      [6, 0.004137795435084, 100.0, 1.3],
      [6, 0.04114951182497, 10.0, 1.3],
      [6, 0.2912855998398, 1.0, 1.3],
      [6, 0.4755627480278, 0.1, 1.3],
      [6, 0.4975515107069, 0.01, 1.3],
      [6, 0.4997551462897, 0.001, 1.3],
      [6, 0.4999755146242, 0.0001, 1.3],
      [6, 0.4999975514624, 1.0e-05, 1.3],
      [6, 0.4999997551462, 1.0e-06, 1.3],
      [6, 0.4999999755146, 1.0e-07, 1.3],
      [6, 0.4999999975515, 1.0e-08, 1.3],
      [6, 0.4999999997551, 1.0e-09, 1.3],
      [6, 0.4999999999755, 1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000245, -1.0e-10, 1.3],
      [6, 0.5000000002449, -1.0e-09, 1.3],
      [6, 0.5000000024485, -1.0e-08, 1.3],
      [6, 0.5000000244854, -1.0e-07, 1.3],
      [6, 0.5000002448538, -1.0e-06, 1.3],
      [6, 0.5000024485376, -1.0e-05, 1.3],
      [6, 0.5000244853758, -0.0001, 1.3],
      [6, 0.5002448537103, -0.001, 1.3],
      [6, 0.5024484892931, -0.01, 1.3],
      [6, 0.5244372519722, -0.1, 1.3],
      [6, 0.7087144001602, -1.0, 1.3],
      [6, 0.958850488175, -10.0, 1.3],
      [6, 0.9958622045649, -100.0, 1.3],
      [6, 0.9995861973811, -1000.0, 1.3],
      [6, 0.999958619715, -10000.0, 1.3],
      [6, 0.9999958619715, -100000.0, 1.3],
      [6, 0.9999995861971, -1000000.0, 1.3],
      [6, 0.9999999586197, -10000000.0, 1.3],
      [6, 0.999999995862, -100000000.0, 1.3],
      [6, 0.9999999995862, -1000000000.0, 1.3],
      [6, 0.9999999999586, -10000000000.0, 1.3],
    ],
    cauchy_Qinv: [
      [6, 10000000000.0, 4.138028520389278e-11, 1.3],
      [6, 1000000000.0, 4.138028520389279e-10, 1.3],
      [6, 100000000.0, 4.138028520389279e-09, 1.3],
      [6, 10000000.0, 4.1380285203892555e-08, 1.3],
      [6, 1000000.0, 4.138028520386949e-07, 1.3],
      [6, 100000.0, 4.138028520156169e-06, 1.3],
      [6, 10000.0, 4.1380284970783855e-05, 1.3],
      [6, 1000.0, 0.00041380261893022424, 1.3],
      [6, 100.0, 0.004137795435083691, 1.3],
      [6, 10.0, 0.041149511824973506, 1.3],
      [6, 1.0, 0.29128559983984725, 1.3],
      [6, 0.1, 0.4755627480278025, 1.3],
      [6, 0.01, 0.49755151070688325, 1.3],
      [6, 0.001, 0.4997551462896916, 1.3],
      [6, 0.0, 0.5000000000000001, 1.3],
      [6, -0.001, 0.5002448537103084, 1.3],
      [6, -0.01, 0.5024484892931167, 1.3],
      [6, -0.1, 0.5244372519721975, 1.3],
      [6, -1.0, 0.7087144001601527, 1.3],
      [6, -10.0, 0.9588504881750265, 1.3],
      [6, -100.0, 0.9958622045649164, 1.3],
      [6, -1000.0, 0.9995861973810698, 1.3],
    ],
    gaussian_P: [
      [6, 0.0, -10000000000.0, 1.3],
      [6, 0.0, -1000000000.0, 1.3],
      [6, 0.0, -100000000.0, 1.3],
      [6, 0.0, -10000000.0, 1.3],
      [6, 0.0, -1000000.0, 1.3],
      [6, 0.0, -100000.0, 1.3],
      [6, 0.0, -10000.0, 1.3],
      [6, 0.0, -1000.0, 1.3],
      [6, 0.0, -100.0, 1.3],
      [6, 7.225229227927e-15, -10.0, 1.3],
      [6, 0.2208781637125, -1.0, 1.3],
      [6, 0.4693423696034, -0.1, 1.3],
      [6, 0.4969312434916, -0.01, 1.3],
      [6, 0.499693121353, -0.001, 1.3],
      [6, 0.4999693121323, -0.0001, 1.3],
      [6, 0.4999969312132, -1.0e-05, 1.3],
      [6, 0.4999996931213, -1.0e-06, 1.3],
      [6, 0.4999999693121, -1.0e-07, 1.3],
      [6, 0.4999999969312, -1.0e-08, 1.3],
      [6, 0.4999999996931, -1.0e-09, 1.3],
      [6, 0.4999999999693, -1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000307, 1.0e-10, 1.3],
      [6, 0.5000000003069, 1.0e-09, 1.3],
      [6, 0.5000000030688, 1.0e-08, 1.3],
      [6, 0.5000000306879, 1.0e-07, 1.3],
      [6, 0.5000003068787, 1.0e-06, 1.3],
      [6, 0.5000030687868, 1.0e-05, 1.3],
      [6, 0.5000306878677, 0.0001, 1.3],
      [6, 0.500306878647, 0.001, 1.3],
      [6, 0.5030687565084, 0.01, 1.3],
      [6, 0.5306576303966, 0.1, 1.3],
      [6, 0.7791218362875, 1.0, 1.3],
      [6, 1.0, 10.0, 1.3],
      [6, 1.0, 100.0, 1.3],
      [6, 1.0, 1000.0, 1.3],
      [6, 1.0, 10000.0, 1.3],
      [6, 1.0, 100000.0, 1.3],
      [6, 1.0, 1000000.0, 1.3],
      [6, 1.0, 10000000.0, 1.3],
      [6, 1.0, 100000000.0, 1.3],
      [6, 1.0, 1000000000.0, 1.3],
      [6, 1.0, 10000000000.0, 1.3],
    ],
    gaussian_Pinv: [
      [6, -10.0, 7.225229227926508e-15, 1.3],
      [6, -1.0, 0.22087816371245972, 1.3],
      [6, -0.1, 0.4693423696033875, 1.3],
      [6, -0.01, 0.49693124349158196, 1.3],
      [6, -0.001, 0.4996931213530323, 1.3],
      [6, 0.0, 0.5, 1.3],
      [6, 0.001, 0.5003068786469678, 1.3],
      [6, 0.01, 0.503068756508418, 1.3],
      [6, 0.1, 0.5306576303966125, 1.3],
      [6, 1.0, 0.7791218362875403, 1.3],
    ],
    gaussian_Q: [
      [6, 0.0, 10000000000.0, 1.3],
      [6, 0.0, 1000000000.0, 1.3],
      [6, 0.0, 100000000.0, 1.3],
      [6, 0.0, 10000000.0, 1.3],
      [6, 0.0, 1000000.0, 1.3],
      [6, 0.0, 100000.0, 1.3],
      [6, 0.0, 10000.0, 1.3],
      [6, 0.0, 1000.0, 1.3],
      [6, 0.0, 100.0, 1.3],
      [6, 7.225229227927e-15, 10.0, 1.3],
      [6, 0.2208781637125, 1.0, 1.3],
      [6, 0.4693423696034, 0.1, 1.3],
      [6, 0.4969312434916, 0.01, 1.3],
      [6, 0.499693121353, 0.001, 1.3],
      [6, 0.4999693121323, 0.0001, 1.3],
      [6, 0.4999969312132, 1.0e-05, 1.3],
      [6, 0.4999996931213, 1.0e-06, 1.3],
      [6, 0.4999999693121, 1.0e-07, 1.3],
      [6, 0.4999999969312, 1.0e-08, 1.3],
      [6, 0.4999999996931, 1.0e-09, 1.3],
      [6, 0.4999999999693, 1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000307, -1.0e-10, 1.3],
      [6, 0.5000000003069, -1.0e-09, 1.3],
      [6, 0.5000000030688, -1.0e-08, 1.3],
      [6, 0.5000000306879, -1.0e-07, 1.3],
      [6, 0.5000003068787, -1.0e-06, 1.3],
      [6, 0.5000030687868, -1.0e-05, 1.3],
      [6, 0.5000306878677, -0.0001, 1.3],
      [6, 0.500306878647, -0.001, 1.3],
      [6, 0.5030687565084, -0.01, 1.3],
      [6, 0.5306576303966, -0.1, 1.3],
      [6, 0.7791218362875, -1.0, 1.3],
      [6, 1.0, -10.0, 1.3],
      [6, 1.0, -100.0, 1.3],
      [6, 1.0, -1000.0, 1.3],
      [6, 1.0, -10000.0, 1.3],
      [6, 1.0, -100000.0, 1.3],
      [6, 1.0, -1000000.0, 1.3],
      [6, 1.0, -10000000.0, 1.3],
      [6, 1.0, -100000000.0, 1.3],
      [6, 1.0, -1000000000.0, 1.3],
      [6, 1.0, -10000000000.0, 1.3],
    ],
    gaussian_Qinv: [
      [6, 10.0, 7.225229227926508e-15, 1.3],
      [6, 1.0, 0.22087816371245972, 1.3],
      [6, 0.1, 0.4693423696033875, 1.3],
      [6, 0.01, 0.49693124349158196, 1.3],
      [6, 0.001, 0.4996931213530323, 1.3],
      [6, 0.0, 0.5, 1.3],
      [6, -0.001, 0.5003068786469678, 1.3],
      [6, -0.01, 0.503068756508418, 1.3],
      [6, -0.1, 0.5306576303966125, 1.3],
      [6, -1.0, 0.7791218362875403, 1.3],
    ],
    laplace_P: [
      [6, 0.0, -10000000000.0, 1.3],
      [6, 0.0, -1000000000.0, 1.3],
      [6, 0.0, -100000000.0, 1.3],
      [6, 0.0, -10000000.0, 1.3],
      [6, 0.0, -1000000.0, 1.3],
      [6, 0.0, -100000.0, 1.3],
      [6, 0.0, -10000.0, 1.3],
      [6, 0.0, -1000.0, 1.3],
      [6, 1.957501779912e-34, -100.0, 1.3],
      [6, 0.0002281619502905, -10.0, 1.3],
      [6, 0.2316846846156, -1.0, 1.3],
      [6, 0.4629805393212, -0.1, 1.3],
      [6, 0.4961686011956, -0.01, 1.3],
      [6, 0.4996155325065, -0.001, 1.3],
      [6, 0.4999615399408, -0.0001, 1.3],
      [6, 0.4999961538609, -1.0e-05, 1.3],
      [6, 0.4999996153848, -1.0e-06, 1.3],
      [6, 0.4999999615385, -1.0e-07, 1.3],
      [6, 0.4999999961538, -1.0e-08, 1.3],
      [6, 0.4999999996154, -1.0e-09, 1.3],
      [6, 0.4999999999615, -1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000385, 1.0e-10, 1.3],
      [6, 0.5000000003846, 1.0e-09, 1.3],
      [6, 0.5000000038462, 1.0e-08, 1.3],
      [6, 0.5000000384615, 1.0e-07, 1.3],
      [6, 0.5000003846152, 1.0e-06, 1.3],
      [6, 0.5000038461391, 1.0e-05, 1.3],
      [6, 0.5000384600592, 0.0001, 1.3],
      [6, 0.5003844674935, 0.001, 1.3],
      [6, 0.5038313988044, 0.01, 1.3],
      [6, 0.5370194606788, 0.1, 1.3],
      [6, 0.7683153153844, 1.0, 1.3],
      [6, 0.9997718380497, 10.0, 1.3],
      [6, 1.0, 100.0, 1.3],
      [6, 1.0, 1000.0, 1.3],
      [6, 1.0, 10000.0, 1.3],
      [6, 1.0, 100000.0, 1.3],
      [6, 1.0, 1000000.0, 1.3],
      [6, 1.0, 10000000.0, 1.3],
      [6, 1.0, 100000000.0, 1.3],
      [6, 1.0, 1000000000.0, 1.3],
      [6, 1.0, 10000000000.0, 1.3],
    ],
    laplace_Pinv: [
      [6, -100.0, 1.957501779912233e-34, 1.3],
      [6, -10.0, 0.0002281619502905156, 1.3],
      [6, -1.0, 0.23168468461558764, 1.3],
      [6, -0.1, 0.462980539321158, 1.3],
      [6, -0.01, 0.4961686011955743, 1.3],
      [6, -0.001, 0.49961553250645546, 1.3],
      [6, 0.0, 0.5, 1.3],
      [6, 0.001, 0.5003844674935445, 1.3],
      [6, 0.01, 0.5038313988044256, 1.3],
      [6, 0.1, 0.537019460678842, 1.3],
      [6, 1.0, 0.7683153153844123, 1.3],
      [6, 10.0, 0.9997718380497095, 1.3],
    ],
    laplace_Q: [
      [6, 0.0, 10000000000.0, 1.3],
      [6, 0.0, 1000000000.0, 1.3],
      [6, 0.0, 100000000.0, 1.3],
      [6, 0.0, 10000000.0, 1.3],
      [6, 0.0, 1000000.0, 1.3],
      [6, 0.0, 100000.0, 1.3],
      [6, 0.0, 10000.0, 1.3],
      [6, 0.0, 1000.0, 1.3],
      [6, 1.957501779912e-34, 100.0, 1.3],
      [6, 0.0002281619502905, 10.0, 1.3],
      [6, 0.2316846846156, 1.0, 1.3],
      [6, 0.4629805393212, 0.1, 1.3],
      [6, 0.4961686011956, 0.01, 1.3],
      [6, 0.4996155325065, 0.001, 1.3],
      [6, 0.4999615399408, 0.0001, 1.3],
      [6, 0.4999961538609, 1.0e-05, 1.3],
      [6, 0.4999996153848, 1.0e-06, 1.3],
      [6, 0.4999999615385, 1.0e-07, 1.3],
      [6, 0.4999999961538, 1.0e-08, 1.3],
      [6, 0.4999999996154, 1.0e-09, 1.3],
      [6, 0.4999999999615, 1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000385, -1.0e-10, 1.3],
      [6, 0.5000000003846, -1.0e-09, 1.3],
      [6, 0.5000000038462, -1.0e-08, 1.3],
      [6, 0.5000000384615, -1.0e-07, 1.3],
      [6, 0.5000003846152, -1.0e-06, 1.3],
      [6, 0.5000038461391, -1.0e-05, 1.3],
      [6, 0.5000384600592, -0.0001, 1.3],
      [6, 0.5003844674935, -0.001, 1.3],
      [6, 0.5038313988044, -0.01, 1.3],
      [6, 0.5370194606788, -0.1, 1.3],
      [6, 0.7683153153844, -1.0, 1.3],
      [6, 0.9997718380497, -10.0, 1.3],
      [6, 1.0, -100.0, 1.3],
      [6, 1.0, -1000.0, 1.3],
      [6, 1.0, -10000.0, 1.3],
      [6, 1.0, -100000.0, 1.3],
      [6, 1.0, -1000000.0, 1.3],
      [6, 1.0, -10000000.0, 1.3],
      [6, 1.0, -100000000.0, 1.3],
      [6, 1.0, -1000000000.0, 1.3],
      [6, 1.0, -10000000000.0, 1.3],
    ],
    laplace_Qinv: [
      [6, 100.0, 1.957501779912233e-34, 1.3],
      [6, 10.0, 0.0002281619502905156, 1.3],
      [6, 1.0, 0.23168468461558764, 1.3],
      [6, 0.1, 0.462980539321158, 1.3],
      [6, 0.01, 0.4961686011955743, 1.3],
      [6, 0.001, 0.49961553250645546, 1.3],
      [6, 0.0, 0.5, 1.3],
      [6, -0.001, 0.5003844674935445, 1.3],
      [6, -0.01, 0.5038313988044256, 1.3],
      [6, -0.1, 0.537019460678842, 1.3],
      [6, -1.0, 0.7683153153844123, 1.3],
      [6, -10.0, 0.9997718380497095, 1.3],
    ],
    rayleigh_P: [
      [6, 0.0, 0.0, 1.3],
      [6, 2.958579881657e-21, 1.0e-10, 1.3],
      [6, 2.958579881657e-19, 1.0e-09, 1.3],
      [6, 2.958579881657e-17, 1.0e-08, 1.3],
      [6, 2.958579881657e-15, 1.0e-07, 1.3],
      [6, 2.958579881656e-13, 1.0e-06, 1.3],
      [6, 2.958579881613e-11, 1.0e-05, 1.3],
      [6, 2.95857987728e-09, 0.0001, 1.3],
      [6, 2.958579443997e-07, 0.001, 1.3],
      [6, 2.958536116114e-05, 0.01, 1.3],
      [6, 0.002954207597179, 0.1, 1.3],
      [6, 0.2561069378624, 1.0, 1.3],
      [6, 0.9999999999999, 10.0, 1.3],
      [6, 1.0, 100.0, 1.3],
      [6, 1.0, 1000.0, 1.3],
      [6, 1.0, 10000.0, 1.3],
      [6, 1.0, 100000.0, 1.3],
      [6, 1.0, 1000000.0, 1.3],
      [6, 1.0, 10000000.0, 1.3],
      [6, 1.0, 100000000.0, 1.3],
      [6, 1.0, 1000000000.0, 1.3],
      [6, 1.0, 10000000000.0, 1.3],
    ],
    rayleigh_Pinv: [
      [6, 1.0e-10, 2.958579881656805e-21, 1.3],
      [6, 1.0e-09, 2.958579881656805e-19, 1.3],
      [6, 1.0e-08, 2.958579881656805e-17, 1.3],
      [6, 1.0e-07, 2.9585798816568e-15, 1.3],
      [6, 1.0e-06, 2.9585798816563665e-13, 1.3],
      [6, 1.0e-05, 2.958579881613039e-11, 1.3],
      [6, 0.0001, 2.9585798772802076e-09, 1.3],
      [6, 0.001, 2.9585794439971025e-07, 1.3],
      [6, 0.01, 2.9585361161138382e-05, 1.3],
      [6, 0.1, 0.0029542075971792496, 1.3],
      [6, 1.0, 0.2561069378623536, 1.3],
    ],
    rayleigh_Q: [
      [6, 0.0, 10000000000.0, 1.3],
      [6, 0.0, 1000000000.0, 1.3],
      [6, 0.0, 100000000.0, 1.3],
      [6, 0.0, 10000000.0, 1.3],
      [6, 0.0, 1000000.0, 1.3],
      [6, 0.0, 100000.0, 1.3],
      [6, 0.0, 10000.0, 1.3],
      [6, 0.0, 1000.0, 1.3],
      [6, 0.0, 100.0, 1.3],
      [6, 1.415959498849e-13, 10.0, 1.3],
      [6, 0.7438930621376, 1.0, 1.3],
      [6, 0.9970457924028, 0.1, 1.3],
      [6, 0.9999704146388, 0.01, 1.3],
      [6, 0.9999997041421, 0.001, 1.3],
      [6, 0.9999999970414, 0.0001, 1.3],
      [6, 0.9999999999704, 1.0e-05, 1.3],
      [6, 0.9999999999997, 1.0e-06, 1.3],
      [6, 1.0, 1.0e-07, 1.3],
      [6, 1.0, 1.0e-08, 1.3],
      [6, 1.0, 1.0e-09, 1.3],
      [6, 1.0, 1.0e-10, 1.3],
      [6, 1.0, 0.0, 1.3],
    ],
    rayleigh_Qinv: [
      [6, 10.0, 1.4159594988487832e-13, 1.3],
      [6, 1.0, 0.7438930621376464, 1.3],
      [6, 0.1, 0.9970457924028208, 1.3],
    ],
    flat_P: [
      [6, 0.0, 0.0, 1.3, 750.0],
      [6, 0.0, 1.0e-10, 1.3, 750.0],
      [6, 0.0, 1.0e-09, 1.3, 750.0],
      [6, 0.0, 1.0e-08, 1.3, 750.0],
      [6, 0.0, 1.0e-07, 1.3, 750.0],
      [6, 0.0, 1.0e-06, 1.3, 750.0],
      [6, 0.0, 1.0e-05, 1.3, 750.0],
      [6, 0.0, 0.0001, 1.3, 750.0],
      [6, 0.0, 0.001, 1.3, 750.0],
      [6, 0.0, 0.01, 1.3, 750.0],
      [6, 0.0, 0.1, 1.3, 750.0],
      [6, 0.0, 1.0, 1.3, 750.0],
      [6, 0.01162014157874, 10.0, 1.3, 750.0],
      [6, 0.1318285027381, 100.0, 1.3, 750.0],
      [6, 1.0, 1000.0, 1.3, 750.0],
      [6, 1.0, 10000.0, 1.3, 750.0],
      [6, 1.0, 100000.0, 1.3, 750.0],
      [6, 1.0, 1000000.0, 1.3, 750.0],
      [6, 1.0, 10000000.0, 1.3, 750.0],
      [6, 1.0, 100000000.0, 1.3, 750.0],
      [6, 1.0, 1000000000.0, 1.3, 750.0],
      [6, 1.0, 10000000000.0, 1.3, 750.0],
    ],
    flat_Pinv: [
      [6, 10.0, 0.011620141578738545, 1.3, 750.0],
      [6, 100.0, 0.13182850273808142, 1.3, 750.0],
    ],
    flat_Q: [
      [6, 0.0, 10000000000.0, 1.3, 750.0],
      [6, 0.0, 1000000000.0, 1.3, 750.0],
      [6, 0.0, 100000000.0, 1.3, 750.0],
      [6, 0.0, 10000000.0, 1.3, 750.0],
      [6, 0.0, 1000000.0, 1.3, 750.0],
      [6, 0.0, 100000.0, 1.3, 750.0],
      [6, 0.0, 10000.0, 1.3, 750.0],
      [6, 0.0, 1000.0, 1.3, 750.0],
      [6, 0.8681714972619, 100.0, 1.3, 750.0],
      [6, 0.9883798584213, 10.0, 1.3, 750.0],
      [6, 1.0, 1.0, 1.3, 750.0],
      [6, 1.0, 0.1, 1.3, 750.0],
      [6, 1.0, 0.01, 1.3, 750.0],
      [6, 1.0, 0.001, 1.3, 750.0],
      [6, 1.0, 0.0001, 1.3, 750.0],
      [6, 1.0, 1.0e-05, 1.3, 750.0],
      [6, 1.0, 1.0e-06, 1.3, 750.0],
      [6, 1.0, 1.0e-07, 1.3, 750.0],
      [6, 1.0, 1.0e-08, 1.3, 750.0],
      [6, 1.0, 1.0e-09, 1.3, 750.0],
      [6, 1.0, 1.0e-10, 1.3, 750.0],
      [6, 1.0, 0.0, 1.3, 750.0],
    ],
    flat_Qinv: [
      [6, 100.0, 0.8681714972619037, 1.3, 750.0],
      [6, 10.0, 0.9883798584212535, 1.3, 750.0],
    ],
    lognormal_P: [
      [6, 0.0, 0.0, 1.3, 2.7],
      [6, 1.034288276012e-19, 1.0e-10, 1.3, 2.7],
      [6, 1.720583234428e-16, 1.0e-09, 1.3, 2.7],
      [6, 1.39714069655e-13, 1.0e-08, 1.3, 2.7],
      [6, 5.550354890102e-11, 1.0e-07, 1.3, 2.7],
      [6, 1.082087222875e-08, 1.0e-06, 1.3, 2.7],
      [6, 1.03981596749e-06, 1.0e-05, 1.3, 2.7],
      [6, 4.956354352667e-05, 0.0001, 1.3, 2.7],
      [6, 0.001183246775456, 0.001, 1.3, 2.7],
      [6, 0.01436760981041, 0.01, 1.3, 2.7],
      [6, 0.09105428982941, 0.1, 1.3, 2.7],
      [6, 0.3150871690838, 1.0, 1.3, 2.7],
      [6, 0.6448033073717, 10.0, 1.3, 2.7],
      [6, 0.889549744837, 100.0, 1.3, 2.7],
      [6, 0.9810967467052, 1000.0, 1.3, 2.7],
      [6, 0.9983038570318, 10000.0, 1.3, 2.7],
      [6, 0.9999223897251, 100000.0, 1.3, 2.7],
      [6, 0.9999982185389, 1000000.0, 1.3, 2.7],
      [6, 0.9999999796956, 10000000.0, 1.3, 2.7],
      [6, 0.9999999998859, 100000000.0, 1.3, 2.7],
      [6, 0.9999999999997, 1000000000.0, 1.3, 2.7],
      [6, 1.0, 10000000000.0, 1.3, 2.7],
    ],
    lognormal_Pinv: [
      [6, 1.0e-10, 1.0342882760115472e-19, 1.3, 2.7],
      [6, 1.0e-09, 1.7205832344275183e-16, 1.3, 2.7],
      [6, 1.0e-08, 1.3971406965496307e-13, 1.3, 2.7],
      [6, 1.0e-07, 5.550354890101576e-11, 1.3, 2.7],
      [6, 1.0e-06, 1.0820872228749844e-08, 1.3, 2.7],
      [6, 1.0e-05, 1.039815967490383e-06, 1.3, 2.7],
      [6, 0.0001, 4.956354352666784e-05, 1.3, 2.7],
      [6, 0.001, 0.001183246775456206, 1.3, 2.7],
      [6, 0.01, 0.014367609810406523, 1.3, 2.7],
      [6, 0.1, 0.09105428982940558, 1.3, 2.7],
      [6, 1.0, 0.31508716908375517, 1.3, 2.7],
      [6, 10.0, 0.6448033073717402, 1.3, 2.7],
      [6, 100.0, 0.8895497448370264, 1.3, 2.7],
      [6, 1000.0, 0.9810967467051815, 1.3, 2.7],
      [6, 10000.0, 0.9983038570318435, 1.3, 2.7],
      [6, 100000.0, 0.9999223897250857, 1.3, 2.7],
    ],
    lognormal_Q: [
      [6, 4.25589351365e-16, 10000000000.0, 1.3, 2.7],
      [6, 3.150574023842e-13, 1000000000.0, 1.3, 2.7],
      [6, 1.14144555008e-10, 100000000.0, 1.3, 2.7],
      [6, 2.030439602858e-08, 10000000.0, 1.3, 2.7],
      [6, 1.781461076603e-06, 1000000.0, 1.3, 2.7],
      [6, 7.761027491429e-05, 100000.0, 1.3, 2.7],
      [6, 0.001696142968157, 10000.0, 1.3, 2.7],
      [6, 0.01890325329482, 1000.0, 1.3, 2.7],
      [6, 0.110450255163, 100.0, 1.3, 2.7],
      [6, 0.3551966926283, 10.0, 1.3, 2.7],
      [6, 0.6849128309162, 1.0, 1.3, 2.7],
      [6, 0.9089457101706, 0.1, 1.3, 2.7],
      [6, 0.9856323901896, 0.01, 1.3, 2.7],
      [6, 0.9988167532245, 0.001, 1.3, 2.7],
      [6, 0.9999504364565, 0.0001, 1.3, 2.7],
      [6, 0.999998960184, 1.0e-05, 1.3, 2.7],
      [6, 0.9999999891791, 1.0e-06, 1.3, 2.7],
      [6, 0.9999999999445, 1.0e-07, 1.3, 2.7],
      [6, 0.9999999999999, 1.0e-08, 1.3, 2.7],
      [6, 1.0, 1.0e-09, 1.3, 2.7],
      [6, 1.0, 1.0e-10, 1.3, 2.7],
      [6, 1.0, 0.0, 1.3, 2.7],
    ],
    lognormal_Qinv: [
      [6, 10000000000.0, 4.2558935136502785e-16, 1.3, 2.7],
      [6, 1000000000.0, 3.1505740238418296e-13, 1.3, 2.7],
      [6, 100000000.0, 1.1414455500802107e-10, 1.3, 2.7],
      [6, 10000000.0, 2.0304396028576915e-08, 1.3, 2.7],
      [6, 1000000.0, 1.7814610766031938e-06, 1.3, 2.7],
      [6, 100000.0, 7.761027491429e-05, 1.3, 2.7],
      [6, 10000.0, 0.0016961429681565346, 1.3, 2.7],
      [6, 1000.0, 0.01890325329481853, 1.3, 2.7],
      [6, 100.0, 0.11045025516297369, 1.3, 2.7],
      [6, 10.0, 0.3551966926282599, 1.3, 2.7],
      [6, 1.0, 0.684912830916245, 1.3, 2.7],
      [6, 0.1, 0.9089457101705947, 1.3, 2.7],
      [6, 0.01, 0.9856323901895937, 1.3, 2.7],
      [6, 0.001, 0.998816753224544, 1.3, 2.7],
    ],
    gamma_P: [
      [6, 2.77472646357927811e-1, 0.325, 1.0, 1.0],
      [6, 0.0, 0.0, 1.3, 2.7],
      [6, 2.356478475164e-14, 1.0e-10, 1.3, 2.7],
      [6, 4.701792696644e-13, 1.0e-09, 1.3, 2.7],
      [6, 9.381309762735e-12, 1.0e-08, 1.3, 2.7],
      [6, 1.871817348197e-10, 1.0e-07, 1.3, 2.7],
      [6, 3.734765911711e-09, 1.0e-06, 1.3, 2.7],
      [6, 7.451823639191e-08, 1.0e-05, 1.3, 2.7],
      [6, 1.486806276026e-06, 0.0001, 1.3, 2.7],
      [6, 2.966009681152e-05, 0.001, 1.3, 2.7],
      [6, 0.000590683103295, 0.01, 1.3, 2.7],
      [6, 0.01156629233128, 0.1, 1.3, 2.7],
      [6, 0.1921237769663, 1.0, 1.3, 2.7],
      [6, 0.9565035356115, 10.0, 1.3, 2.7],
      [6, 1.0, 100.0, 1.3, 2.7],
      [6, 1.0, 1000.0, 1.3, 2.7],
      [6, 1.0, 10000.0, 1.3, 2.7],
      [6, 1.0, 100000.0, 1.3, 2.7],
      [6, 1.0, 1000000.0, 1.3, 2.7],
      [6, 1.0, 10000000.0, 1.3, 2.7],
      [6, 1.0, 100000000.0, 1.3, 2.7],
      [6, 1.0, 1000000000.0, 1.3, 2.7],
      [6, 1.0, 10000000000.0, 1.3, 2.7],
      [6, 0.0, 0.0, 1.3, 123.0],
      [6, 1.644976604681e-16, 1.0e-10, 1.3, 123.0],
      [6, 3.282159828312e-15, 1.0e-09, 1.3, 123.0],
      [6, 6.548769816865e-14, 1.0e-08, 1.3, 123.0],
      [6, 1.306651361959e-12, 1.0e-07, 1.3, 123.0],
      [6, 2.607112210538e-11, 1.0e-06, 1.3, 123.0],
      [6, 5.201872529446e-10, 1.0e-05, 1.3, 123.0],
      [6, 1.037909593275e-08, 0.0001, 1.3, 123.0],
      [6, 2.070893333124e-07, 0.001, 1.3, 123.0],
      [6, 4.131804542806e-06, 0.01, 1.3, 123.0],
      [6, 8.240625287202e-05, 0.1, 1.3, 123.0],
      [6, 0.001637438876041, 1.0, 1.3, 123.0],
      [6, 0.03135521671622, 10.0, 1.3, 123.0],
      [6, 0.4240385705334, 100.0, 1.3, 123.0],
      [6, 0.9993635318324, 1000.0, 1.3, 123.0],
      [6, 1.0, 10000.0, 1.3, 123.0],
      [6, 1.0, 100000.0, 1.3, 123.0],
      [6, 1.0, 1000000.0, 1.3, 123.0],
      [6, 1.0, 10000000.0, 1.3, 123.0],
      [6, 1.0, 100000000.0, 1.3, 123.0],
      [6, 1.0, 1000000000.0, 1.3, 123.0],
      [6, 1.0, 10000000000.0, 1.3, 123.0],
    ],
    gamma_Pinv: [
      [6, 1.0e-10, 2.356478475163866e-14, 1.3, 2.7],
      [6, 1.0e-09, 4.701792696643945e-13, 1.3, 2.7],
      [6, 1.0e-08, 9.381309762734639e-12, 1.3, 2.7],
      [6, 1.0e-07, 1.8718173481972823e-10, 1.3, 2.7],
      [6, 1.0e-06, 3.734765911711424e-09, 1.3, 2.7],
      [6, 1.0e-05, 7.451823639191012e-08, 1.3, 2.7],
      [6, 0.0001, 1.4868062760263472e-06, 1.3, 2.7],
      [6, 0.001, 2.9660096811518665e-05, 1.3, 2.7],
      [6, 0.01, 0.0005906831032949983, 1.3, 2.7],
      [6, 0.1, 0.011566292331279586, 1.3, 2.7],
      [6, 1.0, 0.19212377696630473, 1.3, 2.7],
      [6, 10.0, 0.9565035356115379, 1.3, 2.7],
      [6, 1.0e-10, 1.6449766046812008e-16, 1.3, 123.0],
      [6, 1.0e-09, 3.2821598283122862e-15, 1.3, 123.0],
      [6, 1.0e-08, 6.548769816865393e-14, 1.3, 123.0],
      [6, 1.0e-07, 1.3066513619593202e-12, 1.3, 123.0],
      [6, 1.0e-06, 2.6071122105378624e-11, 1.3, 123.0],
      [6, 1.0e-05, 5.201872529445639e-10, 1.3, 123.0],
      [6, 0.0001, 1.037909593275298e-08, 1.3, 123.0],
      [6, 0.001, 2.0708933331240137e-07, 1.3, 123.0],
      [6, 0.01, 4.131804542806129e-06, 1.3, 123.0],
      [6, 0.1, 8.240625287201719e-05, 1.3, 123.0],
      [6, 1.0, 0.0016374388760411608, 1.3, 123.0],
      [6, 10.0, 0.03135521671622352, 1.3, 123.0],
      [6, 100.0, 0.42403857053338523, 1.3, 123.0],
      [6, 1000.0, 0.9993635318323562, 1.3, 123.0],
    ],
    gamma_Q: [
      [6, 7.22527353642072189e-1, 0.325, 1.0, 1.0],
      [6, 0.0, 10000000000.0, 1.3, 2.7],
      [6, 0.0, 1000000000.0, 1.3, 2.7],
      [6, 0.0, 100000000.0, 1.3, 2.7],
      [6, 0.0, 10000000.0, 1.3, 2.7],
      [6, 0.0, 1000000.0, 1.3, 2.7],
      [6, 0.0, 100000.0, 1.3, 2.7],
      [6, 0.0, 10000.0, 1.3, 2.7],
      [6, 9.292091038794e-161, 1000.0, 1.3, 2.7],
      [6, 2.729167976527e-16, 100.0, 1.3, 2.7],
      [6, 0.04349646438846, 10.0, 1.3, 2.7],
      [6, 0.8078762230337, 1.0, 1.3, 2.7],
      [6, 0.9884337076687, 0.1, 1.3, 2.7],
      [6, 0.9994093168967, 0.01, 1.3, 2.7],
      [6, 0.9999703399032, 0.001, 1.3, 2.7],
      [6, 0.9999985131937, 0.0001, 1.3, 2.7],
      [6, 0.9999999254818, 1.0e-05, 1.3, 2.7],
      [6, 0.9999999962652, 1.0e-06, 1.3, 2.7],
      [6, 0.9999999998128, 1.0e-07, 1.3, 2.7],
      [6, 0.9999999999906, 1.0e-08, 1.3, 2.7],
      [6, 0.9999999999995, 1.0e-09, 1.3, 2.7],
      [6, 1.0, 1.0e-10, 1.3, 2.7],
      [6, 1.0, 0.0, 1.3, 2.7],
      [6, 0.0, 10000000000.0, 1.3, 123.0],
      [6, 0.0, 1000000000.0, 1.3, 123.0],
      [6, 0.0, 100000000.0, 1.3, 123.0],
      [6, 0.0, 10000000.0, 1.3, 123.0],
      [6, 0.0, 1000000.0, 1.3, 123.0],
      [6, 0.0, 100000.0, 1.3, 123.0],
      [6, 2.056363344745e-35, 10000.0, 1.3, 123.0],
      [6, 0.000636468167644, 1000.0, 1.3, 123.0],
      [6, 0.5759614294666, 100.0, 1.3, 123.0],
      [6, 0.9686447832838, 10.0, 1.3, 123.0],
      [6, 0.998362561124, 1.0, 1.3, 123.0],
      [6, 0.9999175937471, 0.1, 1.3, 123.0],
      [6, 0.9999958681955, 0.01, 1.3, 123.0],
      [6, 0.9999997929107, 0.001, 1.3, 123.0],
      [6, 0.9999999896209, 0.0001, 1.3, 123.0],
      [6, 0.9999999994798, 1.0e-05, 1.3, 123.0],
      [6, 0.9999999999739, 1.0e-06, 1.3, 123.0],
      [6, 0.9999999999987, 1.0e-07, 1.3, 123.0],
      [6, 0.9999999999999, 1.0e-08, 1.3, 123.0],
      [6, 1.0, 1.0e-09, 1.3, 123.0],
      [6, 1.0, 1.0e-10, 1.3, 123.0],
      [6, 1.0, 0.0, 1.3, 123.0],
    ],
    gamma_Qinv: [
      [6, 1000.0, 9.292091038793986e-161, 1.3, 2.7],
      [6, 100.0, 2.7291679765273174e-16, 1.3, 2.7],
      [6, 10.0, 0.04349646438846219, 1.3, 2.7],
      [6, 1.0, 0.8078762230336953, 1.3, 2.7],
      [6, 0.1, 0.9884337076687204, 1.3, 2.7],
      [6, 0.01, 0.999409316896705, 1.3, 2.7],
      [6, 10000.0, 2.0563633447452943e-35, 1.3, 123.0],
      [6, 1000.0, 0.0006364681676439553, 1.3, 123.0],
      [6, 100.0, 0.5759614294666149, 1.3, 123.0],
      [6, 10.0, 0.9686447832837765, 1.3, 123.0],
      [6, 1.0, 0.9983625611239588, 1.3, 123.0],
      [6, 0.1, 0.999917593747128, 1.3, 123.0],
    ],
    chisq_P: [
      [6, 3.06065632019251110e-1, 10.0, 13.0],
      [6, 0.0, 0.0, 1.3],
      [6, 2.238884178785e-07, 1.0e-10, 1.3],
      [6, 1.000072827212e-06, 1.0e-09, 1.3],
      [6, 4.467161220799e-06, 1.0e-08, 1.3],
      [6, 1.995407585451e-05, 1.0e-07, 1.3],
      [6, 8.913156700686e-05, 1.0e-06, 1.3],
      [6, 0.0003981353794611, 1.0e-05, 1.3],
      [6, 0.0017783738888, 0.0001, 1.3],
      [6, 0.00794229637959, 0.001, 1.3],
      [6, 0.0354141390254, 0.01, 1.3],
      [6, 0.155426889584, 0.1, 1.3],
      [6, 0.5878620132779, 1.0, 1.3],
      [6, 0.9973867890205, 10.0, 1.3],
      [6, 1.0, 100.0, 1.3],
      [6, 1.0, 1000.0, 1.3],
      [6, 1.0, 10000.0, 1.3],
      [6, 1.0, 100000.0, 1.3],
      [6, 1.0, 1000000.0, 1.3],
      [6, 1.0, 10000000.0, 1.3],
      [6, 1.0, 100000000.0, 1.3],
      [6, 1.0, 1000000000.0, 1.3],
      [6, 1.0, 10000000000.0, 1.3],
    ],
    chisq_Pinv: [
      [6, 1.0e-10, 2.2388841787852728e-07, 1.3],
      [6, 1.0e-09, 1.0000728272124926e-06, 1.3],
      [6, 1.0e-08, 4.467161220799411e-06, 1.3],
      [6, 1.0e-07, 1.9954075854510294e-05, 1.3],
      [6, 1.0e-06, 8.913156700685821e-05, 1.3],
      [6, 1.0e-05, 0.00039813537946105, 1.3],
      [6, 0.0001, 0.001778373888800392, 1.3],
      [6, 0.001, 0.00794229637958962, 1.3],
      [6, 0.01, 0.03541413902540241, 1.3],
      [6, 0.1, 0.15542688958403586, 1.3],
      [6, 1.0, 0.5878620132778858, 1.3],
      [6, 10.0, 0.9973867890205305, 1.3],
    ],
    chisq_Q: [
      [6, 6.93934367980748890e-1, 10.0, 13.0],
      [6, 0.0, 10000000000.0, 1.3],
      [6, 0.0, 1000000000.0, 1.3],
      [6, 0.0, 100000000.0, 1.3],
      [6, 0.0, 10000000.0, 1.3],
      [6, 0.0, 1000000.0, 1.3],
      [6, 0.0, 100000.0, 1.3],
      [6, 0.0, 10000.0, 1.3],
      [6, 5.840240518729e-219, 1000.0, 1.3],
      [6, 3.517864771108e-23, 100.0, 1.3],
      [6, 0.00261321097947, 10.0, 1.3],
      [6, 0.4121379867221, 1.0, 1.3],
      [6, 0.844573110416, 0.1, 1.3],
      [6, 0.9645858609746, 0.01, 1.3],
      [6, 0.9920577036204, 0.001, 1.3],
      [6, 0.9982216261112, 0.0001, 1.3],
      [6, 0.9996018646205, 1.0e-05, 1.3],
      [6, 0.999910868433, 1.0e-06, 1.3],
      [6, 0.9999800459241, 1.0e-07, 1.3],
      [6, 0.9999955328388, 1.0e-08, 1.3],
      [6, 0.9999989999272, 1.0e-09, 1.3],
      [6, 0.9999997761116, 1.0e-10, 1.3],
      [6, 1.0, 0.0, 1.3],
    ],
    chisq_Qinv: [
      [6, 1000.0, 5.840240518728896e-219, 1.3],
      [6, 100.0, 3.517864771107665e-23, 1.3],
      [6, 10.0, 0.002613210979469623, 1.3],
      [6, 1.0, 0.41213798672211427, 1.3],
      [6, 0.1, 0.8445731104159642, 1.3],
      [6, 0.01, 0.9645858609745978, 1.3],
      [6, 0.001, 0.9920577036204106, 1.3],
      [6, 0.0001, 0.9982216261111997, 1.3],
      [6, 1.0e-05, 0.9996018646205391, 1.3],
    ],
    tdist_P: [
      [6, 0.5, 0.0, 1.0],
      [6, 6.00023120032852123e-1, 0.325, 1.0],
      [6, 9.99968169011487724e-1, 10000.0, 1.0],
      [6, 6.11985772746873767e-01, 0.325, 2.0],
      [6, 3.46784811185e-14, -10000000000.0, 1.3],
      [6, 6.91926665161e-13, -1000000000.0, 1.3],
      [6, 1.380575199718e-11, -100000000.0, 1.3],
      [6, 2.754609668978e-10, -10000000.0, 1.3],
      [6, 5.496168864957e-09, -1000000.0, 1.3],
      [6, 1.096629861231e-07, -100000.0, 1.3],
      [6, 2.188064222827e-06, -10000.0, 1.3],
      [6, 4.365759541083e-05, -1000.0, 1.3],
      [6, 0.0008710327647608, -100.0, 1.3],
      [6, 0.0172789338682, -10.0, 1.3],
      [6, 0.2336211937932, -1.0, 1.3],
      [6, 0.4667575980083, -0.1, 1.3],
      [6, 0.4966660755117, -0.01, 1.3],
      [6, 0.4996665978189, -0.001, 1.3],
      [6, 0.4999666597722, -0.0001, 1.3],
      [6, 0.4999966659772, -1.0e-05, 1.3],
      [6, 0.4999996665977, -1.0e-06, 1.3],
      [6, 0.4999999666598, -1.0e-07, 1.3],
      [6, 0.499999996666, -1.0e-08, 1.3],
      [6, 0.4999999996666, -1.0e-09, 1.3],
      [6, 0.4999999999667, -1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000333, 1.0e-10, 1.3],
      [6, 0.5000000003334, 1.0e-09, 1.3],
      [6, 0.500000003334, 1.0e-08, 1.3],
      [6, 0.5000000333402, 1.0e-07, 1.3],
      [6, 0.5000003334023, 1.0e-06, 1.3],
      [6, 0.5000033340228, 1.0e-05, 1.3],
      [6, 0.5000333402278, 0.0001, 1.3],
      [6, 0.5003334021811, 0.001, 1.3],
      [6, 0.5033339244883, 0.01, 1.3],
      [6, 0.5332424019917, 0.1, 1.3],
      [6, 0.7663788062068, 1.0, 1.3],
      [6, 0.9827210661318, 10.0, 1.3],
      [6, 0.9991289672352, 100.0, 1.3],
      [6, 0.9999563424046, 1000.0, 1.3],
      [6, 0.9999978119358, 10000.0, 1.3],
      [6, 0.999999890337, 100000.0, 1.3],
      [6, 0.9999999945038, 1000000.0, 1.3],
      [6, 0.9999999997245, 10000000.0, 1.3],
      [6, 0.9999999999862, 100000000.0, 1.3],
      [6, 0.9999999999993, 1000000000.0, 1.3],
      [6, 1.0, 10000000000.0, 1.3],
    ],
    tdist_Pinv: [
      [6, -10000000000.0, 3.4678481118500305e-14, 1.3],
      [6, -1000000000.0, 6.919266651610352e-13, 1.3],
      [6, -100000000.0, 1.3805751997179027e-11, 1.3],
      [6, -10000000.0, 2.7546096689777484e-10, 1.3],
      [6, -1000000.0, 5.496168864956998e-09, 1.3],
      [6, -100000.0, 1.0966298612314582e-07, 1.3],
      [6, -10000.0, 2.1880642228271703e-06, 1.3],
      [6, -1000.0, 4.365759541083357e-05, 1.3],
      [6, -100.0, 0.000871032764760792, 1.3],
      [6, -10.0, 0.017278933868204446, 1.3],
      [6, -1.0, 0.23362119379322516, 1.3],
      [6, -0.1, 0.4667575980082614, 1.3],
      [6, -0.01, 0.49666607551169606, 1.3],
      [6, -0.001, 0.4996665978188763, 1.3],
      [6, 0.0, 0.499999999999999, 1.3],
      [6, 0.001, 0.5003334021811237, 1.3],
      [6, 0.01, 0.5033339244883039, 1.3],
      [6, 0.1, 0.5332424019917386, 1.3],
      [6, 1.0, 0.7663788062067749, 1.3],
      [6, 10.0, 0.9827210661317956, 1.3],
      [6, 100.0, 0.9991289672352393, 1.3],
    ],
    tdist_Q: [
      [6, 0.5, 0.0, 1.0],
      [6, 3.99976879967147876e-1, 0.325, 1.0],
      [6, 3.88014227253126233e-1, 0.325, 2.0],
      [6, 3.46784811185e-14, 10000000000.0, 1.3],
      [6, 6.91926665161e-13, 1000000000.0, 1.3],
      [6, 1.380575199718e-11, 100000000.0, 1.3],
      [6, 2.754609668978e-10, 10000000.0, 1.3],
      [6, 5.496168864957e-09, 1000000.0, 1.3],
      [6, 1.096629861231e-07, 100000.0, 1.3],
      [6, 2.188064222827e-06, 10000.0, 1.3],
      [6, 4.365759541083e-05, 1000.0, 1.3],
      [6, 0.0008710327647608, 100.0, 1.3],
      [6, 0.0172789338682, 10.0, 1.3],
      [6, 0.2336211937932, 1.0, 1.3],
      [6, 0.4667575980083, 0.1, 1.3],
      [6, 0.4966660755117, 0.01, 1.3],
      [6, 0.4996665978189, 0.001, 1.3],
      [6, 0.4999666597722, 0.0001, 1.3],
      [6, 0.4999966659772, 1.0e-05, 1.3],
      [6, 0.4999996665977, 1.0e-06, 1.3],
      [6, 0.4999999666598, 1.0e-07, 1.3],
      [6, 0.499999996666, 1.0e-08, 1.3],
      [6, 0.4999999996666, 1.0e-09, 1.3],
      [6, 0.4999999999667, 1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000333, -1.0e-10, 1.3],
      [6, 0.5000000003334, -1.0e-09, 1.3],
      [6, 0.500000003334, -1.0e-08, 1.3],
      [6, 0.5000000333402, -1.0e-07, 1.3],
      [6, 0.5000003334023, -1.0e-06, 1.3],
      [6, 0.5000033340228, -1.0e-05, 1.3],
      [6, 0.5000333402278, -0.0001, 1.3],
      [6, 0.5003334021811, -0.001, 1.3],
      [6, 0.5033339244883, -0.01, 1.3],
      [6, 0.5332424019917, -0.1, 1.3],
      [6, 0.7663788062068, -1.0, 1.3],
      [6, 0.9827210661318, -10.0, 1.3],
      [6, 0.9991289672352, -100.0, 1.3],
      [6, 0.9999563424046, -1000.0, 1.3],
      [6, 0.9999978119358, -10000.0, 1.3],
      [6, 0.999999890337, -100000.0, 1.3],
      [6, 0.9999999945038, -1000000.0, 1.3],
      [6, 0.9999999997245, -10000000.0, 1.3],
      [6, 0.9999999999862, -100000000.0, 1.3],
      [6, 0.9999999999993, -1000000000.0, 1.3],
      [6, 1.0, -10000000000.0, 1.3],
    ],
    tdist_Qinv: [
      [6, 10000000000.0, 3.4678481118500305e-14, 1.3],
      [6, 1000000000.0, 6.919266651610352e-13, 1.3],
      [6, 100000000.0, 1.3805751997179027e-11, 1.3],
      [6, 10000000.0, 2.7546096689777484e-10, 1.3],
      [6, 1000000.0, 5.496168864956998e-09, 1.3],
      [6, 100000.0, 1.0966298612314582e-07, 1.3],
      [6, 10000.0, 2.1880642228271703e-06, 1.3],
      [6, 1000.0, 4.365759541083357e-05, 1.3],
      [6, 100.0, 0.000871032764760792, 1.3],
      [6, 10.0, 0.017278933868204446, 1.3],
      [6, 1.0, 0.23362119379322516, 1.3],
      [6, 0.1, 0.4667575980082614, 1.3],
      [6, 0.01, 0.49666607551169606, 1.3],
      [6, 0.001, 0.4996665978188763, 1.3],
      [6, 0.0, 0.499999999999999, 1.3],
      [6, -0.001, 0.5003334021811237, 1.3],
      [6, -0.01, 0.5033339244883039, 1.3],
      [6, -0.1, 0.5332424019917386, 1.3],
      [6, -1.0, 0.7663788062067749, 1.3],
      [6, -10.0, 0.9827210661317956, 1.3],
      [6, -100.0, 0.9991289672352393, 1.3],
    ],
    gumbel1_P: [
      [6, 0.0, -10000000000.0, 1.3, 2.7],
      [6, 0.0, -1000000000.0, 1.3, 2.7],
      [6, 0.0, -100000000.0, 1.3, 2.7],
      [6, 0.0, -10000000.0, 1.3, 2.7],
      [6, 0.0, -1000000.0, 1.3, 2.7],
      [6, 0.0, -100000.0, 1.3, 2.7],
      [6, 0.0, -10000.0, 1.3, 2.7],
      [6, 0.0, -1000.0, 1.3, 2.7],
      [6, 0.0, -100.0, 1.3, 2.7],
      [6, 0.0, -10.0, 1.3, 2.7],
      [6, 4.981965353092e-05, -1.0, 1.3, 2.7],
      [6, 0.0461971747678, -0.1, 1.3, 2.7],
      [6, 0.06487265128366, -0.01, 1.3, 2.7],
      [6, 0.06696988203722, -0.001, 1.3, 2.7],
      [6, 0.06718192621136, -0.0001, 1.3, 2.7],
      [6, 0.06720315385232, -1.0e-05, 1.3, 2.7],
      [6, 0.06720527684866, -1.0e-06, 1.3, 2.7],
      [6, 0.06720548915062, -1.0e-07, 1.3, 2.7],
      [6, 0.06720551038084, -1.0e-08, 1.3, 2.7],
      [6, 0.06720551250386, -1.0e-09, 1.3, 2.7],
      [6, 0.06720551271616, -1.0e-10, 1.3, 2.7],
      [6, 0.06720551273975, 0.0, 1.3, 2.7],
      [6, 0.06720551276334, 1.0e-10, 1.3, 2.7],
      [6, 0.06720551297564, 1.0e-09, 1.3, 2.7],
      [6, 0.06720551509866, 1.0e-08, 1.3, 2.7],
      [6, 0.06720553632889, 1.0e-07, 1.3, 2.7],
      [6, 0.06720574863136, 1.0e-06, 1.3, 2.7],
      [6, 0.06720787167931, 1.0e-05, 1.3, 2.7],
      [6, 0.06722910448133, 0.0001, 1.3, 2.7],
      [6, 0.0674416647619, 0.001, 1.3, 2.7],
      [6, 0.06959050352518, 0.01, 1.3, 2.7],
      [6, 0.09340058564429, 0.1, 1.3, 2.7],
      [6, 0.4791048360125, 1.0, 1.3, 2.7],
      [6, 0.9999938971292, 10.0, 1.3, 2.7],
      [6, 1.0, 100.0, 1.3, 2.7],
      [6, 1.0, 1000.0, 1.3, 2.7],
      [6, 1.0, 10000.0, 1.3, 2.7],
      [6, 1.0, 100000.0, 1.3, 2.7],
      [6, 1.0, 1000000.0, 1.3, 2.7],
      [6, 1.0, 10000000.0, 1.3, 2.7],
      [6, 1.0, 100000000.0, 1.3, 2.7],
      [6, 1.0, 1000000000.0, 1.3, 2.7],
      [6, 1.0, 10000000000.0, 1.3, 2.7],
    ],
    gumbel1_Pinv: [
      [6, -1.0, 4.981965353091824e-05, 1.3, 2.7],
      [6, -0.1, 0.04619717476779808, 1.3, 2.7],
      [6, -0.01, 0.06487265128366305, 1.3, 2.7],
      [6, -0.001, 0.0669698820372176, 1.3, 2.7],
      [6, -0.0001, 0.06718192621136487, 1.3, 2.7],
      [6, 0.0, 0.06720551273974995, 1.3, 2.7],
      [6, 0.0001, 0.06722910448133346, 1.3, 2.7],
      [6, 0.001, 0.06744166476189883, 1.3, 2.7],
      [6, 0.01, 0.06959050352517981, 1.3, 2.7],
      [6, 0.1, 0.09340058564429043, 1.3, 2.7],
      [6, 1.0, 0.47910483601248477, 1.3, 2.7],
    ],
    gumbel1_Q: [
      [6, 0.0, 10000000000.0, 1.3, 2.7],
      [6, 0.0, 1000000000.0, 1.3, 2.7],
      [6, 0.0, 100000000.0, 1.3, 2.7],
      [6, 0.0, 10000000.0, 1.3, 2.7],
      [6, 0.0, 1000000.0, 1.3, 2.7],
      [6, 0.0, 100000.0, 1.3, 2.7],
      [6, 0.0, 10000.0, 1.3, 2.7],
      [6, 0.0, 1000.0, 1.3, 2.7],
      [6, 9.398988467742e-57, 100.0, 1.3, 2.7],
      [6, 6.102870776257e-06, 10.0, 1.3, 2.7],
      [6, 0.5208951639875, 1.0, 1.3, 2.7],
      [6, 0.9065994143557, 0.1, 1.3, 2.7],
      [6, 0.9304094964748, 0.01, 1.3, 2.7],
      [6, 0.9325583352381, 0.001, 1.3, 2.7],
      [6, 0.9327708955187, 0.0001, 1.3, 2.7],
      [6, 0.9327921283207, 1.0e-05, 1.3, 2.7],
      [6, 0.9327942513686, 1.0e-06, 1.3, 2.7],
      [6, 0.9327944636711, 1.0e-07, 1.3, 2.7],
      [6, 0.9327944849013, 1.0e-08, 1.3, 2.7],
      [6, 0.9327944870244, 1.0e-09, 1.3, 2.7],
      [6, 0.9327944872367, 1.0e-10, 1.3, 2.7],
      [6, 0.9327944872603, 0.0, 1.3, 2.7],
      [6, 0.9327944872838, -1.0e-10, 1.3, 2.7],
      [6, 0.9327944874961, -1.0e-09, 1.3, 2.7],
      [6, 0.9327944896192, -1.0e-08, 1.3, 2.7],
      [6, 0.9327945108494, -1.0e-07, 1.3, 2.7],
      [6, 0.9327947231513, -1.0e-06, 1.3, 2.7],
      [6, 0.9327968461477, -1.0e-05, 1.3, 2.7],
      [6, 0.9328180737886, -0.0001, 1.3, 2.7],
      [6, 0.9330301179628, -0.001, 1.3, 2.7],
      [6, 0.9351273487163, -0.01, 1.3, 2.7],
      [6, 0.9538028252322, -0.1, 1.3, 2.7],
      [6, 0.9999501803465, -1.0, 1.3, 2.7],
      [6, 1.0, -10.0, 1.3, 2.7],
      [6, 1.0, -100.0, 1.3, 2.7],
      [6, 1.0, -1000.0, 1.3, 2.7],
      [6, 1.0, -10000.0, 1.3, 2.7],
      [6, 1.0, -100000.0, 1.3, 2.7],
      [6, 1.0, -1000000.0, 1.3, 2.7],
      [6, 1.0, -10000000.0, 1.3, 2.7],
      [6, 1.0, -100000000.0, 1.3, 2.7],
      [6, 1.0, -1000000000.0, 1.3, 2.7],
      [6, 1.0, -10000000000.0, 1.3, 2.7],
    ],
    gumbel1_Qinv: [
      [6, 100.0, 9.398988467741606e-57, 1.3, 2.7],
      [6, 10.0, 6.10287077625722e-06, 1.3, 2.7],
      [6, 1.0, 0.5208951639875152, 1.3, 2.7],
      [6, 0.1, 0.9065994143557096, 1.3, 2.7],
      [6, 0.01, 0.9304094964748202, 1.3, 2.7],
      [6, 0.001, 0.9325583352381012, 1.3, 2.7],
      [6, 0.0, 0.9327944872602503, 1.3, 2.7],
      [6, -0.001, 0.9330301179627825, 1.3, 2.7],
      [6, -0.01, 0.935127348716337, 1.3, 2.7],
      [6, -0.1, 0.953802825232202, 1.3, 2.7],
      [6, -1.0, 0.9999501803464691, 1.3, 2.7],
    ],
    gumbel2_P: [
      [6, 0.0, 0.0, 1.3, 2.7],
      [6, 0.0, 1.0e-10, 1.3, 2.7],
      [6, 0.0, 1.0e-09, 1.3, 2.7],
      [6, 0.0, 1.0e-08, 1.3, 2.7],
      [6, 0.0, 1.0e-07, 1.3, 2.7],
      [6, 0.0, 1.0e-06, 1.3, 2.7],
      [6, 0.0, 1.0e-05, 1.3, 2.7],
      [6, 0.0, 0.0001, 1.3, 2.7],
      [6, 0.0, 0.001, 1.3, 2.7],
      [6, 0.0, 0.01, 1.3, 2.7],
      [6, 4.014688368993e-24, 0.1, 1.3, 2.7],
      [6, 0.06720551273975, 1.0, 1.3, 2.7],
      [6, 0.8734358842463, 10.0, 1.3, 2.7],
      [6, 0.9932408531257, 100.0, 1.3, 2.7],
      [6, 0.9996601479016, 1000.0, 1.3, 2.7],
      [6, 0.9999829642968, 10000.0, 1.3, 2.7],
      [6, 0.9999991461854, 100000.0, 1.3, 2.7],
      [6, 0.9999999572079, 1000000.0, 1.3, 2.7],
      [6, 0.9999999978553, 10000000.0, 1.3, 2.7],
      [6, 0.9999999998925, 100000000.0, 1.3, 2.7],
      [6, 0.9999999999946, 1000000000.0, 1.3, 2.7],
      [6, 0.9999999999997, 10000000000.0, 1.3, 2.7],
    ],
    gumbel2_Pinv: [
      [6, 0.1, 4.0146883689934746e-24, 1.3, 2.7],
      [6, 1.0, 0.06720551273974974, 1.3, 2.7],
      [6, 10.0, 0.8734358842462814, 1.3, 2.7],
      [6, 100.0, 0.9932408531257445, 1.3, 2.7],
      [6, 1000.0, 0.9996601479016278, 1.3, 2.7],
    ],
    gumbel2_Q: [
      [6, 2.7e-13, 10000000000.0, 1.3, 2.7],
      [6, 5.387208250401e-12, 1000000000.0, 1.3, 2.7],
      [6, 1.074889360437e-10, 100000000.0, 1.3, 2.7],
      [6, 2.144686231456e-09, 10000000.0, 1.3, 2.7],
      [6, 4.279211528087e-08, 1000000.0, 1.3, 2.7],
      [6, 8.538146037456e-07, 100000.0, 1.3, 2.7],
      [6, 1.703570319173e-05, 10000.0, 1.3, 2.7],
      [6, 0.0003398520983725, 1000.0, 1.3, 2.7],
      [6, 0.006759146874256, 100.0, 1.3, 2.7],
      [6, 0.1265641157537, 10.0, 1.3, 2.7],
      [6, 0.9327944872603, 1.0, 1.3, 2.7],
      [6, 1.0, 0.1, 1.3, 2.7],
      [6, 1.0, 0.01, 1.3, 2.7],
      [6, 1.0, 0.001, 1.3, 2.7],
      [6, 1.0, 0.0001, 1.3, 2.7],
      [6, 1.0, 1.0e-05, 1.3, 2.7],
      [6, 1.0, 1.0e-06, 1.3, 2.7],
      [6, 1.0, 1.0e-07, 1.3, 2.7],
      [6, 1.0, 1.0e-08, 1.3, 2.7],
      [6, 1.0, 1.0e-09, 1.3, 2.7],
      [6, 1.0, 1.0e-10, 1.3, 2.7],
      [6, 1.0, 0.0, 1.3, 2.7],
    ],
    gumbel2_Qinv: [
      [6, 10000000000.0, 2.699999999999649e-13, 1.3, 2.7],
      [6, 1000000000.0, 5.387208250401491e-12, 1.3, 2.7],
      [6, 100000000.0, 1.0748893604366781e-10, 1.3, 2.7],
      [6, 10000000.0, 2.1446862314557286e-09, 1.3, 2.7],
      [6, 1000000.0, 4.2792115280867646e-08, 1.3, 2.7],
      [6, 100000.0, 8.53814603745569e-07, 1.3, 2.7],
      [6, 10000.0, 1.7035703191725618e-05, 1.3, 2.7],
      [6, 1000.0, 0.0003398520983724625, 1.3, 2.7],
      [6, 100.0, 0.0067591468742558315, 1.3, 2.7],
      [6, 10.0, 0.12656411575371904, 1.3, 2.7],
      [6, 1.0, 0.9327944872602512, 1.3, 2.7],
    ],
    weibull_P: [
      [6, 0.0, 0.0, 1.3, 2.7],
      [6, 4.924395760785e-28, 1.0e-10, 1.3, 2.7],
      [6, 2.468044288634e-25, 1.0e-09, 1.3, 2.7],
      [6, 1.23695228949e-22, 1.0e-08, 1.3, 2.7],
      [6, 6.199446960984e-20, 1.0e-07, 1.3, 2.7],
      [6, 3.107083672395e-17, 1.0e-06, 1.3, 2.7],
      [6, 1.557230670416e-14, 1.0e-05, 1.3, 2.7],
      [6, 7.804641318223e-12, 0.0001, 1.3, 2.7],
      [6, 3.911586584098e-09, 0.001, 1.3, 2.7],
      [6, 1.960435341356e-06, 0.01, 1.3, 2.7],
      [6, 0.0009820635881537, 0.1, 1.3, 2.7],
      [6, 0.3888663329609, 1.0, 1.3, 2.7],
      [6, 1.0, 10.0, 1.3, 2.7],
      [6, 1.0, 100.0, 1.3, 2.7],
      [6, 1.0, 1000.0, 1.3, 2.7],
      [6, 1.0, 10000.0, 1.3, 2.7],
      [6, 1.0, 100000.0, 1.3, 2.7],
      [6, 1.0, 1000000.0, 1.3, 2.7],
      [6, 1.0, 10000000.0, 1.3, 2.7],
      [6, 1.0, 100000000.0, 1.3, 2.7],
      [6, 1.0, 1000000000.0, 1.3, 2.7],
      [6, 1.0, 10000000000.0, 1.3, 2.7],
    ],
    weibull_Pinv: [
      [6, 1.0e-10, 4.92439576078527e-28, 1.3, 2.7],
      [6, 1.0e-09, 2.468044288633838e-25, 1.3, 2.7],
      [6, 1.0e-08, 1.2369522894899823e-22, 1.3, 2.7],
      [6, 1.0e-07, 6.199446960984052e-20, 1.3, 2.7],
      [6, 1.0e-06, 3.107083672394598e-17, 1.3, 2.7],
      [6, 1.0e-05, 1.557230670415903e-14, 1.3, 2.7],
      [6, 0.0001, 7.804641318222502e-12, 1.3, 2.7],
      [6, 0.001, 3.9115865840980536e-09, 1.3, 2.7],
      [6, 0.01, 1.9604353413559907e-06, 1.3, 2.7],
      [6, 0.1, 0.000982063588153714, 1.3, 2.7],
      [6, 1.0, 0.38886633296085954, 1.3, 2.7],
    ],
    weibull_Q: [
      [6, 0.0, 10000000000.0, 1.3, 2.7],
      [6, 0.0, 1000000000.0, 1.3, 2.7],
      [6, 0.0, 100000000.0, 1.3, 2.7],
      [6, 0.0, 10000000.0, 1.3, 2.7],
      [6, 0.0, 1000000.0, 1.3, 2.7],
      [6, 0.0, 100000.0, 1.3, 2.7],
      [6, 0.0, 10000.0, 1.3, 2.7],
      [6, 0.0, 1000.0, 1.3, 2.7],
      [6, 0.0, 100.0, 1.3, 2.7],
      [6, 6.51926200407e-108, 10.0, 1.3, 2.7],
      [6, 0.6111336670391, 1.0, 1.3, 2.7],
      [6, 0.9990179364118, 0.1, 1.3, 2.7],
      [6, 0.9999980395647, 0.01, 1.3, 2.7],
      [6, 0.9999999960884, 0.001, 1.3, 2.7],
      [6, 0.9999999999922, 0.0001, 1.3, 2.7],
      [6, 1.0, 1.0e-05, 1.3, 2.7],
      [6, 1.0, 1.0e-06, 1.3, 2.7],
      [6, 1.0, 1.0e-07, 1.3, 2.7],
      [6, 1.0, 1.0e-08, 1.3, 2.7],
      [6, 1.0, 1.0e-09, 1.3, 2.7],
      [6, 1.0, 1.0e-10, 1.3, 2.7],
      [6, 1.0, 0.0, 1.3, 2.7],
    ],
    weibull_Qinv: [
      [6, 10.0, 6.519262004069862e-108, 1.3, 2.7],
      [6, 1.0, 0.6111336670391404, 1.3, 2.7],
      [6, 0.1, 0.9990179364118463, 1.3, 2.7],
    ],
    pareto_P: [
      [6, 0.0, 0.0, 1.3, 2.7],
      [6, 0.0, 1.0e-10, 1.3, 2.7],
      [6, 0.0, 1.0e-09, 1.3, 2.7],
      [6, 0.0, 1.0e-08, 1.3, 2.7],
      [6, 0.0, 1.0e-07, 1.3, 2.7],
      [6, 0.0, 1.0e-06, 1.3, 2.7],
      [6, 0.0, 1.0e-05, 1.3, 2.7],
      [6, 0.0, 0.0001, 1.3, 2.7],
      [6, 0.0, 0.001, 1.3, 2.7],
      [6, 0.0, 0.01, 1.3, 2.7],
      [6, 0.0, 0.1, 1.3, 2.7],
      [6, 0.0, 1.0, 1.3, 2.7],
      [6, 0.817705782224, 10.0, 1.3, 2.7],
      [6, 0.9908636465287, 100.0, 1.3, 2.7],
      [6, 0.9995420976279, 1000.0, 1.3, 2.7],
      [6, 0.9999770505177, 10000.0, 1.3, 2.7],
      [6, 0.9999988498013, 100000.0, 1.3, 2.7],
      [6, 0.9999999423535, 1000000.0, 1.3, 2.7],
      [6, 0.9999999971109, 10000000.0, 1.3, 2.7],
      [6, 0.9999999998552, 100000000.0, 1.3, 2.7],
      [6, 0.9999999999928, 1000000000.0, 1.3, 2.7],
      [6, 0.9999999999997, 10000000000.0, 1.3, 2.7],
    ],
    pareto_Pinv: [
      [6, 10.0, 0.8177057822239537, 1.3, 2.7],
      [6, 100.0, 0.9908636465286981, 1.3, 2.7],
      [6, 1000.0, 0.9995420976278682, 1.3, 2.7],
    ],
    pareto_Q: [
      [6, 3.637247829654e-13, 10000000000.0, 1.3, 2.7],
      [6, 7.25726352471e-12, 1000000000.0, 1.3, 2.7],
      [6, 1.448014442065e-10, 100000000.0, 1.3, 2.7],
      [6, 2.889168647783e-09, 10000000.0, 1.3, 2.7],
      [6, 5.764649324512e-08, 1000000.0, 1.3, 2.7],
      [6, 1.150198755621e-06, 100000.0, 1.3, 2.7],
      [6, 2.294948231815e-05, 10000.0, 1.3, 2.7],
      [6, 0.0004579023721744, 1000.0, 1.3, 2.7],
      [6, 0.009136353471345, 100.0, 1.3, 2.7],
      [6, 0.1822942177761, 10.0, 1.3, 2.7],
      [6, 1.0, 1.0, 1.3, 2.7],
      [6, 1.0, 0.1, 1.3, 2.7],
      [6, 1.0, 0.01, 1.3, 2.7],
      [6, 1.0, 0.001, 1.3, 2.7],
      [6, 1.0, 0.0001, 1.3, 2.7],
      [6, 1.0, 1.0e-05, 1.3, 2.7],
      [6, 1.0, 1.0e-06, 1.3, 2.7],
      [6, 1.0, 1.0e-07, 1.3, 2.7],
      [6, 1.0, 1.0e-08, 1.3, 2.7],
      [6, 1.0, 1.0e-09, 1.3, 2.7],
      [6, 1.0, 1.0e-10, 1.3, 2.7],
      [6, 1.0, 0.0, 1.3, 2.7],
    ],
    pareto_Qinv: [
      [6, 10000000000.0, 3.6372478296536173e-13, 1.3, 2.7],
      [6, 1000000000.0, 7.257263524710211e-12, 1.3, 2.7],
      [6, 100000000.0, 1.4480144420652496e-10, 1.3, 2.7],
      [6, 10000000.0, 2.8891686477834784e-09, 1.3, 2.7],
      [6, 1000000.0, 5.7646493245119715e-08, 1.3, 2.7],
      [6, 100000.0, 1.1501987556209536e-06, 1.3, 2.7],
      [6, 10000.0, 2.294948231814587e-05, 1.3, 2.7],
      [6, 1000.0, 0.0004579023721744107, 1.3, 2.7],
      [6, 100.0, 0.009136353471344562, 1.3, 2.7],
      [6, 10.0, 0.18229421777608898, 1.3, 2.7],
    ],
    logistic_P: [
      [6, 0.0, -10000000000.0, 1.3],
      [6, 0.0, -1000000000.0, 1.3],
      [6, 0.0, -100000000.0, 1.3],
      [6, 0.0, -10000000.0, 1.3],
      [6, 0.0, -1000000.0, 1.3],
      [6, 0.0, -100000.0, 1.3],
      [6, 0.0, -10000.0, 1.3],
      [6, 0.0, -1000.0, 1.3],
      [6, 3.915003559824e-34, -100.0, 1.3],
      [6, 0.0004561157640565, -10.0, 1.3],
      [6, 0.3166455298122, -1.0, 1.3],
      [6, 0.4807787077894, -0.1, 1.3],
      [6, 0.4980769325595, -0.01, 1.3],
      [6, 0.4998076923172, -0.001, 1.3],
      [6, 0.4999807692308, -0.0001, 1.3],
      [6, 0.4999980769231, -1.0e-05, 1.3],
      [6, 0.4999998076923, -1.0e-06, 1.3],
      [6, 0.4999999807692, -1.0e-07, 1.3],
      [6, 0.4999999980769, -1.0e-08, 1.3],
      [6, 0.4999999998077, -1.0e-09, 1.3],
      [6, 0.4999999999808, -1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000192, 1.0e-10, 1.3],
      [6, 0.5000000001923, 1.0e-09, 1.3],
      [6, 0.5000000019231, 1.0e-08, 1.3],
      [6, 0.5000000192308, 1.0e-07, 1.3],
      [6, 0.5000001923077, 1.0e-06, 1.3],
      [6, 0.5000019230769, 1.0e-05, 1.3],
      [6, 0.5000192307692, 0.0001, 1.3],
      [6, 0.5001923076828, 0.001, 1.3],
      [6, 0.5019230674405, 0.01, 1.3],
      [6, 0.5192212922106, 0.1, 1.3],
      [6, 0.6833544701878, 1.0, 1.3],
      [6, 0.9995438842359, 10.0, 1.3],
      [6, 1.0, 100.0, 1.3],
      [6, 1.0, 1000.0, 1.3],
      [6, 1.0, 10000.0, 1.3],
      [6, 1.0, 100000.0, 1.3],
      [6, 1.0, 1000000.0, 1.3],
      [6, 1.0, 10000000.0, 1.3],
      [6, 1.0, 100000000.0, 1.3],
      [6, 1.0, 1000000000.0, 1.3],
      [6, 1.0, 10000000000.0, 1.3],
    ],
    logistic_Pinv: [
      [6, -100.0, 3.915003559824466e-34, 1.3],
      [6, -10.0, 0.00045611576405646045, 1.3],
      [6, -1.0, 0.316645529812217, 1.3],
      [6, -0.1, 0.4807787077893918, 1.3],
      [6, -0.01, 0.4980769325594948, 1.3],
      [6, -0.001, 0.4998076923171749, 1.3],
      [6, 0.0, 0.5, 1.3],
      [6, 0.001, 0.5001923076828251, 1.3],
      [6, 0.01, 0.5019230674405052, 1.3],
      [6, 0.1, 0.5192212922106082, 1.3],
      [6, 1.0, 0.683354470187783, 1.3],
      [6, 10.0, 0.9995438842359435, 1.3],
    ],
    logistic_Q: [
      [6, 0.0, 10000000000.0, 1.3],
      [6, 0.0, 1000000000.0, 1.3],
      [6, 0.0, 100000000.0, 1.3],
      [6, 0.0, 10000000.0, 1.3],
      [6, 0.0, 1000000.0, 1.3],
      [6, 0.0, 100000.0, 1.3],
      [6, 0.0, 10000.0, 1.3],
      [6, 0.0, 1000.0, 1.3],
      [6, 3.915003559824e-34, 100.0, 1.3],
      [6, 0.0004561157640565, 10.0, 1.3],
      [6, 0.3166455298122, 1.0, 1.3],
      [6, 0.4807787077894, 0.1, 1.3],
      [6, 0.4980769325595, 0.01, 1.3],
      [6, 0.4998076923172, 0.001, 1.3],
      [6, 0.4999807692308, 0.0001, 1.3],
      [6, 0.4999980769231, 1.0e-05, 1.3],
      [6, 0.4999998076923, 1.0e-06, 1.3],
      [6, 0.4999999807692, 1.0e-07, 1.3],
      [6, 0.4999999980769, 1.0e-08, 1.3],
      [6, 0.4999999998077, 1.0e-09, 1.3],
      [6, 0.4999999999808, 1.0e-10, 1.3],
      [6, 0.5, 0.0, 1.3],
      [6, 0.5000000000192, -1.0e-10, 1.3],
      [6, 0.5000000001923, -1.0e-09, 1.3],
      [6, 0.5000000019231, -1.0e-08, 1.3],
      [6, 0.5000000192308, -1.0e-07, 1.3],
      [6, 0.5000001923077, -1.0e-06, 1.3],
      [6, 0.5000019230769, -1.0e-05, 1.3],
      [6, 0.5000192307692, -0.0001, 1.3],
      [6, 0.5001923076828, -0.001, 1.3],
      [6, 0.5019230674405, -0.01, 1.3],
      [6, 0.5192212922106, -0.1, 1.3],
      [6, 0.6833544701878, -1.0, 1.3],
      [6, 0.9995438842359, -10.0, 1.3],
      [6, 1.0, -100.0, 1.3],
      [6, 1.0, -1000.0, 1.3],
      [6, 1.0, -10000.0, 1.3],
      [6, 1.0, -100000.0, 1.3],
      [6, 1.0, -1000000.0, 1.3],
      [6, 1.0, -10000000.0, 1.3],
      [6, 1.0, -100000000.0, 1.3],
      [6, 1.0, -1000000000.0, 1.3],
      [6, 1.0, -10000000000.0, 1.3],
    ],
    logistic_Qinv: [
      [6, 100.0, 3.915003559824466e-34, 1.3],
      [6, 10.0, 0.00045611576405646045, 1.3],
      [6, 1.0, 0.316645529812217, 1.3],
      [6, 0.1, 0.4807787077893918, 1.3],
      [6, 0.01, 0.4980769325594948, 1.3],
      [6, 0.001, 0.4998076923171749, 1.3],
      [6, 0.0, 0.5, 1.3],
      [6, -0.001, 0.5001923076828251, 1.3],
      [6, -0.01, 0.5019230674405052, 1.3],
      [6, -0.1, 0.5192212922106082, 1.3],
      [6, -1.0, 0.683354470187783, 1.3],
      [6, -10.0, 0.9995438842359435, 1.3],
    ],
  }.each { |func, tests|
    define_method("test_#{func}") {
      tests.each { |tol, value, *args|
        tol = TEST_TOL[tol] * GSL::DBL_EPSILON if tol.integer?
        assert_rel GSL::Cdf.send(func, *args), value, tol, '%s(%p)' % [func, args]
      }
    }
  }

end
require 'test_helper'

class MatrixTest < GSL::TestCase

  def test_ispos_neg
    m = GSL::Matrix::Int.alloc([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 3)
    assert_equal 0,     m.ispos
    assert_equal false, m.ispos?
    assert_equal 0,     m.isneg
    assert_equal false, m.isneg?

    m += 1
    assert_equal 1,     m.ispos
    assert_equal true,  m.ispos?
    assert_equal 0,     m.isneg
    assert_equal false, m.isneg?

    m -= 100
    assert_equal 0,     m.ispos
    assert_equal false, m.ispos?
    assert_equal 1,     m.isneg
    assert_equal true,  m.isneg?
  end

  def test_isnonneg
    m = GSL::Matrix::Int.alloc([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 3, 3)
    assert_equal 1,     m.isnonneg
    assert_equal true,  m.isnonneg?
    assert_equal 0,     m.isneg
    assert_equal false, m.isneg?

    m -= 100
    assert_equal 0,     m.isnonneg
    assert_equal false, m.isnonneg?
    assert_equal 1,     m.isneg
    assert_equal true,  m.isneg?

    m += 200
    assert_equal 1,     m.isnonneg
    assert_equal true,  m.isnonneg?
    assert_equal 1,     m.ispos
    assert_equal true,  m.ispos?
  end

  def test_eye
    z = GSL::Complex[1, 0]
    m = GSL::Matrix::Complex.eye(2, z)

    assert_equal z, m[0, 0]
    assert_equal GSL::Complex[0, 0], m[0, 1]
    assert_equal GSL::Complex[0, 0], m[1, 0]
    assert_equal z, m[1, 1]
  end

  def test_set_row
    z0 = GSL::Complex[1, 0]
    z1 = GSL::Complex[2, 0]

    m = GSL::Matrix::Complex[2, 2]
    m.set_row(0, z0, z1)

    assert_equal z0, m[0, 0]
    assert_equal z1, m[0, 1]
  end

  def test_set_col
    z0 = GSL::Complex[1, 0]
    z1 = GSL::Complex[2, 0]

    m = GSL::Matrix::Complex[2, 2]
    m.set_col(0, z0, z1)

    assert_equal z0, m[0, 0]
    assert_equal z1, m[1, 0]
  end

  def test_coerce
    { 1 => m0 = GSL::Matrix.ones(1), 2 => GSL::Matrix[[2]] }.each { |a, b|
      [a, a.to_f].each { |c| assert_equal([b, m0], m0.coerce(c)) } }

    m1 = GSL::Matrix::Int.ones(1); [1, 2].each { |a|
      [a, a.to_f].each { |c| assert_equal([c, m0], m1.coerce(c)) } }
  end

  def test_mul
    { 1 => m0 = GSL::Matrix.ones(1), 2 => GSL::Matrix[[2]] }.each { |a, b|
      [a, a.to_f].each { |c| assert_equal(b, m0 * c); assert_equal(b, c * m0) } }

    { 1 => m1 = GSL::Matrix::Int.ones(1), 2 => GSL::Matrix::Int[[2]] }.each { |a, b|
      assert_equal(b, m1 * a); [a, a.to_f].each { |c| assert_equal(b, c * m1) } }

    assert_equal GSL::Matrix[[0.2]], m0 * 0.2
    assert_equal GSL::Matrix[[0.2]], 0.2 * m0

    assert_equal GSL::Matrix::Int[[0]], 0.2 * m1
  end

end
require 'test_helper'

class VectorTest < GSL::TestCase

  def test_get
    v = GSL::Vector::Int.indgen(5)
    assert_equal GSL::Vector::Int[3, 1, 2], v.get([3, 1, 2])
  end

  def test_addsub
    a = GSL::Vector::Int[2, 5, 4]
    b = GSL::Vector::Int[10, 30, 20]
    c = GSL::Vector::Int[12, 35, 24]
    d = GSL::Vector::Int[8, 25, 16]

    assert_equal c, a + b
    assert_equal d, b - a
  end

  def test_collect
    v = GSL::Vector::Int.indgen(5)
    u = GSL::Vector::Int[0, 1, 4, 9, 16]

    assert_equal u, v.collect { |val| val * val }
  end

  def test_ispos_neg
    v = GSL::Vector::Int.indgen(5)
    assert_equal 0,     v.ispos
    assert_equal false, v.ispos?
    assert_equal 0,     v.isneg
    assert_equal false, v.isneg?

    v += 1
    assert_equal 1,     v.ispos
    assert_equal true,  v.ispos?
    assert_equal 0,     v.isneg
    assert_equal false, v.isneg?

    v -= 100
    assert_equal 0,     v.ispos
    assert_equal false, v.ispos?
    assert_equal 1,     v.isneg
    assert_equal true,  v.isneg?
  end

  def test_isnonneg
    v = GSL::Vector::Int.indgen(5)
    assert_equal 1,     v.isnonneg
    assert_equal true,  v.isnonneg?
    assert_equal 0,     v.isneg
    assert_equal false, v.isneg?

    v -= 100
    assert_equal 0,     v.isnonneg
    assert_equal false, v.isnonneg?
    assert_equal 1,     v.isneg
    assert_equal true,  v.isneg?

    v += 200
    assert_equal 1,     v.isnonneg
    assert_equal true,  v.isnonneg?
    assert_equal 1,     v.ispos
    assert_equal true,  v.ispos?
  end

  def test_subvector
    v = GSL::Vector::Int.indgen(12)

    vv = v.subvector
    assert_not_equal v.object_id, vv.object_id
    assert_equal     v.subvector, v

    vv = v.subvector(3)
    assert_equal [0, 1, 2], vv.to_a
    assert_nothing_raised('subvector(-1)') { v.subvector(-1) }

    vv = v.subvector(-1)
    assert_equal [11], vv.to_a

    vv = v.subvector(-2)
    assert_equal [10, 11], vv.to_a
    assert_raises(RangeError) { v.subvector(-13) }

    vv = v.subvector(2, 3)
    assert_equal [2, 3, 4], vv.to_a

    vv = v.subvector(-4, 3)
    assert_equal [8, 9, 10], vv.to_a
    assert_nothing_raised('subvector(-4, -3)') { v.subvector(-4, -3) }

    vv = v.subvector(-4, -3)
    assert_equal [8, 7, 6], vv.to_a
    assert_raises(GSL::ERROR::EINVAL) { v.subvector(-11, -3) }

    vv = v.subvector(1, 3, 4)
    assert_equal [1, 4, 7, 10], vv.to_a

    {
    # ( range ) => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
      ( 1..  3) => [   1, 2, 3                          ],
      ( 1... 3) => [   1, 2                             ],
      ( 3..  1) => [   3, 2, 1                          ],
      ( 3... 1) => [      3, 2                          ],
      (-7..  9) => [               5, 6, 7, 8, 9        ],
      (-7... 9) => [               5, 6, 7, 8           ],
      ( 4.. -3) => [            4, 5, 6, 7, 8, 9        ],
      ( 4...-3) => [            4, 5, 6, 7, 8           ],
      ( 2.. -2) => [      2, 3, 4, 5, 6, 7, 8, 9, 10    ],
      ( 2...-2) => [      2, 3, 4, 5, 6, 7, 8, 9        ],
      (-2..  2) => [     10, 9, 8, 7, 6, 5, 4, 3,  2    ],
      (-2... 2) => [     10, 9, 8, 7, 6, 5, 4, 3        ],
      (-3.. -1) => [                           9, 10, 11],
      (-3...-1) => [                           9, 10    ],
      (-1.. -3) => [                          11, 10,  9],
      (-1...-3) => [                          11, 10    ]
    }.each { |r, x|
      assert_nothing_raised("subvector(#{r})") { v.subvector(r) }
      assert_equal x, v.subvector(r).to_a, "subvector(#{r})"
    }

    {
    # [( range ), s] => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
      [( 1..  6), 2] => [   1,    3,    5                    ],
      [( 1... 6), 2] => [   1,    3,    5                    ],
      [( 0..  6), 3] => [0,       3,      6                  ],
      [( 0... 6), 3] => [0,    3                             ]
    }.each { |(r, s), x|
      assert_nothing_raised("subvector(#{r},#{s})") { v.subvector(r) }
      assert_equal x, v.subvector(r,s).to_a, "subvector(#{r},#{s})"
    }
  end

  def test_complex_get
    v = GSL::Vector::Complex.indgen(5)
    assert_equal GSL::Vector::Complex[[3, 0], [1, 0], [2, 0]], v.get([3, 1, 2])
  end

  def test_complex_addsub
    a = GSL::Vector::Complex[[-2,  5], [ 4, -1]]
    b = GSL::Vector::Complex[[10, 30], [20, 40]]
    c = GSL::Vector::Complex[[ 8, 35], [24, 39]]
    d = GSL::Vector::Complex[[12, 25], [16, 41]]

    assert_equal c, a + b
    assert_equal d, b - a
  end

  def test_complex_collect
    v = GSL::Vector::Complex.indgen(5)
    u = GSL::Vector::Complex[[0, 0], [1, 0], [4, 0], [9, 0], [16, 0]]

    assert_equal u, v.collect { |val| val * val }
  end

  def test_complex_subvector
    v = GSL::Vector::Complex.indgen(12)

    vv = v.subvector
    assert_not_equal v.object_id, vv.object_id
    assert_equal     v.subvector, v

    vv = v.subvector(3)
    assert_equal [0, 0, 1, 0, 2, 0], vv.to_a
    assert_nothing_raised('subvector(-1)') { v.subvector(-1) }

    vv = v.subvector(-1)
    assert_equal [11, 0], vv.to_a

    vv = v.subvector(-2)
    assert_equal [10, 0, 11, 0], vv.to_a
    assert_raises(RangeError) { v.subvector(-13) }

    vv = v.subvector(2, 3)
    assert_equal [2, 0, 3, 0, 4, 0], vv.to_a

    vv = v.subvector(-4, 3)
    assert_equal [8, 0, 9, 0, 10, 0], vv.to_a
    assert_nothing_raised('subvector(-4, -3)') { v.subvector(-4, -3) }

    vv = v.subvector(-4, -3)
    assert_equal [8, 0, 7, 0, 6, 0], vv.to_a
    assert_raises(GSL::ERROR::EINVAL) { v.subvector(-11, -3) }

    vv = v.subvector(1, 3, 4)
    assert_equal [1, 0, 4, 0, 7, 0, 10, 0], vv.to_a

    {
    # ( range ) => [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10, 0, 11, 0]
      ( 1..  3) => [      1, 0, 2, 0, 3, 0                                                  ],
      ( 1... 3) => [      1, 0, 2, 0,                                                       ],
      ( 3..  1) => [      3, 0, 2, 0, 1, 0                                                  ],
      ( 3... 1) => [            3, 0, 2, 0                                                  ],
      (-7..  9) => [                              5, 0, 6, 0, 7, 0, 8, 0, 9, 0              ],
      (-7... 9) => [                              5, 0, 6, 0, 7, 0, 8, 0                    ],
      ( 4.. -3) => [                        4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0              ],
      ( 4...-3) => [                        4, 0, 5, 0, 6, 0, 7, 0, 8, 0                    ],
      ( 2.. -2) => [            2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10, 0       ],
      ( 2...-2) => [            2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0              ],
      (-2..  2) => [           10, 0, 9, 0, 8, 0, 7, 0, 6, 0, 5, 0, 4, 0, 3, 0,  2, 0       ],
      (-2... 2) => [           10, 0, 9, 0, 8, 0, 7, 0, 6, 0, 5, 0, 4, 0, 3, 0              ],
      (-3.. -1) => [                                                      9, 0, 10, 0, 11, 0],
      (-3...-1) => [                                                      9, 0, 10, 0       ],
      (-1.. -3) => [                                                     11, 0, 10, 0,  9, 0],
      (-1...-3) => [                                                     11, 0, 10, 0       ]
    }.each { |r, x|
      assert_nothing_raised("subvector(#{r})") { v.subvector(r) }
      assert_equal x, v.subvector(r).to_a, "subvector(#{r})"
    }

    {
    # [( range ), s] => [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10, 0, 11, 0]
      [( 1..  6), 2] => [      1, 0,       3, 0,       5, 0                                      ],
      [( 1... 6), 2] => [      1, 0,       3, 0,       5, 0                                      ],
      [( 0..  6), 3] => [0, 0,             3, 0,             6, 0                                ],
      [( 0... 6), 3] => [0, 0,             3, 0                                                  ]
    }.each { |(r, s), x|
      assert_nothing_raised("subvector(#{r},#{s})") { v.subvector(r) }
      assert_equal x, v.subvector(r,s).to_a, "subvector(#{r},#{s})"
    }
  end

end
require 'test_helper'

class ErrTest < GSL::TestCase

  MAX_ERRS = 64

  ERRORS = %w[
    SUCCESS FAILURE CONTINUE EDOM ERANGE EFAULT EINVAL EFAILED
    EFACTOR ESANITY ENOMEM EBADFUNC ERUNAWAY EMAXITER EZERODIV
    EBADTOL ETOL EUNDRFLW EOVRFLW ELOSS EROUND EBADLEN ENOTSQR
    ESING EDIVERGE EUNSUP EUNIMPL ECACHE ETABLE ENOPROG ENOPROGJ
    ETOLF ETOLX ETOLG EOF
  ].map { |name| GSL.const_get(name) }

  def test_number
    assert ERRORS.uniq == ERRORS
  end

  def test_message
    assert ERRORS.map { |e| GSL.strerror(e) }.uniq.size == ERRORS.size
  end

end
require 'test_helper'

class CombinationTest < GSL::TestCase

  def setup
    @c63 = GSL::Matrix.alloc(
      [0, 1, 2], 
      [0, 1, 3], 
      [0, 1, 4], 
      [0, 1, 5],
      [0, 2, 3], 
      [0, 2, 4],
      [0, 2, 5],
      [0, 3, 4], 
      [0, 3, 5],
      [0, 4, 5],
      [1, 2, 3], 
      [1, 2, 4], 
      [1, 2, 5],
      [1, 3, 4], 
      [1, 3, 5],
      [1, 4, 5],
      [2, 3, 4], 
      [2, 3, 5], 
      [2, 4, 5],
      [3, 4, 5]
    )
  end

  def test_6_3
    c = GSL::Combination.alloc(6, 3)
    c.init_first

    status, i = false, 0

    begin
      if i >= 20
        status = true
        break
      end

      3.times { |j| status |= c.data[j] != @c63[i, j] }
      refute c.valid?, 'GSL::Combination#valid(%u)' % i

      i += 1
    end while c.next == GSL::SUCCESS

    refute status, 'GSL::Combination#next, 6 choose 3 combination, 20 steps'

    3.times { c.next }
    3.times { |j| status |= c.data[j] != @c63[19, j] }

    refute status, 'GSL::Combination#prev on the first combination'
    refute c.valid?, 'GSL::Combination#valid on the last combination'

    d = GSL::Combination.alloc(6, 3)
    GSL::Combination.memcpy(d, c)

    status = false
    3.times { |j| status |= d.data[j] != c.data[j] }
    refute status, 'GSL::Combination.memcpy, 6 choose 3 combination'

    c.init_last
    i = 20

    begin
      if i == 0
        status = true
        break
      end

      i -= 1

      3.times { |j| status |= c.data[j] != @c63[i, j] }
      refute c.valid?, 'GSL::Combination#valid(%u)' % i
    end while c.prev == GSL::SUCCESS

    refute status, 'GSL::Combination#prev, 6 choose 3 combination, 20 steps'

    3.times { c.prev }
    3.times { |j| status |= c.data[j] != @c63[0, j] }

    refute status, 'GSL::Combination#prev on the first combination'
    refute c.valid?, 'GSL::Combination#valid on the first combination'

    d = GSL::Combination.alloc(6, 3)
    GSL::Combination.memcpy(d, c)

    status = false
    3.times { |j| status |= d.data[j] != c.data[j] }
    refute status, 'GSL::Combination.memcpy, 6 choose 3 combination'
  end

  def test_7_0
    c, desc = GSL::Combination.calloc(7, 0), 'GSL::Combination 7 choose 0'
    2.times { assert c.next == GSL::FAILURE, desc }
    2.times { assert c.prev == GSL::FAILURE, desc }
  end

  def test_7_7
    c, desc = GSL::Combination.calloc(7, 7), 'GSL::Combination 7 choose 7'

    3.times {
      7.times { |j| assert c.get(j) == j, desc }
      assert c.next == GSL::FAILURE, desc
    }

    7.times { |j| assert c.get(j) == j, desc }
  end

end
require 'test_helper'

class PolyTest < GSL::TestCase

  EPS = 100.0 * GSL::DBL_EPSILON

  def test_poly
    c = GSL::Poly.alloc(1.0, 0.5, 0.3)
    x = 0.5
    y = c.eval(x)
    assert_rel y, 1 + 0.5 * x + 0.3 * x * x, EPS, 'gsl_poly_eval({1, 0.5, 0.3}, 0.5)'

    d = GSL::Poly.alloc( 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1)
    x = 1.0
    y = GSL::Poly.eval(d, x)
    assert_rel y, 1.0, EPS, 'gsl_poly_eval({1,-1, 1, -1, 1, -1, 1, -1, 1, -1, 1}, 1.0)'

    x0, x1 = GSL::Poly.solve_quadratic(4.0, -20.0, 25.0).to_a
    assert_rel x0, 2.5, 1e-9, 'x0, (2x - 5)^2 = 0'
    assert_rel x1, 2.5, 1e-9, 'x1, (2x - 5)^2 = 0'

    x0, x1 = GSL::Poly.solve_quadratic(4.0, 7.0, 0.0).to_a
    assert_rel x0, -1.75, 1e-9, 'x0, x(4x + 7) = 0'
    assert_rel x1, 0.0, 1e-9, 'x1, x(4x + 7) = 0'

    x0, x1 = GSL::Poly.solve_quadratic(5.0, 0.0, -20.0).to_a
    assert_rel x0, -2.0, 1e-9, 'x0, 5 x^2 = 20'
    assert_rel x1, 2.0, 1e-9, 'x1, 5 x^2 = 20'

    # Quadratic single real root (technically not a quadratic)
    x0, x1 = GSL::Poly.solve_quadratic(0.0, 1.0, 0.0).to_a
    assert_rel x0, 0.0, 0, 'x0, x = 0'
    assert x1.nil?, 'x1, x = 0 is nil'

    # Quadratic no real root
    x0, x1 = GSL::Poly.solve_quadratic(1.0, 0.0, 1.0).to_a
    assert x0.nil?, 'x0, x^2 = -1 is nil'
    assert x1.nil?, 'x1, x^2 = -1 is nil'

    x0, x1, x2 = GSL::Poly.solve_cubic(0.0, 0.0, -27.0).to_a
    assert_rel x0, 3.0, 1e-9, 'x0, x^3 = 27'

    # Cubic triple real root
    x0, x1, x2 = GSL::Poly.solve_cubic(-51.0, 867.0, -4913.0).to_a
    assert_rel x0, 17.0, 1e-9, 'x0, (x-17)^3=0'
    assert_rel x1, 17.0, 1e-9, 'x1, (x-17)^3=0'
    assert_rel x2, 17.0, 1e-9, 'x2, (x-17)^3=0'

    # Cubic double real root plus single real root
    x0, x1, x2 = GSL::Poly.solve_cubic(-57.0, 1071.0, -6647.0).to_a
    assert_rel x0, 17.0, 1e-9, 'x0, (x-17)(x-17)(x-23)=0'
    assert_rel x1, 17.0, 1e-9, 'x1, (x-17)(x-17)(x-23)=0'
    assert_rel x2, 23.0, 1e-9, 'x2, (x-17)(x-17)(x-23)=0'

    x0, x1, x2 = GSL::Poly.solve_cubic(-11.0, -493.0, +6647.0).to_a
    assert_rel x0, -23.0, 1e-9, 'x0, (x+23)(x-17)(x-17)=0'
    assert_rel x1, 17.0, 1e-9, 'x1, (x+23)(x-17)(x-17)=0'
    assert_rel x2, 17.0, 1e-9, 'x2, (x+23)(x-17)(x-17)=0'

    x0, x1, x2 = GSL::Poly.solve_cubic(-143.0, 5087.0, -50065.0).to_a
    assert_rel x0, 17.0, 1e-9, 'x0, (x-17)(x-31)(x-95)=0'
    assert_rel x1, 31.0, 1e-9, 'x1, (x-17)(x-31)(x-95)=0'
    assert_rel x2, 95.0, 1e-9, 'x2, (x-17)(x-31)(x-95)=0'

    x0, x1, x2 = GSL::Poly.solve_cubic(-109.0, 803.0, 50065.0).to_a
    assert_rel x0, -17.0, 1e-9, 'x0, (x+17)(x-31)(x-95)=0'
    assert_rel x1, 31.0, 1e-9, 'x1, (x+17)(x-31)(x-95)=0'
    assert_rel x2, 95.0, 1e-9, 'x2, (x+17)(x-31)(x-95)=0'

    # Cubic double real root only is impossible

    # Cubic single real root (and two complex roots, not returned)
    x0, x1, x2 = GSL::Poly.solve_cubic(0.0, 0.0, -1.0).to_a
    assert_rel x0, 1.0, 1e-9, 'x0, x^3 = 1'
    assert x1.nil?, 'x1, x^3 = 1 is nil'
    assert x2.nil?, 'x2, x^3 = 1 is nil'

    # Cubic no real root is impossible

    z = GSL::Poly::Complex.solve_quadratic(4.0, -20.0, 26.0)
    assert_rel z[0].re, 2.5, 1e-9, 'z0.real, (2x - 5)^2 = -1'
    assert_rel z[0].im, -0.5, 1e-9, 'z0.imag, (2x - 5)^2 = -1'
    assert_rel z[1].re, 2.5, 1e-9, 'z1.real, (2x - 5)^2 = -1'
    assert_rel z[1].im, 0.5, 1e-9, 'z1.imag, (2x - 5)^2 = -1'

    z = GSL::Poly.complex_solve_quadratic(4.0, -20.0, 25.0)
    assert_rel z[0].re, 2.5, 1e-9, 'z0.real, (2x - 5)^2 = 0'
    assert_rel z[0].im, 0.0, 1e-9, 'z0.imag (2x - 5)^2 = 0'
    assert_rel z[1].re, 2.5, 1e-9, 'z1.real, (2x - 5)^2 = 0'
    assert_rel z[1].im, 0.0, 1e-9, 'z1.imag (2x - 5)^2 = 0'
    assert_equal z[0].re, z[1].re, 'z0.real == z1.real, (2x - 5)^2 = 0'
    assert_equal z[1].im, z[1].im, 'z0.imag == z1.imag, (2x - 5)^2 = 0'

    z = GSL::Poly.complex_solve_quadratic(4.0, -20.0, 21.0)
    assert_rel z[0].re, 1.5, 1e-9, 'z0.real, (2x - 5)^2 = 4'
    assert_rel z[0].im, 0.0, 1e-9, 'z0.imag, (2x - 5)^2 = 4'
    assert_rel z[1].re, 3.5, 1e-9, 'z1.real, (2x - 5)^2 = 4'
    assert_rel z[1].im, 0.0, 1e-9, 'z1.imag, (2x - 5)^2 = 4'

    z = GSL::Poly.complex_solve_quadratic(4.0, 7.0, 0.0)
    assert_rel z[0].re, -1.75, 1e-9, 'z[0].real, x(4x + 7) = 0'
    assert_rel z[0].im, 0.0, 1e-9, 'z[0].imag, x(4x + 7) = 0'
    assert_rel z[1].re, 0.0, 1e-9, 'z[1].real, x(4x + 7) = 0'
    assert_rel z[1].im, 0.0, 1e-9, 'z[1].imag, x(4x + 7) = 0'

    z = GSL::Poly.complex_solve_quadratic(5.0, 0.0, -20.0)
    assert_rel z[0].re, -2.0, 1e-9, 'z[0].real, 5 x^2 = 20'
    assert_rel z[0].im, 0.0, 1e-9, 'z[0].imag, 5 x^2 = 20'
    assert_rel z[1].re, 2.0, 1e-9, 'z[1].real, 5 x^2 = 20'
    assert_rel z[1].im, 0.0, 1e-9, 'z[1].imag, 5 x^2 = 20'

    z = GSL::Poly.complex_solve_quadratic(5.0, 0.0, 20.0)
    assert_rel z[0].re, 0.0, 1e-9, 'z[0].real, 5 x^2 = -20'
    assert_rel z[0].im, -2.0, 1e-9, 'z[0].imag, 5 x^2 = -20'
    assert_rel z[1].re, 0.0, 1e-9, 'z[1].real, 5 x^2 = -20'
    assert_rel z[1].im, 2.0, 1e-9, 'z[1].imag, 5 x^2 = -20'

    # Quadratic single complex root (technically not quadratic and root not
    # complex since imaginary component is 0, but the data type is complex)
    z = GSL::Poly.complex_solve_quadratic(0.0, 1.0, -1.0)
    assert_rel z[0].re, 1.0, 1e-9, 'z[0].real, x = 1 (complex)'
    assert_rel z[0].im, 0.0, 0.0,  'z[0].imag, x = 1 (complex)'
    assert x1.nil?, 'z[1], x = 0 is nil'

    # Quadratic no complex root (technically not quadratic)
    z = GSL::Poly.complex_solve_quadratic(0.0, 0.0, 1.0)
    assert z[0].nil?, 'z[0], 1 = 0 is nil'
    assert z[1].nil?, 'z[1], 1 = 0 is nil'

    z = GSL::Poly.complex_solve_cubic(0.0, 0.0, -27.0)
    assert_rel z[0].re, -1.5, 1e-9, 'z[0].real, x^3 = 27'
    assert_rel z[0].im, -1.5 * Math.sqrt(3.0), 1e-9, 'z[0].imag, x^3 = 27'
    assert_rel z[1].re, -1.5, 1e-9, 'z[1].real, x^3 = 27'
    assert_rel z[1].im, 1.5 * Math.sqrt(3.0), 1e-9, 'z[1].imag, x^3 = 27'
    assert_rel z[2].re, 3.0, 1e-9, 'z[2].real, x^3 = 27'
    assert_rel z[2].im, 0.0, 1e-9, 'z[2].imag, x^3 = 27'

    z = GSL::Poly.complex_solve_cubic(-1.0, 1.0, 39.0)
    assert_rel z[0].re, -3.0, 1e-9, 'z[0].real, (x+3)(x^2+1) = 0'
    assert_rel z[0].im, 0.0, 1e-9, 'z[0].imag, (x+3)(x^2+1) = 0'
    assert_rel z[1].re, 2.0, 1e-9, 'z[1].real, (x+3)(x^2+1) = 0'
    assert_rel z[1].im, -3.0, 1e-9, 'z[1].imag, (x+3)(x^2+1) = 0'
    assert_rel z[2].re, 2.0, 1e-9, 'z[2].real, (x+3)(x^2+1) = 0'
    assert_rel z[2].im, 3.0, 1e-9, 'z[2].imag, (x+3)(x^2+1) = 0'

    z = GSL::Poly.complex_solve_cubic(-51.0, 867.0, -4913.0)
    assert_rel z[0].re, 17.0, 1e-9, 'z[0].real, (x-17)^3=0'
    assert_rel z[0].im, 0.0, 1e-9, 'z[0].imag, (x-17)^3=0'
    assert_rel z[1].re, 17.0, 1e-9, 'z[1].real, (x-17)^3=0'
    assert_rel z[1].im, 0.0, 1e-9, 'z[1].imag, (x-17)^3=0'
    assert_rel z[2].re, 17.0, 1e-9, 'z[2].real, (x-17)^3=0'
    assert_rel z[2].im, 0.0, 1e-9, 'z[2].imag, (x-17)^3=0'

    z = GSL::Poly.complex_solve_cubic(-57.0, 1071.0, -6647.0)
    assert_rel z[0].re, 17.0, 1e-9, 'z[0].real, (x-17)(x-17)(x-23)=0'
    assert_rel z[0].im, 0.0, 1e-9, 'z[0].imag, (x-17)(x-17)(x-23)=0'
    assert_rel z[1].re, 17.0, 1e-9, 'z[1].real, (x-17)(x-17)(x-23)=0'
    assert_rel z[1].im, 0.0, 1e-9, 'z[1].imag, (x-17)(x-17)(x-23)=0'
    assert_rel z[2].re, 23.0, 1e-9, 'z[2].real, (x-17)(x-17)(x-23)=0'
    assert_rel z[2].im, 0.0, 1e-9, 'z[2].imag, (x-17)(x-17)(x-23)=0'

    z = GSL::Poly.complex_solve_cubic(-11.0, -493.0, +6647.0)
    assert_rel z[0].re, -23.0, 1e-9, 'z[0].real, (x+23)(x-17)(x-17)=0'
    assert_rel z[0].im, 0.0, 1e-9, 'z[0].imag, (x+23)(x-17)(x-17)=0'
    assert_rel z[1].re, 17.0, 1e-9, 'z[1].real, (x+23)(x-17)(x-17)=0'
    assert_rel z[1].im, 0.0, 1e-9, 'z[1].imag, (x+23)(x-17)(x-17)=0'
    assert_rel z[2].re, 17.0, 1e-9, 'z[2].real, (x+23)(x-17)(x-17)=0'
    assert_rel z[2].im, 0.0, 1e-9, 'z[2].imag, (x+23)(x-17)(x-17)=0'

    z = GSL::Poly.complex_solve_cubic(-143.0, 5087.0, -50065.0)
    assert_rel z[0].re, 17.0, 1e-9, 'z[0].real, (x-17)(x-31)(x-95)=0'
    assert_rel z[0].im, 0.0, 1e-9, 'z[0].imag, (x-17)(x-31)(x-95)=0'
    assert_rel z[1].re, 31.0, 1e-9, 'z[1].real, (x-17)(x-31)(x-95)=0'
    assert_rel z[1].im, 0.0, 1e-9, 'z[1].imag, (x-17)(x-31)(x-95)=0'
    assert_rel z[2].re, 95.0, 1e-9, 'z[2].real, (x-17)(x-31)(x-95)=0'
    assert_rel z[2].im, 0.0, 1e-9, 'z[2].imag, (x-17)(x-31)(x-95)=0'

    a = GSL::Poly.alloc(-120, 274, -225, 85, -15, 1)
    w = GSL::Poly::Complex::Workspace.alloc(a.size)
    z = GSL::Poly.complex_solve(a, 6, w)
    assert_rel z[0].re, 1.0, 1e-9, 'z[0].real, 5th-order polynomial'
    assert_rel z[0].im, 0.0, 1e-9, 'z[0].imag, 5th-order polynomial'
    assert_rel z[1].re, 2.0, 1e-9, 'z[1].real, 5th-order polynomial'
    assert_rel z[1].im, 0.0, 1e-9, 'z[1].imag, 5th-order polynomial'
    assert_rel z[2].re, 3.0, 1e-9, 'z[2].real, 5th-order polynomial'
    assert_rel z[2].im, 0.0, 1e-9, 'z[2].imag, 5th-order polynomial'
    assert_rel z[3].re, 4.0, 1e-9, 'z3.real, 5th-order polynomial'
    assert_rel z[3].im, 0.0, 1e-9, 'z3.imag, 5th-order polynomial'
    assert_rel z[4].re, 5.0, 1e-9, 'z4.real, 5th-order polynomial'
    assert_rel z[4].im, 0.0, 1e-9, 'z4.imag, 5th-order polynomial'

    a = GSL::Poly.alloc(1, 0, 0, 0, 1, 0, 0, 0, 1)
    w = GSL::Poly::Complex::Workspace.alloc(a.size)
    c = 0.5
    s = Math.sqrt(3) / 2
    z = GSL::Poly.complex_solve(a, w)
    assert_rel z[0].re, -s, 1e-9, 'z[0].real, 8th-order polynomial'
    assert_rel z[0].im,  c, 1e-9, 'z[0].imag, 8th-order polynomial'
    assert_rel z[1].re, -s, 1e-9, 'z[1].real, 8th-order polynomial'
    assert_rel z[1].im, -c, 1e-9, 'z[1].imag, 8th-order polynomial'
    assert_rel z[2].re, -c, 1e-9, 'z[2].real, 8th-order polynomial'
    assert_rel z[2].im,  s, 1e-9, 'z[2].imag, 8th-order polynomial'
    assert_rel z[3].re, -c, 1e-9, 'z3.real, 8th-order polynomial'
    assert_rel z[3].im, -s, 1e-9, 'z3.imag, 8th-order polynomial'
    assert_rel z[4].re,  c, 1e-9, 'z4.real, 8th-order polynomial'
    assert_rel z[4].im,  s, 1e-9, 'z4.imag, 8th-order polynomial'
    assert_rel z[5].re,  c, 1e-9, 'z5.real, 8th-order polynomial'
    assert_rel z[5].im, -s, 1e-9, 'z5.imag, 8th-order polynomial'
    assert_rel z[6].re,  s, 1e-9, 'z6.real, 8th-order polynomial'
    assert_rel z[6].im,  c, 1e-9, 'z6.imag, 8th-order polynomial'
    assert_rel z[7].re,  s, 1e-9, 'z7.real, 8th-order polynomial'
    assert_rel z[7].im, -c, 1e-9, 'z7.imag, 8th-order polynomial'

    xa = GSL::Poly.alloc(0.16, 0.97, 1.94, 2.74, 3.58, 3.73, 4.70)
    ya = GSL::Poly.alloc(0.73, 1.11, 1.49, 1.84, 2.30, 2.41, 3.07)
    dd_expected = GSL::Vector.alloc(7.30000000000000e-01,
                                    4.69135802469136e-01,
                                   -4.34737219941284e-02,
                                    2.68681098870099e-02,
                                   -3.22937056934996e-03,
                                    6.12763259971375e-03,
                                   -6.45402453527083e-03)
    dd = GSL::Poly.dd_init(xa, ya)

    7.times { |i|
      assert_rel dd[i], dd_expected[i], 1e-10, "divided difference dd[#{i}]"
    }

    7.times { |i|
      y = dd.eval(xa, xa[i])
      assert_rel y, ya[i], 1e-10, "divided difference y[#{i}]"
    }

    coeff = dd.taylor(1.5, xa)

    7.times { |i|
      y = coeff.eval(xa[i] - 1.5)
      assert_rel y, ya[i], 1e-10, "taylor expansion about 1.5 y[#{i}]"
    }

    # Added GSL-1.12.90 (gsl-1.13)
    # gsl_poly_eval_derivs()
    return unless GSL::Poly.method_defined?(:eval_derivs)

    c = GSL::Vector.alloc([1.0, -2.0, 3.0, -4.0, 5.0, -6.0])
    x = -0.5

    dc = GSL::Poly.eval_derivs(c, x)

    assert_rel dc[0], c[0] + c[1] * x + c[2] * x * x + c[3] * x * x * x + c[4] * x * x * x * x + c[5] * x * x * x * x * x , EPS, 'eval_derivs({+1, -2, +3, -4, +5, -6}, 3.75)'
    assert_rel dc[1], c[1] + 2.0 * c[2] * x + 3.0 * c[3] * x * x + 4.0 * c[4] * x * x * x + 5.0 * c[5] * x * x * x * x , EPS, 'eval_derivs({+1, -2, +3, -4, +5, -6} deriv 1, -12.375)'
    assert_rel dc[2], 2.0 * c[2] + 3.0 * 2.0 * c[3] * x + 4.0 * 3.0 * c[4] * x * x + 5.0 * 4.0 * c[5] * x * x * x , EPS, 'eval_derivs({+1, -2, +3, -4, +5, -6} deriv 2, +48.0)'
    assert_rel dc[3], 3.0 * 2.0 * c[3] + 4.0 * 3.0 * 2.0 * c[4] * x + 5.0 * 4.0 * 3.0 * c[5] * x * x , EPS, 'eval_derivs({+1, -2, +3, -4, +5, -6} deriv 3, -174.0)'
    assert_rel dc[4], 4.0 * 3.0 * 2.0 * c[4] + 5.0 * 4.0 * 3.0 * 2.0 * c[5] * x, EPS, 'eval_derivs({+1, -2, +3, -4, +5, -6} deriv 4, +480.0)'
    assert_rel dc[5], 5.0 * 4.0 * 3.0 * 2.0 * c[5] , EPS, 'eval_derivs({+1, -2, +3, -4, +5, -6} deriv 5, -720.0)'

    # Test Poly::fit and Poly::wfit
    x = GSL::Vector[0, 2, 2]
    y = GSL::Vector[0, 1, -1]
    coef, cov, chisq, status = GSL::Poly.fit(x, y, 1)
    assert_rel coef[0], 0.0, 1e-9, 'y intercept == 0'
    assert_rel coef[1], 0.0, 1e-9, 'slope == 0'
    assert_rel chisq, 2.0, 1e-9, 'chisq == 2'

    w = GSL::Vector[1, 1, 0]
    coef, cov, chisq, status = GSL::Poly.wfit(x, w, y, 1)
    assert_rel coef[0], 0.0, 1e-9, 'y intercept == 0'
    assert_rel coef[1], 0.5, 1e-9, 'slope == 0.5'
    assert_rel chisq, 0.0, 1e-9, 'chisq == 0'
  end

  def test_special
    hermit = [
      GSL::Poly::Int[1],
      GSL::Poly::Int[0, 2],
      GSL::Poly::Int[-2, 0, 4],
      GSL::Poly::Int[0, -12, 0, 8],
      GSL::Poly::Int[12, 0, -48, 0, 16],
      GSL::Poly::Int[0, 120, 0, -160, 0, 32],
      GSL::Poly::Int[-120, 0, 720, 0, -480, 0, 64]
    ]
    hermit[0][0] = 1

    6.times { |i|
      hn = GSL::Poly.hermite(i)
      assert_equal hermit[i], hn, "Hermite polynomial, n = #{i}"
    }

    laguerre = [
      GSL::Poly::Int[1],
      GSL::Poly::Int[1, -1],
      GSL::Poly::Int[2, -4, 1],
      GSL::Poly::Int[6, -18, 9, -1],
      GSL::Poly::Int[24, -96, 72, -16, 1],
      GSL::Poly::Int[120, -600, 600, -200, 25, -1],
      GSL::Poly::Int[720, -4320, 5400, -2400, 450, -36, 1]
    ]
    laguerre[0][0] = 1

    7.times { |i|
      hn = GSL::Poly.laguerre(i)
      assert_equal laguerre[i], hn, "Laguerre polynomial, n = #{i}"
    }

    cheb = [
      GSL::Poly::Int[1],
      GSL::Poly::Int[0, 1],
      GSL::Poly::Int[-1, 0, 2],
      GSL::Poly::Int[0, -3, 0, 4],
      GSL::Poly::Int[1, 0, -8, 0, 8],
      GSL::Poly::Int[0, 5, 0, -20, 0, 16],
      GSL::Poly::Int[-1, 0, 18, 0, -48, 0, 32]
    ]
    cheb[0][0] = 1

    7.times { |i|
      hn = GSL::Poly.cheb(i)
      assert_equal cheb[i], hn, "Chebyshev polynomial, n = #{i}"
    }

    cheb_ii = [
      GSL::Poly::Int[1],
      GSL::Poly::Int[0, 2],
      GSL::Poly::Int[-1, 0, 4],
      GSL::Poly::Int[0, -4, 0, 8],
      GSL::Poly::Int[1, 0, -12, 0, 16],
      GSL::Poly::Int[0, 6, 0, -32, 0, 32],
      GSL::Poly::Int[-1, 0, 24, 0, -80, 0, 64]
    ]
    cheb_ii[0][0] = 1

    7.times { |i|
      hn = GSL::Poly.cheb_II(i)
      assert_equal cheb_ii[i], hn, "Chebyshev II polynomial, n = #{i}"
    }
  end

end
require 'test_helper'

class MultisetTest < GSL::TestCase

  def test_multiset
    return if GSL::VERSION < '1.14'

    c63 = [ [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, 0, 4], [0, 0, 5],
            [0, 1, 1], [0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 1, 5],
            [0, 2, 2], [0, 2, 3], [0, 2, 4], [0, 2, 5],
            [0, 3, 3], [0, 3, 4], [0, 3, 5],
            [0, 4, 4], [0, 4, 5],
            [0, 5, 5],
            [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 1, 4], [1, 1, 5],
            [1, 2, 2], [1, 2, 3], [1, 2, 4], [1, 2, 5],
            [1, 3, 3], [1, 3, 4], [1, 3, 5],
            [1, 4, 4], [1, 4, 5],
            [1, 5, 5],
            [2, 2, 2], [2, 2, 3], [2, 2, 4], [2, 2, 5],
            [2, 3, 3], [2, 3, 4], [2, 3, 5],
            [2, 4, 4], [2, 4, 5],
            [2, 5, 5],
            [3, 3, 3], [3, 3, 4], [3, 3, 5],
            [3, 4, 4], [3, 4, 5],
            [3, 5, 5],
            [4, 4, 4], [4, 4, 5],
            [4, 5, 5],
            [5, 5, 5] ]

    c = GSL::Multiset.alloc(6, 3)
    c.init_first

    status = i = 0

    loop {
      if i >= 56
        status = 1
        break
      end

      3.times { |j| status |= c.data[j] != c63[i][j] ? 0 : 1 }
      assert c.valid, "gsl_multiset_valid(#{i})"

      i += 1

      break if c.next != GSL::SUCCESS
    }

    refute status.zero?
  end

end
require 'test_helper'

class Spline2dTest < GSL::TestCase
  def saddle(x,y)
    x*x - y*y
  end

  def setup
    x_samples =(-20..20).map(&:to_f).to_a
    y_samples = (-20..20).map(&:to_f).to_a
    z_samples = []
    x_samples.each do |x|
      y_samples.each do |y|
        z_samples << saddle(x,y)
      end
    end

    @x_array = GSL::Vector.alloc(x_samples)
    @y_array = GSL::Vector.alloc(y_samples)
    @z_array = GSL::Vector.alloc(z_samples)

    @i2d_bicubic = GSL::Spline2d.alloc(GSL::Interp2d::BICUBIC,
      @x_array, @y_array, @z_array)

    @i2d_bilinear = GSL::Spline2d.alloc(GSL::Interp2d::BILINEAR,
      @x_array, @y_array, @z_array)
  end

  def test_info
    str = <<-EOF
Class:      GSL::Spline2d
SuperClass: GSL::Object
Type:       bilinear
xmin:       -20.000000
xmax:       20.000000
ymin:       -20.000000
ymax:       20.000000
xSize:       41
ySize:       41
EOF
    assert_equal str, @i2d_bilinear.info
  end

  def test_use_case_saddle_interpolation
    tolerance = 0.05 # 5% inaccuracy is tolerated in tests below
    interpolator_type = GSL::Interp2d::BICUBIC

    i2d = GSL::Spline2d.alloc(interpolator_type, @x_array, @y_array, @z_array)

    # confirm that the fit passes very close to the sampled data points
    @x_array.each do |x|
      @y_array.each do |y|
        expected_z = saddle(x,y)
        z = i2d.eval(x, y)
        error = (z - expected_z).abs
        max_error = (expected_z.abs)*tolerance
        if max_error == 0
          max_error = tolerance
        end
        refute error > max_error, "error @ sample #{x},#{y} z: #{z} expected_z: #{expected_z}"
      end
    end

    interstitial_x_values = @x_array.to_a.first(@x_array.size-1).map {|v| v+ 0.5}
    interstitial_y_values = @y_array.to_a.first(@y_array.size-1).map {|v| v+ 0.3}

    # confirm that interstitial values are interpolated accurately 
    interstitial_x_values.each do |x|
      interstitial_y_values.each do |y|
        expected_z = saddle(x,y)
        z = i2d.eval(x,y)
        error = (z - expected_z).abs
        max_error = (expected_z.abs)*tolerance
        if max_error == 0
          max_error = tolerance
        end
        refute error > max_error, "error @ interstitial #{x},#{y}"
      end
    end
  end
end if GSL::GSL_VERSION >= '2.0'require 'test_helper'

class DhtTest < GSL::TestCase

  N = 128

  def test_dht
    test_data = [GSL::Vector.alloc(N)]
    test_data << NMatrix.new([N], dtype: :float64) if ENV['NMATRIX']
    test_data.each do |vin|
      dht2 vin
      dht3 vin
      dht4 vin
    end
  end
  
  def test_dht1
    test_data = [GSL::Vector.alloc(1, 2, 3)]
    test_data << NMatrix.new([3], [1,2,3], dtype: :float64) if ENV['NMATRIX']
    test_data.each do |vin|
      dht = GSL::Dht.alloc(3, 1.0, 1.0)

      vout = dht.apply(vin)

      assert_in_delta  0.3752546494075203,  vout[0], 0.001
      assert_in_delta(-0.13350787269556064, vout[1], 0.001)
      assert_in_delta  0.0446799251438404,  vout[2], 0.001

      vin2 = dht.apply(vout)
      vin2 = vin2 * (13.323691936314223 ** 2)

      assert_in_delta 1.0000119186762644, vin2[0], 0.001
      assert_in_delta 1.9999790476647084, vin2[1], 0.001
      assert_in_delta 3.000035803234503,  vin2[2], 0.001
    end
  end

  def dht2 vin
    dht = GSL::Dht.alloc(N, 0.0, 100.0)

    N.times { |i|
      x = dht.x_sample(i)
      vin[i] = 1.0 / (1.0 + x * x)
    }

    vout = dht.apply(vin)

    assert_in_delta 3.999613382195876,   vout[0], 0.001
    assert_in_delta 1.8387637474026606,  vout[5], 0.001
    assert_in_delta 1.2677885358829588,  vout[10], 0.001
    assert_in_delta 0.3521910403797792,  vout[35], 0.001
    assert_in_delta 0.02373661279695407, vout[100], 0.001
  end

  def dht3 vin
    dht = GSL::Dht.alloc(N, 1.0, 20.0)

    N.times { |i|
      x = dht.x_sample(i)
      vin[i] = Math.exp(-x)
    }

    vout = dht.apply(vin)

    assert_in_delta 0.18148296716239096,   vout[0], 0.001
    assert_in_delta 0.35680451269699853,   vout[5], 0.001
    assert_in_delta 0.21101009980456306,   vout[10], 0.001
    assert_in_delta 0.02892068100516861,   vout[35], 0.001
    assert_in_delta 0.0022121119664674426, vout[100], 0.001
  end

  def dht4 vin
    dht = GSL::Dht.alloc(N, 1.0, 1.0)

    N.times { |i|
      x = dht.x_sample(i)
      vin[i] = x * (1.0 - x * x)
    }

    vout = dht.apply(vin)

    assert_in_delta  0.05727421417071144,    vout[0], 0.001
    assert_in_delta -0.0001908501261051786,  vout[5], 0.001
    assert_in_delta  2.434180086051901e-05,  vout[10], 0.001
    assert_in_delta -4.0392713194195724e-07, vout[35], 0.001
    assert_in_delta  8.255662619348403e-09,  vout[100], 0.001
  end
end
require 'test_helper'

class StatsTest < GSL::TestCase

  def test_stats
    lew = GSL::Vector.alloc(
      -213, -564,  -35,  -15,  141,  115, -420, -360,  203, -338, -431,  194,
      -220, -513,  154, -125, -559,   92,  -21, -579,  -52,   99, -543, -175,
       162, -457, -346,  204, -300, -474,  164, -107, -572,   -8,   83, -541,
      -224,  180, -420, -374,  201, -236, -531,   83,   27, -564, -112,  131,
      -507, -254,  199, -311, -495,  143,  -46, -579,  -90,  136, -472, -338,
       202, -287, -477,  169, -124, -568,   17,   48, -568, -135,  162, -430,
      -422,  172,  -74, -577,  -13,   92, -534, -243,  194, -355, -465,  156,
       -81, -578,  -64,  139, -449, -384,  193, -198, -538,  110,  -44, -577,
        -6,   66, -552, -164,  161, -460, -344,  205, -281, -504,  134,  -28,
      -576, -118,  156, -437, -381,  200, -220, -540,   83,   11, -568, -160,
       172, -414, -408,  188, -125, -572,  -32,  139, -492, -321,  205, -262,
      -504,  142,  -83, -574,    0,   48, -571, -106,  137, -501, -266,  190,
      -391, -406,  194, -186, -553,   83,  -13, -577,  -49,  103, -515, -280,
       201,  300, -506,  131,  -45, -578,  -80,  138, -462, -361,  201, -211,
      -554,   32,   74, -533, -235,  187, -372, -442,  182, -147, -566,   25,
        68, -535, -244,  194, -351, -463,  174, -125, -570,   15,   72, -550,
      -190,  172, -424, -385,  198, -218, -536,   96
    )

    mean = lew.mean
    sd   = lew.sd
    lag1 = lew.lag1_autocorrelation

    assert_rel mean, -177.435000000000,    1e-15, 'lew gsl_stats_mean'
    assert_rel sd,    277.332168044316,    1e-15, 'lew gsl_stats_sd'
    assert_rel lag1,   -0.307304800605679, 1e-14, 'lew autocorrelation'

    rel = 1e-10

    rawa = GSL::Vector.alloc(
      0.0421, 0.0941, 0.1064, 0.0242, 0.1331,
      0.0773, 0.0243, 0.0815, 0.1186, 0.0356,
      0.0728, 0.0999, 0.0614, 0.0479
    )

    rawb = GSL::Vector.alloc(
      0.1081, 0.0986, 0.1566, 0.1961, 0.1125,
      0.1942, 0.1079, 0.1021, 0.1583, 0.1673,
      0.1675, 0.1856, 0.1688, 0.1512
    )

    raww = GSL::Vector.alloc(
      0.0000, 0.0000, 0.0000, 3.000, 0.0000,
      1.0000, 1.0000, 1.0000, 0.000, 0.5000,
      7.0000, 5.0000, 4.0000, 0.123
    )

    assert_rel mean = rawa.mean, 0.0728, rel, 'gsl_stats_mean'

    assert_rel rawa.variance_with_fixed_mean(mean), 0.00113837428571429,
      rel, 'gsl_stats_variance_with_fixed_mean'

    assert_rel rawa.sd_with_fixed_mean(mean), 0.0337398026922845,
      rel, 'gsl_stats_sd_with_fixed_mean'

    assert_rel rawb.variance,         0.00124956615384615,  rel, 'gsl_stats_variance'
    assert_rel rawa.sd,               0.0350134479659107,   rel, 'gsl_stats_sd'
    assert_rel rawa.absdev,           0.0287571428571429,   rel, 'gsl_stats_absdev'
    assert_rel rawa.skew,             0.0954642051479004,   rel, 'gsl_stats_skew'
    assert_rel rawa.kurtosis,        -1.38583851548909,     rel, 'gsl_stats_kurtosis'
    assert_rel rawa.wmean(raww),      0.0678111523670601,   rel, 'gsl_stats_wmean'
    assert_rel rawa.wvariance(raww),  0.000769562962860317, rel, 'gsl_stats_wvariance'
    assert_rel rawa.wsd(raww),        0.0277409978706664,   rel, 'gsl_stats_wsd'
    assert_rel rawa.wabsdev(raww),    0.0193205027504008,   rel, 'gsl_stats_wabsdev'
    assert_rel rawa.wskew(raww),     -0.373631000307076,    rel, 'gsl_stats_wskew'
    assert_rel rawa.wkurtosis(raww), -1.48114233353963,     rel, 'gsl_stats_wkurtosis'

    assert_rel GSL::Stats.covariance(rawa, rawb), -0.000139021538461539, rel, 'gsl_stats_covariance'

    if GSL::GSL_VERSION >= '1.9.90'
      assert_rel GSL::Stats.correlation(rawa, rawb), -0.112322712666074171, rel, 'gsl_stats_correlation'
      assert_rel GSL::Stats.pvariance(rawa, rawb),    0.00123775384615385,  rel, 'gsl_stats_pvariance'
      assert_rel GSL::Stats.ttest(rawa, rawb),       -5.67026326985851,     rel, 'gsl_stats_ttest'
    end

    assert_rel rawa.max, 0.1331, rel, 'gsl_stats_max'
    assert_rel rawa.min, 0.0242, rel, 'gsl_stats_min'

    min, max = rawa.minmax
    assert_rel max, 0.1331, rel, 'gsl_stats_minmax: max'
    assert_rel min, 0.0242, rel, 'gsl_stats_minmax: min'

    assert rawa.max_index == 4, 'gsl_stats_max_index'
    assert rawa.min_index == 3, 'gsl_stats_min_index'

    min_index, max_index = rawa.minmax_index
    assert max_index == 4, 'gsl_stats_minmax_index: max'
    assert min_index == 3, 'gsl_stats_minmax_index: min'

    rawa.sort!

    assert_rel rawa.median_from_sorted_data, 0.07505,
      rel, 'gsl_stats_median_from_sorted_data'

    assert_rel rawa.subvector(0, rawa.size - 1).median_from_sorted_data, 0.0728,
      rel, 'gsl_stats_median_from_sorted_data'

    assert_rel rawa.quantile_from_sorted_data(0.0), 0.0242,
      rel, 'gsl_stats_quantile_from_sorted_data'

    assert_rel rawa.quantile_from_sorted_data(1.0), 0.1331,
      rel, 'gsl_stats_quantile_from_sorted_data (100)'

    assert_rel rawa.quantile_from_sorted_data(0.5), 0.07505,
      rel, 'gsl_stats_quantile_from_sorted_data (50even)'

    assert_rel rawa.subvector(0, rawa.size-1).quantile_from_sorted_data(0.5), 0.0728,
      rel, 'gsl_stats_quantile_from_sorted_data (50odd)'
  end

  def test_variance_with_fixed_mean
    v = GSL::Vector[1..8]
    assert_raises(ArgumentError, 'check for no args') { v.variance_with_fixed_mean }
  end

end
require 'test_helper'

class BsplineTest < GSL::TestCase

  N = 100

  NMAX = 10
  BMAX = 10  # 100

  def _test_bspline(bw)
    ncoeffs, order = bw.ncoeffs, bw.order

    a = bw.breakpoint(0)
    b = bw.breakpoint(bw.nbreak - 1)

    N.times { |i|
      xi, sum = a + (b - a) * (i / (N - 1)), 0.0

      bb = bw.eval(xi)

      ncoeffs.times { |j|
        bj = bb[j]
        refute bj < 0 || bj > 1,
          "basis-spline coefficient #{j} is in range [0,1] for x=#{xi}"

        sum += bj
      }

      assert_rel sum, 1.0, order * GSL::DBL_EPSILON,
        "basis-spline coefficient #{order} is in range [0,1] for x=#{xi}"
    }
  end

  def test_bspline_knots_uniform
    1.upto(NMAX) { |order|
      2.upto(BMAX) { |breakpoints|
        bw = GSL::BSpline.alloc(order, breakpoints)
        bw.knots_uniform(-1.23 * order, 45.6 * order)
        _test_bspline(bw)
      }
    }
  end

  def test_bspline_knots
    1.upto(NMAX) do |order|
      2.upto(BMAX) do |breakpoints|
        a, b = -1.23 * order, 45.6 * order

        bw = GSL::BSpline.alloc(order, breakpoints)
        test_data = [GSL::Vector.alloc(breakpoints)]
        test_data << NMatrix.new([breakpoints], dtype: :float64) if ENV['NMATRIX']
        test_data.each do |k|
          breakpoints.times do |i|
            f = GSL.sqrt(i.to_f / (breakpoints - 1.0))
            k[i] = (1 - f) * a + f * b
          end

          bw.knots(k)
          _test_bspline(bw)
        end
      end
    end
  end
end
require 'test_helper'

class WaveletTest < GSL::TestCase

  MEMBERS = [309, 307, 305, 303, 301, 208, 206, 204, 202, 105, 103]

  def _urand
    x = 1
    x = (1103515245 * x + 12345) & 0x7fffffff
    x / 2147483648.0
  end

  def _test_1d(n, stride, type, member)
    nn = n * stride
    data = GSL::Vector.alloc(nn)
    nn.times { |i| data[i] = 12345.0 + i }

    v1 = data.view_with_stride(0, stride, n)
    n.times { |i| v1[i] = _urand }

    v2 = GSL::Vector.alloc(n)
    GSL::Vector.memcpy(v2, v1)

    vdelta = GSL::Vector.alloc(n)

    work = GSL::Wavelet::Workspace.alloc(n)
    w = GSL::Wavelet.alloc(type, member)
    w.transform_forward(v2, work)
    w.transform_inverse(v2, work)

    n.times { |i| vdelta[i] = (v1[i] - v2[i]).abs }

    i = vdelta.max_index
    x1, x2 = v1[i], v2[i]

    refute((x2 - x1).abs > n * 1e-15,
      "#{w.name}(#{member}), n = #{n}, stride = #{stride}, maxerr = #{(x2 - x1).abs}")

    assert((0...nn).all? { |j| j % stride == 0 || data[j] == 12345.0 + j },
      "#{w.name}(#{member}) other data untouched, n = #{n}, stride = #{stride}") if stride > 1
  end

  def _test_2d(n, tda, t, member, type)
    nn = n * tda
    data = GSL::Vector.alloc(nn)
    nn.times { |i| data[i] = 12345.0 + i }

    m1 = data.matrix_view_with_tda(n, n, tda)
    n.times { |i| n.times { |j| m1.set(i, j, _urand) } }

    m2 = GSL::Matrix.alloc(n, n)
    GSL::Matrix.memcpy(m2, m1)

    mdelta = GSL::Matrix.alloc(n, n)

    work = GSL::Wavelet::Workspace.alloc(n)
    w = GSL::Wavelet.alloc(t, member)

    typename = case type
      when 1
        GSL::Wavelet2d.transform_matrix_forward(w, m2, work)
        GSL::Wavelet2d.transform_matrix_inverse(w, m2, work)
        'standard'
      when 2
        GSL::Wavelet2d.nstransform_matrix_forward(w, m2, work)
        GSL::Wavelet2d.nstransform_matrix_inverse(w, m2, work)
        'nonstd'
    end

    n.times { |i| n.times { |j| mdelta.set(i, j, (m1[i, j] - m2[i, j]).abs) } }

    i, j = mdelta.max_index
    x1, x2 = m1[i, j], m1[i, j]

    refute((x2 - x1).abs > n * 1e-15,
      "#{w.name}(#{member})-2d #{typename}, n = #{n}, tda = #{tda}, maxerr = #{(x2 - x1).abs}")

    assert((0...n).to_a.product((n...tda).to_a).all? { |k, l| data[k * tda + l] == 12345.0 + k * tda + l },
      "#{w.name}(#{member})-2d #{typename} other data untouched, n = #{n}, tda = #{tda}") if tda > n
  end

  def _each_pow(n = 14)
    n.times { |i| yield 2 ** i }
  end

  def _each_n(n = 9, m = 4)
    n.times { |i| yield m + 2 * i }
  end

  def test_1d_bspline
    _each_pow { |n| MEMBERS.each { |m| _test_1d(n, 1, 'bspline', m) } }
  end

  def test_1d_bspline_centered
    _each_pow { |n| MEMBERS.each { |m| _test_1d(n, 1, 'bspline_centered', m) } }
  end

  def test_1d_daubechies
    _each_pow { |n| _each_n { |i| _test_1d(n, 1, 'daubechies', i) } }
  end

  def test_1d_daubechies_centered
    _each_pow { |n| _each_n { |i|_test_1d(n, 1, 'daubechies_centered', i) } }
  end

  def test_1d_haar
    _each_pow { |n| _test_1d(n, 1, 'haar', 2) }
  end

  def test_1d_haar_centered
    _each_pow { |n| _test_1d(n, 1, 'haar_centered', 2) }
  end

  def test_2d_bspline_standard
    _each_pow(6) { |n| MEMBERS.each { |m| _test_2d(n, n, 'bspline', m, 1) } }
  end

  def test_2d_bspline_centered_standard
    _each_pow(6) { |n| MEMBERS.each { |m| _test_2d(n, n, 'bspline_centered', m, 1) } }
  end

  def test_2d_bspline_nonstd
    _each_pow(6) { |n| MEMBERS.each { |m| _test_2d(n, n, 'bspline', m, 2) } }
  end

  def test_2d_bspline_centered_nonstd
    _each_pow(6) { |n| MEMBERS.each { |m| _test_2d(n, n, 'bspline_centered', m, 2) } }
  end

end
require 'test_helper'

class OdeivTest < GSL::TestCase

  def setup
    @rhs_func_lin = GSL::Odeiv::System.alloc(lambda { |t, y, f|
      f[0] = 0.0
      f[1] = y[0]
      GSL::SUCCESS
    }, lambda { |t, y, dfdy, dfdt|
      dfdy.set(0, 0, 0.0)
      dfdy.set(0, 1, 0.0)
      dfdy.set(1, 0, 1.0)
      dfdy.set(1, 1, 0.0)
      dfdt[0] = 0.0
      dfdt[1] = 0.0
      GSL::SUCCESS
    }, 2)

    @rhs_func_sin = GSL::Odeiv::System.alloc(lambda { |t, y, f|
      f[0] = -y[1]
      f[1] = y[0]
      GSL::SUCCESS
    }, lambda { |t, y, dfdy, dfdt|
      dfdy.set(0, 0, 0.0)
      dfdy.set(0, 1, -1.0)
      dfdy.set(1, 0, 1.0)
      dfdy.set(1, 1, 0.0)
      dfdt[0] = 0.0
      dfdt[1] = 0.0
      GSL::SUCCESS
    }, 2)

    @rhs_func_exp = GSL::Odeiv::System.alloc(lambda { |t, y, f|
      f[0] = y[1]
      f[1] = y[0]
      GSL::SUCCESS
    }, lambda { |t, y, dfdy, dfdt|
      dfdy.set(0, 0, 0.0)
      dfdy.set(0, 1, 1.0)
      dfdy.set(1, 0, 1.0)
      dfdy.set(1, 1, 0.0)
      dfdt[0] = 0.0
      dfdt[1] = 0.0
      GSL::SUCCESS
    }, 2)

    @rhs_func_stiff = GSL::Odeiv::System.alloc(lambda { |t, y, f|
      f[0] = 998.0 * y[0] + 1998.0 * y[1]
      f[1] = -999.0 * y[0] - 1999.0 * y[1]
      GSL::SUCCESS
    }, lambda { |t, y, dfdy, dfdt|
      dfdy.set(0, 0, 998.0)
      dfdy.set(0, 1, 1998.0)
      dfdy.set(1, 0, -999.0)
      dfdy.set(1, 1, -1999.0)
      dfdt[0] = 0.0
      dfdt[1] = 0.0
      GSL::SUCCESS
    }, 2)
  end

  def self.define_test(test, type, h, b)
    define_method("test_#{test}_#{type}") { send("_test_#{test}", type, h, b) }
  end

  h, b = 1e-3, GSL::SQRT_DBL_EPSILON
  h2, b2 = h / 10, 1e-8

  %w[rk2 rk2imp rk4 rk4imp rkf45 rk8pd rkck bsimp gear1 gear2].each { |type|
    define_test(:stepper_err, type, h, b) unless type == 'bsimp'

    unless type == 'gear2'
      define_test(:stepper_linear, type, h,  b)
      define_test(:stepper_sin,    type, h2, b2)
      define_test(:stepper_exp,    type, h2, b2)
      define_test(:stepper_stiff,  type, h,  b)
    end

    define_test(:evolve_sin,    type, h, b)
    define_test(:evolve_exp,    type, h, b)
    define_test(:evolve_stiff1, type, h, b)
    define_test(:evolve_stiff5, type, h, b)
  }

  def _test_stepper_err(type, h, b)
    t = 0.0

    y = GSL::Vector.alloc(1.0, 0.0)
    yerr = GSL::Vector.alloc(2)

    stepper = GSL::Odeiv::Step.alloc(type, 2)

    while t < GSL::M_PI
      y1_t = y[1]
      dy_exp = Math.cos(t) * Math.sin(h) - 2 * Math.sin(t) * GSL.pow(Math.sin(h / 2), 2.0)

      stepper.apply(t, h, y, yerr, @rhs_func_sin)

      dy_t = y[1] - y1_t
      del = (dy_t - dy_exp).abs

      refute t > 0.1 && t < 0.2 && del > 10.0 * yerr[1].abs + GSL::DBL_EPSILON * y[1].abs,
        "#{stepper.name}, sine [0,pi], accurary of estimate error = #{del} vs #{yerr[1].abs}"

      t += h
    end
  end

  def _test_stepper_linear(type, h, b)
    delmax, n, t = 0.0, 0, 0.0

    stepper = GSL::Odeiv::Step.alloc(type, 2)

    y = GSL::Vector.alloc(1.0, 0.0)
    yerr = GSL::Vector.alloc(2)

    while t < 4.0
      stepper.apply(t, h, y, yerr, @rhs_func_lin)

      del = ((y[1] - (t + h)) / y[1]).abs
      delmax = GSL.MAX_DBL(del, delmax)

      refute del > (n + 1.0) * b,
        "#{stepper.name}, linear [0,4], max relative error = #{delmax}"

      n += 1
      t += h
    end
  end

  def _test_stepper_sin(type, h, b)
    delmax, n, t, pi = 0.0, 0, 0.0, GSL::M_PI

    stepper = GSL::Odeiv::Step.alloc(type, 2)

    y = GSL::Vector.alloc(1.0, 0.0)
    yerr = GSL::Vector.alloc(2)

    while t < pi
      sin_th = Math.sin(t + h)
      stepper.apply(t, h, y, yerr, @rhs_func_sin)

      del = ((y[1] - sin_th) / sin_th).abs
      delmax = GSL.MAX_DBL(del, delmax)

      refute del > (
        t < 0.5 * pi ? 1.0 + n :
        t < 0.7 * pi ? 1.0e+04 :
        t < 0.9 * pi ? 1.0e+06 : 1.0e+09) * b,
        "#{stepper.name}, sine [0,pi], max relative error = #{delmax}"

      n += 1
      t += h
    end

    refute delmax > 1.0e+09 * b,
      "#{stepper.name}, sine [0,pi], max relative error = #{delmax}"

    delmax = 0.0

    while t < 3 * pi
      stepper.apply(t, h, y, yerr, @rhs_func_sin)

      del = (y[1] - Math.sin(t)).abs
      delmax = GSL.MAX_DBL(del, delmax)

      n += 1
      t += h
    end

    refute del > n * 2.0 * b,
      "#{stepper.name}, sin [pi,3*pi], max absolute error = #{delmax}"
  end

  def _test_stepper_exp(type, h, b)
    delmax, n, t = 0.0, 0, 0.0

    stepper = GSL::Odeiv::Step.alloc(type, 2)

    y = GSL::Vector.alloc(1.0, 1.0)
    yerr = GSL::Vector.alloc(2)

    while t < 5.0
      stepper.apply(t, h, y, yerr, @rhs_func_exp)

      del = ((y[1] - Math.exp(t + h)) / y[1]).abs
      delmax = GSL.MAX_DBL(del, delmax)

      refute del > (n + 1.0) * 2.0 * b,
        "#{stepper.name}, exponential [0,5], max relative error = #{delmax}"

      n += 1
      t += h
    end
  end

  def _test_stepper_stiff(type, h, b)
    delmax, n, t = 0.0, 0, 0.0

    stepper = GSL::Odeiv::Step.alloc(type, 2)

    y = GSL::Vector.alloc(1.0, 0.0)
    yerr = GSL::Vector.alloc(2)

    while t < 5.0
      stepper.apply(t, h, y, yerr, @rhs_func_stiff)

      if t > 0.04
        arg = t + h

        e1 = Math.exp(-arg)
        e2 = Math.exp(-1000.0 * arg)

        del = ((y[0] - 2.0 * e1 + e2) / y[0]).abs
        delmax = GSL.MAX_DBL(del, delmax)

        refute del > (n + 1.0) * 100.0 * b,
          "#{stepper.name}, stiff [0,5], max relative error = #{delmax}"
      end

      n += 1
      t += h
    end
  end

  def _test_evolve_system_flat(type, sys, t0, t1, h, y, yfin, err_target, desc, control = nil)
    stepper = GSL::Odeiv::Step.alloc(type, sys.dimension)
    evolve  = GSL::Odeiv::Evolve.alloc(sys.dimension)

    while t0 < t1
      t0, h, _ = evolve.apply(control, stepper, sys, t0, t1, h, y)
    end

    frac = ((y[1] - yfin[1]) / yfin[1]).abs + ((y[0] - yfin[0]) / yfin[0]).abs
    refute frac > 2.0 * evolve.count * err_target, "#{stepper.name}, #{desc}, evolve" <<
      ", #{control ? 'standard' : 'no'} control, relative error = #{frac}"
  end

  def _test_evolve_system(type, sys, t0, t1, h, y, yfin, err_target, desc)
    _test_evolve_system_flat(type, sys, t0, t1, h, y, yfin, err_target, desc,
      GSL::Odeiv::Control.standard_alloc(0.0, err_target, 1.0, 1.0))
  end

  def _test_evolve_sin(type, h, err)
    y = GSL::Vector.alloc(1.0, 0.0)
    yfin = GSL::Vector.alloc(Math.cos(2.0), Math.sin(2.0))

    _test_evolve_system(type, @rhs_func_sin, 0.0, 2.0, h, y, yfin, err, 'sin [0,2]')
  end

  def _test_evolve_exp(type, h, err)
    eee = Math.exp(5.0)

    y = GSL::Vector.alloc(1.0, 1.0)
    yfin = GSL::Vector.alloc(eee, eee)

    _test_evolve_system(type, @rhs_func_exp, 0.0, 5.0, h, y, yfin, err, 'exp [0,5]')
  end

  def _test_evolve_stiff1(type, h, err, arg = 1.0)
    e1 = Math.exp(-arg)
    e2 = Math.exp(-1000.0 * arg)

    y = GSL::Vector.alloc(1.0, 0.0)
    yfin = GSL::Vector.alloc(2.0 * e1 - e2, -e1 + e2)

    _test_evolve_system(type, @rhs_func_stiff, 0.0, arg, h, y, yfin, err, 'stiff [0,%d]' % arg)
  end

  def _test_evolve_stiff5(type, h, err)
    _test_evolve_stiff1(type, h, err, 5.0)
  end

end
require 'test_helper'

class NMatrixEigenTest < GSL::TestCase
  def setup
    @nmatrix = NMatrix.new([4,4],
      [1.0, 1/2.0, 1/3.0, 1/4.0, 
       1/2.0, 1/3.0, 1/4.0, 1/5.0,
       1/3.0, 1/4.0, 1/5.0, 1/6.0,
       1/4.0, 1/5.0, 1/6.0, 1/7.0], dtype: :float64)
  end

  def test_symm_symmv
    eigen_values = NMatrix.new([4], 
      [1.50021, 0.169141, 0.00673827, 9.67023e-05], dtype: :float64)
    eigen_vectors = NMatrix.new([4,4],
      [0.792608, 0.582076,-0.179186,-0.0291933, 
       0.451923,-0.370502, 0.741918, 0.328712 , 
       0.322416,-0.509579,-0.100228,-0.791411 , 
       0.252161,-0.514048,-0.638283, 0.514553], dtype: :float64)
    
    assert_enum_abs GSL::Eigen.symm(@nmatrix), eigen_values, 0.001, "GSL::Eigen.symm(nmatrix)"

    # val, vec = GSL::Eigen.symmv(@nmatrix)

    # assert_enum_abs val, eigen_values , 0.001, "GSL::Eigen.symmv(nmatrix)"
    # assert_enum_abs vec, eigen_vectors, 0.001, "GSL::Eigen.symmv(nmatrix)"
  end
end
require 'test_helper'

class NMatrixInterpTest < GSL::TestCase
  def test_interp_init_eval
    n = 10
    x = NMatrix.new([n], dtype: :float64)
    y = x.clone_structure

    0.upto(n-1) do |i|
      a = i.to_f
      x[i] = i + 0.5*Math::sin(a)
      y[i] = i + Math::cos(a*a)
    end

    interp = GSL::Interp.alloc("akima", n)
    interp.init(x, y)

    yi = []
    xi = x[0]
    r = []
    while xi < x[9]
      r << xi
      xi += 0.01
    end

    yi = interp.eval(x,y,NMatrix.new([r.size], r, dtype: :float64))

    assert_rel yi[1] , 1.0066, 0.001, 'yi[1]'
    assert_rel yi.to_a.last, 9.7618, 0.001, 'yi.last'
  end

  def test_spline_init_eval
    n = 10
    x = NMatrix.new([n], (1..10).to_a, dtype: :float64)
    y = x.dup

    spline = GSL::Spline.alloc(x, y)
    
    xi = NMatrix.new([n], (1..9).map { |a| a += 0.5 }, dtype: :float64)
    yi = spline.eval(xi)

    assert yi.class == NMatrix
    assert_rel yi[0], 1.5, 0.0001, 'yi[0]'
  end
endrequire 'test_helper'

class NMatrixLinalgTest < GSL::TestCase
  def setup
    @nm = NMatrix.new([4,4], 
      [
        0.18, 0.60, 0.57, 0.96, 
        0.41, 0.24, 0.99, 0.58,
        0.14, 0.30, 0.97, 0.66, 
        0.51, 0.13, 0.19, 0.85
      ], dtype: :float64)
    @b = NMatrix.new([4], [1,2,3,4], dtype: :float64)
    @x_exp = NMatrix.new([4], [-4.05205022957397, -12.6056113959069, 1.66091162670884, 8.69376692879523], dtype: :float64)   
  end

  def test_lu
    lu, perm, signum = GSL::Linalg::LU.decomp(@nm)

    lu_exp = NMatrix.new([4,4],
     [0.51,              0.13,              0.19,              0.85,
      0.352941176470588, 0.554117647058823, 0.502941176470588, 0.66,
      0.803921568627451, 0.244515215852796, 0.71427813163482, -0.264713375796178,
      0.274509803921569, 0.476999292285916, 0.949126848480345, 0.363093705877982],
      dtype: :float64)

    assert_enum_abs lu, lu_exp, 0.0001, "GSL::Linalg::LU.decomp(A) with NMatrix"
    assert_enum_abs GSL::Linalg::LU.solve(lu, perm, @b), @x_exp, 0.0001, "GSL::Linalg::LU.solve(lu, perm, b) with NMatrix"

    ##########################################################################

    nm = NMatrix.new([2,2], [1,1,14,1], dtype: :float64)
    lu, perm, sign = GSL::Linalg::LU.decomp(nm)
    inverted  = NMatrix.new([2,2], 
      [
        -0.076923,  0.076923,
         1.076923, -0.076923
      ], dtype: :float64)

    assert_enum_abs GSL::Linalg::LU.invert(lu, perm), inverted, 0.001, "GSL::Linalg::LU.invert(lu, perm) with NMatrix"
    assert GSL::Linalg::LU.det(lu, sign) == -13, "GSL::Linalg::LU.det(lu, sign) with NMatrix"
  end

  def test_qr
    qr_answer = NMatrix.new([4,4], 
      [-0.692965, -0.454136, -1.06961 , -1.35144, 
       0.469664 ,  0.564146,  0.72597 , 0.726696, 
       0.160373 , -0.159838, -0.781606, 0.063932, 
       0.584216 ,  0.593044, -0.332286, 0.239865], dtype: :float64)
    tau_answer = NMatrix.new([4], [1.25975, 1.45217, 1.80113, 0.0], dtype: :float64)
    qr, tau = GSL::Linalg::QR.decomp(@nm)
    
    assert_enum_abs qr_answer , qr , 0.001, "GSL::Linalg::QR.decomp(nmatrix)"
    assert_enum_abs tau_answer, tau, 0.001, "GSL::Linalg::QR.decomp(nmatrix)"

    assert_enum_abs GSL::Linalg::QR.solve(qr, tau, @b), @x_exp, 0.001, 
      "GSL::Linalg::QR.solve(qr, tau, b)"
  end

  def test_sv
    u_answer = NMatrix.new([4,4],
      [-0.545591,-0.312561, 0.709796,-0.317529, 
       -0.5298  , 0.418583,-0.475268,-0.564111, 
       -0.524621, 0.436573, 0.112083, 0.722229, 
       -0.382642,-0.73246 ,-0.507688, 0.243598 ], dtype: :float64)
    v_answer = NMatrix.new([4,4],
      [-0.260024,-0.288729 ,-0.732277,-0.559279 , 
       -0.294582,-0.0751933, 0.659393,-0.687581 , 
       -0.630928, 0.762631 ,-0.12665 , 0.0654517, 
       -0.668983,-0.573912 , 0.113712, 0.458427 ], dtype: :float64)
    s_answer = NMatrix.new([4], [2.24602,0.682566,0.423782,0.112813], dtype: :float64)

    u, v, s = GSL::Linalg::SV.decomp(@nm)

    assert_enum_abs u, u_answer, 0.001, "GSL::Linalg::SV.decomp(nmatrix) -> u"
    assert_enum_abs v, v_answer, 0.001, "GSL::Linalg::SV.decomp(nmatrix) -> v"
    assert_enum_abs s, s_answer, 0.001, "GSL::Linalg::SV.decomp(nmatrix) -> s"

    assert_enum_abs GSL::Linalg::SV.solve(u, v, s, @b), @x_exp, 0.001, 
      "GSL::Linalg::SV.solve(u,v,s,b)"
  end

  def test_cholesky
    m = NMatrix.new([2,2], [4.0, 2, 2, 3], dtype: :float64)
    b = NMatrix.new([2], [1,2], dtype: :float64)

    cholesky = NMatrix.new([2,2], [2.0, 1.0, 1.0, 1.41421], dtype: :float64)
    x_exp = NMatrix.new([2], [-0.125, 0.75], dtype: :float64)

    c = GSL::Linalg::Cholesky
    assert_enum_abs c.decomp(m)         , cholesky, 0.001, "GSL::Linalg::Cholesky.decomp"
    assert_enum_abs c.solve(cholesky, b), x_exp   , 0.001, "GSL::Linalg::Cholesky.solve"
    assert_enum_abs c.svx(cholesky, b)  , x_exp   , 0.001, "GSL::Linalg::Cholesky.svx"
  end

  def test_hh
    hh = GSL::Linalg::HH
    assert_enum_abs hh.solve(@nm, @b), @x_exp, 0.001, "GSL::Linalg::HH.solve(m, b)"
    assert_enum_abs hh.svx(@nm, @b)  , @x_exp, 0.001, "GSL::Linalg::HH.svx(m, b)"
  end
endrequire_relative '../../test_helper'

class NMatrixChebTest < GSL::TestCase
  def test_eval
    f = GSL::Function.alloc do |x|
      if x < 0.5
        0.25
      else
        0.75
      end
    end

    n = 1000
    order = 40
    cs = GSL::Cheb.alloc(order)
    x = NMatrix.new([n], GSL::Vector.linspace(0, 1, n).to_a, dtype: :float64)

    ff = f.eval(x)

    assert ff.class == NMatrix

    cs.init(f, 0, 1)
    r10 = cs.eval_n(10, x)
    r40 = cs.eval(x)

    assert r10.class == NMatrix
    assert_rel r10.to_a.last, 0.758879, 0.001, 'test r10.last'
    assert_rel r10[5]  , 0.247816, 0.001, 'test r10[5]'

    assert r40.class == NMatrix
    assert_rel r40[5]   , 0.255682, 0.001, 'test r40[5]'
    assert_rel r40.first, 0.25633 , 0.001, 'test r40.first'
  end
endrequire 'test_helper'

class NMatrixGslTest < GSL::TestCase
  def setup
    @gsl_vector = GSL::Vector.alloc(2.354, 4.443, 6.776)
    @nm_vector  = NMatrix.new([3], [2.354, 4.443, 6.776], dtype: :float64)

    @gsl_int_vector = GSL::Vector::Int[1,2,3,4,5]
    @nm_int_vector  = NMatrix.new([5], [1,2,3,4,5], dtype: :int32)

    @gsl_complex_vector = GSL::Vector::Complex.alloc([[1,0], [2,0], [3,0]])
    @nm_complex_vector  = NMatrix.new([3], [1,2,3], dtype: :complex128)

    @gsl_matrix = GSL::Matrix.alloc(
      [1,2,3],
      [4,5,6],
      [7,8,9]
    )
    @nm_matrix  = NMatrix.new([3,3], [1,2,3,4,5,6,7,8,9], dtype: :float64)

    @gsl_int_matrix = GSL::Matrix::Int.alloc(
      [1,2,3],
      [4,5,6],
      [7,8,9] 
    )
    @nm_int_matrix = NMatrix.new([3,3], [1,2,3,4,5,6,7,8,9], dtype: :int32)

    @gsl_complex_matrix = GSL::Matrix::Complex.alloc(2,2)
    @gsl_complex_matrix.set(0,0, [1.1,1.1])
    @gsl_complex_matrix.set(0,1, [2.2,2.2])
    @gsl_complex_matrix.set(1,0, [3.3,3.3])
    @gsl_complex_matrix.set(1,1, [4.4,4.4])

    @nm_complex_matrix = NMatrix.new([2,2], 
      [Complex(1.1,1.1), Complex(2.2,2.2), Complex(3.3,3.3), Complex(4.4,4.4)], dtype: :complex128)
  end

  # GSL::Vector to 1D NMatrix
  def test_gsl_vector_to_nmatrix
    assert_equal @nm_vector        , @gsl_vector.to_nm        , 'floating point GSL::Vector to NMatrix'
    assert_equal @nm_int_vector    , @gsl_int_vector.to_nm    , 'integer GSL::Vector to NMatrix'
    assert_equal @nm_complex_vector, @gsl_complex_vector.to_nm, 'complex GSL::Vector to NMatrix'
  end

  # GSL::Matrix to NMatrix
  def test_gsl_matrix_to_nmatrix
    assert_equal @nm_matrix, @gsl_matrix.to_nm, 'floating point GSL::Matrix to 2D NMatrix'
    assert_equal @nm_int_matrix, @gsl_int_matrix.to_nm, 'GSL::Matrix::Int to 2D NMatrix'
    assert_equal @nm_complex_matrix, @gsl_complex_matrix.to_nm, 'GSL::Matrix::Complex to 2D NMatrix'
  end

  # NMatrix to GSL::Vector
  def test_nmatrix_to_gsl_vector
    assert_equal @gsl_vector        , @nm_vector.to_gslv        , 'floating point NMatrix to GSL::Vector'
    assert_equal @gsl_int_vector    , @nm_int_vector.to_gslv    , 'int NMatrix to GSL::Vector::Int'
    assert_equal @gsl_complex_vector, @nm_complex_vector.to_gslv, 'complex NMatrix to GSL::Vector::Complex'
  end

  # NMatrix to GSL::Matrix
  def test_nmatrix_to_gsl_matrix
    assert_equal @gsl_matrix        , @nm_matrix.to_gslm        , 'floating NMatrix to GSL::Matrix'
    assert_equal @gsl_int_matrix    , @nm_int_matrix.to_gslm    , 'int NMatrix to GSL::Matrix::Int'
    assert_equal @gsl_complex_matrix, @nm_complex_matrix.to_gslm, 'complex NMatrix to GSL::Matrix::Complex'
  end
endrequire 'test_helper'

class NMatrixStatsTest < GSL::TestCase
  def setup
    @lew = NMatrix.new([200],
      [-213, -564,  -35,  -15,  141,  115, -420, -360,  203, -338, -431,  194,
      -220, -513,  154, -125, -559,   92,  -21, -579,  -52,   99, -543, -175,
       162, -457, -346,  204, -300, -474,  164, -107, -572,   -8,   83, -541,
      -224,  180, -420, -374,  201, -236, -531,   83,   27, -564, -112,  131,
      -507, -254,  199, -311, -495,  143,  -46, -579,  -90,  136, -472, -338,
       202, -287, -477,  169, -124, -568,   17,   48, -568, -135,  162, -430,
      -422,  172,  -74, -577,  -13,   92, -534, -243,  194, -355, -465,  156,
       -81, -578,  -64,  139, -449, -384,  193, -198, -538,  110,  -44, -577,
        -6,   66, -552, -164,  161, -460, -344,  205, -281, -504,  134,  -28,
      -576, -118,  156, -437, -381,  200, -220, -540,   83,   11, -568, -160,
       172, -414, -408,  188, -125, -572,  -32,  139, -492, -321,  205, -262,
      -504,  142,  -83, -574,    0,   48, -571, -106,  137, -501, -266,  190,
      -391, -406,  194, -186, -553,   83,  -13, -577,  -49,  103, -515, -280,
       201,  300, -506,  131,  -45, -578,  -80,  138, -462, -361,  201, -211,
      -554,   32,   74, -533, -235,  187, -372, -442,  182, -147, -566,   25,
        68, -535, -244,  194, -351, -463,  174, -125, -570,   15,   72, -550,
      -190,  172, -424, -385,  198, -218, -536,   96], dtype: :float64
    )

    @rawa = NMatrix.new([14],
      [0.0421, 0.0941, 0.1064, 0.0242, 0.1331,
      0.0773, 0.0243, 0.0815, 0.1186, 0.0356,
      0.0728, 0.0999, 0.0614, 0.0479], dtype: :float64
    )

    @rawb = NMatrix.new([14],
      [0.1081, 0.0986, 0.1566, 0.1961, 0.1125,
      0.1942, 0.1079, 0.1021, 0.1583, 0.1673,
      0.1675, 0.1856, 0.1688, 0.1512], dtype: :float64
    )

    @raww = NMatrix.new([14],
      [0.0000, 0.0000, 0.0000, 3.000, 0.0000,
      1.0000, 1.0000, 1.0000, 0.000, 0.5000,
      7.0000, 5.0000, 4.0000, 0.123], dtype: :float64
    )
  end

  def test_stats
    assert_rel GSL::Stats.mean(@lew), -177.435000000000,    1e-15, 'lew gsl_stats_mean'
    assert_rel GSL::Stats.sd(@lew),    277.332168044316,    1e-15, 'lew gsl_stats_sd'
    assert_rel GSL::Stats.lag1_autocorrelation(@lew), -0.307304800605679, 1e-14, 'lew autocorrelation'

    rel = 1e-10
    rawa_mean = GSL::Stats.mean(@rawa)

    assert_rel GSL::Stats.variance_with_fixed_mean(@rawa, rawa_mean), 0.00113837428571429,
      rel, 'gsl_stats_variance_with_fixed_mean'

    assert_rel GSL::Stats.sd_with_fixed_mean(@rawa, rawa_mean), 0.0337398026922845,
      rel, 'gsl_stats_sd_with_fixed_mean'

    assert_rel GSL::Stats.variance(@rawb),         0.00124956615384615,  rel, 'gsl_stats_variance'
    assert_rel GSL::Stats.sd(@rawa),               0.0350134479659107,   rel, 'gsl_stats_sd'
    assert_rel GSL::Stats.absdev(@rawa),           0.0287571428571429,   rel, 'gsl_stats_absdev'
    assert_rel GSL::Stats.skew(@rawa),             0.0954642051479004,   rel, 'gsl_stats_skew'
    assert_rel GSL::Stats.kurtosis(@rawa),        -1.38583851548909,     rel, 'gsl_stats_kurtosis'
    assert_rel GSL::Stats.covariance(@rawa,@rawb),-0.000139021538461539, rel, 'gsl_stats_covariance'

    if GSL::GSL_VERSION >= '1.9.90'
      assert_rel GSL::Stats.correlation(@rawa, @rawb), -0.112322712666074171, rel, 'gsl_stats_correlation'
      assert_rel GSL::Stats.pvariance(@rawa, @rawb),    0.00123775384615385,  rel, 'gsl_stats_pvariance'
      assert_rel GSL::Stats.ttest(@rawa, @rawb),       -5.67026326985851,     rel, 'gsl_stats_ttest'
    end

    assert_rel GSL::Stats.max(@rawa), 0.1331, rel, 'gsl_stats_max'
    assert_rel GSL::Stats.min(@rawa), 0.0242, rel, 'gsl_stats_min'

    assert GSL::Stats.max_index(@rawa) == 4, 'gsl_stats_max'
    assert GSL::Stats.min_index(@rawa) == 3, 'gsl_stats_min'

    rawa_sorted = NMatrix.new([@rawa.size], @rawa.sort, dtype: :float64)

    sorted = NMatrix.new([@rawa.size], @rawa.to_a.sort, dtype: :float64)
    assert_rel GSL::Stats.median_from_sorted_data(sorted), 0.07505,
      rel, 'gsl_stats_median_from_sorted_data'

    assert_rel GSL::Stats.median_from_sorted_data(sorted[0..(sorted.size - 2)]), 0.0728,
      rel, 'gsl_stats_median_from_sorted_data'

    #TODO: Expose quantile_from_sorted_data
  end
endrequire 'test_helper.rb'

class NMatrixWaveletTest < GSL::TestCase
# TODO
end