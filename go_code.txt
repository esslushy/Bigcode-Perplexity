package main

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"flag"
	"fmt"
	"html/template"
	"net/http"
	"os"
	"strconv"

	//"encoding/json"
	hd "github.com/Ulbora/GoAuth2/handlers"
	m "github.com/Ulbora/GoAuth2/managers"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
	"github.com/gorilla/mux"
)

//GO111MODULE=on go mod init github.com/Ulbora/GoAuth2
func main() {

	mock := flag.Bool("mock", false, "use mock backend")
	compressJwt := flag.Bool("compressJwt", false, "compress Jwt access token")
	assets := flag.String("assets", "", "Assets to control")
	flag.Parse()
	var logger lg.Logger
	logger.LogLevel = lg.InfoLevel
	logger.Info("mock: ", *mock)
	logger.Info("assets: ", *assets)
	logger.Info("compressJwt: ", *compressJwt)
	// logger.LogLevel = lg.OffLevel
	var dbi db.Database
	var mydb mdb.MyDB
	var goauth2Host string
	var goauth2User string
	var goauth2Password string
	var goauth2Database string
	var authURL string
	var tokenParams m.TokenParams

	if os.Getenv("GOAUTH2_HOST") != "" {
		goauth2Host = os.Getenv("GOAUTH2_HOST")
	} else {
		goauth2Host = "localhost:3306"
	}

	if os.Getenv("GOAUTH2_USER") != "" {
		goauth2User = os.Getenv("GOAUTH2_USER")
	} else {
		goauth2User = "admin"
	}

	if os.Getenv("GOAUTH2_PASSWORD") != "" {
		goauth2Password = os.Getenv("GOAUTH2_PASSWORD")
	} else {
		goauth2Password = "admin"
	}

	if os.Getenv("GOAUTH2_DATABASE") != "" {
		goauth2Database = os.Getenv("GOAUTH2_DATABASE")
	} else {
		goauth2Database = "go_auth2"
	}

	if os.Getenv("AUTHENTICATION_SERVICE") != "" {
		authURL = os.Getenv("AUTHENTICATION_SERVICE")
	} else {
		authURL = "http://localhost:3001/rs/user/login"
	}

	if os.Getenv("ACCESS_TOKEN_KEY") != "" {
		tokenParams.AccessTokenKey = os.Getenv("ACCESS_TOKEN_KEY")
	}
	if os.Getenv("REFRESH_TOKEN_KEY") != "" {
		tokenParams.RefreshTokenKey = os.Getenv("REFRESH_TOKEN_KEY")
	}
	if os.Getenv("TOKEN_ISSUER") != "" {
		tokenParams.Issuer = os.Getenv("TOKEN_ISSUER")
	}
	if os.Getenv("TOKEN_AUDIENCE") != "" {
		tokenParams.Audience = os.Getenv("TOKEN_AUDIENCE")
	}
	logger.Info("tokenParams: ", tokenParams)
	logger.LogLevel = lg.OffLevel

	mydb.Host = goauth2Host
	mydb.User = goauth2User
	mydb.Password = goauth2Password
	mydb.Database = goauth2Database
	dbi = &mydb
	dbi.Connect()

	var wh hd.WebHandler
	var rh hd.RestHandler
	var owh *hd.OauthWebHandler

	if *mock {
		owh = hd.UseMockWeb()
		wh = owh.GetNewWebHandler()
		orh := hd.UseMockRest()
		rh = orh.GetNewRestHandler()
	} else {
		owh = hd.UseWebHandler(dbi, *compressJwt, authURL, &logger, &tokenParams)
		wh = owh.GetNewWebHandler()
		orh := hd.UseRestHandler(dbi, *assets, *compressJwt, authURL, &logger, &tokenParams)
		rh = orh.GetNewRestHandler()
	}

	owh.Templates = template.Must(template.ParseFiles("./static/head.html", "./static/index.html",
		"./static/login.html", "./static/authorizeApp.html", "./static/oauthError.html"))

	router := mux.NewRouter()
	port := "3000"
	envPort := os.Getenv("PORT")
	if envPort != "" {
		portInt, _ := strconv.Atoi(envPort)
		if portInt != 0 {
			port = envPort
		}
	}

	//web routes-------------------------------------
	router.HandleFunc("/", owh.Index).Methods("GET")
	router.HandleFunc("/login", wh.Login).Methods("GET")
	router.HandleFunc("/login", wh.LoginUser).Methods("POST")
	router.HandleFunc("/oauth/authorize", wh.Authorize).Methods("GET")
	router.HandleFunc("/authorizeApp", wh.AuthorizeApp).Methods("GET")
	router.HandleFunc("/applicationAuthorize", wh.ApplicationAuthorizationByUser).Methods("GET")
	router.HandleFunc("/oauth/token", wh.Token).Methods("POST")
	router.HandleFunc("/oauthError", wh.OauthError).Methods("GET")

	//REST routes--------------------------------------
	//Client
	router.HandleFunc("/rs/client/add", rh.AddClient).Methods("POST")
	router.HandleFunc("/rs/client/update", rh.UpdateClient).Methods("PUT")
	router.HandleFunc("/rs/client/get/{id}", rh.GetClient).Methods("GET")
	router.HandleFunc("/rs/client/admin/get", rh.GetClientAdmin).Methods("GET")
	router.HandleFunc("/rs/client/list", rh.GetClientList).Methods("GET")
	router.HandleFunc("/rs/client/search", rh.GetClientSearchList).Methods("POST")
	router.HandleFunc("/rs/client/delete/{id}", rh.DeleteClient).Methods("DELETE")

	//clientGrantType
	router.HandleFunc("/rs/clientGrantType/add", rh.AddGrantType).Methods("POST")
	router.HandleFunc("/rs/clientGrantType/list/{clientId}", rh.GetGrantTypeList).Methods("GET")
	router.HandleFunc("/rs/clientGrantType/delete/{id}", rh.DeleteGrantType).Methods("DELETE")

	//clientAllowedUri
	router.HandleFunc("/rs/clientAllowedUriSuper/add", rh.AddAllowedURISuper).Methods("POST")
	router.HandleFunc("/rs/clientAllowedUri/add", rh.AddAllowedURI).Methods("POST")
	router.HandleFunc("/rs/clientAllowedUriSuper/update", rh.UpdateAllowedURISuper).Methods("PUT")
	router.HandleFunc("/rs/clientAllowedUri/update", rh.UpdateAllowedURI).Methods("PUT")
	router.HandleFunc("/rs/clientAllowedUri/get/{id}", rh.GetAllowedURI).Methods("GET")
	router.HandleFunc("/rs/clientAllowedUri/list/{clientId}", rh.GetAllowedURIList).Methods("GET")
	router.HandleFunc("/rs/clientAllowedUri/delete/{id}", rh.DeleteAllowedURI).Methods("DELETE")

	//clientRedirectUri
	router.HandleFunc("/rs/clientRedirectUri/add", rh.AddRedirectURI).Methods("POST")
	router.HandleFunc("/rs/clientRedirectUri/list/{clientId}", rh.GetRedirectURIList).Methods("GET")
	router.HandleFunc("/rs/clientRedirectUri/delete/{id}", rh.DeleteRedirectURI).Methods("DELETE")

	//clientRole
	router.HandleFunc("/rs/clientRole/add", rh.AddRole).Methods("POST")
	router.HandleFunc("/rs/clientRoleSuper/add", rh.AddRoleSuper).Methods("POST")
	router.HandleFunc("/rs/clientRole/list/{clientId}", rh.GetRoleList).Methods("GET")
	router.HandleFunc("/rs/clientRole/delete/{id}", rh.DeleteRole).Methods("DELETE")

	//clientRoleUri
	router.HandleFunc("/rs/clientRoleUri/add", rh.AddRoleURI).Methods("POST")
	router.HandleFunc("/rs/clientRoleUri/list/{clientRoleId}", rh.GetRoleURIList).Methods("GET")
	//---- added post delete for backwards compatibility
	router.HandleFunc("/rs/clientRoleUri/delete", rh.DeleteRoleURI).Methods("POST")
	router.HandleFunc("/rs/clientRoleUri/delete/{clientRoleId}/{clientAllowedUriId}", rh.DeleteRoleURI).Methods("DELETE")

	//validate token
	router.HandleFunc("/rs/token/validate", rh.ValidateAccessToken).Methods("POST")

	router.HandleFunc("/rs/loglevel", rh.SetLogLevel).Methods("POST")

	router.PathPrefix("/").Handler(http.FileServer(http.Dir("./static/")))

	fmt.Println("Starting server Oauth2 Server on " + port)
	http.ListenAndServe(":"+port, router)

}

// [
//    {
//       "url":"/ulbora/rs/clientAllowedUri/add",
//       "assets":[
//          {
//             "controlledAsset":"ulbora",
//             "allowedRole":"superAdmin"
//          }
//       ]
//    },
//    {
//       "url":"/ulbora/rs/clientAllowedUri/update",
//       "assets":[
//          {
//             "controlledAsset":"ulbora",
//             "allowedRole":"superAdmin"
//          }
//       ]
//    },
//    {
//       "url":"/ulbora/rs/clientRole/add",
//       "assets":[
//          {
//             "controlledAsset":"superAdmin",
//             "allowedRole":"superAdmin"
//          }
//       ]
//    }
// ]

// WwogICB7CiAgICAgICJ1cmwiOiIvdWxib3JhL3JzL2NsaWVudEFsbG93ZWRVcmkvYWRkIiwKICAgICAgImFzc2V0cyI6WwogICAgICAgICB7CiAgICAgICAgICAgICJjb250cm9sbGVkQXNzZXQiOiJ1bGJvcmEiLAogICAgICAgICAgICAiYWxsb3dlZFJvbGUiOiJzdXBlckFkbWluIgogICAgICAgICB9CiAgICAgIF0KICAgfSwKICAgewogICAgICAidXJsIjoiL3VsYm9yYS9ycy9jbGllbnRBbGxvd2VkVXJpL3VwZGF0ZSIsCiAgICAgICJhc3NldHMiOlsKICAgICAgICAgewogICAgICAgICAgICAiY29udHJvbGxlZEFzc2V0IjoidWxib3JhIiwKICAgICAgICAgICAgImFsbG93ZWRSb2xlIjoic3VwZXJBZG1pbiIKICAgICAgICAgfQogICAgICBdCiAgIH0sCiAgIHsKICAgICAgInVybCI6Ii91bGJvcmEvcnMvY2xpZW50Um9sZS9hZGQiLAogICAgICAiYXNzZXRzIjpbCiAgICAgICAgIHsKICAgICAgICAgICAgImNvbnRyb2xsZWRBc3NldCI6InN1cGVyQWRtaW4iLAogICAgICAgICAgICAiYWxsb3dlZFJvbGUiOiJzdXBlckFkbWluIgogICAgICAgICB9CiAgICAgIF0KICAgfQpd
//Package rolecontrol ...
package rolecontrol

import (
	"fmt"
	"testing"
)

func TestMockOauthAssets_AddControledURLs(t *testing.T) {
	var cass ControlledAsset
	cass.ControlledAsset = "test"
	cass.AllowedRole = "admin"

	var cass2 ControlledAsset
	cass2.ControlledAsset = "test2"
	cass2.AllowedRole = "superAdmin"

	var caList = []ControlledAsset{cass, cass2}
	var cu ControlledURL
	cu.URL = "/test"
	cu.Asset = caList

	var cus = []ControlledURL{cu}

	var oa MockOauthAssets

	ac := oa.GetNewAssetControl()
	suc := ac.AddControledURLs(&cus)
	if !suc {
		t.Fail()
	}
}

func TestMockOauthAssets_GetControlledAsset(t *testing.T) {
	var oa MockOauthAssets
	oa.MockSuccess = true
	oa.MockAllowedRole = "admin"
	ac := oa.GetNewAssetControl()
	suc, role := ac.GetControlledAsset("/test", "test")
	fmt.Println("role: ", role)
	if !suc || role != "admin" {
		t.Fail()
	}
}

func TestMockOauthAssets_GetControlledAsset2(t *testing.T) {
	var oa MockOauthAssets
	oa.MockSuccess = true
	oa.MockAllowedRole = "superAdmin"
	ac := oa.GetNewAssetControl()
	suc, role := ac.GetControlledAsset("/test", "test2")
	fmt.Println("role: ", role)
	if !suc || role != "superAdmin" {
		t.Fail()
	}
}

func TestMockOauthAssets_GetControlledAsset3(t *testing.T) {
	var oa MockOauthAssets
	oa.MockSuccess = false
	//oa.MockAllowedRole = "superAdmin"
	ac := oa.GetNewAssetControl()
	suc, role := ac.GetControlledAsset("/test1", "test2")
	fmt.Println("role: ", role)
	if suc {
		t.Fail()
	}
}

func TestMockOauthAssets_GetControlledAsset4(t *testing.T) {
	var oa MockOauthAssets
	oa.MockSuccess = false
	//oa.MockAllowedRole = "superAdmin"
	ac := oa.GetNewAssetControl()
	suc, role := ac.GetControlledAsset("/test", "test22")
	fmt.Println("role: ", role)
	if suc {
		t.Fail()
	}
}
//Package rolecontrol ...
package rolecontrol

import (
	"fmt"
	"testing"
)

var ac AssetControl

func TestOauthAssets_AddControledURLs(t *testing.T) {
	var cass ControlledAsset
	cass.ControlledAsset = "test"
	cass.AllowedRole = "admin"

	var cass2 ControlledAsset
	cass2.ControlledAsset = "test2"
	cass2.AllowedRole = "superAdmin"

	var caList = []ControlledAsset{cass, cass2}
	var cu ControlledURL
	cu.URL = "/test"
	cu.Asset = caList

	var cus = []ControlledURL{cu}

	var oa OauthAssets
	ac = oa.GetNewAssetControl()
	suc := ac.AddControledURLs(&cus)
	if !suc {
		t.Fail()
	}
}

func TestOauthAssets_GetControlledAsset(t *testing.T) {
	suc, role := ac.GetControlledAsset("/test", "test")
	fmt.Println("role: ", role)
	if !suc || role != "admin" {
		t.Fail()
	}
}

func TestOauthAssets_GetControlledAsset2(t *testing.T) {
	suc, role := ac.GetControlledAsset("/test", "test2")
	fmt.Println("role: ", role)
	if !suc || role != "superAdmin" {
		t.Fail()
	}
}

func TestOauthAssets_GetControlledAsset3(t *testing.T) {
	suc, role := ac.GetControlledAsset("/test1", "test2")
	fmt.Println("role: ", role)
	if suc {
		t.Fail()
	}
}

func TestOauthAssets_GetControlledAsset4(t *testing.T) {
	suc, role := ac.GetControlledAsset("/test", "test22")
	fmt.Println("role: ", role)
	if suc {
		t.Fail()
	}
}
//Package rolecontrol ...
package rolecontrol

import "fmt"

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//ControlledAsset ControlledAsset
type ControlledAsset struct {
	ControlledAsset string `json:"controlledAsset"`
	AllowedRole     string `json:"allowedRole"`
}

//ControlledURL ControlledURL
type ControlledURL struct {
	URL   string            `json:"url"`
	Asset []ControlledAsset `json:"assets"`
}

//AssetControl AssetControl
type AssetControl interface {
	AddControledURLs(urls *[]ControlledURL) bool
	GetControlledAsset(url string, ca string) (bool, string)
}

//OauthAssets OauthAssets
type OauthAssets struct {
	m map[string]*[]ControlledAsset
}

//AddControledURLs AddControledURLs
func (c *OauthAssets) AddControledURLs(urls *[]ControlledURL) bool {
	var rtn bool
	//creates a map by url of prohibited sections to be used in a particular url
	c.m = make(map[string]*[]ControlledAsset)
	//for example
	//url https://addTest/admin/user
	//could require role superUser
	for i := range *urls {
		var u = (*urls)[i]
		c.m[u.URL] = &u.Asset
	}
	if len(c.m) > 0 {
		rtn = true
	}
	fmt.Println("assess: ", c.m)
	fmt.Println("assess list: ", c.m["/ulbora/rs/clientAllowedUri/add"])

	return rtn
}

//GetControlledAsset GetControlledAsset
func (c *OauthAssets) GetControlledAsset(url string, ca string) (bool, string) {
	var suc bool
	var rtn string
	cas := c.m[url]
	if cas != nil {
		fmt.Println("cas: ", cas)
		for _, a := range *cas {
			//example
			//url https://addTest/admin/user
			//with controlled asset "admin"
			//could require role superUser
			if a.ControlledAsset == ca {
				suc = true
				rtn = a.AllowedRole
				break
			}
		}
	}
	return suc, rtn
}

//GetNewAssetControl GetNewAssetControl
func (c *OauthAssets) GetNewAssetControl() AssetControl {
	var ac AssetControl
	ac = c
	return ac
}
//Package rolecontrol ...
package rolecontrol

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//MockOauthAssets MockOauthAssets
type MockOauthAssets struct {
	MockSuccess     bool
	MockAllowedRole string
}

//AddControledURLs AddControledURLs
func (c *MockOauthAssets) AddControledURLs(urls *[]ControlledURL) bool {
	return true
}

//GetControlledAsset GetControlledAsset
func (c *MockOauthAssets) GetControlledAsset(url string, ca string) (bool, string) {
	return c.MockSuccess, c.MockAllowedRole
}

//GetNewAssetControl GetNewAssetControl
func (c *MockOauthAssets) GetNewAssetControl() AssetControl {
	var ac AssetControl
	ac = c
	return ac
}
//Package compresstoken ...
package compresstoken

import (
	"fmt"
	"testing"
)

var jwt = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJQYXlsb2FkIjp7ImlzcyI6IkdvQXV0aDIiLCJzdWIiOiJpbXBsaWNpdCIsImF1ZCI6IkdvQXV0aDIuY29tIiwiZXhwIjoxNTc3NDE3NzcxLCJpYXQiOjE1NzczODE3NzF9LCJ0b2tlblR5cGUiOiJhY2Nlc3MiLCJ1c2VySWQiOiJvaXIiLCJjbGllbnRJZCI6NDAzLCJncmFudCI6ImltcGxpY2l0Iiwicm9sZVVSSXMiOlt7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozNjAsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3Um91dGVVcmwvbGlzdCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI2MCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvb3JkZXIvYWRkIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjM4LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9vcHRpb25zL3VwZGF0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM4MCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50L3VzZXIvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6ODUsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudEdyYW50VHlwZS9kZWxldGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo3NSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50Um9sZS9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzQ4LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd1Jlc3RSb3V0ZS9nZXQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozMzAsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NvbnRlbnQvaGl0cyIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI3MCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvb3JkZXIvcGFja2FnZS91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozNjEsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3Um91dGVVcmwvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjYxLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9vcmRlci91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNDIsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL29wdGlvbnMvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjcyLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9vcmRlci9wYWNrYWdlL2RlbGV0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjIwMCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvcm9sZS9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6NzYsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudFJvbGUvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzQ5LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd1Jlc3RSb3V0ZS9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzMxLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9tYWlsU2VydmVyL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjIzMSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY3VzdG9tZXIvbGlzdCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM2MiwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvZ3dSb3V0ZVVybC9hY3RpdmF0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI2NSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvb3JkZXIvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjQzLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9kZXRhaWxzL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI3MywiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvaW1hZ2UvYWRkIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjAxLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9tYWlsL3NlbmQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo3NywiQ2xpZW50QWxsb3dlZFVSSSI6Imh0dHA6Ly9sb2NhbGhvc3QvcnMvYWRkQ2xpZW50U2NvcGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozNTAsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3UmVzdFJvdXRlL2RlbGV0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjMzMiwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvbWFpbFNlcnZlci91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyMzIsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2N1c3RvbWVyL2RlbGV0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM2NCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50QWxsb3dlZFVyaS9nZXQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNjYsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL29yZGVyL2l0ZW0vYWRkIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjQ0LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9kZXRhaWxzL3VwZGF0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjY3LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9jbGllbnRBbGxvd2VkVXJpL2xpc3QiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozMzMsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL21haWxTZXJ2ZXIvZ2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6Mjc0LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9pbWFnZS91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyMjMsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2FkZHJlc3MvYWRkIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6ODAsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudFJvbGVVcmkvYWRkIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzU3LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd1JvdXRlVXJsL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjIzMywiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvcHJvZHVjdC9hZGQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozNzYsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudC91c2VyL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI2NywiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvb3JkZXIvaXRlbS91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNDksIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2RldGFpbHMvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6NjgsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudEFsbG93ZWRVcmkvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzM0LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy90ZW1wbGF0ZS9hZGQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNzgsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2ltYWdlL2RlbGV0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjIyNCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvYWRkcmVzcy91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo4MSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50Um9sZVVyaS9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzU4LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd1JvdXRlVXJsL3VwZGF0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI1NSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvYmFyQ29kZS9hZGQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyMzQsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL3Byb2R1Y3QvdXBkYXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6Mzc3LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9jbGllbnQvdXNlci91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNjgsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL29yZGVyL2l0ZW0vZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6NjksIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudFJlZGlyZWN0VXJpL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjMzNSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvdGVtcGxhdGUvdXBkYXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6Mjc5LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9jb250ZW50L2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjIyNywiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvYWRkcmVzcy9kZWxldGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo4MiwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50Um9sZVVyaS9kZWxldGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNTYsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2JhckNvZGUvdXBkYXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjM2LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9wcm9kdWN0L2RlbGV0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM3OCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50L3VzZXIvZ2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjY5LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9vcmRlci9wYWNrYWdlL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjgzLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9jbGllbnRHcmFudFR5cGUvYWRkIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6NzAsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudFJlZGlyZWN0VXJpL2xpc3QiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozNDYsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3UmVzdFJvdXRlL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI4MCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY29udGVudC91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyMjgsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2N1c3RvbWVyL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI1OSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvYmFyQ29kZS9kZWxldGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyMzcsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL29wdGlvbnMvYWRkIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6Mzc5LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9jbGllbnQvdXNlci9zZWFyY2giLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MSwiUm9sZSI6ImFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozNTksIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3Um91dGVVcmwvZ2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6ODQsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudEdyYW50VHlwZS9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6NzEsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudFJlZGlyZWN0VXJpL2RlbGV0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM0NywiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvZ3dSZXN0Um91dGUvdXBkYXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjEsIlJvbGUiOiJhZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjgzLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9jb250ZW50L2RlbGV0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoxLCJSb2xlIjoiYWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjIyOSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY3VzdG9tZXIvdXBkYXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNDEsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL29wdGlvbnMvc2VhcmNoQnlPcHRpb24iLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MiwiUm9sZSI6InVzZXIiLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI4MiwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY29udGVudC9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNjIsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL29yZGVyL2dldCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyLCJSb2xlIjoidXNlciIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjQ1LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9kZXRhaWxzL2dldCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyLCJSb2xlIjoidXNlciIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjI1LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9hZGRyZXNzL2dldCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyLCJSb2xlIjoidXNlciIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjYzLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9vcmRlci9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyMjYsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2FkZHJlc3MvbGlzdCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyLCJSb2xlIjoidXNlciIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjQ2LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9kZXRhaWxzL2dldEJ5UHJvZHVjdCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyLCJSb2xlIjoidXNlciIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjY0LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9vcmRlci9jdXN0b21lci9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyMzAsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2N1c3RvbWVyL2dldCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyLCJSb2xlIjoidXNlciIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjQ3LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9kZXRhaWxzL2dldEJ5U2t1IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNzEsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL29yZGVyL3BhY2thZ2UvZ2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyMzEsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2N1c3RvbWVyL2xpc3QiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MiwiUm9sZSI6InVzZXIiLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI3NSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvaW1hZ2UvZGV0YWlscyIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyLCJSb2xlIjoidXNlciIsIkNsaWVudEFsbG93ZWRVUklJRCI6MjM1LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9wcm9kdWN0L2dldCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyLCJSb2xlIjoidXNlciIsIkNsaWVudEFsbG93ZWRVUklJRCI6Mjc2LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9pbWFnZS9wYWdlL2NvdW50IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNDgsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2RldGFpbHMvZ2V0QnlCYXJDb2RlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyMzksIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL29wdGlvbnMvZ2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNTcsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2JhckNvZGUvZ2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjIsIlJvbGUiOiJ1c2VyIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoyNzcsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2ltYWdlL2xpc3QiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MiwiUm9sZSI6InVzZXIiLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI0MCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvb3B0aW9ucy9nZXRCeURldGFpbHMiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MiwiUm9sZSI6InVzZXIiLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI1OCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvYmFyQ29kZS9nZXRCeURldGFpbHMiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MiwiUm9sZSI6InVzZXIiLCJDbGllbnRBbGxvd2VkVVJJSUQiOjI4MSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY29udGVudC9nZXQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozNTIsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3Um91dGVVcmxTdXBlci91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozMzksIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3Q2xpZW50L2xpc3QiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoxOTQsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL3VzZXIvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6Mzc1LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy91c2VyL3NlYXJjaCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjE2OCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvdXNlci9hZGQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo0MDEsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3QnJlYWtlclN1cGVyL3N0YXR1cyIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjE5NSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvdXNlci9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzUzLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd1JvdXRlVXJsU3VwZXIvZ2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzQwLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd0NsaWVudC9kZWxldGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo2MiwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50L2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM5NCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvZ3dQZXJmb3JtYW5jZVN1cGVyIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MTkyLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy91c2VyL3VwZGF0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjE5NiwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvcm9sZS9hZGQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozNTQsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3Um91dGVVcmxTdXBlci9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzQxLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd1Jlc3RSb3V0ZVN1cGVyL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjYzLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9jbGllbnQvdXBkYXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6Mzk1LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd0Vycm9yc1N1cGVyIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MTk4LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9yb2xlL2dldCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM1NSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvZ3dSb3V0ZVVybFN1cGVyL2RlbGV0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM0MiwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvZ3dSZXN0Um91dGVTdXBlci91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo2NCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50L2dldCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM5NiwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvZ3dCcmVha2VyU3VwZXIvYWRkIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzQzLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd1Jlc3RSb3V0ZVN1cGVyL2dldCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjE5OSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvcm9sZS9kZWxldGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo2NSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50L2xpc3QiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozOTcsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3QnJlYWtlclN1cGVyL3VwZGF0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM0NCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvZ3dSZXN0Um91dGVTdXBlci9saXN0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzM2LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd0NsaWVudC9hZGQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo2NiwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50QWxsb3dlZFVyaVN1cGVyL2FkZCIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM5OCwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvZ3dCcmVha2VyU3VwZXIvZ2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzU2LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd1JvdXRlVXJsU3VwZXIvYWN0aXZhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjozNDUsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3UmVzdFJvdXRlU3VwZXIvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzM3LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd0NsaWVudC91cGRhdGUiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo3MywiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvY2xpZW50L2RlbGV0ZSIsIkNsaWVudElEIjo0MDN9LHsiQ2xpZW50Um9sZUlEIjoyNSwiUm9sZSI6InN1cGVyQWRtaW4iLCJDbGllbnRBbGxvd2VkVVJJSUQiOjM5OSwiQ2xpZW50QWxsb3dlZFVSSSI6Ii91bGJvcmEvcnMvZ3dCcmVha2VyU3VwZXIvZGVsZXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzYzLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9jbGllbnRBbGxvd2VkVXJpU3VwZXIvdXBkYXRlIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzUxLCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd1JvdXRlVXJsU3VwZXIvYWRkIiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6MzM4LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9nd0NsaWVudC9nZXQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjoxOTMsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL3VzZXIvZ2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6NzQsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2NsaWVudFJvbGVTdXBlci9hZGQiLCJDbGllbnRJRCI6NDAzfSx7IkNsaWVudFJvbGVJRCI6MjUsIlJvbGUiOiJzdXBlckFkbWluIiwiQ2xpZW50QWxsb3dlZFVSSUlEIjo0MDAsIkNsaWVudEFsbG93ZWRVUkkiOiIvdWxib3JhL3JzL2d3QnJlYWtlclN1cGVyL3Jlc2V0IiwiQ2xpZW50SUQiOjQwM30seyJDbGllbnRSb2xlSUQiOjI1LCJSb2xlIjoic3VwZXJBZG1pbiIsIkNsaWVudEFsbG93ZWRVUklJRCI6Mzc0LCJDbGllbnRBbGxvd2VkVVJJIjoiL3VsYm9yYS9ycy9jbGllbnQvc2VhcmNoIiwiQ2xpZW50SUQiOjQwM31dLCJzY29wZUxpc3QiOlsid3JpdGUiLCJyZWFkIl19.1G6eeoHPMAb_WEMBeQymk85op9tcdBqRCYuf5HxpwwQ"
var cjwt string

func TestCompressJwt(t *testing.T) {
	var c JwtCompress
	cjwt = c.CompressJwt(jwt)
	fmt.Println("len of jwt", len(jwt))
	fmt.Println("len of cjwt", len(cjwt))

	fmt.Println("cjwt", cjwt)
	if cjwt == "" {
		t.Fail()
	}
}

func TestUnCompressJwt(t *testing.T) {
	var c JwtCompress
	var ucjwt = c.UnCompressJwt(cjwt)
	fmt.Println("ucjwt", ucjwt)
	if ucjwt != jwt {
		t.Fail()
	}
}
//Package compresstoken ...
package compresstoken

import (
	"bytes"
	"compress/flate"
	"compress/zlib"
	"encoding/base64"
	"io"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//JwtCompress JwtCompress
type JwtCompress struct {
}

//CompressJwt CompressJwt
func (c *JwtCompress) CompressJwt(jwt string) string {
	//compress jwt with zlib and package with base64
	var rtn string
	var b bytes.Buffer
	w, err := zlib.NewWriterLevel(&b, flate.BestCompression)
	if err == nil {
		w.Write([]byte(jwt))
		w.Close()
		rtn = base64.StdEncoding.EncodeToString(b.Bytes())
	}
	return rtn
}

//UnCompressJwt UnCompressJwt
func (c *JwtCompress) UnCompressJwt(cjwt string) string {
	//uncompress jwt with zlib after converting from base64
	var rtn string
	var b bytes.Buffer
	decoded, derr := base64.StdEncoding.DecodeString(cjwt)
	if derr == nil {
		b.Write(decoded)
		r, err := zlib.NewReader(&b)
		if err == nil {
			var out bytes.Buffer
			io.Copy(&out, r)
			r.Close()
			rtn = out.String()
		}
	}
	return rtn
}
package managers

import (
	"fmt"
	"testing"
	//"time"
)

var tkn string

var tknExp string

func TestOauthManagerJwt_GenerateJwtToken(t *testing.T) {

	var man OauthManager
	var pl Payload
	pl.TokenType = "test"
	pl.UserID = "tester1"
	pl.ClientID = 234
	pl.Subject = "code"
	pl.Issuer = "GoAuth2"
	pl.Audience = "GoAuth2.com"
	pl.ExpiresInMinute = 600 //(600 * time.Minute) => (600 * 60) => 36000 minutes => 10 hours
	pl.Grant = "code"
	pl.SecretKey = "secret"
	var ruList []RoleURI
	var ru1 RoleURI
	ru1.ClientRoleID = 1
	ru1.Role = "user"
	ru1.ClientAllowedURIID = 2
	ru1.ClientAllowedURI = "test.com"
	ru1.ClientID = 5
	ruList = append(ruList, ru1)

	var ru2 RoleURI
	ru2.ClientRoleID = 12
	ru2.Role = "user"
	ru2.ClientAllowedURIID = 21
	ru2.ClientAllowedURI = "test2.com"
	ru2.ClientID = 5
	ruList = append(ruList, ru2)

	pl.RoleURIs = ruList

	pl.ScopeList = []string{"web", "sever"}
	token := man.GenerateJwtToken(&pl)
	fmt.Println(token)
	if token == "" {
		t.Fail()
	} else {
		tkn = token
	}
}

func TestOauthManagerJwt_GenerateJwtTokenExp(t *testing.T) {

	var man OauthManager
	var pl Payload
	pl.TokenType = "test"
	pl.UserID = "tester1"
	pl.ClientID = 234
	pl.Subject = "code"
	pl.Issuer = "GoAuth2"
	pl.Audience = "GoAuth2.com"
	pl.ExpiresInMinute = 1 //(600 * time.Minute) => (600 * 60) => 36000 minutes => 10 hours
	pl.Grant = "code"
	pl.SecretKey = "secret"
	var ruList []RoleURI
	var ru1 RoleURI
	ru1.ClientRoleID = 1
	ru1.Role = "user"
	ru1.ClientAllowedURIID = 2
	ru1.ClientAllowedURI = "test.com"
	ru1.ClientID = 5
	ruList = append(ruList, ru1)

	var ru2 RoleURI
	ru2.ClientRoleID = 12
	ru2.Role = "user"
	ru2.ClientAllowedURIID = 21
	ru2.ClientAllowedURI = "test2.com"
	ru2.ClientID = 5
	ruList = append(ruList, ru2)

	pl.RoleURIs = ruList

	pl.ScopeList = []string{"web", "sever"}
	token := man.GenerateJwtToken(&pl)
	fmt.Println("expiring Token:", token)
	if token == "" {
		t.Fail()
	} else {
		tknExp = token
	}
}

func TestOauthManagerJwt_ValidateJwtToken(t *testing.T) {
	var man OauthManager

	suc, pl := man.ValidateJwt(tkn, "secret")
	if !suc || pl.TokenType != "test" || pl.UserID != "tester1" || pl.ClientID != 234 {
		t.Fail()
	} else {
		fmt.Println("pl: ", pl)
		fmt.Println("Audience: ", pl.Audience)
	}

}

// func TestOauthManagerJwt_ValidateJwtTokenExpired(t *testing.T) {
// 	time.Sleep(2 * time.Minute)
// 	var man OauthManager

// 	suc, pl := man.ValidateJwt(tknExp, "secret")
// 	fmt.Println("suc: ", suc)
// 	if suc || pl.TokenType != "test" || pl.UserID != "tester1" || pl.ClientID != 234 {
// 		t.Fail()
// 	} else {
// 		fmt.Println("pl: ", pl)
// 		fmt.Println("Audience: ", pl.Audience)
// 	}

// }
package managers

import (
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//AuthCodeTokenReq AuthCodeTokenReq
type AuthCodeTokenReq struct {
	ClientID    int64
	Secret      string
	Code        string
	RedirectURI string
}

//CredentialsTokenReq CredentialsTokenReq
type CredentialsTokenReq struct {
	ClientID int64
	Secret   string
}

//RefreshTokenReq RefreshTokenReq
type RefreshTokenReq struct {
	ClientID     int64
	Secret       string
	RefreshToken string
}

//PasswordTokenReq PasswordTokenReq
type PasswordTokenReq struct {
	Username string
	// Password string
	ClientID int64
}

//Token Token
type Token struct {
	AccessToken  string `json:"access_token"`
	TokenType    string `json:"token_type"`
	ExpiresIn    int64  `json:"expires_in"`
	RefreshToken string `json:"refresh_token"`
}

const (
	invalidClientError  = "invalid_client"
	invalidGrantError   = "invalid_grant"
	accessDeniedError   = "access_denied"
	invalidRequestError = "invalid_request"
)

//GetAuthCodeToken GetAuthCodeToken
func (m *OauthManager) GetAuthCodeToken(act *AuthCodeTokenReq) (bool, *Token, string) {
	var rtn Token
	var suc bool
	var tokenErr string
	client := m.Db.GetClient(act.ClientID)
	m.Log.Debug("client: ", client)
	if client != nil && client.Secret == act.Secret && client.Enabled {
		rtu := m.Db.GetClientRedirectURI(act.ClientID, act.RedirectURI)
		m.Log.Debug("rtu: ", rtu)
		if rtu.ID > 0 {
			acode := m.Db.GetAuthorizationCodeByCode(act.Code)
			if acode.ClientID == act.ClientID {
				acRev := m.Db.GetAuthCodeRevolk(acode.AuthorizationCode)
				m.Log.Debug("acRev: ", acRev)
				if acRev == nil || acRev.ID == 0 {
					if acode.AlreadyUsed {
						m.Log.Debug("AlreadyUsed: ", acode.AlreadyUsed)
						var rvk odb.AuthCodeRevolk
						rvk.AuthorizationCode = acode.AuthorizationCode
						rvsuc, rvid := m.Db.AddAuthCodeRevolk(nil, &rvk)
						tokenErr = invalidClientError
						m.Log.Debug("rvsuc: ", rvsuc)
						m.Log.Debug("rvid: ", rvid)
					} else {
						acode.AlreadyUsed = true
						usuc := m.Db.UpdateAuthorizationCode(acode)
						m.Log.Debug("usuc: ", usuc)
						if usuc {
							tkn := m.Db.GetAccessToken(acode.AccessTokenID)
							if tkn.ID > 0 {
								m.Log.Info("tkn: ", tkn)
								rtn.AccessToken = tkn.Token
								rtn.TokenType = tokenTypeBearer
								rtn.ExpiresIn = codeAccessTokenLifeInMinutes * 60
								if tkn.RefreshTokenID != 0 {
									rtkn := m.Db.GetRefreshToken(tkn.RefreshTokenID)
									m.Log.Info("rtkn: ", rtkn)
									if rtkn.ID > 0 {
										rtn.RefreshToken = rtkn.Token
										suc = true
									}
								} else {
									suc = true
								}
							} else {
								tokenErr = invalidGrantError
							}
						} else {
							tokenErr = invalidGrantError
						}
					}
				} else {
					tokenErr = invalidClientError
				}
			} else {
				tokenErr = invalidClientError
			}
		} else {
			tokenErr = invalidGrantError
		}
	} else {
		tokenErr = invalidClientError
	}
	return suc, &rtn, tokenErr
}

//GetCredentialsToken GetCredentialsToken
func (m *OauthManager) GetCredentialsToken(ct *CredentialsTokenReq) (bool, *Token, string) {
	var rtn Token
	var suc bool
	var tokenErr string
	client := m.Db.GetClient(ct.ClientID)
	m.Log.Debug("client: ", client)
	if client != nil && client.Secret == ct.Secret && client.Enabled {

		gton := m.grantTypeTurnedOn(ct.ClientID, clientGrantType)
		m.Log.Debug("gton: ", gton)
		if gton {
			delSuc := m.Db.DeleteCredentialsGrant(ct.ClientID)
			m.Log.Debug("delSuc: ", delSuc)
			if delSuc {
				roleURIList := m.Db.GetClientRoleAllowedURIListByClientID(ct.ClientID)
				m.Log.Debug("roleURIList", roleURIList)
				var pl Payload
				pl.TokenType = accessTokenType
				//pl.UserID = hashUser(ac.UserID)
				pl.ClientID = ct.ClientID
				pl.Subject = clientGrantType
				pl.ExpiresInMinute = credentialsGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
				pl.Grant = clientGrantType
				pl.RoleURIs = *m.populateRoleURLList(roleURIList)
				//pl.ScopeList = *scopeStrList
				accessToken := m.GenerateAccessToken(&pl)
				m.Log.Info("accessToken: ", accessToken)
				if accessToken != "" {
					now := time.Now()
					var aToken odb.AccessToken
					aToken.Token = accessToken
					aToken.Expires = now.Add(time.Minute * codeAccessTokenLifeInMinutes)

					var cgrant odb.CredentialsGrant
					cgrant.ClientID = ct.ClientID

					cgSuc, _ := m.Db.AddCredentialsGrant(&cgrant, &aToken)
					m.Log.Debug("cgSuc: ", cgSuc)
					if cgSuc {
						rtn.AccessToken = accessToken
						rtn.TokenType = tokenTypeBearer
						rtn.ExpiresIn = credentialsGrantAccessTokenLifeInMinutes * 60
						suc = true
					}
				}
			}
		}
	} else {
		tokenErr = invalidClientError
	}
	if !suc && tokenErr == "" {
		tokenErr = accessDeniedError
	}
	return suc, &rtn, tokenErr
}

//GetPasswordToken GetPasswordToken
func (m *OauthManager) GetPasswordToken(pt *PasswordTokenReq) (bool, *Token, string) {
	var rtn Token
	var suc bool
	var tokenErr string
	client := m.Db.GetClient(pt.ClientID)
	m.Log.Debug("pw client: ", client)
	if client != nil && client.Enabled {

		gton := m.grantTypeTurnedOn(pt.ClientID, passwordGrantType)
		m.Log.Debug("pw gton: ", gton)
		if gton {
			delSuc := m.Db.DeletePasswordGrant(pt.ClientID, pt.Username)
			m.Log.Debug("delSuc: ", delSuc)
			if delSuc {
				roleURIList := m.Db.GetClientRoleAllowedURIListByClientID(pt.ClientID)
				m.Log.Debug("roleURIList", roleURIList)
				var pl Payload
				pl.TokenType = accessTokenType
				pl.UserID = hashUser(pt.Username)
				pl.ClientID = pt.ClientID
				pl.Subject = passwordGrantType
				pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
				pl.Grant = passwordGrantType
				pl.RoleURIs = *m.populateRoleURLList(roleURIList)
				//pl.ScopeList = *scopeStrList
				accessToken := m.GenerateAccessToken(&pl)
				m.Log.Info("accessToken: ", accessToken)
				if accessToken != "" {
					refToken := m.GenerateRefreshToken(pt.ClientID, hashUser(pt.Username), passwordGrantType)
					m.Log.Info("refToken: ", refToken)

					now := time.Now()
					var aToken odb.AccessToken
					aToken.Token = accessToken
					aToken.Expires = now.Add(time.Minute * passwordGrantAccessTokenLifeInMinutes)

					var rToken odb.RefreshToken
					rToken.Token = refToken

					var pgrant odb.PasswordGrant
					pgrant.ClientID = pt.ClientID
					pgrant.UserID = pt.Username

					cgSuc, _ := m.Db.AddPasswordGrant(&pgrant, &aToken, &rToken)
					m.Log.Debug("cgSuc: ", cgSuc)
					if cgSuc {
						rtn.AccessToken = accessToken
						rtn.TokenType = tokenTypeBearer
						rtn.ExpiresIn = passwordGrantAccessTokenLifeInMinutes * 60
						rtn.RefreshToken = refToken
						suc = true
					}
				}
			}
		}
	} else {
		tokenErr = invalidClientError
	}
	if !suc && tokenErr == "" {
		tokenErr = accessDeniedError
	}
	return suc, &rtn, tokenErr
}

//GetAuthCodeAccesssTokenWithRefreshToken GetAuthCodeAccesssTokenWithRefreshToken
func (m *OauthManager) GetAuthCodeAccesssTokenWithRefreshToken(rt *RefreshTokenReq) (bool, *Token, string) {
	var rtn Token
	var suc bool
	var tokenErr string
	// if rt.ClientID != 0 && rt.Secret != "" {
	if m.checkClient(rt) {
		client := m.Db.GetClient(rt.ClientID)
		m.Log.Debug("client in get with ref: ", client)
		if client.Enabled && client.Secret == rt.Secret {
			m.Log.Debug("client enabled and secrets match")
			rtk := m.Db.GetRefreshTokenKey()
			if rtk != "" {
				m.Log.Info("refresh Token Key", rtk)
				rtsuc, rtpl := m.ValidateJwt(rt.RefreshToken, rtk)
				m.Log.Debug("rtsuc", rtsuc)
				m.Log.Debug("rtpl", rtpl)
				if rtsuc && rtpl.ClientID == rt.ClientID && rtpl.Subject == codeGrantType {
					m.Log.Debug("rtpl in success", rtpl)
					m.Log.Debug("unhashed user", unHashUser(rtpl.UserID))
					acode := m.Db.GetAuthorizationCode(rt.ClientID, unHashUser(rtpl.UserID))
					m.Log.Info("acode", acode)
					m.Log.Debug("acode user", (*acode)[0].UserID)
					m.Log.Info("acode AccessTokenID", (*acode)[0].AccessTokenID)
					if len(*acode) > 0 && (*acode)[0].UserID == unHashUser(rtpl.UserID) {
						m.Log.Debug("acode user suc")
						atkn := m.Db.GetAccessToken((*acode)[0].AccessTokenID)
						//fmt.Println("atkn", atkn)
						if atkn.ID > 0 {
							m.Log.Debug("atkn", atkn)
							tkkey := m.Db.GetAccessTokenKey()
							m.Log.Info("tkkey", tkkey)
							atsuc, atpl := m.ValidateJwt(atkn.Token, tkkey)
							m.Log.Debug("atsuc", atsuc)
							m.Log.Debug("atpl", atpl)
							if atpl.UserID == rtpl.UserID && atpl.ClientID == rt.ClientID {
								m.Log.Debug("atpl in success", atpl)
								var pl Payload
								pl.TokenType = accessTokenType
								pl.UserID = atpl.UserID
								pl.ClientID = rt.ClientID
								pl.Subject = codeGrantType
								pl.ExpiresInMinute = codeAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
								pl.Grant = codeGrantType
								pl.RoleURIs = atpl.RoleURIs
								pl.ScopeList = atpl.ScopeList
								newAccessToken := m.GenerateAccessToken(&pl)
								m.Log.Info("newAccessToken", newAccessToken)
								now := time.Now()
								(*acode)[0].Expires = now.Add(time.Minute * authCodeLifeInMinutes)
								atkn.Token = newAccessToken
								atkn.Expires = now.Add(time.Minute * codeAccessTokenLifeInMinutes)
								suc = m.Db.UpdateAuthorizationCodeAndToken(&(*acode)[0], atkn)
								rtn.AccessToken = newAccessToken
								rtn.TokenType = tokenTypeBearer
								rtn.ExpiresIn = codeAccessTokenLifeInMinutes * 60
								rtn.RefreshToken = rt.RefreshToken
							}
						}
					}
				}
			}
		}
	} else {
		tokenErr = invalidRequestError
	}
	if !suc && tokenErr == "" {
		tokenErr = invalidClientError
	}
	return suc, &rtn, tokenErr
}

func (m *OauthManager) checkClient(rt *RefreshTokenReq) bool {
	var rtn bool
	if rt.ClientID != 0 && rt.Secret != "" {
		rtn = true
	}
	return rtn
}

//GetPasswordAccesssTokenWithRefreshToken GetPasswordAccesssTokenWithRefreshToken
func (m *OauthManager) GetPasswordAccesssTokenWithRefreshToken(rt *RefreshTokenReq) (bool, *Token, string) {
	var rtn Token
	var suc bool
	var tokenErr string
	if rt.ClientID != 0 {
		client := m.Db.GetClient(rt.ClientID)
		m.Log.Debug("client in get with ref: ", client)
		rtk := m.Db.GetRefreshTokenKey()
		if rtk != "" {
			m.Log.Info("refresh Token Key", rtk)
			rtsuc, rtpl := m.ValidateJwt(rt.RefreshToken, rtk)
			m.Log.Debug("rtsuc", rtsuc)
			m.Log.Debug("rtpl", rtpl)
			if rtsuc && rtpl.ClientID == rt.ClientID && rtpl.Subject == passwordGrantType {
				m.Log.Debug("rtpl in success", rtpl)
				m.Log.Debug("unhashed user", unHashUser(rtpl.UserID))
				pgnt := m.Db.GetPasswordGrant(rt.ClientID, unHashUser(rtpl.UserID))
				m.Log.Debug("pgnt", pgnt)
				m.Log.Debug("pgnt user", (*pgnt)[0].UserID)
				m.Log.Debug("pgnt AccessTokenID", (*pgnt)[0].AccessTokenID)
				if len(*pgnt) > 0 && (*pgnt)[0].UserID == unHashUser(rtpl.UserID) {
					m.Log.Debug("pgnt user suc")
					pgatkn := m.Db.GetAccessToken((*pgnt)[0].AccessTokenID)
					m.Log.Debug("pgatkn", pgatkn)
					if pgatkn.ID > 0 {
						m.Log.Debug("pgatkn", pgatkn)
						tkkey := m.Db.GetAccessTokenKey()
						m.Log.Info("tkkey", tkkey)
						atsuc, pwatpl := m.ValidateJwt(pgatkn.Token, tkkey)
						m.Log.Debug("atsuc", atsuc)
						m.Log.Debug("pwatpl", pwatpl)
						if pwatpl.UserID == rtpl.UserID && pwatpl.ClientID == rt.ClientID {
							m.Log.Debug("pwatpl in success", pwatpl)
							var pl Payload
							pl.TokenType = accessTokenType
							pl.UserID = pwatpl.UserID
							pl.ClientID = rt.ClientID
							pl.Subject = passwordGrantType
							pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
							pl.Grant = passwordGrantType
							pl.RoleURIs = pwatpl.RoleURIs
							pl.ScopeList = pwatpl.ScopeList
							newAccessToken := m.GenerateAccessToken(&pl)
							m.Log.Info("newAccessToken", newAccessToken)
							now := time.Now()
							//(*pgnt)[0].Expires = now.Add(time.Minute * authCodeLifeInMinutes)
							pgatkn.Token = newAccessToken
							pgatkn.Expires = now.Add(time.Minute * passwordGrantAccessTokenLifeInMinutes)
							suc = m.Db.UpdateAccessToken(nil, pgatkn)
							rtn.AccessToken = newAccessToken
							rtn.TokenType = tokenTypeBearer
							rtn.ExpiresIn = passwordGrantAccessTokenLifeInMinutes * 60
							rtn.RefreshToken = rt.RefreshToken
						}
					}
				}
			}
		}
	} else {
		tokenErr = invalidRequestError
	}
	if !suc && tokenErr == "" {
		tokenErr = invalidClientError
	}
	return suc, &rtn, tokenErr
}
package managers

import (
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//Implicit Implicit
type Implicit struct {
	ClientID    int64
	UserID      string
	Scope       string
	RedirectURI string
	CallbackURI string
}

//ImplicitReturn ImplicitReturn
type ImplicitReturn struct {
	ID    int64
	Token string
}

//ImplicitClient ImplicitClient
type ImplicitClient struct {
	Valid      bool
	ClientName string
	WebSite    string
}

//AuthorizeImplicit AuthorizeImplicit
func (m *OauthManager) AuthorizeImplicit(imp *Implicit) (bool, *ImplicitReturn) {
	var suc bool
	var rtn *ImplicitReturn
	client := m.Db.GetClient(imp.ClientID)
	if client.Enabled {
		rtu := m.Db.GetClientRedirectURI(imp.ClientID, imp.RedirectURI)
		if rtu.ID > 0 {
			//here
			//check that grant type is on
			gton := m.grantTypeTurnedOn(imp.ClientID, implicitGrantType)
			m.Log.Debug("grant turned on: ", gton)
			if gton {
				impgt := m.Db.GetImplicitGrant(imp.ClientID, imp.UserID)
				m.Log.Debug("impgt: ", impgt)
				var scopeStrList []string
				if len(*impgt) > 0 && (*impgt)[0].ID != 0 {
					scopeList := m.Db.GetImplicitGrantScopeList((*impgt)[0].ID)
					m.Log.Debug("scopeList: ", scopeList)
					var scopeFound bool
					for _, s := range *scopeList {
						if s.Scope == imp.Scope {
							scopeFound = true
							break
						}
					}
					m.Log.Debug("scopeFound: ", scopeFound)
					for _, s := range *scopeList {
						scopeStrList = append(scopeStrList, s.Scope)
					}
					if scopeFound {
						suc, rtn = m.processImplicitInsert(imp, &scopeStrList, true)
					} else {
						scopeStrList = append(scopeStrList, imp.Scope)
						suc, rtn = m.processImplicitInsert(imp, &scopeStrList, true)
					}
				} else {
					scopeStrList = append(scopeStrList, imp.Scope)
					suc, rtn = m.processImplicitInsert(imp, &scopeStrList, false)
				}
			}
		}
	}
	return suc, rtn
}

//CheckImplicitApplicationAuthorization CheckImplicitApplicationAuthorization
func (m *OauthManager) CheckImplicitApplicationAuthorization(imp *Implicit) (authorized bool) {
	if imp.ClientID != 0 && imp.UserID != "" && imp.Scope != "" {
		facs := m.Db.GetImplicitGrantByScope(imp.ClientID, imp.UserID, imp.Scope)
		if len(*facs) > 0 && (*facs)[0].ID != 0 {
			authorized = true
		}
	}
	return authorized
}

//ValidateImplicitClientAndCallback ValidateImplicitClientAndCallback
func (m *OauthManager) ValidateImplicitClientAndCallback(imp *Implicit) *ImplicitClient {
	var rtn ImplicitClient
	if imp.ClientID != 0 && imp.RedirectURI != "" {
		cru := m.Db.GetClientRedirectURI(imp.ClientID, imp.RedirectURI)
		m.Log.Debug("cru: ", cru)
		if cru.ID > 0 && cru.URI == imp.RedirectURI && cru.ClientID == imp.ClientID {
			c := m.Db.GetClient(imp.ClientID)
			if c.Enabled {
				rtn.Valid = true
				rtn.ClientName = c.Name
				rtn.WebSite = c.WebSite
			}
		}
	}
	return &rtn
}

func (m *OauthManager) processImplicitInsert(imp *Implicit, scopeStrList *[]string, existingAuthCode bool) (success bool, rtn *ImplicitReturn) {
	var igdel bool
	if existingAuthCode {
		igdel = m.Db.DeleteImplicitGrant(imp.ClientID, imp.UserID)
		m.Log.Debug("igdel: ", igdel)
	} else {
		igdel = true
	}
	if igdel {
		roleURIList := m.Db.GetClientRoleAllowedURIListByClientID(imp.ClientID)
		m.Log.Debug("roleURIList", roleURIList)
		var pl Payload
		pl.TokenType = accessTokenType
		pl.UserID = hashUser(imp.UserID)
		pl.ClientID = imp.ClientID
		pl.Subject = implicitGrantType
		pl.ExpiresInMinute = implicitAccessTokenLifeInMinutes //(600 * time.Minute) => (600 * 60) => 36000 seconds => 10 hours
		pl.Grant = implicitGrantType
		pl.RoleURIs = *m.populateRoleURLList(roleURIList)
		pl.ScopeList = *scopeStrList
		accessToken := m.GenerateAccessToken(&pl)
		m.Log.Info("accessToken: ", accessToken)
		if accessToken != "" {
			now := time.Now()
			var igt odb.ImplicitGrant
			igt.ClientID = imp.ClientID
			igt.UserID = imp.UserID

			var aToken odb.AccessToken
			aToken.Token = accessToken
			aToken.Expires = now.Add(time.Minute * implicitAccessTokenLifeInMinutes)

			igSuc, igID := m.Db.AddImplicitGrant(&igt, &aToken, scopeStrList)
			m.Log.Debug("igSuc: ", igSuc)
			m.Log.Debug("igID: ", igID)
			if igSuc {
				success = igSuc
				rtn = new(ImplicitReturn)
				rtn.ID = igID
				rtn.Token = accessToken
			}
		}
	}
	return success, rtn
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	//"fmt"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//ClientRedirectURI ClientRedirectURI
type ClientRedirectURI struct {
	ID       int64  `json:"id"`
	URI      string `json:"uri"`
	ClientID int64  `json:"clientId"`
}

//AddClientRedirectURI AddClientRedirectURI
func (m *OauthManager) AddClientRedirectURI(ru *ClientRedirectURI) (bool, int64) {
	// var suc bool
	// var id int64
	var cru odb.ClientRedirectURI
	cru.URI = ru.URI
	cru.ClientID = ru.ClientID
	suc, id := m.Db.AddClientRedirectURI(nil, &cru)
	return suc, id
}

//GetClientRedirectURIList GetClientRedirectURIList
func (m *OauthManager) GetClientRedirectURIList(clientID int64) *[]ClientRedirectURI {
	var rtn = []ClientRedirectURI{}
	ul := m.Db.GetClientRedirectURIList(clientID)
	for _, u := range *ul {
		var ui ClientRedirectURI
		ui.ID = u.ID
		ui.URI = u.URI
		ui.ClientID = u.ClientID
		rtn = append(rtn, ui)
	}
	return &rtn
}

//DeleteClientRedirectURI DeleteClientRedirectURI
func (m *OauthManager) DeleteClientRedirectURI(id int64) bool {
	suc := m.Db.DeleteClientRedirectURI(nil, id)
	return suc
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	odb "github.com/Ulbora/GoAuth2/oauth2database"
	px "github.com/Ulbora/GoProxy"
	lg "github.com/Ulbora/Level_Logger"
	au "github.com/Ulbora/auth_interface"
)

const (
	//Grant Types
	codeGrantType     = "code"
	implicitGrantType = "implicit"
	clientGrantType   = "client_credentials"
	passwordGrantType = "password"

	//token info
	tokenIssuer      = "GoAuth2"
	tokenAudience    = "GoAuth2.com"
	refreshTokenType = "refresh"
	accessTokenType  = "access"

	tokenTypeBearer = "bearer"

	refreshTokenLifeInMinutes                = 600 //10 hours
	codeAccessTokenLifeInMinutes             = 60  //1 hour
	credentialsGrantAccessTokenLifeInMinutes = 60  //1 hour
	passwordGrantAccessTokenLifeInMinutes    = 60  //1 hour
	authCodeLifeInMinutes                    = 5

	implicitAccessTokenLifeInMinutes = 600 //10 hours

	authenticationServiceLocal = "http://localhost:3001/rs/user/login"
)

//Manager Manager
type Manager interface {
	//client
	AddClient(client *Client) (bool, int64)
	UpdateClient(client *Client) bool
	GetClient(id int64) *Client
	GetClientList() *[]Client
	GetClientSearchList(name string) *[]Client
	DeleteClient(id int64) bool

	//client redirect uri
	AddClientRedirectURI(ru *ClientRedirectURI) (bool, int64)
	GetClientRedirectURIList(clientID int64) *[]ClientRedirectURI
	DeleteClientRedirectURI(id int64) bool

	// //client roles
	AddClientRole(r *ClientRole) (bool, int64)
	GetClientRoleList(clientID int64) *[]ClientRole
	DeleteClientRole(id int64) bool

	//client allowed uri
	AddClientAllowedURI(au *ClientAllowedURI) (bool, int64)
	UpdateClientAllowedURI(au *ClientAllowedURI) bool
	GetClientAllowedURI(id int64) *ClientAllowedURI
	GetClientAllowedURIList(clientID int64) *[]ClientAllowedURI
	DeleteClientAllowedURI(id int64) bool

	//client role uri
	AddClientRoleURI(r *ClientRoleURI) bool
	GetClientRoleAllowedURIList(roleID int64) *[]ClientRoleURI
	DeleteClientRoleURI(r *ClientRoleURI) bool

	//client grant type
	AddClientGrantType(gt *ClientGrantType) (bool, int64)
	GetClientGrantTypeList(clientID int64) *[]ClientGrantType
	DeleteClientGrantType(id int64) bool

	//auth code
	AuthorizeAuthCode(ac *AuthCode) (success bool, authCode int64, authCodeString string)
	CheckAuthCodeApplicationAuthorization(ac *AuthCode) (authorized bool)
	ValidateAuthCodeClientAndCallback(ac *AuthCode) *AuthCodeClient

	//implicit
	AuthorizeImplicit(imp *Implicit) (bool, *ImplicitReturn)
	CheckImplicitApplicationAuthorization(imp *Implicit) (authorized bool)
	ValidateImplicitClientAndCallback(imp *Implicit) *ImplicitClient

	//token manager
	GetAuthCodeToken(act *AuthCodeTokenReq) (bool, *Token, string)
	GetCredentialsToken(ct *CredentialsTokenReq) (bool, *Token, string)
	GetPasswordToken(pt *PasswordTokenReq) (bool, *Token, string)
	GetAuthCodeAccesssTokenWithRefreshToken(rt *RefreshTokenReq) (bool, *Token, string)
	GetPasswordAccesssTokenWithRefreshToken(rt *RefreshTokenReq) (bool, *Token, string)

	// //validate Token
	ValidateAccessToken(at *ValidateAccessTokenReq) bool

	UserLogin(login *au.Login) bool
}

//TokenParams AccessTokenParams
type TokenParams struct {
	AccessTokenKey  string
	RefreshTokenKey string
	Issuer          string
	Audience        string
}

//OauthManager OauthManager
type OauthManager struct {
	Db          odb.Oauth2DB
	Proxy       px.Proxy
	AuthService au.AuthInterface
	Log         *lg.Logger
	TokenParams *TokenParams
}
package managers

import (
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerRoleURI_AddClientRoleURI(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	mydb.MockInsertSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var cr ClientRoleURI
	cr.ClientRoleID = 1
	cr.ClientAllowedURIID = 2
	suc := m.AddClientRoleURI(&cr)
	if !suc {
		t.Fail()
	}

}

func TestOauthManagerRoleURI_GetClientRoleURIList(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	//mydb.MockInsertSuccess1 = true

	var rows [][]string
	row1 := []string{"2", "2"}
	rows = append(rows, row1)
	row2 := []string{"2", "3"}
	rows = append(rows, row2)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	rul := m.GetClientRoleAllowedURIList(2)
	if len(*rul) != 2 || (*rul)[1].ClientAllowedURIID != 3 {
		t.Fail()
	}
}

func TestOauthManagerRoleURI_DeleteClientRoleURI(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	mydb.MockDeleteSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var cr ClientRoleURI
	cr.ClientRoleID = 1
	cr.ClientAllowedURIID = 2
	suc := m.DeleteClientRoleURI(&cr)
	if !suc {
		t.Fail()
	}

}
package managers

import (
	"fmt"
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerImplicit_AuthorizeImplicit(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "testUri", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var rows [][]string
	row1 := []string{"1", "implicit", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "3", "user", "2", "test"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var rows3 [][]string
	row3 := []string{"1", "web", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	var rows4 [][]string
	row4 := []string{"1", "3", "user", "2", "test"}
	rows4 = append(rows4, row4)
	var dbrows4 db.DbRows
	dbrows4.Rows = rows4
	mydb.MockRows4 = &dbrows4

	var rows5 [][]string
	row5 := []string{"4", "somerole", "1", "someurl", "2"}
	rows5 = append(rows5, row5)
	var dbrows5 db.DbRows
	dbrows5.Rows = rows5
	mydb.MockRows5 = &dbrows5

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow3 = &mGetRow3

	// var tt = time.Now()
	// var mGetRow3 db.DbRow
	// mGetRow3.Row = []string{"2", "testUri", tt.Format("2006-01-02 15:04:05"), "2"}
	// mydb.MockRow3 = &mGetRow3

	// var mGetRow4 db.DbRow
	// mGetRow4.Row = []string{"2", "testUri"}
	// mydb.MockRow4 = &mGetRow4

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 20

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 5

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var imp Implicit
	imp.ClientID = 2
	imp.UserID = "123"
	imp.Scope = "web"
	imp.RedirectURI = "google.com"
	imp.CallbackURI = "google.com"

	suc, rtn := m.AuthorizeImplicit(&imp)
	fmt.Println("rtn: ", rtn)
	if !suc || rtn.ID != 20 || rtn.Token == "" {
		t.Fail()
	}

}

func TestOauthManagerImplicit_AuthorizeImplicitNewScope(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "testUri", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var rows [][]string
	row1 := []string{"1", "implicit", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "3", "user", "2", "test"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var rows3 [][]string
	row3 := []string{"1", "web", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	var rows4 [][]string
	row4 := []string{"1", "3", "user", "2", "test"}
	rows4 = append(rows4, row4)
	var dbrows4 db.DbRows
	dbrows4.Rows = rows4
	mydb.MockRows4 = &dbrows4

	var rows5 [][]string
	row5 := []string{"4", "somerole", "1", "someurl", "2"}
	rows5 = append(rows5, row5)
	var dbrows5 db.DbRows
	dbrows5.Rows = rows5
	mydb.MockRows5 = &dbrows5

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow3 = &mGetRow3

	// var tt = time.Now()
	// var mGetRow3 db.DbRow
	// mGetRow3.Row = []string{"2", "testUri", tt.Format("2006-01-02 15:04:05"), "2"}
	// mydb.MockRow3 = &mGetRow3

	// var mGetRow4 db.DbRow
	// mGetRow4.Row = []string{"2", "testUri"}
	// mydb.MockRow4 = &mGetRow4

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 20

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 5

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var imp Implicit
	imp.ClientID = 2
	imp.UserID = "123"
	imp.Scope = "cloud"
	imp.RedirectURI = "google.com"
	imp.CallbackURI = "google.com"

	suc, rtn := m.AuthorizeImplicit(&imp)
	fmt.Println("rtn: ", rtn)
	if !suc || rtn.ID != 20 || rtn.Token == "" {
		t.Fail()
	}

}

func TestOauthManagerImplicit_AuthorizeImplicitNew(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "testUri", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var rows [][]string
	row1 := []string{"1", "implicit", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	// var rows2 [][]string
	// row2 := []string{"1", "3", "user", "2", "test"}
	// rows2 = append(rows2, row2)
	// var dbrows2 db.DbRows
	// dbrows2.Rows = rows2
	// mydb.MockRows2 = &dbrows2

	var rows2 [][]string
	//row2 := []string{"1", "3", "user", "2", "test"}
	//rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	// var rows3 [][]string
	// row3 := []string{"1", "web", "2"}
	// rows3 = append(rows3, row3)
	// var dbrows3 db.DbRows
	// dbrows3.Rows = rows3
	// mydb.MockRows3 = &dbrows3

	// var rows4 [][]string
	// row4 := []string{"1", "3", "user", "2", "test"}
	// rows4 = append(rows4, row4)
	// var dbrows4 db.DbRows
	// dbrows4.Rows = rows4
	// mydb.MockRows4 = &dbrows4

	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow3 = &mGetRow3

	// var tt = time.Now()
	// var mGetRow3 db.DbRow
	// mGetRow3.Row = []string{"2", "testUri", tt.Format("2006-01-02 15:04:05"), "2"}
	// mydb.MockRow3 = &mGetRow3

	// var mGetRow4 db.DbRow
	// mGetRow4.Row = []string{"2", "testUri"}
	// mydb.MockRow4 = &mGetRow4

	// mydb.MockDeleteSuccess1 = true
	// mydb.MockDeleteSuccess2 = true
	// mydb.MockDeleteSuccess3 = true

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 20

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 5

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var imp Implicit
	imp.ClientID = 2
	imp.UserID = "123"
	imp.Scope = "cloud"
	imp.RedirectURI = "google.com"
	imp.CallbackURI = "google.com"

	suc, rtn := m.AuthorizeImplicit(&imp)
	fmt.Println("rtn: ", rtn)
	if !suc || rtn.ID != 20 || rtn.Token == "" {
		t.Fail()
	}

}

func TestOauthManagerImplicit_AuthorizeImplicitClientDisabled(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "testUri", "test", "test", "test", "false", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var rows [][]string
	row1 := []string{"1", "implicit", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	// var rows2 [][]string
	// row2 := []string{"1", "3", "user", "2", "test"}
	// rows2 = append(rows2, row2)
	// var dbrows2 db.DbRows
	// dbrows2.Rows = rows2
	// mydb.MockRows2 = &dbrows2

	var rows2 [][]string
	//row2 := []string{"1", "3", "user", "2", "test"}
	//rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	// var rows3 [][]string
	// row3 := []string{"1", "web", "2"}
	// rows3 = append(rows3, row3)
	// var dbrows3 db.DbRows
	// dbrows3.Rows = rows3
	// mydb.MockRows3 = &dbrows3

	// var rows4 [][]string
	// row4 := []string{"1", "3", "user", "2", "test"}
	// rows4 = append(rows4, row4)
	// var dbrows4 db.DbRows
	// dbrows4.Rows = rows4
	// mydb.MockRows4 = &dbrows4

	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow3 = &mGetRow3

	// var tt = time.Now()
	// var mGetRow3 db.DbRow
	// mGetRow3.Row = []string{"2", "testUri", tt.Format("2006-01-02 15:04:05"), "2"}
	// mydb.MockRow3 = &mGetRow3

	// var mGetRow4 db.DbRow
	// mGetRow4.Row = []string{"2", "testUri"}
	// mydb.MockRow4 = &mGetRow4

	// mydb.MockDeleteSuccess1 = true
	// mydb.MockDeleteSuccess2 = true
	// mydb.MockDeleteSuccess3 = true

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 20

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 5

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var imp Implicit
	imp.ClientID = 2
	imp.UserID = "123"
	imp.Scope = "cloud"
	imp.RedirectURI = "google.com"
	imp.CallbackURI = "google.com"

	suc, rtn := m.AuthorizeImplicit(&imp)
	fmt.Println("rtn: ", rtn)
	if suc {
		t.Fail()
	}

}

func TestOauthManagerImplicit_CheckImplicitApplicationAuthorization(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	// var mGetRow db.DbRow
	// mGetRow.Row = []string{"2", "testUri", "test", "test", "test", "false", "false"}
	// mydb.MockRow1 = &mGetRow

	// var mGetRow2 db.DbRow
	// mGetRow2.Row = []string{"2", "testUri", "2"}
	// mydb.MockRow2 = &mGetRow2

	// var rows [][]string
	// row1 := []string{"1", "implicit", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var rows1 [][]string
	row1 := []string{"1", "3", "user", "2", "test"}
	rows1 = append(rows1, row1)
	var dbrows1 db.DbRows
	dbrows1.Rows = rows1
	mydb.MockRows1 = &dbrows1

	// var rows2 [][]string
	// //row2 := []string{"1", "3", "user", "2", "test"}
	// //rows2 = append(rows2, row2)
	// var dbrows2 db.DbRows
	// dbrows2.Rows = rows2
	// mydb.MockRows2 = &dbrows2

	// var rows3 [][]string
	// row3 := []string{"1", "web", "2"}
	// rows3 = append(rows3, row3)
	// var dbrows3 db.DbRows
	// dbrows3.Rows = rows3
	// mydb.MockRows3 = &dbrows3

	// var rows4 [][]string
	// row4 := []string{"1", "3", "user", "2", "test"}
	// rows4 = append(rows4, row4)
	// var dbrows4 db.DbRows
	// dbrows4.Rows = rows4
	// mydb.MockRows4 = &dbrows4

	// var rows3 [][]string
	// row3 := []string{"4", "somerole", "1", "someurl", "2"}
	// rows3 = append(rows3, row3)
	// var dbrows3 db.DbRows
	// dbrows3.Rows = rows3
	// mydb.MockRows3 = &dbrows3

	// var mGetRow3 db.DbRow
	// mGetRow3.Row = []string{"2", "6g651dfg6gf6"}
	// mydb.MockRow3 = &mGetRow3

	// var tt = time.Now()
	// var mGetRow3 db.DbRow
	// mGetRow3.Row = []string{"2", "testUri", tt.Format("2006-01-02 15:04:05"), "2"}
	// mydb.MockRow3 = &mGetRow3

	// var mGetRow4 db.DbRow
	// mGetRow4.Row = []string{"2", "testUri"}
	// mydb.MockRow4 = &mGetRow4

	// mydb.MockDeleteSuccess1 = true
	// mydb.MockDeleteSuccess2 = true
	// mydb.MockDeleteSuccess3 = true

	// mydb.MockInsertSuccess1 = true
	// mydb.MockInsertID1 = 2

	// mydb.MockInsertSuccess2 = true
	// mydb.MockInsertID2 = 20

	// mydb.MockInsertSuccess3 = true
	// mydb.MockInsertID3 = 5

	// mydb.MockInsertSuccess4 = true
	// mydb.MockInsertID4 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var imp Implicit
	imp.ClientID = 2
	imp.UserID = "123"
	imp.Scope = "cloud"
	imp.RedirectURI = "google.com"
	imp.CallbackURI = "google.com"

	suc := m.CheckImplicitApplicationAuthorization(&imp)
	fmt.Println("authorized: ", suc)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerImplicit_ValidateAuthCodeClientAndCallback(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"5", "someurl.com", "25"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"25", "secret", "testname", "testWebSite", "test", "true", "false"}
	mydb.MockRow2 = &mGetRow2

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var imp Implicit
	imp.ClientID = 25
	imp.UserID = "123"
	imp.Scope = "cloud"
	imp.RedirectURI = "someurl.com"
	imp.CallbackURI = "google.com"
	ip := m.ValidateImplicitClientAndCallback(&imp)
	fmt.Println("auth: ", ip)
	if !ip.Valid || ip.ClientName != "testname" || ip.WebSite != "testWebSite" {
		t.Fail()
	}
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"time"

	jwt "github.com/gbrlsnchs/jwt/v3"
)

//Payload Payload
type Payload struct {
	TokenType       string
	UserID          string
	ClientID        int64
	Subject         string
	Issuer          string
	Audience        string
	ExpiresInMinute time.Duration
	Grant           string
	SecretKey       string
	RoleURIs        []RoleURI
	ScopeList       []string
}

//JwtPayload JwtPayload
type jwtPayload struct {
	Payload   jwt.Payload
	TokenType string    `json:"tokenType,omitempty"`
	UserID    string    `json:"userId,omitempty"`
	ClientID  int64     `json:"clientId,omitempty"`
	Grant     string    `json:"grant,omitempty"`
	RoleURIs  []RoleURI `json:"roleURIs,omitempty"`
	ScopeList []string  `json:"scopeList,omitempty"`
}

//RoleURI RoleURI
type RoleURI struct {
	ClientRoleID       int64
	Role               string
	ClientAllowedURIID int64
	ClientAllowedURI   string
	ClientID           int64
}

//GenerateJwtToken GenerateJwtToken
func (m *OauthManager) GenerateJwtToken(pl *Payload) string {
	var rtn string
	now := time.Now()
	var jwtPl jwt.Payload
	jwtPl.Subject = pl.Subject
	jwtPl.Issuer = pl.Issuer
	jwtPl.Audience = jwt.Audience{pl.Audience}
	jwtPl.ExpirationTime = jwt.NumericDate(now.Add(pl.ExpiresInMinute * time.Minute))
	jwtPl.IssuedAt = jwt.NumericDate(now)

	var jpl jwtPayload
	jpl.Payload = jwtPl
	jpl.TokenType = pl.TokenType
	if pl.UserID != "" {
		jpl.UserID = pl.UserID
	}
	jpl.ClientID = pl.ClientID
	if pl.Grant != "" {
		jpl.Grant = pl.Grant
	}
	jpl.RoleURIs = pl.RoleURIs
	jpl.ScopeList = pl.ScopeList

	hs := jwt.NewHS256([]byte(pl.SecretKey))
	token, err := jwt.Sign(jpl, hs)
	if err == nil {
		rtn = string(token)
	}
	return rtn
}

//ValidateJwt ValidateJwt
func (m *OauthManager) ValidateJwt(token string, secret string) (bool, *Payload) {
	var valid bool
	var rtn Payload
	var pl jwtPayload
	now := time.Now()
	var hs = jwt.NewHS256([]byte(secret))
	//aud = jwt.Audience{"https://golang.org"}

	// Validate claims "iat", "exp" and "aud".
	iatValidator := jwt.IssuedAtValidator(now)
	expValidator := jwt.ExpirationTimeValidator(now)
	//audValidator = jwt.AudienceValidator(aud)

	// Use jwt.ValidatePayload to build a jwt.VerifyOption.
	// Validators are run in the order informed.
	//pl              CustomPayload
	validatePayload := jwt.ValidatePayload(&pl.Payload, iatValidator, expValidator)
	_, err := jwt.Verify([]byte(token), hs, &pl, validatePayload)
	if err == nil {
		valid = true
	}

	//fmt.Println("pl: ", pl)
	rtn.TokenType = pl.TokenType
	rtn.UserID = pl.UserID
	rtn.ClientID = pl.ClientID
	rtn.Subject = pl.Payload.Subject
	rtn.Issuer = pl.Payload.Issuer
	aud := pl.Payload.Audience
	for _, a := range aud {
		rtn.Audience = a
		break
	}
	rtn.Grant = pl.Grant
	rtn.RoleURIs = pl.RoleURIs
	rtn.ScopeList = pl.ScopeList

	return valid, &rtn
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	//"fmt"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//Client Client
type Client struct {
	ClientID     int64                `json:"clientId"`
	Secret       string               `json:"secret"`
	Name         string               `json:"name"`
	WebSite      string               `json:"webSite"`
	Email        string               `json:"email"`
	Enabled      bool                 `json:"enabled"`
	Paid         bool                 `json:"paid"`
	RedirectURIs *[]ClientRedirectURI `json:"redirectUrls"`
}

// //ClientRedirectURI ClientRedirectURI
// type ClientRedirectURI struct {
// 	ID       int64
// 	URI      string
// 	ClientID int64
// }

//AddClient AddClient
func (m *OauthManager) AddClient(client *Client) (bool, int64) {
	var suc bool
	var id int64
	//fmt.Println("client: ", client)
	//fmt.Println("uris: ", client.RedirectURIs)
	if len(*client.RedirectURIs) > 0 && (*client.RedirectURIs)[0].URI != "" {
		//fmt.Println("client: ", client)
		var c odb.Client
		c.Secret = generateClientSecret()
		c.Name = client.Name
		c.WebSite = client.WebSite
		c.Email = client.Email
		c.Enabled = client.Enabled
		c.Paid = client.Paid
		var uri []odb.ClientRedirectURI
		for _, u := range *client.RedirectURIs {
			var curi odb.ClientRedirectURI
			curi.URI = u.URI
			uri = append(uri, curi)
		}
		//fmt.Println("c: ", c)
		//fmt.Println("uri: ", uri)
		s, tid := m.Db.AddClient(&c, &uri)
		//fmt.Println("suc: ", s)
		suc = s
		id = tid
	}
	return suc, id
}

//UpdateClient UpdateClient
func (m *OauthManager) UpdateClient(client *Client) bool {
	// var suc bool
	var c odb.Client
	if client.Secret == "" {
		c.Secret = generateClientSecret()
	} else {
		c.Secret = client.Secret
	}
	c.ClientID = client.ClientID
	c.Name = client.Name
	c.WebSite = client.WebSite
	c.Email = client.Email
	c.Enabled = client.Enabled
	c.Paid = client.Paid
	//fmt.Println("c in update: ", c)

	suc := m.Db.UpdateClient(&c)

	return suc
}

//GetClient GetClient
func (m *OauthManager) GetClient(id int64) *Client {
	var rtn Client
	c := m.Db.GetClient(id)
	//fmt.Println("client in get: ", c)
	if c != nil && c.ClientID != 0 {
		rtn.ClientID = c.ClientID
		rtn.Secret = c.Secret
		rtn.Name = c.Name
		rtn.WebSite = c.WebSite
		rtn.Email = c.Email
		rtn.Enabled = c.Enabled
		rtn.Paid = c.Paid
		uris := m.Db.GetClientRedirectURIList(id)
		var cruis []ClientRedirectURI
		for _, u := range *uris {
			var uri ClientRedirectURI
			uri.ID = u.ID
			uri.URI = u.URI
			uri.ClientID = u.ClientID
			cruis = append(cruis, uri)
		}
		rtn.RedirectURIs = &cruis
	}
	return &rtn
}

//GetClientList GetClientList
func (m *OauthManager) GetClientList() *[]Client {
	var rtn = []Client{}
	cs := m.Db.GetClients()
	for _, c := range *cs {
		cc := populateClient(c)
		rtn = append(rtn, cc)
	}
	return &rtn
}

//GetClientSearchList GetClientSearchList
func (m *OauthManager) GetClientSearchList(name string) *[]Client {
	var rtn = []Client{}
	cs := m.Db.SearchClients(name)
	for _, c := range *cs {
		cc := populateClient(c)
		rtn = append(rtn, cc)
	}
	return &rtn
}

//DeleteClient DeleteClient
func (m *OauthManager) DeleteClient(id int64) bool {
	suc := m.Db.DeleteClient(id)
	return suc
}

func populateClient(c odb.Client) Client {
	var cc Client
	cc.ClientID = c.ClientID
	cc.Name = c.Name
	cc.WebSite = c.WebSite
	cc.Email = c.Email
	cc.Enabled = c.Enabled
	return cc
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	//"fmt"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//ClientRoleURI ClientRoleURI
type ClientRoleURI struct {
	ClientRoleID       int64 `json:"clientRoleId"`
	ClientAllowedURIID int64 `json:"clientAllowedUriId"`
}

//AddClientRoleURI AddClientRoleURI
func (m *OauthManager) AddClientRoleURI(r *ClientRoleURI) bool {
	var ru odb.ClientRoleURI
	ru.ClientRoleID = r.ClientRoleID
	ru.ClientAllowedURIID = r.ClientAllowedURIID
	suc := m.Db.AddClientRoleURI(&ru)
	return suc

}

//GetClientRoleAllowedURIList GetClientRoleAllowedURIList
func (m *OauthManager) GetClientRoleAllowedURIList(roleID int64) *[]ClientRoleURI {
	var rtn = []ClientRoleURI{}
	rul := m.Db.GetClientRoleAllowedURIList(roleID)
	for _, ru := range *rul {
		var r ClientRoleURI
		r.ClientRoleID = ru.ClientRoleID
		r.ClientAllowedURIID = ru.ClientAllowedURIID
		rtn = append(rtn, r)
	}
	return &rtn
}

//DeleteClientRoleURI DeleteClientRoleURI
func (m *OauthManager) DeleteClientRoleURI(r *ClientRoleURI) bool {
	var ru odb.ClientRoleURI
	ru.ClientRoleID = r.ClientRoleID
	ru.ClientAllowedURIID = r.ClientAllowedURIID
	suc := m.Db.DeleteClientRoleURI(&ru)
	return suc
}
//Package managers ...
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/
import (
	au "github.com/Ulbora/auth_interface"
)

//px "github.com/Ulbora/GoProxy"

//Login Login
type Login struct {
	Username string `json:"username"`
	Password string `json:"password"`
	ClientID int64  `json:"clientId"`
}

//LoginRes LoginRes
type LoginRes struct {
	Valid bool   `json:"valid"`
	Code  string `json:"code"`
}

//UserLogin UserLogin
func (m *OauthManager) UserLogin(login *au.Login) bool {
	rtn := m.AuthService.UserLogin(login)
	return rtn
}
package managers

import (
	"fmt"
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerClient_AddClient(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow
	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2
	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 2

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var c Client
	c.Name = "tester"
	c.WebSite = "www"
	c.Email = "test@test.com"
	c.Enabled = true
	c.Paid = false
	var uris []ClientRedirectURI
	var uri ClientRedirectURI
	uri.URI = "test"
	uris = append(uris, uri)
	c.RedirectURIs = &uris

	suc, id := m.AddClient(&c)
	if !suc || id == 0 {
		t.Fail()
	}
}

func TestOauthManagerClient_UpdateClient(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow
	mydb.MockUpdateSuccess1 = true
	// mydb.MockInsertID1 = 2
	// mydb.MockInsertSuccess2 = true
	// mydb.MockInsertID2 = 2

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var c Client
	c.ClientID = 22
	c.Name = "tester"
	c.WebSite = "www"
	c.Email = "test@test.com"
	c.Secret = "12345"
	c.Enabled = true
	c.Paid = false
	var uris []ClientRedirectURI
	var uri ClientRedirectURI
	uri.URI = "test"
	uris = append(uris, uri)
	c.RedirectURIs = &uris

	suc := m.UpdateClient(&c)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerClient_UpdateClient2(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow
	mydb.MockUpdateSuccess1 = true
	// mydb.MockInsertID1 = 2
	// mydb.MockInsertSuccess2 = true
	// mydb.MockInsertID2 = 2

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var c Client
	c.ClientID = 22
	c.Name = "tester"
	c.WebSite = "www"
	c.Email = "test@test.com"
	//c.Secret = "12345"
	c.Enabled = true
	c.Paid = false
	// uri := []string{"testuri"}
	// c.RedirectURIs = &uri

	suc := m.UpdateClient(&c)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerClient_GetClient(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var rows [][]string
	row1 := []string{"3", "testurl", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "secret", "tester", "tester.com", "t@t.com", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	c := m.GetClient(1)
	fmt.Println("client in get test: ", c)
	fmt.Println("client uris in get test: ", c.RedirectURIs)
	if c.ClientID != 2 || (*c.RedirectURIs)[0].ID != 3 {
		t.Fail()
	}
}

func TestOauthManagerClient_GetClients(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var rows [][]string
	row1 := []string{"3", "secret", "tester", "tester.com", "t@t.com", "true", "false"}
	rows = append(rows, row1)
	row2 := []string{"4", "secret", "tester", "tester.com", "t@t.com", "true", "false"}
	rows = append(rows, row2)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	// var mGetRow db.DbRow
	// mGetRow.Row = []string{"2", "secret", "tester", "tester.com", "t@t.com", "true", "false"}
	// mydb.MockRow1 = &mGetRow

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	cs := m.GetClientList()
	fmt.Println("clients in get test: ", cs)

	if len(*cs) != 2 || (*cs)[0].ClientID != 3 {
		t.Fail()
	}
}

func TestOauthManagerClient_GetClientSearch(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var rows [][]string
	row1 := []string{"3", "secret", "tester", "tester.com", "t@t.com", "true", "false"}
	rows = append(rows, row1)
	row2 := []string{"4", "secret", "tester", "tester.com", "t@t.com", "true", "false"}
	rows = append(rows, row2)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	// var mGetRow db.DbRow
	// mGetRow.Row = []string{"2", "secret", "tester", "tester.com", "t@t.com", "true", "false"}
	// mydb.MockRow1 = &mGetRow

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	cs := m.GetClientSearchList("tester")
	fmt.Println("clients in get test: ", cs)

	if len(*cs) != 2 || (*cs)[0].ClientID != 3 {
		t.Fail()
	}
}

func TestOauthManagerClient_DeleteClient(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow
	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	// mydb.MockInsertID1 = 2
	// mydb.MockInsertSuccess2 = true
	// mydb.MockInsertID2 = 2

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	suc := m.DeleteClient(2)
	if !suc {
		t.Fail()
	}
}
package managers

import (
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerAllowedURI_AddClientAllowedURI(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertID1 = 2
	mydb.MockInsertSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var cu ClientAllowedURI
	cu.URI = "testuri"
	cu.ClientID = 2
	suc, id := m.AddClientAllowedURI(&cu)
	if !suc || id != 2 {
		t.Fail()
	}
}

func TestOauthManagerAllowedURI_UpdateClientAllowedURI(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	mydb.MockUpdateSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var cu ClientAllowedURI
	cu.ID = 1
	cu.URI = "testuri"
	cu.ClientID = 2
	suc := m.UpdateClientAllowedURI(&cu)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerAllowedURI_GetClientAllowedURI(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	//mydb.MockUpdateSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "testUri", "3"}
	mydb.MockRow1 = &mGetRow

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	cu := m.GetClientAllowedURI(2)
	if cu.ID != 2 {
		t.Fail()
	}
}

func TestOauthManagerAllowedURI_GetClientAllowedURIList(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	//mydb.MockUpdateSuccess1 = true

	var rows [][]string
	row1 := []string{"1", "testuri1", "2"}
	rows = append(rows, row1)
	row2 := []string{"2", "testuri2", "2"}
	rows = append(rows, row2)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	// var mGetRow db.DbRow
	// mGetRow.Row = []string{"2", "testUri", "3"}
	// mydb.MockRow1 = &mGetRow

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	cul := m.GetClientAllowedURIList(2)
	if len(*cul) != 2 || (*cul)[1].ID != 2 {
		t.Fail()
	}
}

func TestOauthManagerAllowedURI_DeleteClientAllowedURI(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	mydb.MockDeleteSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	suc := m.DeleteClientAllowedURI(2)
	if !suc {
		t.Fail()
	}
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//ValidateAccessTokenReq ValidateAccessTokenReq
type ValidateAccessTokenReq struct {
	AccessToken string `json:"accessToken"`
	Hashed      bool   `json:"hashed"`
	UserID      string `json:"userId"`
	ClientID    int64  `json:"clientId"`
	Role        string `json:"role"`
	URI         string `json:"url"`
	Scope       string `json:"scope"`
}

//ValidateAccessToken ValidateAccessToken
func (m *OauthManager) ValidateAccessToken(at *ValidateAccessTokenReq) bool {
	var rtn bool
	//fix issue with no user needed with client grant
	//fmt.Println("log level in validate token: ", m.Log.LogLevel)
	m.Log.Debug("at role", at.Role)
	if at.AccessToken != "" && at.ClientID != 0 {
		var userID string
		if at.Hashed && at.UserID != "" {
			userID = unHashUser(at.UserID)
			m.Log.Debug("unhashed user: ", userID)
		} else {
			userID = at.UserID
		}
		tkkey := m.Db.GetAccessTokenKey()
		m.Log.Debug("tkkey", tkkey)
		atsuc, pwatpl := m.ValidateJwt(at.AccessToken, tkkey)
		m.Log.Debug("atsuc", atsuc)
		m.Log.Debug("userPass", userID == unHashUser(pwatpl.UserID))
		m.Log.Debug("user", userID)
		m.Log.Debug("userUnhash", unHashUser(pwatpl.UserID))
		m.Log.Debug("pwatpl.UserID", pwatpl.UserID)
		m.Log.Info("pwatpl", *pwatpl)
		var noUser bool
		if pwatpl.UserID == "" || at.UserID == "" {
			noUser = true
		}
		m.Log.Debug("noUser", noUser)
		if m.isAcceptable(atsuc, noUser, userID, pwatpl, at) {
			// if atsuc && (noUser || userID == unHashUser(pwatpl.UserID)) && pwatpl.TokenType == accessTokenType &&
			// 	pwatpl.ClientID == at.ClientID && pwatpl.Issuer == tokenIssuer {
			m.Log.Debug("inside if")
			var roleFound bool
			var scopeFound bool
			roleFound = m.findRole(pwatpl, at)
			// if at.Role != "" && at.URI != "" {
			// 	for _, r := range pwatpl.RoleURIs {
			// 		if r.Role == at.Role && r.ClientAllowedURI == at.URI {
			// 			roleFound = true
			// 			break
			// 		}
			// 	}
			// } else {
			// 	roleFound = true
			// }
			m.Log.Debug("at.Scope", at.Scope)
			scopeFound = m.findScope(pwatpl, at)
			// if at.Scope != "" {
			// 	var foundWrite bool
			// 	for _, s := range pwatpl.ScopeList {
			// 		if s == "write" {
			// 			foundWrite = true
			// 		}
			// 		if s == at.Scope {
			// 			scopeFound = true
			// 			//break
			// 		}
			// 	}
			// 	if at.Scope == "read" && foundWrite {
			// 		scopeFound = true
			// 	}
			// } else {
			// 	for _, s := range pwatpl.ScopeList {
			// 		if s == "write" {
			// 			scopeFound = true
			// 			break
			// 		}
			// 	}
			// }
			m.Log.Debug("roleFound", roleFound)
			m.Log.Debug("scopeFound", scopeFound)
			if (pwatpl.Grant == codeGrantType || pwatpl.Grant == implicitGrantType) && roleFound && scopeFound {
				rtn = true
			} else if (pwatpl.Grant == clientGrantType || pwatpl.Grant == passwordGrantType) && roleFound {
				rtn = true
			}
		}
	}
	return rtn
}

func (m *OauthManager) findRole(pwatpl *Payload, at *ValidateAccessTokenReq) bool {
	var roleFound bool
	if at.Role != "" && at.URI != "" {
		for _, r := range pwatpl.RoleURIs {
			if r.Role == at.Role && r.ClientAllowedURI == at.URI {
				roleFound = true
				break
			}
		}
	} else {
		roleFound = true
	}
	return roleFound
}

func (m *OauthManager) findScope(pwatpl *Payload, at *ValidateAccessTokenReq) bool {
	var scopeFound bool
	if at.Scope != "" {
		var foundWrite bool
		for _, s := range pwatpl.ScopeList {
			if s == "write" {
				foundWrite = true
			}
			if s == at.Scope {
				scopeFound = true
				//break
			}
		}
		if at.Scope == "read" && foundWrite {
			scopeFound = true
		}
	} else {
		for _, s := range pwatpl.ScopeList {
			if s == "write" {
				scopeFound = true
				break
			}
		}
	}
	return scopeFound
}

func (m *OauthManager) isAcceptable(atsuc bool, noUser bool, userID string, pwatpl *Payload, at *ValidateAccessTokenReq) bool {
	var rtn bool
	if atsuc && (noUser || userID == unHashUser(pwatpl.UserID)) && pwatpl.TokenType == accessTokenType &&
		pwatpl.ClientID == at.ClientID && pwatpl.Issuer == tokenIssuer {
		rtn = true
	}
	return rtn
}
package managers

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"testing"

	px "github.com/Ulbora/GoProxy"
	au "github.com/Ulbora/auth_interface"
	dau "github.com/Ulbora/default_auth"
)

func TestOauthManagerLogin_UserLogin(t *testing.T) {
	// var gp px.MockGoProxy
	// gp.MockDoSuccess1 = true
	// gp.MockRespCode = 200
	var proxy px.GoProxy
	var da dau.MockDefaultAuth
	da.MockValid = true
	da.AuthServerURL = authenticationServiceLocal
	da.Proxy = proxy.GetNewProxy()
	//ai := da.GetNew()

	var res http.Response
	res.Body = ioutil.NopCloser(bytes.NewBufferString(`{"valid":true, "code":"1"}`))
	//gp.MockResp = &res
	var man OauthManager
	man.AuthService = da.GetNew()
	//man.Proxy = gp.GetNewProxy()
	var m Manager
	m = &man
	var l au.Login
	l.Username = "admin"
	l.Password = "admin"
	l.ClientID = 10
	suc := m.UserLogin(&l)
	fmt.Println("suc: ", suc)
	if !suc {
		t.Fail()
	}
}

// func TestOauthManagerLogin_UserLoginEnvBadUrl(t *testing.T) {
// 	os.Setenv("AUTHENTICATION_SERVICE", "://localhost:3001/rs/user/login")
// 	// var gp px.MockGoProxy
// 	// gp.MockDoSuccess1 = true
// 	// gp.MockRespCode = 200
// 	var proxy px.GoProxy
// 	var da dau.MockDefaultAuth
// 	da.MockValid = false
// 	da.AuthServerURL = authenticationServiceLocal
// 	da.Proxy = proxy.GetNewProxy()
// 	var res http.Response
// 	res.Body = ioutil.NopCloser(bytes.NewBufferString(`{"valid":true, "code":"1"}`))
// 	//gp.MockResp = &res
// 	var man OauthManager
// 	man.AuthService = da.GetNew()
// 	//man.Proxy = gp.GetNewProxy()
// 	var m Manager
// 	m = &man
// 	var l au.Login
// 	l.Username = "ken"
// 	l.Password = "ken"
// 	l.ClientID = 1
// 	suc := m.UserLogin(&l)
// 	if suc {
// 		t.Fail()
// 	}
// }
//Package managers ...
package managers

import (
	"time"

	"github.com/Ulbora/GoAuth2/oauth2database"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//AuthCode AuthCode
type AuthCode struct {
	ClientID    int64
	UserID      string
	Scope       string
	RedirectURI string
	CallbackURI string
}

//AuthCodeClient AuthCodeClient
type AuthCodeClient struct {
	Valid      bool
	ClientName string
	WebSite    string
}

//AuthorizeAuthCode AuthorizeAuthCode
func (m *OauthManager) AuthorizeAuthCode(ac *AuthCode) (success bool, authCode int64, authCodeString string) {
	client := m.Db.GetClient(ac.ClientID)
	if client.Enabled {
		rtu := m.Db.GetClientRedirectURI(ac.ClientID, ac.RedirectURI)
		if rtu.ID > 0 {
			gton := m.grantTypeTurnedOn(ac.ClientID, codeGrantType)
			m.Log.Debug("grant turned on: ", gton)
			if gton {
				acode := m.Db.GetAuthorizationCode(ac.ClientID, ac.UserID)
				m.Log.Debug("acode: ", acode)
				var scopeStrList []string
				if len(*acode) > 0 && (*acode)[0].AuthorizationCode != 0 {
					scopeList := m.Db.GetAuthorizationCodeScopeList((*acode)[0].AuthorizationCode)
					m.Log.Debug("scopeList: ", scopeList)
					var scopeFound bool
					for _, s := range *scopeList {
						if s.Scope == ac.Scope {
							scopeFound = true
							break
						}
					}
					m.Log.Debug("scopeFound: ", scopeFound)
					for _, s := range *scopeList {
						scopeStrList = append(scopeStrList, s.Scope)
					}
					if scopeFound {
						success, authCode, authCodeString = m.processAuthCodeInsert(ac, &scopeStrList, true)
					} else {
						scopeStrList = append(scopeStrList, ac.Scope)
						success, authCode, authCodeString = m.processAuthCodeInsert(ac, &scopeStrList, true)
					}
				} else {
					scopeStrList = append(scopeStrList, ac.Scope)
					success, authCode, authCodeString = m.processAuthCodeInsert(ac, &scopeStrList, false)
				}
			}
		}
	}

	return success, authCode, authCodeString
}

//CheckAuthCodeApplicationAuthorization CheckAuthCodeApplicationAuthorization
func (m *OauthManager) CheckAuthCodeApplicationAuthorization(ac *AuthCode) (authorized bool) {
	if ac.ClientID != 0 && ac.UserID != "" && ac.Scope != "" {
		facs := m.Db.GetAuthorizationCodeByScope(ac.ClientID, ac.UserID, ac.Scope)
		if len(*facs) > 0 && (*facs)[0].AuthorizationCode != 0 {
			authorized = true
		}
	}
	return authorized
}

//ValidateAuthCodeClientAndCallback ValidateAuthCodeClientAndCallback
func (m *OauthManager) ValidateAuthCodeClientAndCallback(ac *AuthCode) *AuthCodeClient {
	var rtn AuthCodeClient
	if ac.ClientID != 0 && ac.RedirectURI != "" {
		cru := m.Db.GetClientRedirectURI(ac.ClientID, ac.RedirectURI)
		m.Log.Debug("cru: ", cru)
		if cru.ID > 0 && cru.URI == ac.RedirectURI && cru.ClientID == ac.ClientID {
			c := m.Db.GetClient(ac.ClientID)
			if c.Enabled {
				rtn.Valid = true
				rtn.ClientName = c.Name
				rtn.WebSite = c.WebSite
			}
		}
	}
	return &rtn
}

func (m *OauthManager) processAuthCodeInsert(ac *AuthCode, scopeStrList *[]string, existingAuthCode bool) (success bool, authCode int64, authCodeString string) {
	var acdel bool
	if existingAuthCode {
		acdel = m.Db.DeleteAuthorizationCode(ac.ClientID, ac.UserID)
		m.Log.Debug("acdel: ", acdel)
	} else {
		acdel = true
	}
	if acdel {
		refToken := m.GenerateRefreshToken(ac.ClientID, hashUser(ac.UserID), codeGrantType)
		m.Log.Info("refToken:", refToken)
		if refToken != "" {
			roleURIList := m.Db.GetClientRoleAllowedURIListByClientID(ac.ClientID)
			m.Log.Debug("roleURIList", roleURIList)
			var pl Payload
			pl.TokenType = accessTokenType
			pl.UserID = hashUser(ac.UserID)
			pl.ClientID = ac.ClientID
			pl.Subject = codeGrantType
			pl.ExpiresInMinute = codeAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
			pl.Grant = codeGrantType
			pl.RoleURIs = *m.populateRoleURLList(roleURIList)
			pl.ScopeList = *scopeStrList
			accessToken := m.GenerateAccessToken(&pl)
			m.Log.Info("accessToken: ", accessToken)
			if accessToken != "" {
				var code odb.AuthorizationCode
				code.ClientID = ac.ClientID
				code.UserID = ac.UserID
				code.RandonAuthCode = generateRandonAuthCode()
				now := time.Now()
				code.Expires = now.Add(time.Minute * authCodeLifeInMinutes)

				var aToken odb.AccessToken
				aToken.Token = accessToken
				aToken.Expires = now.Add(time.Minute * codeAccessTokenLifeInMinutes)

				var rToken odb.RefreshToken
				rToken.Token = refToken
				acSuc, acID := m.Db.AddAuthorizationCode(&code, &aToken, &rToken, scopeStrList)
				m.Log.Debug("acSuc: ", acSuc)
				m.Log.Debug("acID: ", acID)
				if acSuc {
					newRanCode := generateAuthCodeString(acID, code.RandonAuthCode)
					var uac odb.AuthorizationCode
					uac.AuthorizationCode = acID
					uac.RandonAuthCode = newRanCode
					usuc := m.Db.UpdateAuthorizationCode(&uac)
					m.Log.Debug("update success: ", usuc)
					if usuc {
						success = usuc
						authCode = acID
						authCodeString = newRanCode
					}
				}
			}
		}
	}
	return success, authCode, authCodeString
}

func (m *OauthManager) populateRoleURLList(rl *[]oauth2database.RoleURI) *[]RoleURI {
	var rtn []RoleURI
	for _, r := range *rl {
		var ru RoleURI
		ru.ClientRoleID = r.ClientRoleID
		ru.Role = r.Role
		ru.ClientAllowedURIID = r.ClientAllowedURIID
		ru.ClientAllowedURI = r.ClientAllowedURI
		ru.ClientID = r.ClientID
		rtn = append(rtn, ru)
	}
	return &rtn
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	//"fmt"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//ClientGrantType ClientGrantType
type ClientGrantType struct {
	ID        int64  `json:"id"`
	GrantType string `json:"grantType"`
	ClientID  int64  `json:"clientId"`
}

//AddClientGrantType AddClientGrantType
func (m *OauthManager) AddClientGrantType(gt *ClientGrantType) (bool, int64) {
	var cgt odb.ClientGrantType
	cgt.GrantType = gt.GrantType
	cgt.ClientID = gt.ClientID
	suc, id := m.Db.AddClientGrantType(&cgt)
	return suc, id
}

func (m *OauthManager) grantTypeTurnedOn(clientID int64, grantType string) bool {
	var rtn bool
	gtlist := m.Db.GetClientGrantTypeList(clientID)
	for _, gt := range *gtlist {
		if gt.GrantType == grantType {
			rtn = true
		}
	}
	return rtn
}

//GetClientGrantTypeList GetClientGrantTypeList
func (m *OauthManager) GetClientGrantTypeList(clientID int64) *[]ClientGrantType {
	var rtn = []ClientGrantType{}
	gtl := m.Db.GetClientGrantTypeList(clientID)
	for _, gt := range *gtl {
		var g ClientGrantType
		g.ID = gt.ID
		g.GrantType = gt.GrantType
		g.ClientID = gt.ClientID
		rtn = append(rtn, g)
	}
	return &rtn
}

//DeleteClientGrantType DeleteClientGrantType
func (m *OauthManager) DeleteClientGrantType(id int64) bool {
	suc := m.Db.DeleteClientGrantType(id)
	return suc
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	//"fmt"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//ClientAllowedURI ClientAllowedURI
type ClientAllowedURI struct {
	ID       int64  `json:"id"`
	URI      string `json:"uri"`
	ClientID int64  `json:"clientId"`
}

//AddClientAllowedURI AddClientAllowedURI
func (m *OauthManager) AddClientAllowedURI(au *ClientAllowedURI) (bool, int64) {
	var cu odb.ClientAllowedURI
	cu.URI = au.URI
	cu.ClientID = au.ClientID
	suc, id := m.Db.AddClientAllowedURI(&cu)
	return suc, id
}

//UpdateClientAllowedURI UpdateClientAllowedURI
func (m *OauthManager) UpdateClientAllowedURI(au *ClientAllowedURI) bool {
	var cu odb.ClientAllowedURI
	cu.URI = au.URI
	cu.ID = au.ID
	suc := m.Db.UpdateClientAllowedURI(&cu)
	return suc
}

//GetClientAllowedURI GetClientAllowedURI
func (m *OauthManager) GetClientAllowedURI(id int64) *ClientAllowedURI {
	var rtn ClientAllowedURI
	au := m.Db.GetClientAllowedURIByID(id)
	rtn.ID = au.ID
	rtn.URI = au.URI
	rtn.ClientID = au.ClientID
	return &rtn
}

//GetClientAllowedURIList GetClientAllowedURIList
func (m *OauthManager) GetClientAllowedURIList(clientID int64) *[]ClientAllowedURI {
	var rtn = []ClientAllowedURI{}
	aul := m.Db.GetClientAllowedURIList(clientID)
	for _, au := range *aul {
		var u ClientAllowedURI
		u.ID = au.ID
		u.URI = au.URI
		u.ClientID = au.ClientID
		rtn = append(rtn, u)
	}
	return &rtn
}

//DeleteClientAllowedURI DeleteClientAllowedURI
func (m *OauthManager) DeleteClientAllowedURI(id int64) bool {
	suc := m.Db.DeleteClientAllowedURI(id)
	return suc
}
package managers

import (
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerURI_AddClientRedirectURI(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertID1 = 2
	mydb.MockInsertSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var uri ClientRedirectURI
	uri.URI = "test"
	suc, id := m.AddClientRedirectURI(&uri)
	if !suc || id != 2 {
		t.Fail()
	}

}

func TestOauthManagerURI_GetClientRedirectURI(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	// mydb.MockInsertID1 = 2
	// mydb.MockInsertSuccess1 = true

	var rows [][]string
	row1 := []string{"1", "testUrl", "2"}
	rows = append(rows, row1)
	row2 := []string{"2", "testUrl", "3"}
	rows = append(rows, row2)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	ul := m.GetClientRedirectURIList(2)
	if len(*ul) > 2 || (*ul)[1].ID != 2 {
		t.Fail()
	}

}

func TestOauthManagerURI_DeleteClientRedirectURI(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	mydb.MockDeleteSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var uri ClientRedirectURI
	uri.URI = "test"
	suc := m.DeleteClientRedirectURI(5)
	if !suc {
		t.Fail()
	}

}
package managers

import (
	"fmt"
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerAccessToken_GenerateAccessToken(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var m OauthManager
	var l lg.Logger
	l.LogLevel = lg.AllLevel
	m.Log = &l
	moadb.Log = &l
	m.Db = odbAu
	var pl Payload
	pl.TokenType = codeGrantType
	pl.UserID = "tester1"
	pl.ClientID = 125
	pl.Subject = "code"
	//pl.Issuer = tokenIssuer
	//pl.Audience = tokenAudience
	pl.ExpiresInMinute = codeAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = codeGrantType
	var ruList []RoleURI
	var ru1 RoleURI
	ru1.ClientRoleID = 1
	ru1.Role = "user"
	ru1.ClientAllowedURIID = 2
	ru1.ClientAllowedURI = "test.com"
	ru1.ClientID = 5
	ruList = append(ruList, ru1)

	var ru2 RoleURI
	ru2.ClientRoleID = 12
	ru2.Role = "user"
	ru2.ClientAllowedURIID = 21
	ru2.ClientAllowedURI = "test2.com"
	ru2.ClientID = 5
	ruList = append(ruList, ru2)

	pl.RoleURIs = ruList

	pl.ScopeList = []string{"web", "rest"}
	//pl.SecretKey = rtk
	token := m.GenerateAccessToken(&pl)
	if token == "" {
		t.Fail()
	} else {
		fmt.Println("accessToken in test: ", token)
	}

	valid, val := m.ValidateJwt(token, "6g651dfg6gf6")
	if !valid || val.UserID != "tester1" {
		t.Fail()
	}
}

func TestOauthManagerAccessToken_GenerateAccessTokenEnvVar(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var m OauthManager
	var tkp TokenParams
	tkp.AccessTokenKey = "12345"
	tkp.Issuer = "testIss"
	tkp.Audience = "testAud"
	m.TokenParams = &tkp
	var l lg.Logger
	l.LogLevel = lg.AllLevel
	m.Log = &l
	moadb.Log = &l
	m.Db = odbAu
	var pl Payload
	pl.TokenType = codeGrantType
	pl.UserID = "tester1"
	pl.ClientID = 125
	pl.Subject = "code"
	//pl.Issuer = tokenIssuer
	//pl.Audience = tokenAudience
	pl.ExpiresInMinute = codeAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = codeGrantType
	var ruList []RoleURI
	var ru1 RoleURI
	ru1.ClientRoleID = 1
	ru1.Role = "user"
	ru1.ClientAllowedURIID = 2
	ru1.ClientAllowedURI = "test.com"
	ru1.ClientID = 5
	ruList = append(ruList, ru1)

	var ru2 RoleURI
	ru2.ClientRoleID = 12
	ru2.Role = "user"
	ru2.ClientAllowedURIID = 21
	ru2.ClientAllowedURI = "test2.com"
	ru2.ClientID = 5
	ruList = append(ruList, ru2)

	pl.RoleURIs = ruList

	pl.ScopeList = []string{"web", "rest"}
	//pl.SecretKey = rtk
	token := m.GenerateAccessToken(&pl)
	if token == "" {
		t.Fail()
	} else {
		fmt.Println("accessToken in test: ", token)
	}
	valid, val := m.ValidateJwt(token, "12345")
	if !valid || val.UserID != "tester1" {
		t.Fail()
	}
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//GenerateRefreshToken GenerateRefreshToken
func (m *OauthManager) GenerateRefreshToken(clientID int64, userID string, grantType string) string {
	var token string
	m.Log.Debug("m.TokenParams: ", m.TokenParams)
	var theKey string
	var theIssuer string
	var theAudience string
	if m.TokenParams != nil && m.TokenParams.RefreshTokenKey != "" {
		theKey = m.TokenParams.RefreshTokenKey
	} else {
		theKey = m.Db.GetRefreshTokenKey()
	}
	if m.TokenParams != nil && m.TokenParams.Issuer != "" {
		theIssuer = m.TokenParams.Issuer
	} else {
		theIssuer = tokenIssuer
	}
	if m.TokenParams != nil && m.TokenParams.Audience != "" {
		theAudience = m.TokenParams.Audience
	} else {
		theAudience = tokenAudience
	}
	//rtk := m.Db.GetRefreshTokenKey()
	//if rtk != "" {
	// here write code to generate refresh token
	var pl Payload
	pl.TokenType = refreshTokenType
	pl.UserID = userID
	pl.ClientID = clientID
	pl.Subject = grantType
	pl.Issuer = theIssuer
	pl.Audience = theAudience
	pl.ExpiresInMinute = refreshTokenLifeInMinutes //(600 * time.Minute) => (600 * 60) => 36000 minutes => 10 hours
	pl.Grant = grantType
	pl.SecretKey = theKey
	token = m.GenerateJwtToken(&pl)
	//}
	return token
}
//Package managers ...
package managers

import (
	"fmt"
	"testing"
)

func Test_generateClientSecret(t *testing.T) {
	sec := generateClientSecret()
	fmt.Println("secret :", sec)
	if len(sec) < 50 {
		t.Fail()
	}
}

func Test_generateRandonAuthCode(t *testing.T) {
	sec := generateClientSecret()
	fmt.Println("random :", sec)
	if len(sec) < 20 {
		t.Fail()
	}
}

func Test_hashUser(t *testing.T) {
	h := hashUser("kenz")
	fmt.Println("hash :", h)
	if h != "oir~" {
		t.Fail()
	}
}

func Test_unHashUser(t *testing.T) {
	h := unHashUser("oir~")
	fmt.Println("hash :", h)
	if h != "kenz" {
		t.Fail()
	}
}
package managers

import au "github.com/Ulbora/auth_interface"

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//MockManager MockManager
type MockManager struct {
	MockInsertSuccess1 bool
	MockInsertID1      int64

	MockUpdateSuccess1 bool
	MockDeleteSuccess1 bool

	MockClient     Client
	MockClientList []Client

	MockClientRedirectURIList []ClientRedirectURI
	MockClientRoleList        []ClientRole

	MockClientAllowedURI     ClientAllowedURI
	MockClientAllowedURIList []ClientAllowedURI

	MockClientRoleURIList []ClientRoleURI

	MockClientGrantTypeList []ClientGrantType

	MockAuthCodeAuthorizeSuccess bool
	MockAuthCode                 int64
	MockAuthCodeString           string

	MockAuthCodeAuthorized bool

	MockAuthCodeClient AuthCodeClient

	MockImplicitAuthorizeSuccess bool
	MockImplicitReturn           ImplicitReturn
	MockImplicitAuthorized       bool
	MockImplicitClient           ImplicitClient

	MockToken                       Token
	MockAuthCodeTokenSuccess        bool
	MockCredentialsTokenSuccess     bool
	MockPasswordTokenSuccess        bool
	MockAuthCodeRefreshTokenSuccess bool
	MockPasswordRefreshTokenSuccess bool

	MockTokenError string

	MockValidateAccessTokenSuccess bool

	MockUserLoginSuccess bool
}

//client

//AddClient AddClient
func (m *MockManager) AddClient(client *Client) (bool, int64) {
	return m.MockInsertSuccess1, m.MockInsertID1
}

//UpdateClient UpdateClient
func (m *MockManager) UpdateClient(client *Client) bool {
	return m.MockUpdateSuccess1
}

//GetClient GetClient
func (m *MockManager) GetClient(id int64) *Client {
	return &m.MockClient
}

//GetClientList GetClientList
func (m *MockManager) GetClientList() *[]Client {
	return &m.MockClientList
}

//GetClientSearchList GetClientSearchList
func (m *MockManager) GetClientSearchList(name string) *[]Client {
	return &m.MockClientList
}

//DeleteClient DeleteClient
func (m *MockManager) DeleteClient(id int64) bool {
	return m.MockDeleteSuccess1
}

//client redirect uri

//AddClientRedirectURI AddClientRedirectURI
func (m *MockManager) AddClientRedirectURI(ru *ClientRedirectURI) (bool, int64) {
	return m.MockInsertSuccess1, m.MockInsertID1
}

//GetClientRedirectURIList GetClientRedirectURIList
func (m *MockManager) GetClientRedirectURIList(clientID int64) *[]ClientRedirectURI {
	return &m.MockClientRedirectURIList
}

//DeleteClientRedirectURI DeleteClientRedirectURI
func (m *MockManager) DeleteClientRedirectURI(id int64) bool {
	return m.MockDeleteSuccess1
}

//client roles

//AddClientRole AddClientRole
func (m *MockManager) AddClientRole(r *ClientRole) (bool, int64) {
	return m.MockInsertSuccess1, m.MockInsertID1
}

//GetClientRoleList GetClientRoleList
func (m *MockManager) GetClientRoleList(clientID int64) *[]ClientRole {
	return &m.MockClientRoleList
}

//DeleteClientRole DeleteClientRole
func (m *MockManager) DeleteClientRole(id int64) bool {
	return m.MockDeleteSuccess1
}

//client allowed uri

//AddClientAllowedURI AddClientAllowedURI
func (m *MockManager) AddClientAllowedURI(au *ClientAllowedURI) (bool, int64) {
	return m.MockInsertSuccess1, m.MockInsertID1
}

//UpdateClientAllowedURI UpdateClientAllowedURI
func (m *MockManager) UpdateClientAllowedURI(au *ClientAllowedURI) bool {
	return m.MockUpdateSuccess1
}

//GetClientAllowedURI GetClientAllowedURI
func (m *MockManager) GetClientAllowedURI(id int64) *ClientAllowedURI {
	return &m.MockClientAllowedURI
}

//GetClientAllowedURIList GetClientAllowedURIList
func (m *MockManager) GetClientAllowedURIList(clientID int64) *[]ClientAllowedURI {
	return &m.MockClientAllowedURIList
}

//DeleteClientAllowedURI DeleteClientAllowedURI
func (m *MockManager) DeleteClientAllowedURI(id int64) bool {
	return m.MockDeleteSuccess1
}

//client role uri

//AddClientRoleURI AddClientRoleURI
func (m *MockManager) AddClientRoleURI(r *ClientRoleURI) bool {
	return m.MockInsertSuccess1
}

//GetClientRoleAllowedURIList GetClientRoleAllowedURIList
func (m *MockManager) GetClientRoleAllowedURIList(roleID int64) *[]ClientRoleURI {
	return &m.MockClientRoleURIList
}

//DeleteClientRoleURI DeleteClientRoleURI
func (m *MockManager) DeleteClientRoleURI(r *ClientRoleURI) bool {
	return m.MockDeleteSuccess1
}

//client grant type

//AddClientGrantType AddClientGrantType
func (m *MockManager) AddClientGrantType(gt *ClientGrantType) (bool, int64) {
	return m.MockInsertSuccess1, m.MockInsertID1
}

//GetClientGrantTypeList GetClientGrantTypeList
func (m *MockManager) GetClientGrantTypeList(clientID int64) *[]ClientGrantType {
	return &m.MockClientGrantTypeList
}

//DeleteClientGrantType DeleteClientGrantType
func (m *MockManager) DeleteClientGrantType(id int64) bool {
	return m.MockDeleteSuccess1
}

//auth code

//AuthorizeAuthCode AuthorizeAuthCode
func (m *MockManager) AuthorizeAuthCode(ac *AuthCode) (success bool, authCode int64, authCodeString string) {
	return m.MockAuthCodeAuthorizeSuccess, m.MockAuthCode, m.MockAuthCodeString
}

//CheckAuthCodeApplicationAuthorization CheckAuthCodeApplicationAuthorization
func (m *MockManager) CheckAuthCodeApplicationAuthorization(ac *AuthCode) (authorized bool) {
	return m.MockAuthCodeAuthorized
}

//ValidateAuthCodeClientAndCallback ValidateAuthCodeClientAndCallback
func (m *MockManager) ValidateAuthCodeClientAndCallback(ac *AuthCode) *AuthCodeClient {
	return &m.MockAuthCodeClient
}

//implicit

//AuthorizeImplicit AuthorizeImplicit
func (m *MockManager) AuthorizeImplicit(imp *Implicit) (bool, *ImplicitReturn) {
	return m.MockImplicitAuthorizeSuccess, &m.MockImplicitReturn
}

//CheckImplicitApplicationAuthorization CheckImplicitApplicationAuthorization
func (m *MockManager) CheckImplicitApplicationAuthorization(imp *Implicit) (authorized bool) {
	return m.MockImplicitAuthorized
}

//ValidateImplicitClientAndCallback ValidateImplicitClientAndCallback
func (m *MockManager) ValidateImplicitClientAndCallback(imp *Implicit) *ImplicitClient {
	return &m.MockImplicitClient
}

//token manager

//GetAuthCodeToken GetAuthCodeToken
func (m *MockManager) GetAuthCodeToken(act *AuthCodeTokenReq) (bool, *Token, string) {
	return m.MockAuthCodeTokenSuccess, &m.MockToken, m.MockTokenError
}

//GetCredentialsToken GetCredentialsToken
func (m *MockManager) GetCredentialsToken(ct *CredentialsTokenReq) (bool, *Token, string) {
	return m.MockCredentialsTokenSuccess, &m.MockToken, m.MockTokenError
}

//GetPasswordToken GetPasswordToken
func (m *MockManager) GetPasswordToken(pt *PasswordTokenReq) (bool, *Token, string) {
	return m.MockPasswordTokenSuccess, &m.MockToken, m.MockTokenError
}

//GetAuthCodeAccesssTokenWithRefreshToken GetAuthCodeAccesssTokenWithRefreshToken
func (m *MockManager) GetAuthCodeAccesssTokenWithRefreshToken(rt *RefreshTokenReq) (bool, *Token, string) {
	return m.MockAuthCodeRefreshTokenSuccess, &m.MockToken, m.MockTokenError
}

//GetPasswordAccesssTokenWithRefreshToken GetPasswordAccesssTokenWithRefreshToken
func (m *MockManager) GetPasswordAccesssTokenWithRefreshToken(rt *RefreshTokenReq) (bool, *Token, string) {
	return m.MockPasswordRefreshTokenSuccess, &m.MockToken, m.MockTokenError
}

//validate Token

//ValidateAccessToken ValidateAccessToken
func (m *MockManager) ValidateAccessToken(at *ValidateAccessTokenReq) bool {
	return m.MockValidateAccessTokenSuccess
}

//UserLogin UserLogin
func (m *MockManager) UserLogin(login *au.Login) bool {
	return m.MockUserLoginSuccess
}
package managers

import (
	"fmt"
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//var token string

func TestOauthManagerRefToken_GenerateRefreshToken(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var m OauthManager
	var l lg.Logger
	m.Log = &l
	moadb.Log = &l
	m.Db = odbAu
	token := m.GenerateRefreshToken(125, "tester1", "code")
	if token == "" {
		t.Fail()
	} else {
		fmt.Println("refreshToken in test: ", token)
	}

	valid, val := m.ValidateJwt(token, "6g651dfg6gf6")
	if !valid || val.UserID != "tester1" {
		t.Fail()
	}
}

func TestOauthManagerRefToken_GenerateRefreshTokenEnvVar(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var m OauthManager
	var tkp TokenParams
	tkp.RefreshTokenKey = "12345"
	tkp.Issuer = "testIss"
	tkp.Audience = "testAud"
	m.TokenParams = &tkp
	var l lg.Logger
	m.Log = &l
	moadb.Log = &l
	m.Db = odbAu
	token := m.GenerateRefreshToken(125, "tester1", "code")
	if token == "" {
		t.Fail()
	} else {
		fmt.Println("refreshToken in test: ", token)
	}

	valid, val := m.ValidateJwt(token, "12345")
	if !valid || val.UserID != "tester1" {
		t.Fail()
	}
}
//Package managers ...
package managers

import (
	"fmt"
	"testing"

	au "github.com/Ulbora/auth_interface"
)

func TestMockManager_AddClient(t *testing.T) {
	var man MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 1
	var m Manager
	m = &man
	var c Client

	suc, id := m.AddClient(&c)
	if !suc || id != 1 {
		t.Fail()
	}
}

func TestMockManager_UpdateClient(t *testing.T) {
	var man MockManager
	man.MockUpdateSuccess1 = true

	var m Manager
	m = &man
	var c Client

	suc := m.UpdateClient(&c)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_GetClient(t *testing.T) {
	var c Client
	c.ClientID = 1
	var man MockManager
	man.MockClient = c

	var m Manager
	m = &man

	clt := m.GetClient(2)
	if clt.ClientID != 1 {
		t.Fail()
	}
}

func TestMockManager_GetClientList(t *testing.T) {
	var c Client
	var cl = []Client{c}
	var man MockManager
	man.MockClientList = cl

	var m Manager
	m = &man

	clt := m.GetClientList()
	if clt == nil || len(*clt) != 1 {
		t.Fail()
	}
}

func TestMockManager_GetClientSearchList(t *testing.T) {
	var c Client
	var cl = []Client{c}
	var man MockManager
	man.MockClientList = cl

	var m Manager
	m = &man

	clt := m.GetClientSearchList("test")
	if clt == nil || len(*clt) != 1 {
		t.Fail()
	}
}

func TestMockManager_DeleteClient(t *testing.T) {
	var man MockManager
	man.MockDeleteSuccess1 = true

	var m Manager
	m = &man

	suc := m.DeleteClient(1)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_AddClientRedirectURI(t *testing.T) {
	var man MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 1
	var m Manager
	m = &man
	var c ClientRedirectURI

	suc, id := m.AddClientRedirectURI(&c)
	if !suc || id != 1 {
		t.Fail()
	}
}

func TestMockManager_GetClientRedirectURIList(t *testing.T) {
	var c ClientRedirectURI
	var cl = []ClientRedirectURI{c}
	var man MockManager
	man.MockClientRedirectURIList = cl

	var m Manager
	m = &man

	clt := m.GetClientRedirectURIList(1)
	if clt == nil || len(*clt) != 1 {
		t.Fail()
	}
}

func TestMockManager_DeleteClientRedirectURI(t *testing.T) {
	var man MockManager
	man.MockDeleteSuccess1 = true

	var m Manager
	m = &man

	suc := m.DeleteClientRedirectURI(1)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_AddClientRole(t *testing.T) {
	var man MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 1
	var m Manager
	m = &man
	var c ClientRole

	suc, id := m.AddClientRole(&c)
	if !suc || id != 1 {
		t.Fail()
	}
}

func TestMockManager_GetClientRoleList(t *testing.T) {
	var c ClientRole
	var cl = []ClientRole{c}
	var man MockManager
	man.MockClientRoleList = cl

	var m Manager
	m = &man

	clt := m.GetClientRoleList(1)
	if clt == nil || len(*clt) != 1 {
		t.Fail()
	}
}

func TestMockManager_DeleteClientRole(t *testing.T) {
	var man MockManager
	man.MockDeleteSuccess1 = true

	var m Manager
	m = &man

	suc := m.DeleteClientRole(1)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_AddClientAllowedURI(t *testing.T) {
	var man MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 1
	var m Manager
	m = &man
	var c ClientAllowedURI

	suc, id := m.AddClientAllowedURI(&c)
	if !suc || id != 1 {
		t.Fail()
	}
}

func TestMockManager_UpdateClientAllowedURI(t *testing.T) {
	var man MockManager
	man.MockUpdateSuccess1 = true

	var m Manager
	m = &man
	var c ClientAllowedURI

	suc := m.UpdateClientAllowedURI(&c)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_GetClientAllowedURI(t *testing.T) {
	var c ClientAllowedURI
	c.ID = 2
	var man MockManager
	man.MockClientAllowedURI = c

	var m Manager
	m = &man

	clt := m.GetClientAllowedURI(2)
	fmt.Println("clt: ", clt)
	if clt.ID != 2 {
		t.Fail()
	}
}

func TestMockManager_GetClientAllowedURIList(t *testing.T) {
	var c ClientAllowedURI
	var cl = []ClientAllowedURI{c}
	var man MockManager
	man.MockClientAllowedURIList = cl

	var m Manager
	m = &man

	clt := m.GetClientAllowedURIList(1)
	if clt == nil || len(*clt) != 1 {
		t.Fail()
	}
}

func TestMockManager_DeleteClientAllowedURI(t *testing.T) {
	var man MockManager
	man.MockDeleteSuccess1 = true

	var m Manager
	m = &man

	suc := m.DeleteClientAllowedURI(1)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_AddClientRoleURI(t *testing.T) {
	var man MockManager
	man.MockInsertSuccess1 = true
	var m Manager
	m = &man
	var c ClientRoleURI

	suc := m.AddClientRoleURI(&c)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_GetClientRoleAllowedURIList(t *testing.T) {
	var c ClientRoleURI
	var cl = []ClientRoleURI{c}
	var man MockManager
	man.MockClientRoleURIList = cl

	var m Manager
	m = &man

	clt := m.GetClientRoleAllowedURIList(1)
	if clt == nil || len(*clt) != 1 {
		t.Fail()
	}
}

func TestMockManager_DeleteClientRoleURI(t *testing.T) {
	var man MockManager
	man.MockDeleteSuccess1 = true

	var m Manager
	m = &man
	var cr ClientRoleURI

	suc := m.DeleteClientRoleURI(&cr)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_AddClientGrantType(t *testing.T) {
	var man MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 2
	var m Manager
	m = &man
	var c ClientGrantType

	suc, id := m.AddClientGrantType(&c)
	if !suc || id != 2 {
		t.Fail()
	}
}

func TestMockManager_GetClientGrantTypeList(t *testing.T) {
	var c ClientGrantType
	var cl = []ClientGrantType{c}
	var man MockManager
	man.MockClientGrantTypeList = cl

	var m Manager
	m = &man

	clt := m.GetClientGrantTypeList(1)
	if clt == nil || len(*clt) != 1 {
		t.Fail()
	}
}

func TestMockManager_DeleteClientGrantType(t *testing.T) {
	var man MockManager
	man.MockDeleteSuccess1 = true

	var m Manager
	m = &man

	suc := m.DeleteClientGrantType(1)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_AuthorizeAuthCode(t *testing.T) {
	var man MockManager
	man.MockAuthCodeAuthorizeSuccess = true
	man.MockAuthCode = 2
	man.MockAuthCodeString = "1234"

	var m Manager
	m = &man
	var ac AuthCode
	suc, cd, cds := m.AuthorizeAuthCode(&ac)
	if !suc || cd != 2 || cds != "1234" {
		t.Fail()
	}
}

func TestMockManager_CheckAuthCodeApplicationAuthorization(t *testing.T) {
	var man MockManager
	man.MockAuthCodeAuthorized = true

	var m Manager
	m = &man
	var ac AuthCode
	suc := m.CheckAuthCodeApplicationAuthorization(&ac)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_ValidateAuthCodeClientAndCallback(t *testing.T) {
	var man MockManager
	var ac AuthCodeClient
	ac.Valid = true
	man.MockAuthCodeClient = ac

	var m Manager
	m = &man
	var acode AuthCode
	acc := m.ValidateAuthCodeClientAndCallback(&acode)
	if !acc.Valid {
		t.Fail()
	}
}

func TestMockManager_AuthorizeImplicit(t *testing.T) {
	var man MockManager
	var im1 ImplicitReturn
	im1.ID = 2
	man.MockImplicitReturn = im1
	man.MockImplicitAuthorizeSuccess = true

	var m Manager
	m = &man
	var imp Implicit
	suc, im := m.AuthorizeImplicit(&imp)
	if !suc || im.ID != 2 {
		t.Fail()
	}
}

func TestMockManager_CheckImplicitApplicationAuthorization(t *testing.T) {
	var man MockManager

	man.MockImplicitAuthorized = true

	var m Manager
	m = &man
	var imp Implicit
	suc := m.CheckImplicitApplicationAuthorization(&imp)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_ValidateImplicitClientAndCallback(t *testing.T) {
	var man MockManager
	var im1 ImplicitClient
	im1.Valid = true
	man.MockImplicitClient = im1

	var m Manager
	m = &man
	var imp Implicit
	im := m.ValidateImplicitClientAndCallback(&imp)
	if !im.Valid {
		t.Fail()
	}
}

func TestMockManager_GetAuthCodeToken(t *testing.T) {
	var man MockManager
	var tk1 Token
	tk1.AccessToken = "1234"
	man.MockToken = tk1
	man.MockAuthCodeTokenSuccess = true

	var m Manager
	m = &man
	var imp AuthCodeTokenReq
	suc, tk, _ := m.GetAuthCodeToken(&imp)
	if !suc || tk.AccessToken != "1234" {
		t.Fail()
	}
}

func TestMockManager_GetCredentialsToken(t *testing.T) {
	var man MockManager
	var tk1 Token
	tk1.AccessToken = "1234"
	man.MockToken = tk1
	man.MockCredentialsTokenSuccess = true

	var m Manager
	m = &man
	var imp CredentialsTokenReq
	suc, tk, _ := m.GetCredentialsToken(&imp)
	if !suc || tk.AccessToken != "1234" {
		t.Fail()
	}
}

func TestMockManager_GetPasswordToken(t *testing.T) {
	var man MockManager
	var tk1 Token
	tk1.AccessToken = "1234"
	man.MockToken = tk1
	man.MockPasswordTokenSuccess = true

	var m Manager
	m = &man
	var imp PasswordTokenReq
	suc, tk, _ := m.GetPasswordToken(&imp)
	if !suc || tk.AccessToken != "1234" {
		t.Fail()
	}
}

func TestMockManager_GetAuthCodeAccesssTokenWithRefreshToken(t *testing.T) {
	var man MockManager
	var tk1 Token
	tk1.AccessToken = "1234"
	man.MockToken = tk1
	man.MockAuthCodeRefreshTokenSuccess = true

	var m Manager
	m = &man
	var imp RefreshTokenReq
	suc, tk, _ := m.GetAuthCodeAccesssTokenWithRefreshToken(&imp)
	if !suc || tk.AccessToken != "1234" {
		t.Fail()
	}
}

func TestMockManager_GetPasswordAccesssTokenWithRefreshToken(t *testing.T) {
	var man MockManager
	var tk1 Token
	tk1.AccessToken = "1234"
	man.MockToken = tk1
	man.MockPasswordRefreshTokenSuccess = true

	var m Manager
	m = &man
	var imp RefreshTokenReq
	suc, tk, _ := m.GetPasswordAccesssTokenWithRefreshToken(&imp)
	if !suc || tk.AccessToken != "1234" {
		t.Fail()
	}
}

func TestMockManager_ValidateAccessToken(t *testing.T) {
	var man MockManager

	man.MockValidateAccessTokenSuccess = true

	var m Manager
	m = &man
	var imp ValidateAccessTokenReq
	suc := m.ValidateAccessToken(&imp)
	if !suc {
		t.Fail()
	}
}

func TestMockManager_UserLogin(t *testing.T) {
	var man MockManager

	man.MockUserLoginSuccess = true

	var m Manager
	m = &man
	var l au.Login
	suc := m.UserLogin(&l)
	if !suc {
		t.Fail()
	}
}
package managers

import (
	"fmt"
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerGrantType_grantTypeTurnedOn(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var rows [][]string
	row1 := []string{"1", "code", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu

	res := man.grantTypeTurnedOn(1, "code")
	fmt.Println("grant turned on: ", res)
	if !res {
		t.Fail()
	}

}

func TestOauthManagerGrantType_AddGrantType(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertID1 = 2
	mydb.MockInsertSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var gt ClientGrantType
	gt.GrantType = "code"
	gt.ClientID = 2
	suc, id := m.AddClientGrantType(&gt)
	if !suc || id != 2 {
		t.Fail()
	}
}

func TestOauthManagerGrantType_GetGrantTypeList(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	// mydb.MockInsertID1 = 2
	// mydb.MockInsertSuccess1 = true

	var rows [][]string
	row1 := []string{"1", "code", "2"}
	rows = append(rows, row1)
	row2 := []string{"2", "client", "2"}
	rows = append(rows, row2)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	gtl := m.GetClientGrantTypeList(2)
	if len(*gtl) != 2 {
		t.Fail()
	}
}

func TestOauthManagerGrantType_DeleteGrantType(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	mydb.MockDeleteSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	suc := m.DeleteClientGrantType(2)
	if !suc {
		t.Fail()
	}
}
package managers

import (
	"fmt"
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerTakenVal_ValidateAccessToken(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	man.Db = odbAu
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	var m Manager
	m = &man

	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("tester1")
	pl.ClientID = 2
	pl.Subject = passwordGrantType
	pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = passwordGrantType
	pl.Issuer = tokenIssuer
	pl.ScopeList = []string{"write"}
	//pl.RoleURIs = *m.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	fmt.Println("accessToken: ", accessToken)

	var at ValidateAccessTokenReq
	at.UserID = hashUser("tester1")
	at.Hashed = true
	at.AccessToken = accessToken
	at.ClientID = 2
	suc := m.ValidateAccessToken(&at)
	fmt.Println("suc: ", suc)
	//fmt.Println("tkn: ", tkn)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerTakenVal_ValidateAccessToken2(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var rows [][]string
	row := []string{"4", "somerole", "1", "someurl", "2"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	roleURIList := man.Db.GetClientRoleAllowedURIListByClientID(2)
	fmt.Println("roleURIList", roleURIList)
	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("tester1")
	pl.ClientID = 2
	pl.Subject = passwordGrantType
	pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = passwordGrantType
	pl.Issuer = tokenIssuer
	pl.ScopeList = []string{"web"}

	pl.RoleURIs = *man.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	fmt.Println("accessToken: ", accessToken)

	var at ValidateAccessTokenReq
	at.UserID = "tester1"
	at.Hashed = false
	at.AccessToken = accessToken
	at.ClientID = 2
	at.Scope = "web"
	at.Role = "somerole"
	at.URI = "someurl"
	suc := m.ValidateAccessToken(&at)
	fmt.Println("suc: ", suc)
	//fmt.Println("tkn: ", tkn)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerTakenVal_ValidateAccessToken3(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var rows [][]string
	row := []string{"4", "somerole", "1", "someurl", "2"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	roleURIList := man.Db.GetClientRoleAllowedURIListByClientID(2)
	fmt.Println("roleURIList", roleURIList)
	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("tester1")
	pl.ClientID = 2
	pl.Subject = implicitGrantType
	pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = implicitGrantType
	pl.Issuer = tokenIssuer
	pl.ScopeList = []string{"web"}

	pl.RoleURIs = *man.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	fmt.Println("accessToken: ", accessToken)

	var at ValidateAccessTokenReq
	at.UserID = "tester1"
	at.Hashed = false
	at.AccessToken = accessToken
	at.ClientID = 2
	at.Scope = "web"
	at.Role = "somerole"
	at.URI = "someurl"
	suc := m.ValidateAccessToken(&at)
	fmt.Println("suc: ", suc)
	//fmt.Println("tkn: ", tkn)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerTakenVal_ValidateAccessToken3a(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var rows [][]string
	row := []string{"4", "somerole", "1", "someurl", "2"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	roleURIList := man.Db.GetClientRoleAllowedURIListByClientID(2)
	fmt.Println("roleURIList", roleURIList)
	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("tester1")
	pl.ClientID = 2
	pl.Subject = implicitGrantType
	pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = implicitGrantType
	pl.Issuer = tokenIssuer
	pl.ScopeList = []string{"write"}

	pl.RoleURIs = *man.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	fmt.Println("accessToken: ", accessToken)

	var at ValidateAccessTokenReq
	at.UserID = "tester1"
	at.Hashed = false
	at.AccessToken = accessToken
	at.ClientID = 2
	at.Scope = "read"
	at.Role = "somerole"
	at.URI = "someurl"
	suc := m.ValidateAccessToken(&at)
	fmt.Println("suc: ", suc)
	//fmt.Println("tkn: ", tkn)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerTakenVal_ValidateAccessToken4(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var rows [][]string
	row := []string{"4", "somerole", "1", "someurl", "2"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	roleURIList := man.Db.GetClientRoleAllowedURIListByClientID(2)
	fmt.Println("roleURIList", roleURIList)
	var pl Payload
	pl.TokenType = accessTokenType
	//pl.UserID = hashUser("tester1")
	pl.ClientID = 2
	pl.Subject = clientGrantType
	pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = clientGrantType
	pl.Issuer = tokenIssuer
	pl.ScopeList = []string{"web"}

	pl.RoleURIs = *man.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	fmt.Println("accessToken: ", accessToken)

	var at ValidateAccessTokenReq
	//at.UserID = "tester1"
	at.Hashed = false
	at.AccessToken = accessToken
	at.ClientID = 2
	at.Scope = "web"
	at.Role = "somerole"
	at.URI = "someurl"
	suc := m.ValidateAccessToken(&at)
	fmt.Println("suc: ", suc)
	//fmt.Println("tkn: ", tkn)
	if !suc {
		t.Fail()
	}
}
package managers

import (
	"fmt"
	"testing"
	"time"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerAuthCode_AuthorizeAuthCode(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "testUri", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	//mydb.MockInsertID1 = 2
	//mydb.MockDeleteSuccess1 = true

	var rows [][]string
	row1 := []string{"1", "code", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var tt = time.Now()
	var rows2 [][]string
	row2 := []string{"1", "3", "code", tt.Format("2006-01-02 15:04:05"), "2", "test", "false", "test"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var rows3 [][]string
	row3 := []string{"1", "web", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	var rows4 [][]string
	row4 := []string{"1", "3", "code", tt.Format("2006-01-02 15:04:05"), "2", "test", "false", "test"}
	rows4 = append(rows4, row4)
	var dbrows4 db.DbRows
	dbrows4.Rows = rows4
	mydb.MockRows4 = &dbrows4

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "testUri", tt.Format("2006-01-02 15:04:05"), "2"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "testUri"}
	mydb.MockRow4 = &mGetRow4

	var mGetRow5 db.DbRow
	mGetRow5.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow5 = &mGetRow5

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true
	mydb.MockDeleteSuccess4 = true
	mydb.MockDeleteSuccess5 = true

	var rows5 [][]string
	row5 := []string{"4", "somerole", "1", "someurl", "2"}
	rows5 = append(rows5, row5)
	var dbrows5 db.DbRows
	dbrows5.Rows = rows5
	mydb.MockRows5 = &dbrows5

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 2

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 5

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 22

	mydb.MockUpdateSuccess1 = true

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ac AuthCode
	ac.ClientID = 2
	ac.UserID = "tester"
	ac.Scope = "web"
	ac.RedirectURI = "someurl.com"
	ac.CallbackURI = "someotherurl.com"
	suc, acode, cstring := m.AuthorizeAuthCode(&ac)
	fmt.Println("success: ", suc, "acode: ", acode, "cstring: ", cstring)
	if !suc || acode != 5 || cstring == "" {
		t.Fail()
	}
}

func TestOauthManagerAuthCode_AuthorizeAuthCodeNoScope(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "testUri", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	//mydb.MockInsertID1 = 2
	//mydb.MockDeleteSuccess1 = true

	var rows [][]string
	row1 := []string{"1", "code", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var tt = time.Now()
	var rows2 [][]string
	row2 := []string{"1", "3", "code", tt.Format("2006-01-02 15:04:05"), "2", "test", "false", "test"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var rows3 [][]string
	row3 := []string{"1", "web", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	var rows4 [][]string
	row4 := []string{"1", "3", "code", tt.Format("2006-01-02 15:04:05"), "2", "test", "false", "test"}
	rows4 = append(rows4, row4)
	var dbrows4 db.DbRows
	dbrows4.Rows = rows4
	mydb.MockRows4 = &dbrows4

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "testUri", tt.Format("2006-01-02 15:04:05"), "2"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "testUri"}
	mydb.MockRow4 = &mGetRow4

	var mGetRow5 db.DbRow
	mGetRow5.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow5 = &mGetRow5

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true
	mydb.MockDeleteSuccess4 = true
	mydb.MockDeleteSuccess5 = true

	var rows5 [][]string
	row5 := []string{"4", "somerole", "1", "someurl", "2"}
	rows5 = append(rows5, row5)
	var dbrows5 db.DbRows
	dbrows5.Rows = rows5
	mydb.MockRows5 = &dbrows5

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 2

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 5

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 22

	mydb.MockInsertSuccess5 = true
	mydb.MockInsertID5 = 23

	mydb.MockUpdateSuccess1 = true

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	man.Db = odbAu
	moadb.Log = &l
	var m Manager
	m = &man
	var ac AuthCode
	ac.ClientID = 2
	ac.UserID = "tester"
	ac.Scope = "facebook"
	ac.RedirectURI = "someurl.com"
	ac.CallbackURI = "someotherurl.com"
	suc, acode, cstring := m.AuthorizeAuthCode(&ac)
	fmt.Println("success: ", suc, "acode: ", acode, "cstring: ", cstring)
	if !suc || acode != 5 || cstring == "" {
		t.Fail()
	}
}

func TestOauthManagerAuthCode_AuthorizeAuthCodeNoAuthCode(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "testUri", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	//mydb.MockInsertID1 = 2
	//mydb.MockDeleteSuccess1 = true

	var rows [][]string
	row1 := []string{"1", "code", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var tt = time.Now()
	var rows2 [][]string
	row2 := []string{"0", "3", "code", tt.Format("2006-01-02 15:04:05"), "2", "test", "false", "test"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	// var rows3 [][]string
	// row3 := []string{"1", "web", "2"}
	// rows3 = append(rows3, row3)
	// var dbrows3 db.DbRows
	// dbrows3.Rows = rows3
	// mydb.MockRows3 = &dbrows3

	// var rows4 [][]string
	// row4 := []string{"1", "3", "code", tt.Format("2006-01-02 15:04:05"), "2", "test", "false", "test"}
	// rows4 = append(rows4, row4)
	// var dbrows4 db.DbRows
	// dbrows4.Rows = rows4
	// mydb.MockRows4 = &dbrows4

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "testUri", tt.Format("2006-01-02 15:04:05"), "2"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "testUri"}
	mydb.MockRow4 = &mGetRow4

	var mGetRow5 db.DbRow
	mGetRow5.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow5 = &mGetRow5

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true
	mydb.MockDeleteSuccess4 = true
	mydb.MockDeleteSuccess5 = true

	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 2

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 5

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 22

	mydb.MockInsertSuccess5 = true
	mydb.MockInsertID5 = 23

	mydb.MockUpdateSuccess1 = true

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ac AuthCode
	ac.ClientID = 2
	ac.UserID = "tester"
	ac.Scope = "facebook"
	ac.RedirectURI = "someurl.com"
	ac.CallbackURI = "someotherurl.com"
	suc, acode, cstring := m.AuthorizeAuthCode(&ac)
	fmt.Println("success: ", suc, "acode: ", acode, "cstring: ", cstring)
	if !suc || acode != 5 || cstring == "" {
		t.Fail()
	}
}

func TestOauthManagerAuthCode_CheckAuthCodeApplicationAuthorization(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var tt = time.Now()
	var rows1 [][]string
	row1 := []string{"5", "3", "code", tt.Format("2006-01-02 15:04:05"), "2", "test", "false", "test"}
	rows1 = append(rows1, row1)
	var dbrows1 db.DbRows
	dbrows1.Rows = rows1
	mydb.MockRows1 = &dbrows1

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ac AuthCode
	ac.ClientID = 2
	ac.UserID = "tester"
	ac.Scope = "facebook"
	ac.RedirectURI = "someurl.com"
	ac.CallbackURI = "someotherurl.com"
	auth := m.CheckAuthCodeApplicationAuthorization(&ac)
	fmt.Println("auth: ", auth)
	if !auth {
		t.Fail()
	}
}

func TestOauthManagerAuthCode_ValidateAuthCodeClientAndCallback(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"5", "someurl.com", "25"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"25", "secret", "testname", "testWebSite", "test", "true", "false"}
	mydb.MockRow2 = &mGetRow2

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ac AuthCode
	ac.ClientID = 25
	ac.UserID = "tester"
	//ac.Scope = "facebook"
	ac.RedirectURI = "someurl.com"
	ac.CallbackURI = "someotherurl.com"
	auth := m.ValidateAuthCodeClientAndCallback(&ac)
	fmt.Println("auth: ", auth)
	if !auth.Valid || auth.ClientName != "testname" || auth.WebSite != "testWebSite" {
		t.Fail()
	}
}
// +build integration move to top

package managers

import (
	"testing"

	"fmt"

	px "github.com/Ulbora/GoProxy"
	lg "github.com/Ulbora/Level_Logger"
	au "github.com/Ulbora/auth_interface"
	dau "github.com/Ulbora/default_auth"
)

func TestOauthManagerLoginInt_UserLogin(t *testing.T) {
	var gp px.GoProxy
	var da dau.DefaultAuth
	var authURL = "http://localhost:3001/rs/user/login"
	da.AuthServerURL = authURL
	da.Proxy = gp.GetNewProxy()
	var man OauthManager
	var ll lg.Logger
	man.Log = &ll
	//moadb.Log = &l
	man.AuthService = da.GetNew()
	//man.Proxy = gp.GetNewProxy()
	var m Manager
	m = &man
	var l au.Login
	l.Username = "admin"
	l.Password = "admin"
	l.ClientID = 10
	suc := m.UserLogin(&l)
	fmt.Println("suc: ", suc)
	if !suc {
		t.Fail()
	}
}
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	//"fmt"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//ClientRole ClientRole
type ClientRole struct {
	ID       int64  `json:"id"`
	Role     string `json:"role"`
	ClientID int64  `json:"clientId"`
}

//AddClientRole AddClientRole
func (m *OauthManager) AddClientRole(r *ClientRole) (bool, int64) {
	// var suc bool
	// var id int64
	var cr odb.ClientRole
	cr.Role = r.Role
	cr.ClientID = r.ClientID
	suc, id := m.Db.AddClientRole(&cr)
	return suc, id
}

//GetClientRoleList GetClientRoleList
func (m *OauthManager) GetClientRoleList(clientID int64) *[]ClientRole {
	var rtn = []ClientRole{}
	rl := m.Db.GetClientRoleList(clientID)
	for _, r := range *rl {
		var cr ClientRole
		cr.ID = r.ID
		cr.Role = r.Role
		cr.ClientID = r.ClientID
		rtn = append(rtn, cr)
	}
	return &rtn
}

//DeleteClientRole DeleteClientRole
func (m *OauthManager) DeleteClientRole(id int64) bool {
	suc := m.Db.DeleteClientRole(id)
	return suc
}
//Package managers ...
package managers

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//GenerateAccessToken GenerateAccessToken
func (m *OauthManager) GenerateAccessToken(pl *Payload) string {
	var token string
	m.Log.Debug("m.TokenParams: ", m.TokenParams)
	var theKey string
	var theIssuer string
	var theAudience string
	if m.TokenParams != nil && m.TokenParams.AccessTokenKey != "" {
		theKey = m.TokenParams.AccessTokenKey
	} else {
		theKey = m.Db.GetAccessTokenKey()
	}
	if m.TokenParams != nil && m.TokenParams.Issuer != "" {
		theIssuer = m.TokenParams.Issuer
	} else {
		theIssuer = tokenIssuer
	}
	if m.TokenParams != nil && m.TokenParams.Audience != "" {
		theAudience = m.TokenParams.Audience
	} else {
		theAudience = tokenAudience
	}
	//key := m.Db.GetAccessTokenKey()
	//if key != "" {
	pl.SecretKey = theKey
	pl.Subject = pl.Grant
	pl.Issuer = theIssuer
	pl.Audience = theAudience
	token = m.GenerateJwtToken(pl)
	//}
	return token
}
package managers

import (
	"fmt"
	"testing"
	"time"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerToken_GetAuthCodeToken(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var tt = time.Now()
	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{}
	mydb.MockRow4 = &getRow4

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 4

	mydb.MockUpdateSuccess1 = true

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", "someacctoken2", nowTime, "5"}
	mydb.MockRow5 = &getRow5

	var getRow6 db.DbRow
	getRow6.Row = []string{"1", "somereftoken2"}
	mydb.MockRow6 = &getRow6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var tkr AuthCodeTokenReq
	tkr.ClientID = 2
	tkr.Secret = "12345"
	tkr.Code = "5555"
	tkr.RedirectURI = "google.com"
	suc, tkn, _ := m.GetAuthCodeToken(&tkr)
	fmt.Println("auth code tkn suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeTokenNoAccessToken(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var tt = time.Now()
	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{}
	mydb.MockRow4 = &getRow4

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 4

	mydb.MockUpdateSuccess1 = true

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"0", "someacctoken2", nowTime, "5"}
	mydb.MockRow5 = &getRow5

	var getRow6 db.DbRow
	getRow6.Row = []string{"1", "somereftoken2"}
	mydb.MockRow6 = &getRow6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var tkr AuthCodeTokenReq
	tkr.ClientID = 2
	tkr.Secret = "12345"
	tkr.Code = "5555"
	tkr.RedirectURI = "google.com"
	suc, tkn, err := m.GetAuthCodeToken(&tkr)
	fmt.Println("auth code tkn suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidGrantError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeTokenUpdateFailed(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var tt = time.Now()
	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{}
	mydb.MockRow4 = &getRow4

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 4

	//mydb.MockUpdateSuccess1 = true

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", "someacctoken2", nowTime, "5"}
	mydb.MockRow5 = &getRow5

	var getRow6 db.DbRow
	getRow6.Row = []string{"1", "somereftoken2"}
	mydb.MockRow6 = &getRow6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var tkr AuthCodeTokenReq
	tkr.ClientID = 2
	tkr.Secret = "12345"
	tkr.Code = "5555"
	tkr.RedirectURI = "google.com"
	suc, tkn, err := m.GetAuthCodeToken(&tkr)
	fmt.Println("auth code tkn suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidGrantError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeTokenRevolked(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var tt = time.Now()
	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{"2", "3"}
	mydb.MockRow4 = &getRow4

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 4

	mydb.MockUpdateSuccess1 = true

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", "someacctoken2", nowTime, "5"}
	mydb.MockRow5 = &getRow5

	var getRow6 db.DbRow
	getRow6.Row = []string{"1", "somereftoken2"}
	mydb.MockRow6 = &getRow6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var tkr AuthCodeTokenReq
	tkr.ClientID = 2
	tkr.Secret = "12345"
	tkr.Code = "5555"
	tkr.RedirectURI = "google.com"
	suc, tkn, err := m.GetAuthCodeToken(&tkr)
	fmt.Println("auth code tkn suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidClientError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeTokenBadClient(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var tt = time.Now()
	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{}
	mydb.MockRow4 = &getRow4

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 4

	mydb.MockUpdateSuccess1 = true

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", "someacctoken2", nowTime, "5"}
	mydb.MockRow5 = &getRow5

	var getRow6 db.DbRow
	getRow6.Row = []string{"1", "somereftoken2"}
	mydb.MockRow6 = &getRow6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var tkr AuthCodeTokenReq
	tkr.ClientID = 1
	tkr.Secret = "12345"
	tkr.Code = "5555"
	tkr.RedirectURI = "google.com"
	suc, tkn, err := m.GetAuthCodeToken(&tkr)
	fmt.Println("auth code tkn suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidClientError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeTokenBadRedirect(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"0", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var tt = time.Now()
	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{}
	mydb.MockRow4 = &getRow4

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 4

	mydb.MockUpdateSuccess1 = true

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", "someacctoken2", nowTime, "5"}
	mydb.MockRow5 = &getRow5

	var getRow6 db.DbRow
	getRow6.Row = []string{"1", "somereftoken2"}
	mydb.MockRow6 = &getRow6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var tkr AuthCodeTokenReq
	tkr.ClientID = 2
	tkr.Secret = "12345"
	tkr.Code = "5555"
	tkr.RedirectURI = "google.com"
	suc, tkn, err := m.GetAuthCodeToken(&tkr)
	fmt.Println("auth code tkn suc: ", suc)
	fmt.Println("tkn: ", tkn)
	fmt.Println("err: ", err)
	if suc || err != "invalid_grant" {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeTokenBadSecret(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var tt = time.Now()
	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{}
	mydb.MockRow4 = &getRow4

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 4

	mydb.MockUpdateSuccess1 = true

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", "someacctoken2", nowTime, "5"}
	mydb.MockRow5 = &getRow5

	var getRow6 db.DbRow
	getRow6.Row = []string{"1", "somereftoken2"}
	mydb.MockRow6 = &getRow6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var tkr AuthCodeTokenReq
	tkr.ClientID = 2
	tkr.Secret = ""
	tkr.Code = "5555"
	tkr.RedirectURI = "google.com"
	suc, tkn, err := m.GetAuthCodeToken(&tkr)
	fmt.Println("auth code tkn suc: ", suc)
	fmt.Println("tkn: ", tkn)
	fmt.Println("err: ", err)
	if suc || err != "invalid_client" {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeTokenAlreadUsed(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var tt = time.Now()
	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "true"}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{}
	mydb.MockRow4 = &getRow4

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 4

	mydb.MockUpdateSuccess1 = true

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", "someacctoken2", nowTime, "5"}
	mydb.MockRow5 = &getRow5

	var getRow6 db.DbRow
	getRow6.Row = []string{"1", "somereftoken2"}
	mydb.MockRow6 = &getRow6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var tkr AuthCodeTokenReq
	tkr.ClientID = 2
	tkr.Secret = "12345"
	tkr.Code = "5555"
	tkr.RedirectURI = "google.com"
	suc, tkn, err := m.GetAuthCodeToken(&tkr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidClientError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeTokenNoRefresh(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "testUri", "2"}
	mydb.MockRow2 = &mGetRow2

	var tt = time.Now()
	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{}
	mydb.MockRow4 = &getRow4

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 4

	mydb.MockUpdateSuccess1 = true

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", "someacctoken2", nowTime, "0"}
	mydb.MockRow5 = &getRow5

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var tkr AuthCodeTokenReq
	tkr.ClientID = 2
	tkr.Secret = "12345"
	tkr.Code = "5555"
	tkr.RedirectURI = "google.com"
	suc, tkn, _ := m.GetAuthCodeToken(&tkr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if !suc {
		t.Fail()
	}
}

func TestOauthManagerToken_GetCredToken(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "client_credentials", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	//get cred grant for del
	var rows2 [][]string
	row2 := []string{"1", "2", "2"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true

	//ClientRoleAllowedURIList
	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	//access token key
	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ctr CredentialsTokenReq
	ctr.ClientID = 2
	ctr.Secret = "12345"
	suc, tkn, _ := m.GetCredentialsToken(&ctr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if !suc || tkn.TokenType != "bearer" {
		t.Fail()
	}
}

func TestOauthManagerToken_GetCredTokenDeleteFailed(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "client_credentials", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	//get cred grant for del
	var rows2 [][]string
	row2 := []string{"1", "2", "2"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	//mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true

	//ClientRoleAllowedURIList
	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	//access token key
	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ctr CredentialsTokenReq
	ctr.ClientID = 2
	ctr.Secret = "12345"
	suc, tkn, err := m.GetCredentialsToken(&ctr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != accessDeniedError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetCredTokenGrantOff(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "client_credentials111", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	//get cred grant for del
	var rows2 [][]string
	row2 := []string{"1", "2", "2"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true

	//ClientRoleAllowedURIList
	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	//access token key
	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ctr CredentialsTokenReq
	ctr.ClientID = 2
	ctr.Secret = "12345"
	suc, tkn, err := m.GetCredentialsToken(&ctr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != accessDeniedError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetCredTokenBadSecret(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "client_credentials", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	//get cred grant for del
	var rows2 [][]string
	row2 := []string{"1", "2", "2"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true

	//ClientRoleAllowedURIList
	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	//access token key
	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ctr CredentialsTokenReq
	ctr.ClientID = 2
	ctr.Secret = ""
	suc, tkn, err := m.GetCredentialsToken(&ctr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidClientError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeWithRefToken(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	var tt = time.Now()
	// var getRow4 db.DbRow
	// getRow4.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	// mydb.MockRow4 = &getRow4
	var rows [][]string
	row1 := []string{"1", "2", "12345", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("12345")
	pl.ClientID = 2
	pl.Subject = codeGrantType
	pl.ExpiresInMinute = codeAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = codeGrantType
	//pl.RoleURIs = *m.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", accessToken, nowTime, "5"}
	mydb.MockRow5 = &getRow5

	rtoken := man.GenerateRefreshToken(2, hashUser("12345"), "code")
	fmt.Println("rtoken: ", rtoken)

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	var mGetRow7 db.DbRow
	mGetRow7.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow7 = &mGetRow7

	mydb.MockUpdateSuccess1 = true
	mydb.MockUpdateSuccess2 = true

	var rtr RefreshTokenReq
	rtr.ClientID = 2
	rtr.Secret = "12345"
	rtr.RefreshToken = rtoken
	suc, tkn, _ := m.GetAuthCodeAccesssTokenWithRefreshToken(&rtr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if !suc || tkn.TokenType != "bearer" {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeWithRefTokenTokenNotValid(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	var tt = time.Now()
	// var getRow4 db.DbRow
	// getRow4.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	// mydb.MockRow4 = &getRow4
	var rows [][]string
	row1 := []string{"1", "2", "12345", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("12345")
	pl.ClientID = 2
	pl.Subject = codeGrantType
	pl.ExpiresInMinute = codeAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = codeGrantType
	//pl.RoleURIs = *m.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", accessToken, nowTime, "5"}
	mydb.MockRow5 = &getRow5

	rtoken := man.GenerateRefreshToken(2, hashUser("12345"), "code2")
	fmt.Println("rtoken: ", rtoken)

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	var mGetRow7 db.DbRow
	mGetRow7.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow7 = &mGetRow7

	mydb.MockUpdateSuccess1 = true
	mydb.MockUpdateSuccess2 = true

	var rtr RefreshTokenReq
	rtr.ClientID = 2
	rtr.Secret = "12345"
	rtr.RefreshToken = rtoken
	suc, tkn, err := m.GetAuthCodeAccesssTokenWithRefreshToken(&rtr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidClientError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeWithRefTokenNoTokenKey(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", ""}
	mydb.MockRow4 = &mGetRow4

	var tt = time.Now()
	// var getRow4 db.DbRow
	// getRow4.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	// mydb.MockRow4 = &getRow4
	var rows [][]string
	row1 := []string{"1", "2", "12345", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("12345")
	pl.ClientID = 2
	pl.Subject = codeGrantType
	pl.ExpiresInMinute = codeAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = codeGrantType
	//pl.RoleURIs = *m.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", accessToken, nowTime, "5"}
	mydb.MockRow5 = &getRow5

	rtoken := man.GenerateRefreshToken(2, hashUser("12345"), "code")
	fmt.Println("rtoken: ", rtoken)

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	var mGetRow7 db.DbRow
	mGetRow7.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow7 = &mGetRow7

	mydb.MockUpdateSuccess1 = true
	mydb.MockUpdateSuccess2 = true

	var rtr RefreshTokenReq
	rtr.ClientID = 2
	rtr.Secret = "12345"
	rtr.RefreshToken = rtoken
	suc, tkn, err := m.GetAuthCodeAccesssTokenWithRefreshToken(&rtr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidClientError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeWithRefTokenBadSecret(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "12345", "test", "test", "test", "false", "false"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	var tt = time.Now()
	// var getRow4 db.DbRow
	// getRow4.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	// mydb.MockRow4 = &getRow4
	var rows [][]string
	row1 := []string{"1", "2", "12345", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("12345")
	pl.ClientID = 2
	pl.Subject = codeGrantType
	pl.ExpiresInMinute = codeAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = codeGrantType
	//pl.RoleURIs = *m.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", accessToken, nowTime, "5"}
	mydb.MockRow5 = &getRow5

	rtoken := man.GenerateRefreshToken(2, hashUser("12345"), "code")
	fmt.Println("rtoken: ", rtoken)

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	var mGetRow7 db.DbRow
	mGetRow7.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow7 = &mGetRow7

	mydb.MockUpdateSuccess1 = true
	mydb.MockUpdateSuccess2 = true

	var rtr RefreshTokenReq
	rtr.ClientID = 2
	rtr.Secret = "12345"
	rtr.RefreshToken = rtoken
	suc, tkn, err := m.GetAuthCodeAccesssTokenWithRefreshToken(&rtr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidClientError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetAuthCodeWithRefTokenBadClient(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	var tt = time.Now()
	// var getRow4 db.DbRow
	// getRow4.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	// mydb.MockRow4 = &getRow4
	var rows [][]string
	row1 := []string{"1", "2", "12345", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("12345")
	pl.ClientID = 2
	pl.Subject = codeGrantType
	pl.ExpiresInMinute = codeAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = codeGrantType
	//pl.RoleURIs = *m.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", accessToken, nowTime, "5"}
	mydb.MockRow5 = &getRow5

	rtoken := man.GenerateRefreshToken(2, hashUser("12345"), "code")
	fmt.Println("rtoken: ", rtoken)

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	var mGetRow7 db.DbRow
	mGetRow7.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow7 = &mGetRow7

	mydb.MockUpdateSuccess1 = true
	mydb.MockUpdateSuccess2 = true

	var rtr RefreshTokenReq
	rtr.ClientID = 0
	rtr.Secret = "12345"
	rtr.RefreshToken = rtoken
	suc, tkn, err := m.GetAuthCodeAccesssTokenWithRefreshToken(&rtr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidRequestError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetPasseordToken(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "password", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	//get cred grant for del
	var rows2 [][]string
	row2 := []string{"1", "2", "tester1", "2"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow2 db.DbRow
	getRow2.Row = []string{"2", "someacctoken2", nowTime, "1"}
	mydb.MockRow2 = &getRow2

	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "somereftoken2"}
	mydb.MockRow3 = &getRow3

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true

	//ClientRoleAllowedURIList
	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	//access token key
	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	var mGetRow5 db.DbRow
	mGetRow5.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow5 = &mGetRow5

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ptr PasswordTokenReq
	ptr.ClientID = 2
	ptr.Username = "tester1"
	suc, tkn, _ := m.GetPasswordToken(&ptr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if !suc || tkn.TokenType != "bearer" {
		t.Fail()
	}
}

func TestOauthManagerToken_GetPasseordTokenAddFailed(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "password", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	//get cred grant for del
	var rows2 [][]string
	row2 := []string{"1", "2", "tester1", "2"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow2 db.DbRow
	getRow2.Row = []string{"2", "someacctoken2", nowTime, "1"}
	mydb.MockRow2 = &getRow2

	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "somereftoken2"}
	mydb.MockRow3 = &getRow3

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true

	//ClientRoleAllowedURIList
	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	//access token key
	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	var mGetRow5 db.DbRow
	mGetRow5.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow5 = &mGetRow5

	// mydb.MockInsertSuccess1 = true
	// mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ptr PasswordTokenReq
	ptr.ClientID = 2
	ptr.Username = "tester1"
	suc, tkn, err := m.GetPasswordToken(&ptr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != accessDeniedError {
		t.Fail()
	}
}
func TestOauthManagerToken_GetPasseordTokenDeleteFailed(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "password", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	//get cred grant for del
	var rows2 [][]string
	row2 := []string{"1", "2", "tester1", "2"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow2 db.DbRow
	getRow2.Row = []string{"2", "someacctoken2", nowTime, "1"}
	mydb.MockRow2 = &getRow2

	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "somereftoken2"}
	mydb.MockRow3 = &getRow3

	//mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true

	//ClientRoleAllowedURIList
	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	//access token key
	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	var mGetRow5 db.DbRow
	mGetRow5.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow5 = &mGetRow5

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ptr PasswordTokenReq
	ptr.ClientID = 2
	ptr.Username = "tester1"
	suc, tkn, err := m.GetPasswordToken(&ptr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != accessDeniedError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetPasseordTokenGrantOff(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "password1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	//get cred grant for del
	var rows2 [][]string
	row2 := []string{"1", "2", "tester1", "2"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow2 db.DbRow
	getRow2.Row = []string{"2", "someacctoken2", nowTime, "1"}
	mydb.MockRow2 = &getRow2

	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "somereftoken2"}
	mydb.MockRow3 = &getRow3

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true

	//ClientRoleAllowedURIList
	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	//access token key
	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	var mGetRow5 db.DbRow
	mGetRow5.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow5 = &mGetRow5

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ptr PasswordTokenReq
	ptr.ClientID = 2
	ptr.Username = "tester1"
	suc, tkn, err := m.GetPasswordToken(&ptr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != accessDeniedError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetPasseordTokenDisabledClient(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow db.DbRow
	mGetRow.Row = []string{"2", "12345", "test", "test", "test", "false", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "password", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	//get cred grant for del
	var rows2 [][]string
	row2 := []string{"1", "2", "tester1", "2"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow2 db.DbRow
	getRow2.Row = []string{"2", "someacctoken2", nowTime, "1"}
	mydb.MockRow2 = &getRow2

	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "somereftoken2"}
	mydb.MockRow3 = &getRow3

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true

	//ClientRoleAllowedURIList
	var rows3 [][]string
	row3 := []string{"4", "somerole", "1", "someurl", "2"}
	rows3 = append(rows3, row3)
	var dbrows3 db.DbRows
	dbrows3.Rows = rows3
	mydb.MockRows3 = &dbrows3

	//access token key
	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	var mGetRow5 db.DbRow
	mGetRow5.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow5 = &mGetRow5

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 6

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man
	var ptr PasswordTokenReq
	ptr.ClientID = 2
	ptr.Username = "tester1"
	suc, tkn, err := m.GetPasswordToken(&ptr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidClientError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetPasswordWithRefToken(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	//var tt = time.Now()
	// var getRow4 db.DbRow
	// getRow4.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	// mydb.MockRow4 = &getRow4
	var rows [][]string
	row1 := []string{"1", "2", "tester1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("tester1")
	pl.ClientID = 2
	pl.Subject = passwordGrantType
	pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = passwordGrantType
	//pl.RoleURIs = *m.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", accessToken, nowTime, "5"}
	mydb.MockRow5 = &getRow5

	rtoken := man.GenerateRefreshToken(2, hashUser("tester1"), "password")
	fmt.Println("rtoken: ", rtoken)

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	var mGetRow7 db.DbRow
	mGetRow7.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow7 = &mGetRow7

	mydb.MockUpdateSuccess1 = true
	// mydb.MockUpdateSuccess2 = true

	var rtr RefreshTokenReq
	rtr.ClientID = 2
	//rtr.Secret = "12345"
	rtr.RefreshToken = rtoken
	suc, tkn, _ := m.GetPasswordAccesssTokenWithRefreshToken(&rtr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if !suc || tkn.TokenType != "bearer" {
		t.Fail()
	}
}

func TestOauthManagerToken_GetPasswordWithRefTokenBadKey(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", ""}
	mydb.MockRow4 = &mGetRow4

	//var tt = time.Now()
	// var getRow4 db.DbRow
	// getRow4.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	// mydb.MockRow4 = &getRow4
	var rows [][]string
	row1 := []string{"1", "2", "tester1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("tester1")
	pl.ClientID = 2
	pl.Subject = passwordGrantType
	pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = passwordGrantType
	//pl.RoleURIs = *m.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", accessToken, nowTime, "5"}
	mydb.MockRow5 = &getRow5

	rtoken := man.GenerateRefreshToken(2, hashUser("tester1"), "password")
	fmt.Println("rtoken: ", rtoken)

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	var mGetRow7 db.DbRow
	mGetRow7.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow7 = &mGetRow7

	mydb.MockUpdateSuccess1 = true
	// mydb.MockUpdateSuccess2 = true

	var rtr RefreshTokenReq
	rtr.ClientID = 2
	//rtr.Secret = "12345"
	rtr.RefreshToken = rtoken
	suc, tkn, err := m.GetPasswordAccesssTokenWithRefreshToken(&rtr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidClientError {
		t.Fail()
	}
}

func TestOauthManagerToken_GetPasswordWithRefTokenBadClient(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var mGetRow1 db.DbRow
	mGetRow1.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow1 = &mGetRow1

	var mGetRow2 db.DbRow
	mGetRow2.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow2 = &mGetRow2

	var mGetRow3 db.DbRow
	mGetRow3.Row = []string{"2", "12345", "test", "test", "test", "true", "false"}
	mydb.MockRow3 = &mGetRow3

	var mGetRow4 db.DbRow
	mGetRow4.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow4 = &mGetRow4

	//var tt = time.Now()
	// var getRow4 db.DbRow
	// getRow4.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "false"}
	// mydb.MockRow4 = &getRow4
	var rows [][]string
	row1 := []string{"1", "2", "tester1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var pl Payload
	pl.TokenType = accessTokenType
	pl.UserID = hashUser("tester1")
	pl.ClientID = 2
	pl.Subject = passwordGrantType
	pl.ExpiresInMinute = passwordGrantAccessTokenLifeInMinutes //(60 * time.Minute) => (60 * 60) => 3600 minutes => 1 hours
	pl.Grant = passwordGrantType
	//pl.RoleURIs = *m.populateRoleURLList(roleURIList)
	//pl.ScopeList = *scopeStrList
	accessToken := man.GenerateAccessToken(&pl)

	var nowTime = time.Now().Format(odb.TimeFormat)
	var getRow5 db.DbRow
	getRow5.Row = []string{"2", accessToken, nowTime, "5"}
	mydb.MockRow5 = &getRow5

	rtoken := man.GenerateRefreshToken(2, hashUser("tester1"), "password")
	fmt.Println("rtoken: ", rtoken)

	var mGetRow6 db.DbRow
	mGetRow6.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow6 = &mGetRow6

	var mGetRow7 db.DbRow
	mGetRow7.Row = []string{"2", "6g651dfg6gf6"}
	mydb.MockRow7 = &mGetRow7

	mydb.MockUpdateSuccess1 = true
	// mydb.MockUpdateSuccess2 = true

	var rtr RefreshTokenReq
	rtr.ClientID = 0
	//rtr.Secret = "12345"
	rtr.RefreshToken = rtoken
	suc, tkn, err := m.GetPasswordAccesssTokenWithRefreshToken(&rtr)
	fmt.Println("suc: ", suc)
	fmt.Println("tkn: ", tkn)
	if suc || err != invalidRequestError {
		t.Fail()
	}
}
package managers

import (
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"

	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

func TestOauthManagerClientRoles_AddClientRole(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertID1 = 2
	mydb.MockInsertSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	var cr ClientRole
	cr.Role = "tester"
	cr.ClientID = 3
	suc, id := m.AddClientRole(&cr)
	if !suc || id != 2 {
		t.Fail()
	}
}

func TestOauthManagerClientRoles_GetClientRole(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	// mydb.MockInsertID1 = 2
	// mydb.MockInsertSuccess1 = true

	var rows [][]string
	row1 := []string{"1", "role1", "2"}
	rows = append(rows, row1)
	row2 := []string{"2", "role2", "2"}
	rows = append(rows, row2)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	rl := m.GetClientRoleList(2)
	if len(*rl) != 2 || (*rl)[1].ID != 2 {
		t.Fail()
	}
}

func TestOauthManagerClientRoles_DeleteClientRole(t *testing.T) {

	var dbAu db.Database
	var odbAu odb.Oauth2DB
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertID1 = 2
	mydb.MockDeleteSuccess1 = true

	// var rows [][]string
	// row1 := []string{"1", "code", "2"}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows

	var moadb msdb.MySQLOauthDB
	moadb.DB = dbAu

	odbAu = &moadb

	var man OauthManager
	var l lg.Logger
	man.Log = &l
	moadb.Log = &l
	man.Db = odbAu
	var m Manager
	m = &man

	suc := m.DeleteClientRole(2)
	if !suc {
		t.Fail()
	}
}
package managers

import (
	"math/rand"
	"strconv"
	"time"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

const (
	shifter = 4
)

func generateRandonAuthCode() string {
	var text = ""
	var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
	for i := 0; i < 20; i++ {
		rand.Seed(time.Now().UnixNano())
		t := possible[rand.Intn(len(possible))]
		text += string(t)
	}
	return text
}

func generateAuthCodeString(authCode int64, randCode string) string {
	var rtn string
	if authCode != 0 && randCode != "" {
		fpart := string(randCode[0:8])
		spart := string(randCode[8:])
		cpart := strconv.FormatInt(authCode, 10)
		rtn = fpart + cpart + spart
		//fmt.Println("old authcode string: ", randCode)
		//fmt.Println("new authcode string: ", rtn)
	}

	return rtn
}

func generateClientSecret() string {
	var text = ""
	var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
	for i := 0; i < 50; i++ {
		rand.Seed(time.Now().UnixNano())
		t := possible[rand.Intn(len(possible))]
		text += string(t)
	}
	return text
}

func hashUser(username string) string {
	var rtn string
	for i := 0; i < len(username); i++ {
		//fmt.Println("username[i]: ", username[i])
		c := username[i]
		//fmt.Println("c before: ", c)
		c += shifter
		//fmt.Println("c: ", c)
		char := string(c)
		//fmt.Println("char: ", char)
		rtn += char
	}
	return rtn
}

func unHashUser(username string) string {
	var rtn string
	for i := 0; i < len(username); i++ {
		//fmt.Println("username[i]: ", username[i])
		c := username[i]
		//fmt.Println("c before: ", c)
		c -= shifter
		//fmt.Println("c: ", c)
		char := string(c)
		//fmt.Println("char: ", char)
		rtn += char
	}
	return rtn
}
package oauth2database

import (
	"time"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//Client Client
type Client struct {
	ClientID int64  `json:"clientId"`
	Secret   string `json:"secret"`
	Name     string `json:"name"`
	WebSite  string `json:"webSite"`
	Email    string `json:"email"`
	Enabled  bool   `json:"enabled"`
	Paid     bool   `json:"paid"`
}

//ClientRedirectURI ClientRedirectURI
type ClientRedirectURI struct {
	ID       int64
	URI      string
	ClientID int64
}

//ClientAllowedURI ClientAllowedURI
type ClientAllowedURI struct {
	ID       int64
	URI      string
	ClientID int64
	//Super    bool
}

//ClientRole ClientRole
type ClientRole struct {
	ID       int64
	Role     string
	ClientID int64
	//Super    bool
}

//ClientScope ClientScope
type ClientScope struct {
	ID       int64
	Scope    string
	ClientID int64
}

//ClientRoleURI ClientRoleURI
type ClientRoleURI struct {
	ClientRoleID       int64
	ClientAllowedURIID int64
}

//RoleURI RoleURI
type RoleURI struct {
	ClientRoleID       int64
	Role               string
	ClientAllowedURIID int64
	ClientAllowedURI   string
	ClientID           int64
}

//RefreshToken RefreshToken
type RefreshToken struct {
	ID    int64
	Token string
}

//AccessToken AccessToken
type AccessToken struct {
	ID             int64
	Token          string
	Expires        time.Time
	RefreshTokenID int64
}

//start on AuthCode here

//AuthorizationCode AuthorizationCode
type AuthorizationCode struct {
	AuthorizationCode int64
	ClientID          int64
	UserID            string
	Expires           time.Time
	AccessTokenID     int64
	RandonAuthCode    string
	AlreadyUsed       bool
	Scope             string
}

//AuthCodeScope AuthCodeScope
type AuthCodeScope struct {
	ID                int64
	Scope             string
	AuthorizationCode int64
}

//AuthCodeRevolk AuthCodeRevolk
type AuthCodeRevolk struct {
	ID                int64
	AuthorizationCode int64
}

//ClientGrantType ClientGrantType
type ClientGrantType struct {
	ID        int64
	GrantType string
	ClientID  int64
}

//ImplicitGrant ImplicitGrant
type ImplicitGrant struct {
	ID            int64
	ClientID      int64
	UserID        string
	AccessTokenID int64
	Scope         string
}

//here add implicit grant scope

//ImplicitScope ImplicitScope
type ImplicitScope struct {
	ID              int64
	Scope           string
	ImplicitGrantID int64
}

//PasswordGrant PasswordGrant
type PasswordGrant struct {
	ID            int64
	ClientID      int64
	UserID        string
	AccessTokenID int64
}

//CredentialsGrant CredentialsGrant
type CredentialsGrant struct {
	ID            int64
	ClientID      int64
	AccessTokenID int64
}
package oauth2database

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	dbtx "github.com/Ulbora/dbinterface"
)

const (
	//TimeFormat TimeFormat
	TimeFormat = "2006-01-02 15:04:05"
)

//Oauth2DB Oauth2DB
type Oauth2DB interface {
	//client
	AddClient(client *Client, uris *[]ClientRedirectURI) (bool, int64)
	UpdateClient(client *Client) bool
	GetClient(clientID int64) *Client
	GetClients() *[]Client
	SearchClients(name string) *[]Client
	DeleteClient(clientID int64) bool

	//Redirect URI
	AddClientRedirectURI(tx dbtx.Transaction, ru *ClientRedirectURI) (bool, int64)
	GetClientRedirectURIList(clientID int64) *[]ClientRedirectURI
	GetClientRedirectURI(clientID int64, uri string) *ClientRedirectURI
	DeleteClientRedirectURI(tx dbtx.Transaction, id int64) bool
	DeleteClientAllRedirectURI(tx dbtx.Transaction, clientID int64) bool

	//Allowed URI
	AddClientAllowedURI(au *ClientAllowedURI) (bool, int64)
	UpdateClientAllowedURI(au *ClientAllowedURI) bool
	GetClientAllowedURIByID(id int64) *ClientAllowedURI
	GetClientAllowedURIList(clientID int64) *[]ClientAllowedURI
	GetClientAllowedURI(clientID int64, uri string) *ClientAllowedURI
	DeleteClientAllowedURI(id int64) bool

	//Roles
	AddClientRole(r *ClientRole) (bool, int64)
	GetClientRoleList(clientID int64) *[]ClientRole
	DeleteClientRole(id int64) bool

	//Scope
	AddClientScope(s *ClientScope) (bool, int64)
	GetClientScopeList(clientID int64) *[]ClientScope
	DeleteClientScope(id int64) bool

	//Role URI
	AddClientRoleURI(r *ClientRoleURI) bool
	GetClientRoleAllowedURIList(roleID int64) *[]ClientRoleURI
	GetClientRoleAllowedURIListByClientID(clientID int64) *[]RoleURI
	DeleteClientRoleURI(r *ClientRoleURI) bool

	//Refresh Token
	AddRefreshToken(tx dbtx.Transaction, t *RefreshToken) (bool, int64)
	UpdateRefreshToken(t *RefreshToken) bool
	GetRefreshToken(id int64) *RefreshToken
	DeleteRefreshToken(tx dbtx.Transaction, id int64) bool

	//Access Token
	AddAccessToken(tx dbtx.Transaction, t *AccessToken) (bool, int64)
	UpdateAccessToken(tx dbtx.Transaction, t *AccessToken) bool
	GetAccessToken(id int64) *AccessToken
	DeleteAccessToken(tx dbtx.Transaction, id int64) bool

	//start on auth code

	//AuthorizationCode
	AddAuthorizationCode(code *AuthorizationCode, at *AccessToken, rt *RefreshToken, scopeList *[]string) (bool, int64)
	UpdateAuthorizationCode(code *AuthorizationCode) bool
	UpdateAuthorizationCodeAndToken(code *AuthorizationCode, at *AccessToken) bool
	GetAuthorizationCode(clientID int64, userID string) *[]AuthorizationCode
	GetAuthorizationCodeByCode(code string) *AuthorizationCode
	GetAuthorizationCodeByScope(clientID int64, userID string, scope string) *[]AuthorizationCode
	DeleteAuthorizationCode(clientID int64, userID string) bool

	//authcode revolk
	AddAuthCodeRevolk(tx dbtx.Transaction, rv *AuthCodeRevolk) (bool, int64)
	GetAuthCodeRevolk(ac int64) *AuthCodeRevolk
	DeleteAuthCodeRevolk(tx dbtx.Transaction, ac int64) bool

	//Auth code scope
	GetAuthorizationCodeScopeList(ac int64) *[]AuthCodeScope

	//grant types
	AddClientGrantType(gt *ClientGrantType) (bool, int64)
	GetClientGrantTypeList(cid int64) *[]ClientGrantType
	DeleteClientGrantType(id int64) bool

	//implicit grant
	AddImplicitGrant(ig *ImplicitGrant, at *AccessToken, scopeList *[]string) (bool, int64)
	GetImplicitGrant(clientID int64, userID string) *[]ImplicitGrant
	GetImplicitGrantByScope(clientID int64, userID string, scope string) *[]ImplicitGrant
	DeleteImplicitGrant(clientID int64, userID string) bool

	//implicit grant scope
	GetImplicitGrantScopeList(ig int64) *[]ImplicitScope

	// Password grand
	AddPasswordGrant(pwg *PasswordGrant, at *AccessToken, rt *RefreshToken) (bool, int64)
	GetPasswordGrant(clientID int64, userID string) *[]PasswordGrant
	DeletePasswordGrant(clientID int64, userID string) bool

	//credentials grant
	AddCredentialsGrant(cg *CredentialsGrant, at *AccessToken) (bool, int64)
	GetCredentialsGrant(clientID int64) *[]CredentialsGrant
	DeleteCredentialsGrant(clientID int64) bool

	// keys
	GetAccessTokenKey() string
	GetRefreshTokenKey() string
	GetSessionKey() string
}
//Package oauthclient ...
package oauthclient

import (
	"net/http"
	"strconv"
	"strings"

	cp "github.com/Ulbora/GoAuth2/compresstoken"
	m "github.com/Ulbora/GoAuth2/managers"
	lg "github.com/Ulbora/Level_Logger"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//OauthClient OauthClient
type OauthClient struct {
	Manager         m.Manager
	TokenCompressed bool
	JwtCompress     cp.JwtCompress
	Log             *lg.Logger
}

//Authorize Authorize
func (o *OauthClient) Authorize(r *http.Request, c *Claim) bool {
	var rtn bool
	var hashed bool
	tokenHeader := r.Header.Get("Authorization")
	clientIDStr := r.Header.Get("clientId")
	clientID, _ := strconv.ParseInt(clientIDStr, 10, 64)
	userID := r.Header.Get("userId")
	hashedStr := r.Header.Get("hashed")
	if hashedStr == "true" {
		hashed = true
	}
	//fmt.Println("tokenHeader", tokenHeader)
	o.Log.Debug("clientIDStr", clientIDStr)
	o.Log.Debug("clientID", clientID)
	o.Log.Debug("userID", userID)
	o.Log.Debug("hashed", hashed)
	if tokenHeader != "" {
		tokenArray := strings.Split(tokenHeader, " ")
		//fmt.Println("tokenArray", tokenArray)
		if len(tokenArray) == 2 {
			var token string
			if o.TokenCompressed {
				token = o.JwtCompress.UnCompressJwt(tokenArray[1])
			} else {
				token = tokenArray[1]
			}
			o.Log.Info("token:", token)
			var vr m.ValidateAccessTokenReq
			vr.AccessToken = token
			vr.Hashed = hashed
			vr.UserID = userID
			vr.ClientID = clientID
			vr.Role = c.Role
			vr.URI = c.URL
			vr.Scope = c.Scope
			rtn = o.Manager.ValidateAccessToken(&vr)
			o.Log.Debug("valid: ", rtn)
		}
	}
	return rtn
}

//GetNewClient GetNewClient
func (o *OauthClient) GetNewClient() Client {
	var c Client
	c = o
	return c
}
package oauthclient

import (
	"net/http"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//Claim Claim
type Claim struct {
	Role  string
	URL   string
	Scope string
}

//Client Client
type Client interface {
	Authorize(r *http.Request, c *Claim) bool
}
//Package oauthclient ...
package oauthclient

import (
	"net/http"

	m "github.com/Ulbora/GoAuth2/managers"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//MockOauthClient MockOauthClient
type MockOauthClient struct {
	Manager   m.Manager
	MockValid bool
}

//Authorize Authorize
func (o *MockOauthClient) Authorize(r *http.Request, c *Claim) bool {
	// var mrtn bool
	// var mhashed bool
	// mtokenHeader := r.Header.Get("Authorization")
	// mclientIDStr := r.Header.Get("clientId")
	// mclientID, _ := strconv.ParseInt(mclientIDStr, 10, 64)
	// muserID := r.Header.Get("userId")
	// mhashedStr := r.Header.Get("hashed")
	// if mhashedStr == "true" {
	// 	mhashed = true
	// }
	// fmt.Println("tokenHeader", mtokenHeader)
	// fmt.Println("clientIDStr", mclientIDStr)
	// fmt.Println("clientID", mclientID)
	// fmt.Println("userID", muserID)
	// fmt.Println("hashed", mhashed)
	// if mtokenHeader != "" {
	// 	mtokenArray := strings.Split(mtokenHeader, " ")
	// 	fmt.Println("tokenArray", mtokenArray)
	// 	if len(mtokenArray) == 2 {
	// 		fmt.Println("tokenArray[1]", mtokenArray[1])
	// 		mrtn = o.MockValid
	// 	}
	// }

	return o.MockValid
}

//GetNewClient GetNewClient
func (o *MockOauthClient) GetNewClient() Client {
	var c Client
	c = o
	return c
}
package oauthclient

import (
	"fmt"
	"net/http"
	"testing"

	cp "github.com/Ulbora/GoAuth2/compresstoken"
	m "github.com/Ulbora/GoAuth2/managers"
	lg "github.com/Ulbora/Level_Logger"
)

func TestOauthClient_Authorize(t *testing.T) {
	var man m.MockManager
	man.MockValidateAccessTokenSuccess = true

	var oc OauthClient
	oc.Manager = &man
	var l lg.Logger
	oc.Log = &l
	//oc.TokenCompressed = true
	c := oc.GetNewClient()
	var cl Claim
	cl.Role = "testRole"
	cl.URL = "testURL"
	cl.Scope = "web"
	r, _ := http.NewRequest("GET", "/testurl", nil)
	r.Header.Set("Authorization", "Bearer jdljdfldjslkjdslkldksldfks")
	r.Header.Set("hashed", "true")
	r.Header.Set("clientId", "22")
	r.Header.Set("userId", "lfo")

	suc := c.Authorize(r, &cl)
	fmt.Println("suc", suc)
	if !suc {
		t.Fail()
	}
}

func TestOauthClient_AuthorizeCompressed(t *testing.T) {
	var man m.MockManager
	man.MockValidateAccessTokenSuccess = true

	var oc OauthClient
	oc.Manager = &man
	oc.TokenCompressed = true
	var l lg.Logger
	oc.Log = &l
	c := oc.GetNewClient()
	var cl Claim
	cl.Role = "testRole"
	cl.URL = "testURL"
	cl.Scope = "web"
	var token = "jdljdfldjslkjdsdfgdfgdffgdfgfdfgdfgdfgdfgdfdfdfdfdfdfdfdfgdgdfgdffgdfgdfdfgfdfgdfdfgddddgdgdgdgdgdgdgddggdgdgdgdggdfgdfgdfgdgflkldksldfks"
	fmt.Println("len of token: ", len(token))
	var jc cp.JwtCompress
	tkn := jc.CompressJwt(token)
	fmt.Println("tkn", tkn)
	fmt.Println("len of compressed token: ", len(tkn))
	r, _ := http.NewRequest("GET", "/testurl", nil)
	r.Header.Set("Authorization", "Bearer "+tkn)
	r.Header.Set("hashed", "true")
	r.Header.Set("clientId", "22")
	r.Header.Set("userId", "lfo")

	suc := c.Authorize(r, &cl)
	fmt.Println("suc", suc)
	if !suc {
		t.Fail()
	}
}
package oauthclient

import (
	"fmt"
	"net/http"
	"testing"
	//m "github.com/Ulbora/GoAuth2/managers"
)

func TestMockOauthClient_Authorize(t *testing.T) {

	var oc MockOauthClient
	oc.MockValid = true
	c := oc.GetNewClient()
	var cl Claim
	cl.Role = "testRole"
	cl.URL = "testURL"
	cl.Scope = "web"
	r, _ := http.NewRequest("GET", "/testurl", nil)
	r.Header.Set("Authorization", "Bearer jdljdfldjslkjdslkldksldfks")
	r.Header.Set("hashed", "true")
	r.Header.Set("clientId", "22")
	r.Header.Set("userId", "lfo")

	suc := c.Authorize(r, &cl)
	fmt.Println("suc", suc)
	if !suc {
		t.Fail()
	}
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbCgti db.Database
var odbCgti odb.Oauth2DB
var cidCgti int64
var idCgti int64

func TestMySQLOauthDBCgti_ConnectClientGrantType(t *testing.T) {
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbCgti = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbCgti

	odbCgti = &moadb

	dbCgti.Connect()
}

func TestMySQLOauthDBCgti_AddClientInClientGrantType(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbCgti.AddClient(&c, nil)
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidCgti = id
	}
}
func TestMySQLOauthDBCgti_AddClientGrantType(t *testing.T) {
	var ur odb.ClientGrantType
	ur.ClientID = cidCgti
	ur.GrantType = "someGrantType"
	res, id := odbCgti.AddClientGrantType(&ur)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idCgti = id
	}
}

func TestMySQLOauthDBCgti_GetClientGrantTypeList(t *testing.T) {
	res := odbCgti.GetClientGrantTypeList(cidCgti)
	fmt.Println("grant type list res: ", res)
	if res == nil || (*res)[0].ClientID != cidCgti {
		t.Fail()
	}
}

func TestMySQLOauthDBCgti_DeleteClientGrantType(t *testing.T) {
	res := odbCgti.DeleteClientGrantType(idCgti)
	fmt.Println("client grant type  delete: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBCgti_DeleteClientInClientGrantType(t *testing.T) {
	suc := odbCgti.DeleteClient(cidCgti)
	if !suc {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//AddPasswordGrant AddPasswordGrant
func (d *MySQLOauthDB) AddPasswordGrant(pwg *odb.PasswordGrant, at *odb.AccessToken, rt *odb.RefreshToken) (bool, int64) {
	var suc bool
	var id int64
	if !d.testConnection() {
		d.DB.Connect()
	}
	tx := d.DB.BeginTransaction()
	var cont bool
	if rt != nil && rt.Token != "" {
		rtsuc, rtID := d.AddRefreshToken(tx, rt)
		d.Log.Debug("refTk res: ", rtsuc)
		d.Log.Debug("refTk id: ", rtID)
		if rtsuc {
			at.RefreshTokenID = rtID
			cont = true
		}
	} else {
		cont = true
	}
	if cont {
		atsuc, atID := d.AddAccessToken(tx, at)
		d.Log.Debug("atTk res: ", atsuc)
		d.Log.Debug("atTk id: ", atID)
		if atsuc {
			pwg.AccessTokenID = atID
			var a []interface{}
			a = append(a, pwg.ClientID, pwg.UserID, pwg.AccessTokenID)
			suc, id = tx.Insert(insertPasswordGrant, a...)
			d.Log.Debug("pwg res: ", suc)
			d.Log.Debug("pwg id: ", id)
			if suc {
				tx.Commit()
			} else {
				id = 0
				d.Log.Debug("pw grant rolling back: ", suc)
				tx.Rollback()
			}
		} else {
			tx.Rollback()
		}
	} else {
		tx.Rollback()
	}
	return suc, id
}

//GetPasswordGrant GetPasswordGrant
func (d *MySQLOauthDB) GetPasswordGrant(clientID int64, userID string) *[]odb.PasswordGrant {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.PasswordGrant
	var a []interface{}
	a = append(a, clientID, userID)
	rows := d.DB.GetList(getPasswordGrant, a...)
	d.Log.Debug("rows in getbyscope: ", rows)
	d.Log.Debug("rows", rows)
	d.Log.Debug("rows", len(rows.Rows))
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		d.Log.Debug("foundRows in getbyscope: ", foundRows)
		for r := range foundRows {
			foundRow := foundRows[r]
			d.Log.Debug("foundRows in get pg len: ", len(foundRow))
			if len(foundRow) > 0 {
				d.Log.Debug("foundRow in getbyscope: ", foundRow)
				pgID, err := strconv.ParseInt((foundRow)[0], 10, 64)
				if err == nil {
					cid, err := strconv.ParseInt((foundRow)[1], 10, 64)
					if err == nil {
						tid, err := strconv.ParseInt((foundRow)[3], 10, 64)
						if err == nil {
							var rtnc odb.PasswordGrant
							rtnc.ID = pgID
							rtnc.ClientID = cid
							rtnc.UserID = (foundRow)[2]
							rtnc.AccessTokenID = tid
							d.Log.Debug("rtnc in getbyscope: ", rtnc)
							rtn = append(rtn, rtnc)
						}
					}
				}
			}
		}
	}
	d.Log.Debug("pw grant: ", rtn)
	return &rtn
}

//DeletePasswordGrant DeletePasswordGrant
func (d *MySQLOauthDB) DeletePasswordGrant(clientID int64, userID string) bool {
	var suc bool
	if !d.testConnection() {
		d.DB.Connect()
	}
	pwgList := d.GetPasswordGrant(clientID, userID)
	d.Log.Debug("pwgList: ", pwgList)
	d.Log.Debug("pwgList len: ", len(*pwgList))
	if len(*pwgList) == 0 {
		suc = true
	} else {
		for _, pw := range *pwgList {
			if pw.ID > 0 {
				at := d.GetAccessToken(pw.AccessTokenID)
				d.Log.Debug("at: ", at)
				var rtid int64
				if at.RefreshTokenID > 0 {
					rt := d.GetRefreshToken(at.RefreshTokenID)
					rtid = rt.ID
				}
				tx := d.DB.BeginTransaction()
				var a []interface{}
				a = append(a, pw.ID)
				pwgdel := tx.Delete(deletePasswordGrantByID, a...)
				d.Log.Debug("delete pwg: ", pwgdel)
				if pwgdel {
					atdel := d.DeleteAccessToken(tx, pw.AccessTokenID)
					d.Log.Debug("delete AccessToken: ", atdel)
					if atdel {
						var cont = true
						if rtid > 0 {
							cont = d.DeleteRefreshToken(tx, rtid)
							d.Log.Debug("delete RefreshToken: ", cont)
						}
						if cont {
							suc = true
							tx.Commit()
						} else {
							tx.Rollback()
						}
					} else {
						tx.Rollback()
					}
				} else {
					tx.Rollback()
				}
			}
		}
	}

	return suc
}
package mysqldb

import (
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbCg db.Database
var odbCg odb.Oauth2DB
var cidCg int64 = 1
var spIDCg int64
var spID2Cg int64

func TestMySQLOauthDBCg_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbCg = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbCg

	odbCg = &moadb

	dbCg.Connect()
}

func TestMySQLOauthDBCg_AddCredentialsGrant(t *testing.T) {

	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbCg = &moadb

	dbCg.Connect()

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.CredentialsGrant
	pwg.ClientID = cidCg
	res, id := odbCg.AddCredentialsGrant(&pwg, &at)
	if !res || id < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBCg_AddCredentialsGrantFail1(t *testing.T) {

	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	//mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbCg = &moadb

	dbCg.Connect()

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.CredentialsGrant
	pwg.ClientID = cidCg
	res, id := odbCg.AddCredentialsGrant(&pwg, &at)
	if res || id != 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBCg_AddCredentialsGrantFail2(t *testing.T) {

	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	//mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbCg = &moadb

	dbCg.Connect()

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.CredentialsGrant
	pwg.ClientID = cidCg
	res, id := odbCg.AddCredentialsGrant(&pwg, &at)
	if res || id != 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBCg_DeleteCredentialsGrant(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	var rows [][]string
	row := []string{"1", "2", "4"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbCg = &moadb

	dbCg.Connect()

	res := odbCg.DeleteCredentialsGrant(cidCg)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBCg_DeleteCredentialsGrant2(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	var rows [][]string
	row := []string{}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbCg = &moadb

	dbCg.Connect()

	res := odbCg.DeleteCredentialsGrant(cidCg)
	if !res {
		t.Fail()
	}
}
func TestMySQLOauthDBCg_DeleteCredentialsGrantFail1(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	//mydb.MockDeleteSuccess2 = true

	var rows [][]string
	row := []string{"1", "2", "4"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbCg = &moadb

	dbCg.Connect()

	res := odbCg.DeleteCredentialsGrant(cidCg)
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBCg_DeleteCredentialsGrantFail2(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockDeleteSuccess1 = true

	//mydb.MockDeleteSuccess2 = true

	var rows [][]string
	row := []string{"1", "2", "4"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbCg = &moadb

	dbCg.Connect()

	res := odbCg.DeleteCredentialsGrant(cidCg)
	if res {
		t.Fail()
	}
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbCgi db.Database
var odbCgi odb.Oauth2DB
var cidCgi int64
var spIDCgi int64
var spID2Cgi int64

func TestMySQLOauthDBCgi_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbCgi = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbCgi

	odbCgi = &moadb

	dbCgi.Connect()
}

func TestMySQLOauthDBCgi_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbCgi.AddClient(&c, nil)
	fmt.Println("client add res: ", res)
	fmt.Println("client id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidCgi = id
	}
}

func TestMySQLOauthDBCgi_AddCredentialsGrant(t *testing.T) {

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.CredentialsGrant
	pwg.ClientID = cidCgi
	res, id := odbCgi.AddCredentialsGrant(&pwg, &at)
	if !res || id < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBCgi_DeleteCredentialsGrant(t *testing.T) {
	res := odbCgi.DeleteCredentialsGrant(cidCgi)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBCgi_DeleteClient(t *testing.T) {
	suc := odbCgi.DeleteClient(cidCgi)
	if !suc {
		t.Fail()
	}
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbKeyi db.Database
var odbKeyi odb.Oauth2DB
var cidKeyi int64
var idKeyi int64

func TestMySQLOauthDBKeyi_ConnectAllowURI(t *testing.T) {
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbKeyi = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbKeyi

	odbKeyi = &moadb

	dbKeyi.Connect()
}

func TestMySQLOauthDBKeyi_GetAccessTokenKey(t *testing.T) {
	key := odbKeyi.GetAccessTokenKey()
	fmt.Println("access token key: ", key)
	if key == "" {
		t.Fail()
	}
}

func TestMySQLOauthDBKeyi_GetRefreshTokenKey(t *testing.T) {
	key := odbKeyi.GetRefreshTokenKey()
	fmt.Println("refresh token key: ", key)
	if key == "" {
		t.Fail()
	}
}

func TestMySQLOauthDBKeyi_GetSessionKey(t *testing.T) {
	key := odbKeyi.GetSessionKey()
	fmt.Println("session key: ", key)
	if key == "" {
		t.Fail()
	}
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbRti db.Database
var odbRti odb.Oauth2DB
var idRti int64

//var cidRti int64

func TestMySQLOauthDBReTokeni_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbRti = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbRti

	odbRti = &moadb

	dbRti.Connect()
}

func TestMySQLOauthDBReTokeni_AddRefreshToken(t *testing.T) {
	var tk odb.RefreshToken
	tk.Token = "somereftoken"
	res, id := odbRti.AddRefreshToken(nil, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idRti = id
	}
}

func TestMySQLOauthDBReTokeni_UpdateRefreshToken(t *testing.T) {
	var tk odb.RefreshToken
	tk.ID = idRti
	tk.Token = "somereftoken2"
	res := odbRti.UpdateRefreshToken(&tk)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBReTokeni_GetRefreshToken(t *testing.T) {
	res := odbRti.GetRefreshToken(idRti)
	fmt.Println("ref token: ", res)
	if res == nil || (*res).Token != "somereftoken2" {
		t.Fail()
	}
}

func TestMySQLOauthDBReTokeni_DeleteRefreshToken(t *testing.T) {
	res := odbRti.DeleteRefreshToken(nil, idRti)
	fmt.Println("del ref token: ", res)
	if !res {
		t.Fail()
	}
}
//Package mysqldb ...
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	//"fmt"

	odb "github.com/Ulbora/GoAuth2/oauth2database"

	//"log"
	"strconv"
)

//AddClient AddClient
func (d *MySQLOauthDB) AddClient(client *odb.Client, uris *[]odb.ClientRedirectURI) (bool, int64) {
	var suc = false
	//log.Println("in add client")
	if !d.testConnection() {
		d.DB.Connect()
	}
	var fail bool
	tx := d.DB.BeginTransaction()
	var a []interface{}
	a = append(a, client.Secret, client.Name, client.WebSite, client.Email, client.Enabled, client.Paid)
	succ, cid := tx.Insert(insertClient, a...)
	if succ && cid > 0 {
		//fmt.Println("cid in add client: ", cid)
		//fail = addURIs(tx, id, uris)
		if uris != nil && len(*uris) > 0 {
			for i := range *uris {
				var u = &(*uris)[i]
				//d.Tx = tx
				u.ClientID = cid
				rsus, rid := d.AddClientRedirectURI(tx, u)
				// fmt.Println("cid in add client: ", cid)
				// fmt.Println("rid in add client: ", rid)
				// fmt.Println("rsus in add client: ", rsus)
				// var au []interface{}
				// au = append(au, u.URI, id)
				// u.ClientID = id
				// rsus, rid := tx.Insert(insertRedirectURI, au...)
				if !rsus || rid <= 0 {
					tx.Rollback()
					fail = true
					break
				}
			}
		}
	} else {
		fail = true
		tx.Rollback()
	}
	if !fail {
		suc = true
		tx.Commit()
	}
	return suc, cid
}

// func addURIs(tx dbtx.Transaction, id int64, uris *[]odb.ClientRedirectURI) bool {
// 	var fail = false
// 	if uris != nil && len(*uris) > 0 {
// 		for _, u := range *uris {
// 			var au []interface{}
// 			au = append(au, u.URI, id)
// 			u.ClientID = id
// 			rsus, rid := tx.Insert(insertRedirectURI, au...)
// 			if !rsus || rid <= 0 {
// 				tx.Rollback()
// 				fail = true
// 				break
// 			}
// 		}
// 	}
// 	return fail
// }

//UpdateClient UpdateClient
func (d *MySQLOauthDB) UpdateClient(client *odb.Client) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, client.Secret, client.Name, client.WebSite, client.Email, client.Enabled, client.Paid, client.ClientID)
	suc := d.DB.Update(updateClient, a...)
	return suc
}

//GetClient GetClient
func (d *MySQLOauthDB) GetClient(clientID int64) *odb.Client {
	var rtn *odb.Client
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, clientID)
	row := d.DB.Get(getClientByID, a...)
	if row != nil && len(row.Row) != 0 {
		foundRow := row.Row
		rtn = parseClientRow(&foundRow)
		// 	int64Val, err := strconv.ParseInt(foundRow[0], 10, 64)
		// 	if err == nil {
		// 		rtn.ClientID = int64Val
		// 		rtn.Secret = foundRow[1]
		// 		rtn.Name = foundRow[2]
		// 		rtn.WebSite = foundRow[3]
		// 		rtn.Email = foundRow[4]
		// 		rtn.Enabled, _ = strconv.ParseBool(foundRow[5])
		// 		rtn.Paid, _ = strconv.ParseBool(foundRow[6])
		//}
	}

	return rtn
}

//GetClients GetClients
func (d *MySQLOauthDB) GetClients() *[]odb.Client {
	var rtn []odb.Client
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	rows := d.DB.GetList(getClientsAll, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			rowContent := parseClientRow(&foundRow)
			rtn = append(rtn, *rowContent)
		}

	}

	return &rtn
}

func parseClientRow(foundRow *[]string) *odb.Client {
	var rtn odb.Client
	if len(*foundRow) > 0 {
		int64Val, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			rtn.ClientID = int64Val
			rtn.Secret = (*foundRow)[1]
			rtn.Name = (*foundRow)[2]
			rtn.WebSite = (*foundRow)[3]
			rtn.Email = (*foundRow)[4]
			rtn.Enabled, _ = strconv.ParseBool((*foundRow)[5])
			rtn.Paid, _ = strconv.ParseBool((*foundRow)[6])
		}
	}
	return &rtn
}

//SearchClients SearchClients
func (d *MySQLOauthDB) SearchClients(name string) *[]odb.Client {
	var rtn []odb.Client
	if !d.testConnection() {
		d.DB.Connect()
	}
	var searchName = "%" + name + "%"
	//fmt.Println("searchName: ", searchName)
	var a []interface{}
	a = append(a, searchName)
	rows := d.DB.GetList(searchClientByName, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			rowContent := parseClientRow(&foundRow)
			rtn = append(rtn, *rowContent)
		}

	}
	return &rtn
}

//DeleteClient DeleteClient
func (d *MySQLOauthDB) DeleteClient(clientID int64) bool {
	var suc = false
	if !d.testConnection() {
		d.DB.Connect()
	}
	var fail = false
	tx := d.DB.BeginTransaction()
	// var au []interface{}
	// au = append(au, clientID)
	// usuc := tx.Delete(deleteAllRedirectURI, au...)
	//d.Tx = tx
	usuc := d.DeleteClientAllRedirectURI(tx, clientID)
	if usuc {
		var a []interface{}
		a = append(a, clientID)
		sucu := tx.Delete(deleteClient, a...)
		if !sucu {
			fail = true
			tx.Rollback()
		}
	} else {
		fail = true
		tx.Rollback()
	}
	if !fail {
		suc = true
		tx.Commit()
	}

	return suc
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbbUri db.Database
var odbbUri odb.Oauth2DB
var rdidi int64
var cidUri int64

func TestMySQLOauthDB_Connect(t *testing.T) {

	//var db db.Database
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbbUri = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbbUri

	odbbUri = &moadb

	dbbUri.Connect()

}

func TestMySQLOauthDB_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbbUri.AddClient(&c, nil)
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidUri = id
	}
}

func TestMySQLOauthDB_AddClientRedirectURI(t *testing.T) {
	var ur odb.ClientRedirectURI
	ur.ClientID = cidUri
	ur.URI = "someuri"
	res, id := odbbUri.AddClientRedirectURI(nil, &ur)
	if !res || id <= 0 {
		t.Fail()
	} else {
		rdidi = id
	}
}

func TestMySQLOauthDB_GetClientRedirectURIList(t *testing.T) {
	res := odbbUri.GetClientRedirectURIList(cidUri)
	fmt.Println("uri res: ", res)
	if res == nil || (*res)[0].ClientID != cidUri {
		t.Fail()
	}
}

func TestMySQLOauthDB_GetClientRedirectURI(t *testing.T) {
	res := odbbUri.GetClientRedirectURI(cidUri, "someuri")
	fmt.Println("uri res by id: ", res)
	if res == nil || (*res).ClientID != cidUri {
		t.Fail()
	}
}

func TestMySQLOauthDB_DeleteClientRedirectURI(t *testing.T) {
	res := odbbUri.DeleteClientRedirectURI(nil, rdidi)
	fmt.Println("uri  delete: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDB_DeleteClient(t *testing.T) {
	suc := odbbUri.DeleteClient(cidUri)
	if !suc {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//AddClientAllowedURI AddClientAllowedURI
func (d *MySQLOauthDB) AddClientAllowedURI(au *odb.ClientAllowedURI) (bool, int64) {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, au.URI, au.ClientID)
	suc, id := d.DB.Insert(insertAllowedURI, a...)
	return suc, id
}

//UpdateClientAllowedURI UpdateClientAllowedURI
func (d *MySQLOauthDB) UpdateClientAllowedURI(au *odb.ClientAllowedURI) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, au.URI, au.ID)
	suc := d.DB.Update(updateAllowedURI, a...)
	return suc
}

//GetClientAllowedURIByID GetClientAllowedURIByID
func (d *MySQLOauthDB) GetClientAllowedURIByID(id int64) *odb.ClientAllowedURI {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	row := d.DB.Get(getAllowedURIByID, a...)
	rtn := parseClientAllowedURIRow(&row.Row)
	return rtn
}

//GetClientAllowedURIList GetClientAllowedURIList
func (d *MySQLOauthDB) GetClientAllowedURIList(clientID int64) *[]odb.ClientAllowedURI {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.ClientAllowedURI
	var a []interface{}
	a = append(a, clientID)
	rows := d.DB.GetList(getAllowedURIList, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			rowContent := parseClientAllowedURIRow(&foundRow)
			rtn = append(rtn, *rowContent)
		}
	}
	return &rtn
}

//GetClientAllowedURI GetClientAllowedURI
func (d *MySQLOauthDB) GetClientAllowedURI(clientID int64, uri string) *odb.ClientAllowedURI {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, clientID, uri)
	row := d.DB.Get(getAllowedURI, a...)
	rtn := parseClientAllowedURIRow(&row.Row)
	return rtn
}

//DeleteClientAllowedURI DeleteClientAllowedURI
func (d *MySQLOauthDB) DeleteClientAllowedURI(id int64) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	return d.DB.Delete(deleteAllowedURI, a...)
}

func parseClientAllowedURIRow(foundRow *[]string) *odb.ClientAllowedURI {
	var rtn odb.ClientAllowedURI
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			clientID, err := strconv.ParseInt((*foundRow)[2], 10, 64)
			if err == nil {
				rtn.ID = id
				rtn.ClientID = clientID
				rtn.URI = (*foundRow)[1]
			}
		}
	}
	return &rtn
}
package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbAu db.Database
var odbAu odb.Oauth2DB
var cidAu int64
var idAu int64

func TestMySQLOauthDB_ConnectAllowURI(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAu = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockUpdateSuccess1 = true

	var getRow db.DbRow
	getRow.Row = []string{"1", "someuri2", "2"}
	mydb.MockRow1 = &getRow
	mydb.MockRow2 = &getRow

	var rows [][]string
	row1 := []string{"1", "tester5", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAu

	odbAu = &moadb

	dbAu.Connect()
}

func TestMySQLOauthDB_AddClientAllowedURI(t *testing.T) {
	cidAu = 2
	var ur odb.ClientAllowedURI
	ur.ClientID = cidAu
	ur.URI = "someuri"
	res, id := odbAu.AddClientAllowedURI(&ur)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idAu = id
	}
}

func TestMySQLOauthDB_UpdateClientAllowedURI(t *testing.T) {
	var ur odb.ClientAllowedURI
	ur.ID = idAu
	ur.URI = "someuri2"
	res := odbAu.UpdateClientAllowedURI(&ur)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDB_GetClientAllowedURIByID(t *testing.T) {
	res := odbAu.GetClientAllowedURIByID(idAu)
	fmt.Println("allowed uri res by id: ", res)
	if res == nil || (*res).ClientID != cidAu || (*res).URI != "someuri2" {
		t.Fail()
	}
}

func TestMySQLOauthDB_GetClientAllowedURIList(t *testing.T) {
	res := odbAu.GetClientAllowedURIList(cidAu)
	fmt.Println("allowed uri list res: ", res)
	if res == nil || (*res)[0].ClientID != cidAu {
		t.Fail()
	}
}

func TestMySQLOauthDB_GetClientAllowedURI(t *testing.T) {
	res := odbAu.GetClientAllowedURI(cidAu, "someuri2")
	fmt.Println("allowed uri res: ", res)
	if res == nil || (*res).ClientID != cidAu || (*res).URI != "someuri2" {
		t.Fail()
	}
}

func TestMySQLOauthDB_DeleteClientAllowedURI(t *testing.T) {
	res := odbAu.DeleteClientAllowedURI(idAu)
	fmt.Println("allowed uri  delete: ", res)
	if !res {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

const (
	oauthTest = "select count(*) from client "

	//Client queries
	insertClient = "insert into client (secret, name, web_site, email, enabled, paid) values(?, ?, ?, ?, ?, ?)"
	updateClient = " UPDATE client SET secret = ?, name = ?, web_site = ?, email = ?, " +
		" enabled = ?, paid = ? WHERE client_id = ? "
	getClientByID      = "SELECT client_id, secret, name, web_site, email, enabled, paid FROM client WHERE client_id = ?"
	getClientsAll      = "SELECT client_id, secret, name, web_site, email, enabled, paid FROM client "
	searchClientByName = "SELECT c.client_id, c.secret, c.name, c.web_site, c.email, c.enabled, c.paid " +
		"FROM client c where c.name like ? "
	deleteClient = "DELETE FROM client WHERE client_id = ? "

	//Redirect URI queries
	insertRedirectURI    = "INSERT INTO client_redirect_uri (uri, client_id) values(?, ?)"
	getRedirectURIList   = "SELECT id, uri, client_id FROM client_redirect_uri WHERE client_id = ? "
	getRedirectURI       = "SELECT id, uri, client_id FROM client_redirect_uri WHERE client_id = ? and uri = ? "
	deleteAllRedirectURI = "DELETE FROM client_redirect_uri WHERE client_id = ? "
	deleteRedirectURI    = "DELETE FROM client_redirect_uri WHERE id = ?"

	//Allowed URI queries
	insertAllowedURI  = "INSERT INTO client_allowed_uri (uri, client_id) values(?, ?) "
	updateAllowedURI  = "UPDATE client_allowed_uri SET uri = ? WHERE id = ? "
	getAllowedURIByID = "SELECT id, uri, client_id from client_allowed_uri WHERE id = ? "
	getAllowedURIList = "SELECT id, uri, client_id from client_allowed_uri WHERE client_id = ? order by uri "
	getAllowedURI     = "SELECT id, uri, client_id from client_allowed_uri WHERE client_id = ? and uri = ? "
	deleteAllowedURI  = "DELETE FROM client_allowed_uri WHERE id = ? "

	//Role
	insertRole  = "INSERT INTO client_role (role, client_id) values(?, ?) "
	getRoleList = "SELECT id, role, client_id FROM client_role WHERE client_id = ? "
	deleteRole  = "DELETE FROM client_role WHERE id = ? "

	//Scope
	insertScope  = "INSERT INTO client_scope (scope, client_id) values(?, ?) "
	getScopeList = "SELECT id, scope, client_id FROM client_scope WHERE client_id = ? "
	deleteScope  = "DELETE FROM client_scope WHERE id = ? "

	//RoleURI
	insertRoleURI  = "INSERT INTO uri_role (client_role_id, client_allowed_uri_id) values(?, ?) "
	getRoleURIList = "SELECT client_role_id, client_allowed_uri_id FROM uri_role WHERE client_role_id = ?"
	roleURIJoin    = "SELECT cr.id as role_id, cr.role, " +
		"cau.id as uri_id, cau.uri, cr.client_id " +
		"FROM client_role cr inner join " +
		"uri_role ur on cr.id = ur.client_role_id " +
		"left join client_allowed_uri cau on cau.id = ur.client_allowed_uri_id " +
		"WHERE cr.client_id = ? " +
		"order by ur.client_role_id "
	deleteRoleURI = "DELETE FROM uri_role WHERE client_role_id = ? and client_allowed_uri_id = ? "

	//Refresh Token
	insertRefreshToken = "INSERT INTO refresh_token (token) values(?)"
	updateRefreshToken = "UPDATE refresh_token SET token = ? WHERE id = ? "
	getRefreshToken    = "SELECT id, token FROM refresh_token WHERE id = ? "
	deleteRefreshToken = "DELETE FROM refresh_token WHERE id = ? "

	//Access Token
	insertAccessToken     = "INSERT INTO access_token  (token, expires, refresh_token_id) values(?, ?, ?) "
	insertAccessTokenNull = "INSERT INTO access_token  (token, expires) values(?, ?) "
	updateAccessToken     = "UPDATE access_token SET token = ?, expires = ?, refresh_token_id = ? WHERE id = ? "
	updateAccessTokenNull = "UPDATE access_token SET token = ?, expires = ? WHERE id = ? "
	getAccessToken        = "SELECT id, token, expires, refresh_token_id FROM access_token WHERE id = ? "
	deleteAccessToken     = "DELETE FROM access_token WHERE id = ? "

	//Auth Code
	insertAuthCode = "INSERT INTO authorization_code  (client_id, user_id, expires, access_token_id, randon_auth_code, already_used) values(?, ?, ?, ?, ?, ?) "
	updateAuthCode = "UPDATE authorization_code SET randon_auth_code = ?, already_used = ? " +
		"WHERE authorization_code = ? "
	updateAuthCodeToken = "UPDATE authorization_code SET expires = ? " +
		"WHERE authorization_code = ? "

	getByAuthorizationCodeClientUser = "SELECT authorization_code, client_id, user_id, expires,  access_token_id, randon_auth_code, already_used " +
		"FROM authorization_code WHERE client_id = ? and user_id = ?"
	getAuthorizationCodeByCode = "SELECT authorization_code, client_id, user_id, expires,  access_token_id, randon_auth_code, already_used " +
		"FROM authorization_code WHERE randon_auth_code = ?"
	getAuthorizationCodeByClientUserScope = "SELECT a.authorization_code, a.client_id, s.scope, a.randon_auth_code, a.already_used " +
		"FROM authorization_code a inner join auth_code_scope s " +
		"on a.authorization_code = s.authorization_code " +
		"WHERE a.client_id = ? and a.user_id = ? and s.scope = ?"
	deleteAuthCode       = "DELETE FROM authorization_code WHERE client_id = ? and user_id = ?"
	deleteAuthCodeByCode = "DELETE FROM authorization_code WHERE  authorization_code = ?"

	//Auth Code Scope
	insertAuthCodeScope           = "INSERT INTO auth_code_scope  (scope, authorization_code) values(?, ?) "
	getAuthorizationCodeScopeList = "SELECT id, scope, authorization_code " +
		"FROM auth_code_scope WHERE authorization_code = ?"
	deleteAllAuthCodeScope = "DELETE FROM auth_code_scope WHERE authorization_code = ?"

	//Auth Code Revolk
	insertAuthCodeRevolk = "INSERT INTO auth_code_revoke  (authorization_code) values(?) "
	getAuthCodeRevolk    = "SELECT id, authorization_code FROM auth_code_revoke WHERE authorization_code = ?"
	deleteAuthCodeRevolk = "DELETE FROM auth_code_revoke WHERE authorization_code = ?"

	//Grant Types
	insertClientGrantType  = "INSERT INTO client_grant_type  (grant_type, client_id) values(?, ?) "
	getClientGrantTypeList = "SELECT * FROM client_grant_type WHERE client_id = ?"
	deleteClientGrantType  = "DELETE FROM client_grant_type WHERE id = ?"

	//Implicit Grant
	insertImplicitGrant = "INSERT INTO implicit_grant  (client_id, user_id, access_token_id) values(?, ?, ?) "
	getImplicitGrant    = "SELECT id, client_id, user_id, access_token_id " +
		"FROM implicit_grant WHERE client_id = ? and user_id = ? "
	getImplicitGrantByScope = "SELECT i.id, i.client_id, s.scope, i.access_token_id " +
		"FROM implicit_grant i inner join implicit_scope s " +
		"on i.id = s.implicit_grant_id " +
		"WHERE i.client_id = ? and i.user_id = ? and s.scope = ?"
	deleteImplicitGrant     = "DELETE FROM implicit_grant WHERE client_id = ? and user_id = ? "
	deleteImplicitGrantByID = "DELETE FROM implicit_grant WHERE id = ? "

	//Implicit Scope
	insertImplicitScope  = "INSERT INTO implicit_scope  (scope, implicit_grant_id) values(?, ?) "
	getImplicitScopeList = "SELECT id, scope, implicit_grant_id " +
		"FROM implicit_scope WHERE implicit_grant_id = ?"
	deleteImplicitScope = "DELETE FROM implicit_scope WHERE implicit_grant_id = ?"

	//Password grant
	insertPasswordGrant = "INSERT INTO password_grant  (client_id, user_id, access_token_id) values(?, ?, ?) "
	getPasswordGrant    = "SELECT id, client_id, user_id, access_token_id " +
		"FROM password_grant WHERE client_id = ? and user_id = ?"
	deletePasswordGrantByID = "DELETE FROM password_grant WHERE id = ? "

	//Credentials Grant
	insertCredentialsGrant = "INSERT INTO credentials_grant  (client_id, access_token_id) values(?, ?) "
	getCredentialsGrant    = "SELECT id, client_id, access_token_id " +
		"FROM credentials_grant WHERE client_id = ?"
	deleteCredentialsGrant = "DELETE FROM credentials_grant WHERE id = ? "

	//keys
	getAccessTokenKey  = "SELECT * FROM access_token_key "
	getRefreshTokenKey = "SELECT * FROM refresh_token_key"
	getSessionKey      = "SELECT * FROM session_key"
)
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//GetAccessTokenKey GetAccessTokenKey
func (d *MySQLOauthDB) GetAccessTokenKey() string {
	var rtn string
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	row := d.DB.Get(getAccessTokenKey, a...)
	if len(row.Row) > 0 {
		rtn = row.Row[1]
	}
	return rtn
}

//GetRefreshTokenKey GetRefreshTokenKey
func (d *MySQLOauthDB) GetRefreshTokenKey() string {
	var rtn string
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	row := d.DB.Get(getRefreshTokenKey, a...)
	if len(row.Row) > 0 {
		rtn = row.Row[1]
	}
	return rtn
}

//GetSessionKey GetSessionKey
func (d *MySQLOauthDB) GetSessionKey() string {
	var rtn string
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	row := d.DB.Get(getSessionKey, a...)
	if len(row.Row) > 0 {
		rtn = row.Row[1]
	}
	return rtn
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	//"fmt"

	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

// AddImplicitGrant AddImplicitGrant
func (d *MySQLOauthDB) AddImplicitGrant(ig *odb.ImplicitGrant, at *odb.AccessToken, scopeList *[]string) (bool, int64) {
	var suc = false
	var id int64
	if !d.testConnection() {
		d.DB.Connect()
	}
	tx := d.DB.BeginTransaction()
	atsuc, acID := d.AddAccessToken(tx, at)
	d.Log.Debug("atTk res: ", atsuc)
	d.Log.Debug("atTk id: ", acID)
	if atsuc {
		ig.AccessTokenID = acID
		var a []interface{}
		a = append(a, ig.ClientID, ig.UserID, ig.AccessTokenID)
		suc, id = tx.Insert(insertImplicitGrant, a...)
		d.Log.Debug("ig res: ", suc)
		d.Log.Debug("ig id: ", id)
		if suc {
			var scSuc = true
			if scopeList != nil {
				for _, s := range *scopeList {
					var igs odb.ImplicitScope
					igs.ImplicitGrantID = id
					igs.Scope = s
					ssuc, sid := d.AddImplicitGrantScope(tx, &igs)
					d.Log.Debug("scope res: ", ssuc)
					d.Log.Debug("scope id: ", sid)
					if !ssuc {
						d.Log.Debug("scope failed rolling back res: ", ssuc)
						scSuc = false
					}
				}
			}
			if scSuc {
				suc = true
				tx.Commit()
			} else {
				suc = false
				id = 0
				d.Log.Debug("rolling back suc: ", suc)
				tx.Rollback()
			}
		} else {
			tx.Rollback()
		}
	} else {
		tx.Rollback()
	}
	return suc, id
}

//GetImplicitGrant GetImplicitGrant
func (d *MySQLOauthDB) GetImplicitGrant(clientID int64, userID string) *[]odb.ImplicitGrant {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.ImplicitGrant
	var a []interface{}
	a = append(a, clientID, userID)
	rows := d.DB.GetList(getImplicitGrant, a...)
	d.Log.Debug("rows", rows)
	d.Log.Debug("rows", len(rows.Rows))
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		d.Log.Debug("foundRows in get len: ", len(foundRows))
		for r := range foundRows {
			foundRow := foundRows[r]
			d.Log.Debug("foundRows in get ig len: ", len(foundRow))
			if len(foundRow) > 0 {
				rowContent := parseImplicitGrantRow(&foundRow)
				rtn = append(rtn, *rowContent)
			}
		}
	}
	// rtn := parseAuthCodeRow(&row.Row)
	d.Log.Debug("ImplicitGrant list: ", rtn)
	return &rtn
}

//GetImplicitGrantByScope GetImplicitGrantByScope
func (d *MySQLOauthDB) GetImplicitGrantByScope(clientID int64, userID string, scope string) *[]odb.ImplicitGrant {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.ImplicitGrant
	var a []interface{}
	a = append(a, clientID, userID, scope)
	rows := d.DB.GetList(getImplicitGrantByScope, a...)
	d.Log.Debug("rows in getbyscope: ", rows)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		d.Log.Debug("foundRows in getbyscope: ", foundRows)
		for r := range foundRows {
			foundRow := foundRows[r]
			d.Log.Debug("foundRow in getbyscope: ", foundRow)
			id, err := strconv.ParseInt((foundRow)[0], 10, 64)
			if err == nil {
				cid, err := strconv.ParseInt((foundRow)[1], 10, 64)
				if err == nil {
					aid, err := strconv.ParseInt((foundRow)[3], 10, 64)
					if err == nil {
						var rtnc odb.ImplicitGrant
						rtnc.ID = id
						rtnc.ClientID = cid
						rtnc.UserID = userID
						rtnc.Scope = (foundRow)[2]
						rtnc.AccessTokenID = aid
						d.Log.Debug("rtnc in getbyscope: ", rtnc)
						rtn = append(rtn, rtnc)
					}

				}
			}
		}
	}
	d.Log.Debug("ImplicitGrant in scope: ", rtn)
	return &rtn
}

//DeleteImplicitGrant DeleteImplicitGrant
func (d *MySQLOauthDB) DeleteImplicitGrant(clientID int64, userID string) bool {
	var suc bool
	if !d.testConnection() {
		d.DB.Connect()
	}
	igList := d.GetImplicitGrant(clientID, userID)
	d.Log.Debug("ImplicitGrant list in delete: ", igList)
	d.Log.Debug("ImplicitGrant len list in delete: ", len(*igList))
	if len(*igList) == 0 {
		suc = true
	} else {
		for _, ig := range *igList {
			if ig.ID > 0 {
				//at := d.GetAccessToken(ig.AccessTokenID)
				tx := d.DB.BeginTransaction()
				sdel := d.DeleteImplicitGrantScopeList(tx, ig.ID)
				d.Log.Debug("delete scope: ", sdel)
				if sdel {
					var a []interface{}
					a = append(a, ig.ID)
					igdel := tx.Delete(deleteImplicitGrantByID, a...)
					d.Log.Debug("delete ImplicitGrant: ", igdel)
					if igdel {
						atdel := d.DeleteAccessToken(tx, ig.AccessTokenID)
						d.Log.Debug("delete AccessToken: ", atdel)
						//if atdel {
						if atdel {
							suc = true
							tx.Commit()
						} else {
							tx.Rollback()
						}
						//}
					} else {
						tx.Rollback()
					}
				} else {
					tx.Rollback()
				}
			}
		}
	}
	return suc
}

func parseImplicitGrantRow(foundRow *[]string) *odb.ImplicitGrant {
	//fmt.Println("foundRow in parseImplicitGrantRow: ", foundRow)
	var rtn odb.ImplicitGrant
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			// rtn.ImplicitGrant = id
			cid, err := strconv.ParseInt((*foundRow)[1], 10, 64)
			if err == nil {
				atid, err := strconv.ParseInt((*foundRow)[3], 10, 64)
				if err == nil {
					rtn.ID = id
					rtn.ClientID = cid
					rtn.UserID = (*foundRow)[2]
					rtn.AccessTokenID = atid
				}
			}
		}
	}
	return &rtn
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbAci db.Database
var odbAci odb.Oauth2DB
var cidAci int64
var spIDAci int64
var spID2Aci int64

func TestMySQLOauthDBACi_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAci = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAci

	odbAci = &moadb

	dbAci.Connect()
}

func TestMySQLOauthDBACi_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbAci.AddClient(&c, nil)
	fmt.Println("client add res: ", res)
	fmt.Println("client id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidAci = id
	}
}

func TestMySQLOauthDBACi_AddAuthorizationCode(t *testing.T) {

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAci
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445a"

	res, id := odbAci.AddAuthorizationCode(&ac, &at, &rt, nil)
	if !res || id < 1 {
		t.Fail()
	}
}

// func TestMySQLOauthDBACi_DeleteAuthorizationCodeScope1(t *testing.T) {
// 	res := odbAci.DeleteAuthorizationCode(cidAci, "1234")
// 	if !res {
// 		t.Fail()
// 	}
// }

func TestMySQLOauthDBACi_AddAuthorizationCodeScope(t *testing.T) {

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAci
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445b"
	var scope = []string{"test1", "test2"}

	res, id := odbAci.AddAuthorizationCode(&ac, &at, &rt, &scope)
	if !res || id < 1 {
		t.Fail()
	} else {
		spID2Aci = id
	}
}

func TestMySQLOauthDBACi_GetAuthCodeScopeList(t *testing.T) {
	res := odbAci.GetAuthorizationCodeScopeList(spID2Aci)
	fmt.Println("auth code scope in get: ", res)
	if res == nil || (*res)[0].Scope != "test1" {
		t.Fail()
	}
}

func TestMySQLOauthDBACi_AddAuthCodeRevolk(t *testing.T) {
	var rv odb.AuthCodeRevolk
	rv.AuthorizationCode = spID2Aci
	res, id := odbAci.AddAuthCodeRevolk(nil, &rv)
	fmt.Println("revolk id: ", id)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBACi_UpdateAuthCode(t *testing.T) {
	var ac odb.AuthorizationCode
	ac.RandonAuthCode = "13445bb"
	ac.AlreadyUsed = true
	ac.AuthorizationCode = spID2Aci
	res := odbAci.UpdateAuthorizationCode(&ac)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBACi_UpdateAuthCodeToken(t *testing.T) {
	ac := odbAci.GetAuthorizationCodeByCode("13445bb")

	fmt.Println("auth code in update token: ", ac)
	var rt odb.RefreshToken
	rt.Token = "somereftoken2upd"
	rfs, rfid := odbAci.AddRefreshToken(nil, &rt)
	fmt.Println("new refresh token: ", rfs)
	if rfs {
		at := odbAci.GetAccessToken(ac.AccessTokenID)
		fmt.Println("at in update token: ", at)
		at.Token = "someacctokenupd"
		at.Expires = time.Now()
		at.RefreshTokenID = rfid
		tt := time.Now()
		ac.Expires = tt
		res := odbAci.UpdateAuthorizationCodeAndToken(ac, at)
		fmt.Println("auth code update token suc: ", res)
		ac2 := odbAci.GetAuthorizationCodeByCode("13445bb")
		fmt.Println("auth2 code in update token: ", ac2)
		fmt.Println("tt in update token: ", tt.UTC())
		fmt.Println("expires in update token: ", ac2.Expires)
		at2 := odbAci.GetAccessToken(ac.AccessTokenID)
		fmt.Println("at2 in update token: ", at2)
		if !res || at2.Token != "someacctokenupd" {
			t.Fail()
		}
	}

}

func TestMySQLOauthDBACi_GetAuthCodeByCode(t *testing.T) {
	res := odbAci.GetAuthorizationCodeByCode("13445bb")
	fmt.Println("auth code in get: ", res)
	if res == nil || res.RandonAuthCode != "13445bb" || res.AlreadyUsed != true {
		t.Fail()
	}
}

func TestMySQLOauthDBACi_GetAuthCodeByClient(t *testing.T) {
	res := odbAci.GetAuthorizationCode(cidAci, "1234")
	fmt.Println("auth code in get by client: ", res)
	if len(*res) < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBACi_GetAuthCodeByScope(t *testing.T) {
	res := odbAci.GetAuthorizationCodeByScope(cidAci, "1234", "test1")
	fmt.Println("auth code in get by scope: ", res)
	if len(*res) < 1 || (*res)[0].Scope != "test1" {
		t.Fail()
	}
}

func TestMySQLOauthDBACi_DeleteAuthorizationCode(t *testing.T) {
	res := odbAci.DeleteAuthorizationCode(cidAci, "1234")
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBACi_DeleteClient(t *testing.T) {
	suc := odbAci.DeleteClient(cidAci)
	if !suc {
		t.Fail()
	}
}
package mysqldb

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbAc db.Database
var odbAc odb.Oauth2DB
var cidAc int64
var spIDAc int64
var spID2Ac int64

func TestMySQLOauthDBAC_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	var getRow db.DbRow
	getRow.Row = []string{"1", "somereftoken2"}
	mydb.MockRow1 = &getRow

	mydb.MockUpdateSuccess1 = true

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	dbAc.Connect()
}

func TestMySQLOauthDBAC_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbAc.AddClient(&c, nil)
	fmt.Println("client add res: ", res)
	fmt.Println("client id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidAc = id
	}
}

func TestMySQLOauthDBAC_AddAuthorizationCode(t *testing.T) {

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAc
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445a"

	res, id := odbAc.AddAuthorizationCode(&ac, &at, &rt, nil)
	if !res || id < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_AddAuthorizationCodeNoRefresh(t *testing.T) {

	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	var getRow db.DbRow
	getRow.Row = []string{"1", "somereftoken2"}
	mydb.MockRow1 = &getRow

	mydb.MockUpdateSuccess1 = true

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	var rt odb.RefreshToken
	rt.Token = ""

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAc
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445a"

	res, id := odbAc.AddAuthorizationCode(&ac, &at, &rt, nil)
	if !res || id < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_AddAuthorizationCodeAuthCodeFail(t *testing.T) {

	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = false
	mydb.MockInsertID2 = 0

	mydb.MockInsertSuccess3 = false
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	var getRow db.DbRow
	getRow.Row = []string{"1", "somereftoken2"}
	mydb.MockRow1 = &getRow

	mydb.MockUpdateSuccess1 = true

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	var rt odb.RefreshToken
	rt.Token = ""

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAc
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445a"

	res, id := odbAc.AddAuthorizationCode(&ac, &at, &rt, nil)
	if res || id != 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_AddAuthorizationCodeRefTokenFail(t *testing.T) {

	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = false
	mydb.MockInsertID1 = 0

	mydb.MockInsertSuccess2 = false
	mydb.MockInsertID2 = 0

	mydb.MockInsertSuccess3 = false
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	var getRow db.DbRow
	getRow.Row = []string{"1", "somereftoken2"}
	mydb.MockRow1 = &getRow

	mydb.MockUpdateSuccess1 = true

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	var rt odb.RefreshToken
	rt.Token = "aaaaa"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAc
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445a"

	res, id := odbAc.AddAuthorizationCode(&ac, &at, &rt, nil)
	if res || id != 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_AddAuthorizationCodeAcTokenFail(t *testing.T) {

	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 0

	mydb.MockInsertSuccess2 = false
	mydb.MockInsertID2 = 0

	mydb.MockInsertSuccess3 = false
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	var getRow db.DbRow
	getRow.Row = []string{"1", "somereftoken2"}
	mydb.MockRow1 = &getRow

	mydb.MockUpdateSuccess1 = true

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	var rt odb.RefreshToken
	rt.Token = "aaaaa"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAc
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445a"

	res, id := odbAc.AddAuthorizationCode(&ac, &at, &rt, nil)
	if res || id != 0 {
		t.Fail()
	}
}

// func TestMySQLOauthDBACi_DeleteAuthorizationCodeScope1(t *testing.T) {
// 	res := odbAci.DeleteAuthorizationCode(cidAci, "1234")
// 	if !res {
// 		t.Fail()
// 	}
// }

func TestMySQLOauthDBAC_AddAuthorizationCodeScope(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockInsertSuccess5 = true
	mydb.MockInsertID5 = 1

	var rows [][]string
	row1 := []string{"1", "test1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAc
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445b"
	var scope = []string{"test1", "test2"}

	res, id := odbAc.AddAuthorizationCode(&ac, &at, &rt, &scope)
	if !res || id < 1 {
		t.Fail()
	} else {
		spID2Ac = id
	}
}

func TestMySQLOauthDBAC_AddAuthorizationCodeScopeFailscope(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	// mydb.MockInsertSuccess5 = true
	// mydb.MockInsertID5 = 1

	var rows [][]string
	row1 := []string{"1", "test1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAc
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445b"
	var scope = []string{"test1", "test2"}

	res, _ := odbAc.AddAuthorizationCode(&ac, &at, &rt, &scope)
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_GetAuthCodeScopeList(t *testing.T) {
	res := odbAc.GetAuthorizationCodeScopeList(spID2Ac)
	fmt.Println("auth code scope in get: ", res)
	if res == nil || (*res)[0].Scope != "test1" {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_AddAuthCodeRevolk(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var rows [][]string
	row1 := []string{"1", "test1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	var rv odb.AuthCodeRevolk
	rv.AuthorizationCode = spID2Ac
	res, id := odbAc.AddAuthCodeRevolk(nil, &rv)
	fmt.Println("revolk id: ", id)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_UpdateAuthCode(t *testing.T) {
	var ac odb.AuthorizationCode
	ac.RandonAuthCode = "13445bb"
	ac.AlreadyUsed = true
	ac.AuthorizationCode = spID2Ac
	res := odbAc.UpdateAuthorizationCode(&ac)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_UpdateAuthCodeToken(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "someacctoken2", "false", ""}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "someacctoken2", tt.Format("2006-01-02 15:04:05"), "3", ""}
	mydb.MockRow2 = &getRow2

	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "someacctoken2", "false", ""}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{"1", "someacctokenupd", tt.Format("2006-01-02 15:04:05"), "3", ""}
	mydb.MockRow4 = &getRow4

	var rows [][]string
	row1 := []string{"1", "test1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	ac := odbAc.GetAuthorizationCodeByCode("13445bb")

	fmt.Println("auth code in update token: ", ac)
	var rt odb.RefreshToken
	rt.Token = "somereftoken2upd"
	rfs, rfid := odbAc.AddRefreshToken(nil, &rt)
	fmt.Println("new refresh token: ", rfs)
	if rfs {
		at := odbAc.GetAccessToken(ac.AccessTokenID)
		fmt.Println("at in update token: ", at)
		at.Token = "someacctokenupd"
		at.Expires = time.Now()
		at.RefreshTokenID = rfid
		tt := time.Now()
		ac.Expires = tt
		res := odbAc.UpdateAuthorizationCodeAndToken(ac, at)
		fmt.Println("auth code update token suc: ", res)
		ac2 := odbAc.GetAuthorizationCodeByCode("13445bb")
		fmt.Println("auth2 code in update token: ", ac2)
		fmt.Println("tt in update token: ", tt.UTC())
		fmt.Println("expires in update token: ", ac2.Expires)
		at2 := odbAc.GetAccessToken(ac.AccessTokenID)
		fmt.Println("at2 in update token: ", at2)
		if !res || at2.Token != "someacctokenupd" {
			t.Fail()
		}
	}

}

func TestMySQLOauthDBAC_UpdateAuthCodeTokenFail(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = false

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "someacctoken2", "false", ""}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "someacctoken2", tt.Format("2006-01-02 15:04:05"), "3", ""}
	mydb.MockRow2 = &getRow2

	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "someacctoken2", "false", ""}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{"1", "someacctokenupd", tt.Format("2006-01-02 15:04:05"), "3", ""}
	mydb.MockRow4 = &getRow4

	var rows [][]string
	row1 := []string{"1", "test1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	ac := odbAc.GetAuthorizationCodeByCode("13445bb")

	fmt.Println("auth code in update token: ", ac)
	var rt odb.RefreshToken
	rt.Token = "somereftoken2upd"
	rfs, rfid := odbAc.AddRefreshToken(nil, &rt)
	fmt.Println("new refresh token: ", rfs)
	if rfs {
		at := odbAc.GetAccessToken(ac.AccessTokenID)
		fmt.Println("at in update token: ", at)
		at.Token = "someacctokenupd"
		at.Expires = time.Now()
		at.RefreshTokenID = rfid
		tt := time.Now()
		ac.Expires = tt
		res := odbAc.UpdateAuthorizationCodeAndToken(ac, at)
		fmt.Println("auth code update token suc: ", res)
		ac2 := odbAc.GetAuthorizationCodeByCode("13445bb")
		fmt.Println("auth2 code in update token: ", ac2)
		fmt.Println("tt in update token: ", tt.UTC())
		fmt.Println("expires in update token: ", ac2.Expires)
		at2 := odbAc.GetAccessToken(ac.AccessTokenID)
		fmt.Println("at2 in update token: ", at2)
		if res {
			t.Fail()
		}
	}

}

func TestMySQLOauthDBAC_UpdateAuthCodeTokenFail2(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockUpdateSuccess1 = false

	mydb.MockUpdateSuccess2 = false

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "someacctoken2", "false", ""}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "someacctoken2", tt.Format("2006-01-02 15:04:05"), "3", ""}
	mydb.MockRow2 = &getRow2

	var getRow3 db.DbRow
	getRow3.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "someacctoken2", "false", ""}
	mydb.MockRow3 = &getRow3

	var getRow4 db.DbRow
	getRow4.Row = []string{"1", "someacctokenupd", tt.Format("2006-01-02 15:04:05"), "3", ""}
	mydb.MockRow4 = &getRow4

	var rows [][]string
	row1 := []string{"1", "test1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	ac := odbAc.GetAuthorizationCodeByCode("13445bb")

	fmt.Println("auth code in update token: ", ac)
	var rt odb.RefreshToken
	rt.Token = "somereftoken2upd"
	rfs, rfid := odbAc.AddRefreshToken(nil, &rt)
	fmt.Println("new refresh token: ", rfs)
	if rfs {
		at := odbAc.GetAccessToken(ac.AccessTokenID)
		fmt.Println("at in update token: ", at)
		at.Token = "someacctokenupd"
		at.Expires = time.Now()
		at.RefreshTokenID = rfid
		tt := time.Now()
		ac.Expires = tt
		res := odbAc.UpdateAuthorizationCodeAndToken(ac, at)
		fmt.Println("auth code update token suc: ", res)
		ac2 := odbAc.GetAuthorizationCodeByCode("13445bb")
		fmt.Println("auth2 code in update token: ", ac2)
		fmt.Println("tt in update token: ", tt.UTC())
		fmt.Println("expires in update token: ", ac2.Expires)
		at2 := odbAc.GetAccessToken(ac.AccessTokenID)
		fmt.Println("at2 in update token: ", at2)
		if res {
			t.Fail()
		}
	}

}

func TestMySQLOauthDBAC_GetAuthCodeByCode(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "true", ""}
	mydb.MockRow1 = &getRow

	var rows [][]string
	row1 := []string{"1", "test1", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "2", "test1", "13445bb", "true"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	res := odbAc.GetAuthorizationCodeByCode("13445bb")
	fmt.Println("auth code in get: ", res)
	if res == nil || res.RandonAuthCode != "13445bb" || res.AlreadyUsed != true {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_GetAuthCodeByClient(t *testing.T) {
	res := odbAc.GetAuthorizationCode(cidAc, "1234")
	fmt.Println("auth code in get by client: ", res)
	if len(*res) < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_GetAuthCodeByScope(t *testing.T) {
	res := odbAc.GetAuthorizationCodeByScope(cidAc, "1234", "test1")
	fmt.Println("auth code in get by scope: ", res)
	if len(*res) < 1 || (*res)[0].Scope != "test1" {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_DeleteAuthorizationCode(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockDeleteSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockDeleteSuccess5 = true

	mydb.MockDeleteSuccess6 = true

	mydb.MockDeleteSuccess7 = true

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var rows [][]string
	row1 := []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "true", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "2", "test1", "13445bb", "true"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	res := odbAc.DeleteAuthorizationCode(cidAc, "1234")
	fmt.Println("auth code delete: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_DeleteAuthorizationCode2(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockDeleteSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockDeleteSuccess5 = true

	mydb.MockDeleteSuccess6 = true

	mydb.MockDeleteSuccess7 = true

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var rows [][]string
	row1 := []string{}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "2", "test1", "13445bb", "true"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	res := odbAc.DeleteAuthorizationCode(cidAc, "1234")
	fmt.Println("auth code delete: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_DeleteAuthorizationCodeFail1(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockDeleteSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockDeleteSuccess5 = false

	mydb.MockDeleteSuccess6 = true

	mydb.MockDeleteSuccess7 = true

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var rows [][]string
	row1 := []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "true", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "2", "test1", "13445bb", "true"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	res := odbAc.DeleteAuthorizationCode(cidAc, "1234")
	fmt.Println("auth code delete: ", res)
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_DeleteAuthorizationCodeFail2(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockDeleteSuccess4 = false
	mydb.MockInsertID4 = 1

	mydb.MockDeleteSuccess5 = true

	mydb.MockDeleteSuccess6 = true

	mydb.MockDeleteSuccess7 = true

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var rows [][]string
	row1 := []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "true", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "2", "test1", "13445bb", "true"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	res := odbAc.DeleteAuthorizationCode(cidAc, "1234")
	fmt.Println("auth code delete: ", res)
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_DeleteAuthorizationCodeFail3(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = false
	mydb.MockInsertID3 = 1

	mydb.MockDeleteSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockDeleteSuccess5 = true

	mydb.MockDeleteSuccess6 = true

	mydb.MockDeleteSuccess7 = true

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var rows [][]string
	row1 := []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "true", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "2", "test1", "13445bb", "true"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	res := odbAc.DeleteAuthorizationCode(cidAc, "1234")
	fmt.Println("auth code delete: ", res)
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_DeleteAuthorizationCodeFail4(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = false

	mydb.MockDeleteSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockDeleteSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockDeleteSuccess5 = true

	mydb.MockDeleteSuccess6 = true

	mydb.MockDeleteSuccess7 = true

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var rows [][]string
	row1 := []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "true", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "2", "test1", "13445bb", "true"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	res := odbAc.DeleteAuthorizationCode(cidAc, "1234")
	fmt.Println("auth code delete: ", res)
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBAC_DeleteAuthorizationCodeFail5(t *testing.T) {
	var mydb mdb.MyDBMock
	dbAc = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = false

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockDeleteSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockDeleteSuccess5 = true

	mydb.MockDeleteSuccess6 = true

	mydb.MockDeleteSuccess7 = true

	mydb.MockUpdateSuccess1 = true

	mydb.MockUpdateSuccess2 = true

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var rows [][]string
	row1 := []string{"1", "2", "3", tt.Format("2006-01-02 15:04:05"), "3", "13445bb", "true", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rows2 [][]string
	row2 := []string{"1", "2", "test1", "13445bb", "true"}
	rows2 = append(rows2, row2)
	var dbrows2 db.DbRows
	dbrows2.Rows = rows2
	mydb.MockRows2 = &dbrows2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAc

	odbAc = &moadb

	res := odbAc.DeleteAuthorizationCode(cidAc, "1234")
	fmt.Println("auth code delete fail5: ", res)
	if res {
		t.Fail()
	}
}
func TestMySQLOauthDBAC_DeleteClient(t *testing.T) {
	suc := odbAc.DeleteClient(cidAc)
	if !suc {
		t.Fail()
	}
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbSoi db.Database
var odbSoi odb.Oauth2DB
var cidSoi int64
var idSoi int64

func TestMySQLOauthDBi_ConnectScope(t *testing.T) {
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbSoi = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbSoi

	odbSoi = &moadb

	dbSoi.Connect()
}

func TestMySQLOauthDBi_AddClientInScope(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbSoi.AddClient(&c, nil)
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidSoi = id
	}
}

func TestMySQLOauthDBi_AddClientScope(t *testing.T) {
	var ur odb.ClientScope
	ur.ClientID = cidSoi
	ur.Scope = "somescope"
	res, id := odbSoi.AddClientScope(&ur)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idSoi = id
	}
}

func TestMySQLOauthDBi_GetClientScopeList(t *testing.T) {
	res := odbSoi.GetClientScopeList(cidSoi)
	fmt.Println("scope list res: ", res)
	if res == nil || (*res)[0].ClientID != cidSoi {
		t.Fail()
	}
}

func TestMySQLOauthDBi_DeleteClientScope(t *testing.T) {
	res := odbSoi.DeleteClientScope(idSoi)
	fmt.Println("scope  delete: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBi_DeleteClientInScope(t *testing.T) {
	suc := odbSoi.DeleteClient(cidSoi)
	if !suc {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//AddClientRoleURI AddClientRoleURI
func (d *MySQLOauthDB) AddClientRoleURI(r *odb.ClientRoleURI) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, r.ClientRoleID, r.ClientAllowedURIID)
	suc, _ := d.DB.Insert(insertRoleURI, a...)
	return suc
}

//GetClientRoleAllowedURIList GetClientRoleAllowedURIList
func (d *MySQLOauthDB) GetClientRoleAllowedURIList(roleID int64) *[]odb.ClientRoleURI {
	var rtn []odb.ClientRoleURI
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, roleID)
	rows := d.DB.GetList(getRoleURIList, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			rowContent := parseRowURIRow(&foundRow)
			rtn = append(rtn, *rowContent)
		}
	}
	return &rtn
}

// GetClientRoleAllowedURIListByClientID GetClientRoleAllowedURIListByClientID
func (d *MySQLOauthDB) GetClientRoleAllowedURIListByClientID(clientID int64) *[]odb.RoleURI {
	var rtn []odb.RoleURI
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, clientID)
	rows := d.DB.GetList(roleURIJoin, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			rowContent := parseClientRowURIRow(&foundRow)
			rtn = append(rtn, *rowContent)
		}
	}
	return &rtn
}

//DeleteClientRoleURI DeleteClientRoleURI
func (d *MySQLOauthDB) DeleteClientRoleURI(r *odb.ClientRoleURI) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, r.ClientRoleID, r.ClientAllowedURIID)
	return d.DB.Delete(deleteRoleURI, a...)
}

func parseRowURIRow(foundRow *[]string) *odb.ClientRoleURI {
	var rtn odb.ClientRoleURI
	roleID, err := strconv.ParseInt((*foundRow)[0], 10, 64)
	if err == nil {
		URIID, err := strconv.ParseInt((*foundRow)[1], 10, 64)
		if err == nil {
			rtn.ClientRoleID = roleID
			rtn.ClientAllowedURIID = URIID

		}
	}
	return &rtn
}

func parseClientRowURIRow(foundRow *[]string) *odb.RoleURI {
	var rtn odb.RoleURI
	if len(*foundRow) > 0 {
		roleID, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			URIID, err := strconv.ParseInt((*foundRow)[2], 10, 64)
			if err == nil {
				clientID, err := strconv.ParseInt((*foundRow)[4], 10, 64)
				if err == nil {
					rtn.ClientRoleID = roleID
					rtn.ClientAllowedURIID = URIID
					rtn.ClientID = clientID
					rtn.Role = (*foundRow)[1]
					rtn.ClientAllowedURI = (*foundRow)[3]
				}
			}
		}
	}
	return &rtn
}
package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbCgt db.Database
var odbCgt odb.Oauth2DB
var cidCgt int64 = 1
var idCgt int64

func TestMySQLOauthDBCgt_ConnectClientGrantType(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbCgt = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	var rows [][]string
	row1 := []string{"1", "tester5", "1"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbCgt

	odbCgt = &moadb

	dbCgt.Connect()
}

func TestMySQLOauthDBCgt_AddClientGrantType(t *testing.T) {
	var ur odb.ClientGrantType
	ur.ClientID = cidCgt
	ur.GrantType = "someGrantType"
	res, id := odbCgt.AddClientGrantType(&ur)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idCgt = id
	}
}

func TestMySQLOauthDBCgt_GetClientGrantTypeList(t *testing.T) {
	res := odbCgt.GetClientGrantTypeList(cidCgt)
	fmt.Println("grant type list res: ", res)
	if res == nil || (*res)[0].ClientID != cidCgt {
		t.Fail()
	}
}

func TestMySQLOauthDBCgt_DeleteClientGrantType(t *testing.T) {
	res := odbCgt.DeleteClientGrantType(idCgt)
	fmt.Println("client grant type  delete: ", res)
	if !res {
		t.Fail()
	}
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbRli db.Database
var odbRli odb.Oauth2DB
var cidRli int64
var idRli int64

func TestMySQLOauthDBi_ConnectRole(t *testing.T) {
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbRli = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbRli

	odbRli = &moadb

	dbRli.Connect()
}

func TestMySQLOauthDBi_AddClientInRole(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbRli.AddClient(&c, nil)
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidRli = id
	}
}

func TestMySQLOauthDBi_AddClientRole(t *testing.T) {
	var r odb.ClientRole
	r.ClientID = cidRli
	r.Role = "someRole"
	res, id := odbRli.AddClientRole(&r)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idRli = id
	}
}

func TestMySQLOauthDBi_GetClientRoleList(t *testing.T) {
	res := odbRli.GetClientRoleList(cidRli)
	fmt.Println("Role list res: ", res)
	if res == nil || (*res)[0].ClientID != cidRli {
		t.Fail()
	}
}

func TestMySQLOauthDBi_DeleteClientRole(t *testing.T) {
	res := odbRli.DeleteClientRole(idRli)
	fmt.Println("role  delete: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBi_DeleteClientInRole(t *testing.T) {
	suc := odbRli.DeleteClient(cidRli)
	if !suc {
		t.Fail()
	}
}
package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbb2 db.Database
var odbb2 odb.Oauth2DB
var cid2b int64
var cid22 int64

func TestMySQLDB2_Connect(t *testing.T) {

	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	var mTestRow db.DbRow
	mTestRow.Row = []string{"1"}
	mydb.MockTestRow = &mTestRow
	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 4

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 4

	mydb.MockInsertSuccess4 = false
	mydb.MockInsertID4 = 4

	mydb.MockUpdateSuccess1 = true

	var mGetRow db.DbRow
	mGetRow.Row = []string{"1", "1235", "tester5", "some site", "some email", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "1235", "tester5", "some site", "some email", "true", "false"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	mydb.MockRows2 = &dbrows
	//mGetRows.Rows[0] = []string{"1", "1235", "tester5", "some site", "some email", "true", "false"}

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = false
	mydb.MockDeleteSuccess3 = false
	mydb.MockDeleteSuccess4 = true

	dbb2 = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbb2

	odbb2 = &moadb

	dbb2.Connect()

}

// func TestMySQLDB_AddClientNullUri(t *testing.T) {
// 	var c odb.Client
// 	c.Secret = "12345"
// 	c.Name = "tester"
// 	c.Email = "bob@bob.com"
// 	c.WebSite = "www.bob.com"
// 	c.Enabled = true
// 	c.Paid = false

// 	fmt.Println("before db add")
// 	res, id := odbb.AddClient(&c, nil)
// 	fmt.Println("res: ", res)
// 	fmt.Println("id: ", id)
// 	if res || id == 0 {
// 		t.Fail()
// 	} else {
// 		cid = id
// 	}
// }

func TestMySQLDB2_AddClient(t *testing.T) {
	var c odb.Client
	c.Secret = "1234567"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false
	var uis []odb.ClientRedirectURI
	var u1 odb.ClientRedirectURI
	u1.URI = "addSomething"
	uis = append(uis, u1)

	var u2 odb.ClientRedirectURI
	u2.URI = "addSomething2"
	uis = append(uis, u2)

	fmt.Println("before db add")
	res, id := odbb2.AddClient(&c, &uis)
	cid2b = id
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if !res || id == 0 {
		t.Fail()
	}
}

// func TestMySQLDB_UpdateClient(t *testing.T) {
// 	var c odb.Client
// 	c.Secret = "555555"
// 	c.Name = "tester5"
// 	c.Email = "bob5@bob.com"
// 	c.WebSite = "www.bob.com"
// 	c.Enabled = false
// 	c.Paid = false
// 	c.ClientID = cid
// 	suc := odbb.UpdateClient(&c)
// 	if !suc {
// 		t.Fail()
// 	}
// }

// func TestMySQLDB_GetClient(t *testing.T) {
// 	c := odbb.GetClient(cid)
// 	fmt.Println("client found: ", c)
// 	if c.Name != "tester5" {
// 		t.Fail()
// 	}
// }

// func TestMySQLDB_GetClients(t *testing.T) {
// 	cs := odbb.GetClients()
// 	fmt.Println("client found: ", cs)
// 	for _, c := range *cs {
// 		fmt.Println("client found in getClients: ", c)
// 	}
// 	if len(*cs) == 0 {
// 		t.Fail()
// 	}

// }

// func TestMySQLDB_SearchClients(t *testing.T) {
// 	cs := odbb.SearchClients("tester")
// 	fmt.Println("client found in search: ", cs)
// 	for _, c := range *cs {
// 		fmt.Println("client found in searchClients: ", c)
// 	}
// 	if len(*cs) == 0 {
// 		t.Fail()
// 	}

// }

func TestMySQLDB2_DeleteClient(t *testing.T) {
	suc := odbb2.DeleteClient(cid2b)
	if suc {
		t.Fail()
	}
}

func TestMySQLDB2_DeleteClient2(t *testing.T) {
	suc := odbb2.DeleteClient(cid2b)
	if suc {
		t.Fail()
	}
}

// func TestMySQLDB_DeleteClient2(t *testing.T) {
// 	suc := odbb.DeleteClient(cid2)
// 	if !suc {
// 		t.Fail()
// 	}
// }
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//AddClientRole AddClientRole
func (d *MySQLOauthDB) AddClientRole(r *odb.ClientRole) (bool, int64) {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, r.Role, r.ClientID)
	suc, id := d.DB.Insert(insertRole, a...)
	return suc, id
}

//GetClientRoleList GetClientRoleList
func (d *MySQLOauthDB) GetClientRoleList(clientID int64) *[]odb.ClientRole {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.ClientRole
	var a []interface{}
	a = append(a, clientID)
	rows := d.DB.GetList(getRoleList, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			rowContent := parseClientRoleRow(&foundRow)
			rtn = append(rtn, *rowContent)
		}
	}
	return &rtn
}

//DeleteClientRole DeleteClientRole
func (d *MySQLOauthDB) DeleteClientRole(id int64) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	return d.DB.Delete(deleteRole, a...)
}

func parseClientRoleRow(foundRow *[]string) *odb.ClientRole {
	var rtn odb.ClientRole
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			clientID, err := strconv.ParseInt((*foundRow)[2], 10, 64)
			if err == nil {
				rtn.ID = id
				rtn.ClientID = clientID
				rtn.Role = (*foundRow)[1]
			}
		}
	}
	return &rtn
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//AddClientScope AddClientScope
func (d *MySQLOauthDB) AddClientScope(s *odb.ClientScope) (bool, int64) {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, s.Scope, s.ClientID)
	suc, id := d.DB.Insert(insertScope, a...)
	return suc, id
}

//GetClientScopeList GetClientScopeList
func (d *MySQLOauthDB) GetClientScopeList(clientID int64) *[]odb.ClientScope {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.ClientScope
	var a []interface{}
	a = append(a, clientID)
	rows := d.DB.GetList(getScopeList, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			rowContent := parseClientScopeRow(&foundRow)
			rtn = append(rtn, *rowContent)
		}
	}
	return &rtn
}

//DeleteClientScope DeleteClientScope
func (d *MySQLOauthDB) DeleteClientScope(id int64) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	return d.DB.Delete(deleteScope, a...)
}

func parseClientScopeRow(foundRow *[]string) *odb.ClientScope {
	var rtn odb.ClientScope
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			clientID, err := strconv.ParseInt((*foundRow)[2], 10, 64)
			if err == nil {
				rtn.ID = id
				rtn.ClientID = clientID
				rtn.Scope = (*foundRow)[1]
			}
		}
	}
	return &rtn
}
package mysqldb

import (
	//"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbbUri2 db.Database
var odbbUri2 odb.Oauth2DB
var rdid2 int64
var cidUri2 int64

func TestMySQLOauthDB2_Connect(t *testing.T) {

	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbbUri2 = &mydb

	//mydb.MockTestRow
	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow
	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	var getRow db.DbRow
	getRow.Row = []string{"1", "test", "2"}
	mydb.MockRow1 = &getRow

	var rows [][]string
	row1 := []string{"1", "tester5", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbbUri2

	odbbUri2 = &moadb

	dbbUri2.Connect()

}

func TestMySQLOauthDB2_AddClientRedirectURI(t *testing.T) {
	var ur odb.ClientRedirectURI
	ur.ClientID = 4
	ur.URI = "someuri"
	res, id := odbbUri2.AddClientRedirectURI(nil, &ur)
	if !res || id <= 0 {
		t.Fail()
	}
}

func TestMySQLOauthDB2_AddClientRedirectURITx(t *testing.T) {
	var ur odb.ClientRedirectURI
	ur.ClientID = 4
	ur.URI = "someuri"

	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockInsertSuccess1 = true
	mdbx.MockInsertID1 = 1
	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.Tx = &mtx
	var odbbUri2TX = &moadbtx

	res, id := odbbUri2TX.AddClientRedirectURI(&mtx, &ur)
	if !res || id <= 0 {
		t.Fail()
	}
}

func TestMySQLOauthDB2_GetClientRedirectURI(t *testing.T) {
	var cid int64 = 2
	res := odbbUri2.GetClientRedirectURI(cid, "someuri")
	if res == nil {
		t.Fail()
	}
}

func TestMySQLOauthDB2_GetClientRedirectURIList(t *testing.T) {
	var cid int64 = 2
	res := odbbUri2.GetClientRedirectURIList(cid)
	if res == nil || len(*res) == 0 {
		t.Fail()
	}
}

func TestMySQLOauthDB2_DeleteClientRedirectURI(t *testing.T) {
	var id int64 = 2
	res := odbbUri2.DeleteClientRedirectURI(nil, id)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDB2_DeleteClientRedirectURIAll(t *testing.T) {
	var id int64 = 2
	res := odbbUri2.DeleteClientAllRedirectURI(nil, id)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDB2_DeleteClientRedirectURITx(t *testing.T) {
	var id int64 = 2

	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockDeleteSuccess1 = true
	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.Tx = &mtx
	var odbbUri2TX = &moadbtx

	res := odbbUri2TX.DeleteClientRedirectURI(&mtx, id)
	if !res {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/
import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	dbtx "github.com/Ulbora/dbinterface"
)

//AddClientRedirectURI AddClientRedirectURI
func (d *MySQLOauthDB) AddClientRedirectURI(tx dbtx.Transaction, ru *odb.ClientRedirectURI) (bool, int64) {
	var suc bool
	var id int64
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, ru.URI, ru.ClientID)
	if tx == nil {
		suc, id = d.DB.Insert(insertRedirectURI, a...)
	} else {
		suc, id = tx.Insert(insertRedirectURI, a...)
	}

	return suc, id
}

//GetClientRedirectURIList GetClientRedirectURIList
func (d *MySQLOauthDB) GetClientRedirectURIList(clientID int64) *[]odb.ClientRedirectURI {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.ClientRedirectURI
	var a []interface{}
	a = append(a, clientID)
	rows := d.DB.GetList(getRedirectURIList, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			rowContent := parseClientURIRow(&foundRow)
			rtn = append(rtn, *rowContent)
		}
	}
	return &rtn
}

//GetClientRedirectURI GetClientRedirectURI
func (d *MySQLOauthDB) GetClientRedirectURI(clientID int64, uri string) *odb.ClientRedirectURI {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, clientID, uri)
	row := d.DB.Get(getRedirectURI, a...)
	rtn := parseClientURIRow(&row.Row)
	return rtn
}

//DeleteClientRedirectURI DeleteClientRedirectURI
func (d *MySQLOauthDB) DeleteClientRedirectURI(tx dbtx.Transaction, id int64) bool {
	var suc bool
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	if tx == nil {
		suc = d.DB.Delete(deleteRedirectURI, a...)
	} else {
		suc = tx.Delete(deleteRedirectURI, a...)
	}
	return suc
}

//DeleteClientAllRedirectURI DeleteClientAllRedirectURI
func (d *MySQLOauthDB) DeleteClientAllRedirectURI(tx dbtx.Transaction, clientID int64) bool {
	var suc bool
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, clientID)
	if tx == nil {
		suc = d.DB.Delete(deleteAllRedirectURI, a...)
	} else {
		suc = tx.Delete(deleteAllRedirectURI, a...)
	}
	return suc
}

func parseClientURIRow(foundRow *[]string) *odb.ClientRedirectURI {
	var rtn odb.ClientRedirectURI
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			clientID, err := strconv.ParseInt((*foundRow)[2], 10, 64)
			if err == nil {
				rtn.ID = id
				rtn.ClientID = clientID
				rtn.URI = (*foundRow)[1]
			}
		}
	}
	return &rtn
}
package mysqldb

// +bbuild integration move to top

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbAt db.Database
var odbAt odb.Oauth2DB
var idAt int64
var refTkId int64

//var cidRti int64

func TestMySQLOauthDBAcToken_Connect(t *testing.T) {
	refTkId = 5
	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAt = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 2

	mydb.MockUpdateSuccess1 = true
	mydb.MockUpdateSuccess2 = true

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true

	var nowTime = time.Now().Format(odb.TimeFormat)

	fmt.Println("time now: ", nowTime)

	var getRow db.DbRow
	getRow.Row = []string{"1", "someacctoken2", nowTime, ""}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"2", "someacctoken2", nowTime, "5"}
	mydb.MockRow2 = &getRow2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAt

	odbAt = &moadb

	dbAt.Connect()
}

func TestMySQLOauthDBAcToken_AddAccessToken(t *testing.T) {
	var tk odb.AccessToken
	tk.Token = "someacctoken"
	tk.Expires = time.Now()
	res, id := odbAt.AddAccessToken(nil, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idAt = id
	}
}

func TestMySQLOauthDBAcToken_AddAccessTokenTx(t *testing.T) {
	var tk odb.AccessToken
	tk.Token = "someacctoken"
	tk.Expires = time.Now()

	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockInsertSuccess1 = true
	mdbx.MockInsertID1 = 1
	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.Tx = &mtx
	var odbbUri2TX = &moadbtx

	res, id := odbbUri2TX.AddAccessToken(&mtx, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idAt = id
	}
}

func TestMySQLOauthDBAcToken_UpdateAccessToken(t *testing.T) {
	var tk odb.AccessToken
	tk.ID = idAt
	tk.Token = "someacctoken2"
	tk.Expires = time.Now()
	res := odbAt.UpdateAccessToken(nil, &tk)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcToken_UpdateAccessTokenTx(t *testing.T) {
	var tk odb.AccessToken
	tk.ID = idAt
	tk.Token = "someacctoken2"
	tk.Expires = time.Now()

	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockUpdateSuccess1 = true

	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.Tx = &mtx
	var odbbUri2TX = &moadbtx

	res := odbbUri2TX.UpdateAccessToken(&mtx, &tk)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcToken_GetAccessToken(t *testing.T) {
	res := odbAt.GetAccessToken(idAt)
	fmt.Println("access token: ", res)
	fmt.Println("access token refTokenId: ", res.RefreshTokenID)
	if res == nil || (*res).Token != "someacctoken2" {
		t.Fail()
	}
}

func TestMySQLOauthDBAcToken_DeleteAccessToken(t *testing.T) {
	res := odbAt.DeleteAccessToken(nil, idAt)
	fmt.Println("del access token: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcToken_DeleteAccessTokenTx(t *testing.T) {

	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockDeleteSuccess1 = true

	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.Tx = &mtx
	var odbbUri2TX = &moadbtx

	res := odbbUri2TX.DeleteAccessToken(&mtx, idAt)
	fmt.Println("del access token: ", res)
	if !res {
		t.Fail()
	}
}

// func TestMySQLOauthDBAcToken_AddRefreshToken(t *testing.T) {
// 	var tk odb.RefreshToken
// 	tk.Token = "somereftoken"
// 	res, id := odbAt.AddRefreshToken(&tk)
// 	if !res || id <= 0 {
// 		t.Fail()
// 	} else {
// 		refTkIdi = id
// 	}
// }

func TestMySQLOauthDBAcToken_AddAccessToken2(t *testing.T) {
	var tk odb.AccessToken
	tk.Token = "someacctoken"
	tk.Expires = time.Now()
	tk.RefreshTokenID = refTkId
	res, id := odbAt.AddAccessToken(nil, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idAt = id
	}
}

func TestMySQLOauthDBAcToken_AddAccessToken2Tx(t *testing.T) {
	var tk odb.AccessToken
	tk.Token = "someacctoken"
	tk.Expires = time.Now()
	tk.RefreshTokenID = refTkId

	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockInsertSuccess1 = true
	mdbx.MockInsertID1 = 1
	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.Tx = &mtx
	var odbbUri2TX = &moadbtx

	res, id := odbbUri2TX.AddAccessToken(&mtx, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idAt = id
	}
}

func TestMySQLOauthDBAcToken_UpdateAccessToken2(t *testing.T) {
	var tk odb.AccessToken
	tk.ID = idAt
	tk.Token = "someacctoken2"
	tk.Expires = time.Now()
	tk.RefreshTokenID = refTkId
	res := odbAt.UpdateAccessToken(nil, &tk)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcToken_UpdateAccessToken2Tx(t *testing.T) {
	var tk odb.AccessToken
	tk.ID = idAt
	tk.Token = "someacctoken2"
	tk.Expires = time.Now()
	tk.RefreshTokenID = refTkId

	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockUpdateSuccess1 = true
	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.Tx = &mtx
	var odbbUri2TX = &moadbtx

	res := odbbUri2TX.UpdateAccessToken(&mtx, &tk)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcToken_GetAccessToken2(t *testing.T) {
	res := odbAt.GetAccessToken(idAt)
	fmt.Println("access token: ", res)
	fmt.Println("access token refTokenId: ", res.RefreshTokenID)
	if res == nil || (*res).Token != "someacctoken2" {
		t.Fail()
	}
}

func TestMySQLOauthDBAcToken_DeleteAccessToken2(t *testing.T) {
	res := odbAt.DeleteAccessToken(nil, idAt)
	fmt.Println("del access token: ", res)
	if !res {
		t.Fail()
	}
}

// func TestMySQLOauthDBAcToken_DeleteRefreshToken(t *testing.T) {
// 	res := odbAt.DeleteRefreshToken(refTkIdi)
// 	fmt.Println("del ref token: ", res)
// 	if !res {
// 		t.Fail()
// 	}
// }
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbAcRvi db.Database
var odbAcRvi odb.Oauth2DB
var cidAcRvi int64
var acIDAcRvi int64
var spID2AcRvi int64

func TestMySQLOauthDBAcRvi_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAcRvi = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAcRvi

	odbAcRvi = &moadb

	dbAcRvi.Connect()
}

func TestMySQLOauthDBAcRvi_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbAcRvi.AddClient(&c, nil)
	fmt.Println("client add res: ", res)
	fmt.Println("client id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidAcRvi = id
	}
}

func TestMySQLOauthDBAcRvi_AddAuthorizationCode(t *testing.T) {

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ac odb.AuthorizationCode
	ac.ClientID = cidAcRvi
	ac.UserID = "1234"
	ac.Expires = time.Now()
	ac.RandonAuthCode = "13445"

	res, id := odbAcRvi.AddAuthorizationCode(&ac, &at, &rt, nil)

	if !res || id < 1 {
		t.Fail()
	} else {
		acIDAcRvi = id
	}
}

func TestMySQLOauthDBAcRvi_AddAuthCodeRevolk(t *testing.T) {
	var rv odb.AuthCodeRevolk
	rv.AuthorizationCode = acIDAcRvi
	res, id := odbAcRvi.AddAuthCodeRevolk(nil, &rv)
	fmt.Println("revolk id: ", id)
	if !res {
		t.Fail()
	}
}
func TestMySQLOauthDBAcRvi_GetAuthCodeRevolk(t *testing.T) {
	rv := odbAcRvi.GetAuthCodeRevolk(acIDAcRvi)
	fmt.Println("revolk : ", rv)
	if rv == nil {
		t.Fail()
	}
}
func TestMySQLOauthDBAcRvi_DeleteAuthCodeRevolk(t *testing.T) {
	res := odbAcRvi.DeleteAuthCodeRevolk(nil, acIDAcRvi)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcRvi_DeleteAuthorizationCode(t *testing.T) {
	res := odbAcRvi.DeleteAuthorizationCode(cidAcRvi, "1234")
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcRvi_DeleteClient(t *testing.T) {
	suc := odbAcRvi.DeleteClient(cidAcRvi)
	if !suc {
		t.Fail()
	}
}
package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbRt db.Database
var odbRt odb.Oauth2DB
var idRt int64

//var cidRti int64

func TestMySQLOauthDBReToken_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbRt = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	var getRow db.DbRow
	getRow.Row = []string{"1", "somereftoken2"}
	mydb.MockRow1 = &getRow

	mydb.MockUpdateSuccess1 = true

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbRt

	odbRt = &moadb

	dbRt.Connect()
}

func TestMySQLOauthDBReToken_AddRefreshToken(t *testing.T) {
	var tk odb.RefreshToken
	tk.Token = "somereftoken"
	res, id := odbRt.AddRefreshToken(nil, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idRt = id
	}
}

func TestMySQLOauthDBReToken_AddRefreshTokenTx(t *testing.T) {
	var tk odb.RefreshToken
	tk.Token = "somereftoken"

	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockInsertSuccess1 = true
	mdbx.MockInsertID1 = 1
	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.Tx = &mtx
	var odbbUri2TX = &moadbtx

	res, id := odbbUri2TX.AddRefreshToken(&mtx, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idRt = id
	}
}

func TestMySQLOauthDBReToken_UpdateRefreshToken(t *testing.T) {
	var tk odb.RefreshToken
	tk.ID = idRt
	tk.Token = "somereftoken2"
	res := odbRt.UpdateRefreshToken(&tk)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBReToken_GetRefreshToken(t *testing.T) {
	res := odbRt.GetRefreshToken(idRt)
	fmt.Println("ref token: ", res)
	if res == nil || (*res).Token != "somereftoken2" {
		t.Fail()
	}
}

func TestMySQLOauthDBReToken_DeleteRefreshToken(t *testing.T) {
	res := odbRt.DeleteRefreshToken(nil, idRt)
	fmt.Println("del ref token: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBReToken_DeleteRefreshTokenTx(t *testing.T) {
	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockDeleteSuccess1 = true
	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.Tx = &mtx
	var odbbUri2TX = &moadbtx
	res := odbbUri2TX.DeleteRefreshToken(&mtx, idRt)
	fmt.Println("del ref token: ", res)
	if !res {
		t.Fail()
	}
}
package mysqldb

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbIg db.Database
var odbIg odb.Oauth2DB
var cidIg int64
var spIDIg int64
var spID2Ig int64

func TestMySQLOauthDBIg_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	mydb.MockInsertSuccess4 = true
	mydb.MockInsertID4 = 1

	mydb.MockInsertSuccess5 = true
	mydb.MockInsertID5 = 1
	mydb.MockInsertSuccess6 = true
	mydb.MockInsertID6 = 1
	mydb.MockInsertSuccess7 = true
	mydb.MockInsertID7 = 1
	mydb.MockInsertSuccess8 = true
	mydb.MockInsertID8 = 1

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true
	mydb.MockDeleteSuccess4 = true

	// var getRow db.DbRow
	// getRow.Row = []string{"1", "2", "user", "4", ""}
	// mydb.MockRow1 = &getRow

	var rows1 [][]string
	row1 := []string{"1", "scope1", "4"}
	rows1 = append(rows1, row1)
	var dbrows1 db.DbRows
	dbrows1.Rows = rows1
	mydb.MockRows1 = &dbrows1

	// var rows [][]string
	// row1 := []string{"1", "2", "user", "4", ""}
	// rows = append(rows, row1)
	// var dbrows db.DbRows
	// dbrows.Rows = rows
	// mydb.MockRows1 = &dbrows
	// mydb.MockRows2 = &dbrows
	// mydb.MockRows3 = &dbrows

	var rows [][]string
	row := []string{"1", "2", "user", "4", ""}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	//mydb.MockRows1 = &dbrows
	mydb.MockRows2 = &dbrows
	mydb.MockRows3 = &dbrows
	mydb.MockRows4 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIg

	odbIg = &moadb

	dbIg.Connect()
}

func TestMySQLOauthDBIg_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbIg.AddClient(&c, nil)
	fmt.Println("client add res: ", res)
	fmt.Println("client id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidIg = id
	}
}

func TestMySQLOauthDBIg_AddImplicitGrantNoScope(t *testing.T) {

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ig odb.ImplicitGrant
	ig.ClientID = cidIg
	ig.UserID = "1234"
	res, igid := odbIg.AddImplicitGrant(&ig, &at, nil)
	if !res || igid <= 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_AddImplicitGrant(t *testing.T) {

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ig odb.ImplicitGrant
	ig.ClientID = cidIg
	ig.UserID = "1234"
	var scope = []string{"test1", "test2"}
	res, igid := odbIg.AddImplicitGrant(&ig, &at, &scope)
	if !res || igid <= 0 {
		t.Fail()
	} else {
		spIDIg = igid
	}

}

func TestMySQLOauthDBIg_GetImplicitGrantScopeList(t *testing.T) {
	res := odbIg.GetImplicitGrantScopeList(spIDIg)
	fmt.Println("implicit grant scope in get: ", res)
	if res == nil || (*res)[0].Scope != "scope1" {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_GetImplicitGrant(t *testing.T) {
	res := odbIg.GetImplicitGrant(cidIg, "1234")
	if len(*res) < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_GetImplicitGrantByScope(t *testing.T) {
	res := odbIg.GetImplicitGrantByScope(cidIg, "1234", "test1")
	if len(*res) != 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_AddImplicitGrantFailTk(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	//mydb.MockInsertSuccess1 = true
	//mydb.MockInsertID1 = 5

	//mydb.MockInsertSuccess2 = true
	//mydb.MockInsertID2 = 6

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 7

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIg

	odbIg = &moadb

	dbIg.Connect()

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ig odb.ImplicitGrant
	ig.ClientID = cidIg
	ig.UserID = "1234"
	var scope = []string{"test1", "test2"}
	fmt.Println("last add -------------------------------------------------------")
	res, igid := odbIg.AddImplicitGrant(&ig, &at, &scope)
	if res || igid != 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_AddImplicitGrantFailIg(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	//mydb.MockInsertSuccess2 = true
	//mydb.MockInsertID2 = 6

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 7

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIg

	odbIg = &moadb

	dbIg.Connect()

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ig odb.ImplicitGrant
	ig.ClientID = cidIg
	ig.UserID = "1234"
	var scope = []string{"test1", "test2"}
	fmt.Println("last add -------------------------------------------------------")
	res, igid := odbIg.AddImplicitGrant(&ig, &at, &scope)
	if res || igid != 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_AddImplicitGrantFailScope(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 5

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 6

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 7

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true
	mydb.MockDeleteSuccess4 = true

	// var getRow db.DbRow
	// getRow.Row = []string{"1", "2", "user", "4", ""}
	// mydb.MockRow1 = &getRow

	var rows [][]string
	row1 := []string{"1", "2", "user", "4", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	mydb.MockRows2 = &dbrows
	mydb.MockRows3 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIg

	odbIg = &moadb

	dbIg.Connect()

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ig odb.ImplicitGrant
	ig.ClientID = cidIg
	ig.UserID = "1234"
	var scope = []string{"test1", "test2"}
	fmt.Println("last add -------------------------------------------------------")
	res, _ := odbIg.AddImplicitGrant(&ig, &at, &scope)
	fmt.Println("res in AddImplicitGrantFailScope: ", res)
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_DeleteImplicitGrant(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	// mydb.MockInsertSuccess1 = true
	// mydb.MockInsertID1 = 5

	// mydb.MockInsertSuccess2 = true
	// mydb.MockInsertID2 = 6

	// mydb.MockInsertSuccess3 = true
	// mydb.MockInsertID3 = 7

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true
	mydb.MockDeleteSuccess4 = true

	// var getRow db.DbRow
	// getRow.Row = []string{"1", "2", "user", "4", ""}
	// mydb.MockRow1 = &getRow

	var rows [][]string
	row1 := []string{"1", "2", "user", "4", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	mydb.MockRows2 = &dbrows
	mydb.MockRows3 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIg

	odbIg = &moadb

	dbIg.Connect()

	res := odbIg.DeleteImplicitGrant(cidIg, "1234")
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_DeleteImplicitGrant2(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	// mydb.MockInsertSuccess1 = true
	// mydb.MockInsertID1 = 5

	// mydb.MockInsertSuccess2 = true
	// mydb.MockInsertID2 = 6

	// mydb.MockInsertSuccess3 = true
	// mydb.MockInsertID3 = 7

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true
	mydb.MockDeleteSuccess4 = true

	// var getRow db.DbRow
	// getRow.Row = []string{"1", "2", "user", "4", ""}
	// mydb.MockRow1 = &getRow

	var rows [][]string
	row1 := []string{}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	fmt.Println("rows in test", mydb.MockRows1)
	fmt.Println("rows in test len", len(mydb.MockRows1.Rows))
	//mydb.MockRows2 = &dbrows
	//mydb.MockRows3 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIg

	odbIg = &moadb

	dbIg.Connect()

	res := odbIg.DeleteImplicitGrant(cidIg, "1234")
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_DeleteImplicitGrantFail1(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	// mydb.MockInsertSuccess1 = true
	// mydb.MockInsertID1 = 5

	// mydb.MockInsertSuccess2 = true
	// mydb.MockInsertID2 = 6

	// mydb.MockInsertSuccess3 = true
	// mydb.MockInsertID3 = 7

	// mydb.MockDeleteSuccess1 = true
	// mydb.MockDeleteSuccess2 = true
	// mydb.MockDeleteSuccess3 = true
	// mydb.MockDeleteSuccess4 = true

	// var getRow db.DbRow
	// getRow.Row = []string{"1", "2", "user", "4", ""}
	// mydb.MockRow1 = &getRow

	var rows [][]string
	row1 := []string{"1", "2", "user", "4", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	mydb.MockRows2 = &dbrows
	mydb.MockRows3 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIg

	odbIg = &moadb

	dbIg.Connect()

	res := odbIg.DeleteImplicitGrant(cidIg, "1234")
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_DeleteImplicitGrantFail2(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	// mydb.MockInsertSuccess1 = true
	// mydb.MockInsertID1 = 5

	// mydb.MockInsertSuccess2 = true
	// mydb.MockInsertID2 = 6

	// mydb.MockInsertSuccess3 = true
	// mydb.MockInsertID3 = 7

	mydb.MockDeleteSuccess1 = true
	// mydb.MockDeleteSuccess2 = true
	// mydb.MockDeleteSuccess3 = true
	// mydb.MockDeleteSuccess4 = true

	// var getRow db.DbRow
	// getRow.Row = []string{"1", "2", "user", "4", ""}
	// mydb.MockRow1 = &getRow

	var rows [][]string
	row1 := []string{"1", "2", "user", "4", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	mydb.MockRows2 = &dbrows
	mydb.MockRows3 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIg

	odbIg = &moadb

	dbIg.Connect()

	res := odbIg.DeleteImplicitGrant(cidIg, "1234")
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBIg_DeleteImplicitGrantFail3(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	// mydb.MockInsertSuccess1 = true
	// mydb.MockInsertID1 = 5

	// mydb.MockInsertSuccess2 = true
	// mydb.MockInsertID2 = 6

	// mydb.MockInsertSuccess3 = true
	// mydb.MockInsertID3 = 7

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	// mydb.MockDeleteSuccess3 = true
	// mydb.MockDeleteSuccess4 = true

	// var getRow db.DbRow
	// getRow.Row = []string{"1", "2", "user", "4", ""}
	// mydb.MockRow1 = &getRow

	var rows [][]string
	row1 := []string{"1", "2", "user", "4", ""}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	// var rows2 [][]string
	// row2 := []string{"1", "scope1", "4"}
	// rows2 = append(rows2, row2)
	// var dbrows2 db.DbRows
	// dbrows2.Rows = rows2
	// mydb.MockRows2 = &dbrows2
	//mydb.MockRows2 = &dbrows
	//mydb.MockRows3 = &dbrows

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIg

	odbIg = &moadb

	dbIg.Connect()

	res := odbIg.DeleteImplicitGrant(cidIg, "1234")
	if res {
		t.Fail()
	}
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbroui db.Database
var odbroui odb.Oauth2DB
var cidroui int64

//uil id
var idrouiUidi int64

//role id
var idrouiRoidi int64

var idroui int64

func TestMySQLOauthDBRoleUrii_ConnectAllowURI(t *testing.T) {
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbroui = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbroui

	odbroui = &moadb

	dbroui.Connect()
}

func TestMySQLOauthDBRoleUrii_AddClient(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbroui.AddClient(&c, nil)
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidroui = id
	}
}

func TestMySQLOauthDBRoleUrii_AddClientAllowedURI(t *testing.T) {
	var ur odb.ClientAllowedURI
	ur.ClientID = cidroui
	ur.URI = "someuri"
	res, id := odbroui.AddClientAllowedURI(&ur)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idrouiUidi = id
	}
}

func TestMySQLOauthDBRoleUrii_AddClientRole(t *testing.T) {
	var r odb.ClientRole
	r.ClientID = cidroui
	r.Role = "someRole"
	res, id := odbroui.AddClientRole(&r)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idrouiRoidi = id
	}
}
func TestMySQLOauthDBRoleUrii_AddClientRoleURI(t *testing.T) {
	var r odb.ClientRoleURI
	r.ClientAllowedURIID = idrouiUidi
	r.ClientRoleID = idrouiRoidi
	res := odbroui.AddClientRoleURI(&r)
	// fmt.Println("role uri id: ", id)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBRoleUrii_GetClientRoleURIList(t *testing.T) {
	res := odbroui.GetClientRoleAllowedURIList(idrouiRoidi)
	fmt.Println("Role URI list res: ", res)
	if res == nil || (*res)[0].ClientRoleID != idrouiRoidi {
		t.Fail()
	}
}

func TestMySQLOauthDBRoleUrii_GetClientRoleURIListByClient(t *testing.T) {
	res := odbroui.GetClientRoleAllowedURIListByClientID(cidroui)
	fmt.Println("Role URI list by client res: ", res)
	if res == nil || (*res)[0].ClientRoleID != idrouiRoidi {
		t.Fail()
	}
}

func TestMySQLOauthDBRoleUrii_DeleteClientRoleURI(t *testing.T) {
	var r odb.ClientRoleURI
	r.ClientAllowedURIID = idrouiUidi
	r.ClientRoleID = idrouiRoidi
	res := odbroui.DeleteClientRoleURI(&r)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBRoleUrii_DeleteClientAllowedURI(t *testing.T) {
	res := odbroui.DeleteClientAllowedURI(idrouiUidi)
	fmt.Println("allowed uri  delete: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBRoleUrii_DeleteClientRole(t *testing.T) {
	res := odbroui.DeleteClientRole(idrouiRoidi)
	fmt.Println("role  delete: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBRoleUrii_DeleteClient(t *testing.T) {
	suc := odbroui.DeleteClient(cidroui)
	if !suc {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	//"fmt"

	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//AddCredentialsGrant AddCredentialsGrant
func (d *MySQLOauthDB) AddCredentialsGrant(cg *odb.CredentialsGrant, at *odb.AccessToken) (bool, int64) {
	var suc = false
	var id int64
	if !d.testConnection() {
		d.DB.Connect()
	}
	tx := d.DB.BeginTransaction()
	atsuc, acID := d.AddAccessToken(tx, at)
	d.Log.Debug("atTk res: ", atsuc)
	d.Log.Debug("atTk id: ", acID)
	if atsuc {
		cg.AccessTokenID = acID
		var a []interface{}
		a = append(a, cg.ClientID, cg.AccessTokenID)
		suc, id = tx.Insert(insertCredentialsGrant, a...)
		d.Log.Debug("ig res: ", suc)
		d.Log.Debug("ig id: ", id)
		if suc {
			tx.Commit()
		} else {
			suc = false
			id = 0
			d.Log.Debug("rolling back suc: ", suc)
			tx.Rollback()
		}
	} else {
		tx.Rollback()
	}
	return suc, id
}

//GetCredentialsGrant GetCredentialsGrant
func (d *MySQLOauthDB) GetCredentialsGrant(clientID int64) *[]odb.CredentialsGrant {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.CredentialsGrant
	var a []interface{}
	a = append(a, clientID)
	rows := d.DB.GetList(getCredentialsGrant, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		d.Log.Debug("foundRows in getbyscope: ", foundRows)
		for r := range foundRows {
			foundRow := foundRows[r]
			if len(foundRow) > 0 {
				d.Log.Debug("foundRow in getbyscope: ", foundRow)
				cgID, err := strconv.ParseInt((foundRow)[0], 10, 64)
				if err == nil {
					cid, err := strconv.ParseInt((foundRow)[1], 10, 64)
					if err == nil {
						tid, err := strconv.ParseInt((foundRow)[2], 10, 64)
						if err == nil {
							var rtnc odb.CredentialsGrant
							rtnc.ID = cgID
							rtnc.ClientID = cid
							rtnc.AccessTokenID = tid
							d.Log.Debug("rtnc in getbyscope: ", rtnc)
							rtn = append(rtn, rtnc)
						}
					}
				}
			}
		}
	}
	d.Log.Debug("CredentialsGrant list: ", rtn)
	return &rtn
}

//DeleteCredentialsGrant DeleteCredentialsGrant
func (d *MySQLOauthDB) DeleteCredentialsGrant(clientID int64) bool {
	var suc bool
	if !d.testConnection() {
		d.DB.Connect()
	}
	cgList := d.GetCredentialsGrant(clientID)
	d.Log.Debug("cgList: ", cgList)
	if len(*cgList) == 0 {
		suc = true
	} else {
		for _, cg := range *cgList {
			if cg.ID > 0 {
				tx := d.DB.BeginTransaction()
				var a []interface{}
				a = append(a, cg.ID)
				cgdel := tx.Delete(deleteCredentialsGrant, a...)
				d.Log.Debug("delete cg: ", cgdel)
				if cgdel {
					atdel := d.DeleteAccessToken(tx, cg.AccessTokenID)
					d.Log.Debug("delete AccessToken: ", atdel)
					if atdel {
						suc = true
						tx.Commit()
					} else {
						tx.Rollback()
					}
				} else {
					tx.Rollback()
				}
			}
		}
	}
	return suc
}
package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbb db.Database
var odbb odb.Oauth2DB
var cid int64
var cid2 int64

func TestMySQLDB_Connect(t *testing.T) {

	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow
	mydb.MockInsertSuccess1 = false
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 4

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 4

	mydb.MockInsertSuccess4 = false
	mydb.MockInsertID4 = 4

	mydb.MockUpdateSuccess1 = true

	var mGetRow db.DbRow
	mGetRow.Row = []string{"1", "1235", "tester5", "some site", "some email", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "1235", "tester5", "some site", "some email", "true", "false"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	mydb.MockRows2 = &dbrows
	//mGetRows.Rows[0] = []string{"1", "1235", "tester5", "some site", "some email", "true", "false"}

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = true
	mydb.MockDeleteSuccess3 = true
	mydb.MockDeleteSuccess4 = true

	dbb = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbb

	odbb = &moadb

	dbb.Connect()

}

func TestMySQLDB_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbb.AddClient(&c, nil)
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if res || id == 0 {
		t.Fail()
	} else {
		cid = id
	}
}

func TestMySQLDB_AddClient(t *testing.T) {
	var c odb.Client
	c.Secret = "1234567"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false
	var uis []odb.ClientRedirectURI
	var u1 odb.ClientRedirectURI
	u1.URI = "addSomething"
	uis = append(uis, u1)

	var u2 odb.ClientRedirectURI
	u2.URI = "addSomething2"
	uis = append(uis, u2)

	fmt.Println("before db add")
	res, id := odbb.AddClient(&c, &uis)
	cid2 = id
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if res || id == 0 {
		t.Fail()
	}
}

func TestMySQLDB_UpdateClient(t *testing.T) {
	var c odb.Client
	c.Secret = "555555"
	c.Name = "tester5"
	c.Email = "bob5@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = false
	c.Paid = false
	c.ClientID = cid
	suc := odbb.UpdateClient(&c)
	if !suc {
		t.Fail()
	}
}

func TestMySQLDB_GetClient(t *testing.T) {
	c := odbb.GetClient(cid)
	fmt.Println("client found: ", c)
	if c.Name != "tester5" {
		t.Fail()
	}
}

func TestMySQLDB_GetClients(t *testing.T) {
	cs := odbb.GetClients()
	fmt.Println("client found: ", cs)
	for _, c := range *cs {
		fmt.Println("client found in getClients: ", c)
	}
	if len(*cs) == 0 {
		t.Fail()
	}

}

func TestMySQLDB_SearchClients(t *testing.T) {
	cs := odbb.SearchClients("tester")
	fmt.Println("client found in search: ", cs)
	for _, c := range *cs {
		fmt.Println("client found in searchClients: ", c)
	}
	if len(*cs) == 0 {
		t.Fail()
	}

}

func TestMySQLDB_DeleteClient(t *testing.T) {
	suc := odbb.DeleteClient(cid)
	if !suc {
		t.Fail()
	}
}

func TestMySQLDB_DeleteClient2(t *testing.T) {
	suc := odbb.DeleteClient(cid2)
	if !suc {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	dbtx "github.com/Ulbora/dbinterface"
)

//AddAuthCodeRevolk AddAuthCodeRevolk
func (d *MySQLOauthDB) AddAuthCodeRevolk(tx dbtx.Transaction, rv *odb.AuthCodeRevolk) (bool, int64) {
	var suc bool
	var id int64
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, rv.AuthorizationCode)
	if tx == nil {
		suc, id = d.DB.Insert(insertAuthCodeRevolk, a...)
	} else {
		suc, id = tx.Insert(insertAuthCodeRevolk, a...)
	}
	return suc, id
}

//GetAuthCodeRevolk GetAuthCodeRevolk
func (d *MySQLOauthDB) GetAuthCodeRevolk(ac int64) *odb.AuthCodeRevolk {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, ac)
	row := d.DB.Get(getAuthCodeRevolk, a...)
	d.Log.Debug("row: ", row)
	rtn := parseAuthCodeRevolkRow(&row.Row)
	return rtn
}

//DeleteAuthCodeRevolk DeleteAuthCodeRevolk
func (d *MySQLOauthDB) DeleteAuthCodeRevolk(tx dbtx.Transaction, ac int64) bool {
	var suc bool
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, ac)
	if tx == nil {
		suc = d.DB.Delete(deleteAuthCodeRevolk, a...)
	} else {
		suc = tx.Delete(deleteAuthCodeRevolk, a...)
	}
	return suc
}

func parseAuthCodeRevolkRow(foundRow *[]string) *odb.AuthCodeRevolk {
	var rtn odb.AuthCodeRevolk
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			ac, err := strconv.ParseInt((*foundRow)[1], 10, 64)
			if err == nil {
				rtn.ID = id
				rtn.AuthorizationCode = ac
			}
		}
	}

	return &rtn
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//AddClientGrantType AddClientGrantType
func (d *MySQLOauthDB) AddClientGrantType(gt *odb.ClientGrantType) (bool, int64) {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, gt.GrantType, gt.ClientID)
	suc, id := d.DB.Insert(insertClientGrantType, a...)
	return suc, id
}

//GetClientGrantTypeList GetClientGrantTypeList
func (d *MySQLOauthDB) GetClientGrantTypeList(clientID int64) *[]odb.ClientGrantType {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.ClientGrantType
	var a []interface{}
	a = append(a, clientID)
	rows := d.DB.GetList(getClientGrantTypeList, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			rowContent := parseClientGrantType(&foundRow)
			rtn = append(rtn, *rowContent)
		}
	}
	return &rtn
}

//DeleteClientGrantType DeleteClientGrantType
func (d *MySQLOauthDB) DeleteClientGrantType(id int64) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	return d.DB.Delete(deleteClientGrantType, a...)
}

func parseClientGrantType(foundRow *[]string) *odb.ClientGrantType {
	var rtn odb.ClientGrantType
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			clientID, err := strconv.ParseInt((*foundRow)[2], 10, 64)
			if err == nil {
				rtn.ID = id
				rtn.ClientID = clientID
				rtn.GrantType = (*foundRow)[1]
			}
		}
	}
	return &rtn
}
package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbSo db.Database
var odbSo odb.Oauth2DB
var cidSo int64
var idSo int64

func TestMySQLOauthDB_ConnectScope(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbSo = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	var rows [][]string
	row1 := []string{"1", "somescope", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbSo

	odbSo = &moadb

	dbSo.Connect()
}

func TestMySQLOauthDB_AddClientScope(t *testing.T) {
	cidSo = 2
	var ur odb.ClientScope
	ur.ClientID = cidSo
	ur.Scope = "somescope"
	res, id := odbSo.AddClientScope(&ur)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idSo = id
	}
}

func TestMySQLOauthDB_GetClientScopeList(t *testing.T) {
	res := odbSo.GetClientScopeList(cidSo)
	fmt.Println("scope list res: ", res)
	if res == nil || (*res)[0].ClientID != cidSo {
		t.Fail()
	}
}

func TestMySQLOauthDB_DeleteClientScope(t *testing.T) {
	res := odbSo.DeleteClientScope(idSo)
	fmt.Println("scope  delete: ", res)
	if !res {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	dbtx "github.com/Ulbora/dbinterface"
)

//AddAuthCodeScope AddAuthCodeScope
func (d *MySQLOauthDB) AddAuthCodeScope(tx dbtx.Transaction, as *odb.AuthCodeScope) (bool, int64) {
	var suc bool
	var id int64
	if tx != nil {
		var a []interface{}
		a = append(a, as.Scope, as.AuthorizationCode)
		suc, id = tx.Insert(insertAuthCodeScope, a...)
	}
	return suc, id
}

//GetAuthorizationCodeScopeList GetAuthorizationCodeScopeList
func (d *MySQLOauthDB) GetAuthorizationCodeScopeList(ac int64) *[]odb.AuthCodeScope {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.AuthCodeScope
	var a []interface{}
	a = append(a, ac)
	rows := d.DB.GetList(getAuthorizationCodeScopeList, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			var acs odb.AuthCodeScope
			if len(foundRow) > 0 {
				id, err := strconv.ParseInt((foundRow)[0], 10, 64)
				if err == nil {
					ac, err := strconv.ParseInt((foundRow)[2], 10, 64)
					if err == nil {
						acs.ID = id
						acs.Scope = (foundRow)[1]
						acs.AuthorizationCode = ac
					}
				}
				rtn = append(rtn, acs)
			}
		}
	}
	return &rtn
}

//DeleteAuthCodeScopeList DeleteAuthCodeScopeList
func (d *MySQLOauthDB) DeleteAuthCodeScopeList(tx dbtx.Transaction, ac int64) bool {
	var suc bool
	if tx != nil {
		var a []interface{}
		a = append(a, ac)
		suc = tx.Delete(deleteAllAuthCodeScope, a...)
	}
	return suc
}
package mysqldb

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbPg db.Database
var odbPg odb.Oauth2DB
var cidPg int64 = 1
var spIDPg int64
var spID2Pg int64

func TestMySQLOauthDBPg_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()
}

func TestMySQLOauthDBPg_AddPasswordGrant(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.PasswordGrant
	pwg.ClientID = cidPg
	pwg.UserID = "1234"
	res, id := odbPg.AddPasswordGrant(&pwg, &at, &rt)
	if !res || id < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBPg_AddPasswordGrantFail1(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = false
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.PasswordGrant
	pwg.ClientID = cidPg
	pwg.UserID = "1234"
	res, id := odbPg.AddPasswordGrant(&pwg, &at, &rt)
	if res || id != 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBPg_AddPasswordGrantFail2(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	var rt odb.RefreshToken
	rt.Token = ""

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.PasswordGrant
	pwg.ClientID = cidPg
	pwg.UserID = "1234"
	res, id := odbPg.AddPasswordGrant(&pwg, &at, &rt)
	if !res || id < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBPg_AddPasswordGrantFail3(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = false
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 1

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.PasswordGrant
	pwg.ClientID = cidPg
	pwg.UserID = "1234"
	res, id := odbPg.AddPasswordGrant(&pwg, &at, &rt)
	if res || id != 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBPg_AddPasswordGrantFail4(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 1

	mydb.MockInsertSuccess3 = false
	mydb.MockInsertID3 = 1

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.PasswordGrant
	pwg.ClientID = cidPg
	pwg.UserID = "1234"
	res, id := odbPg.AddPasswordGrant(&pwg, &at, &rt)
	if res || id != 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBPg_DeletePasswordGrant(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = true

	var rows [][]string
	row := []string{"1", "2", "user", "4"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	res := odbPg.DeletePasswordGrant(cidPg, "1234")
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBPg_DeletePasswordGrant2(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = true

	var rows [][]string
	row := []string{}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	fmt.Println("rows in test", mydb.MockRows1)
	fmt.Println("rows in test len", len(mydb.MockRows1.Rows))

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	res := odbPg.DeletePasswordGrant(cidPg, "1234")
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBPg_DeletePasswordGrantFail1(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = false

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = true

	var rows [][]string
	row := []string{"1", "2", "user", "4"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	res := odbPg.DeletePasswordGrant(cidPg, "1234")
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBPg_DeletePasswordGrantFail2(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = false

	mydb.MockDeleteSuccess3 = true

	var rows [][]string
	row := []string{"1", "2", "user", "4"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	res := odbPg.DeletePasswordGrant(cidPg, "1234")
	if res {
		t.Fail()
	}
}

func TestMySQLOauthDBPg_DeletePasswordGrantFail3(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPg = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockDeleteSuccess1 = true

	mydb.MockDeleteSuccess2 = true

	mydb.MockDeleteSuccess3 = false

	var rows [][]string
	row := []string{"1", "2", "user", "4"}
	rows = append(rows, row)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var tt = time.Now()

	var getRow db.DbRow
	getRow.Row = []string{"1", "test1token", tt.Format("2006-01-02 15:04:05"), "1"}
	mydb.MockRow1 = &getRow

	var getRow2 db.DbRow
	getRow2.Row = []string{"1", "test1refreshtoken"}
	mydb.MockRow2 = &getRow2

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPg

	odbPg = &moadb

	dbPg.Connect()

	res := odbPg.DeletePasswordGrant(cidPg, "1234")
	if res {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	dbtx "github.com/Ulbora/dbinterface"
)

//AddImplicitGrantScope AddImplicitGrantScope
func (d *MySQLOauthDB) AddImplicitGrantScope(tx dbtx.Transaction, igs *odb.ImplicitScope) (bool, int64) {
	var suc bool
	var id int64
	if tx != nil {
		var a []interface{}
		a = append(a, igs.Scope, igs.ImplicitGrantID)
		suc, id = tx.Insert(insertImplicitScope, a...)
	}
	return suc, id
}

//GetImplicitGrantScopeList GetImplicitGrantScopeList
func (d *MySQLOauthDB) GetImplicitGrantScopeList(ig int64) *[]odb.ImplicitScope {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.ImplicitScope
	var a []interface{}
	a = append(a, ig)
	rows := d.DB.GetList(getImplicitScopeList, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			if len(foundRow) > 0 {
				var igs odb.ImplicitScope
				id, err := strconv.ParseInt((foundRow)[0], 10, 64)
				if err == nil {
					igid, err := strconv.ParseInt((foundRow)[2], 10, 64)
					if err == nil {
						igs.ID = id
						igs.Scope = (foundRow)[1]
						igs.ImplicitGrantID = igid
					}
				}
				rtn = append(rtn, igs)
			}
		}
	}
	return &rtn
}

//DeleteImplicitGrantScopeList DeleteImplicitGrantScopeList
func (d *MySQLOauthDB) DeleteImplicitGrantScopeList(tx dbtx.Transaction, ig int64) bool {
	var suc bool
	if tx != nil {
		var a []interface{}
		a = append(a, ig)
		suc = tx.Delete(deleteImplicitScope, a...)
	}
	return suc
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbbi db.Database
var odbbi odb.Oauth2DB
var cidi int64
var cid2i int64

func TestMySQLDBi_Connect(t *testing.T) {

	//var db db.Database
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbbi = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbbi

	odbbi = &moadb

	dbbi.Connect()

}

func TestMySQLDBi_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbbi.AddClient(&c, nil)
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidi = id
	}
}

func TestMySQLDBi_AddClient(t *testing.T) {
	var c odb.Client
	c.Secret = "1234567"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false
	var uis []odb.ClientRedirectURI
	var u1 odb.ClientRedirectURI
	u1.URI = "addSomething"
	uis = append(uis, u1)

	var u2 odb.ClientRedirectURI
	u2.URI = "addSomething2"
	uis = append(uis, u2)

	fmt.Println("before db add")
	res, id := odbbi.AddClient(&c, &uis)
	cid2i = id
	fmt.Println("res: ", res)
	fmt.Println("id in addclient int test: ", id)
	if !res || id == 0 {
		t.Fail()
	}
}

func TestMySQLDBi_UpdateClient(t *testing.T) {
	var c odb.Client
	c.Secret = "555555"
	c.Name = "tester5"
	c.Email = "bob5@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = false
	c.Paid = false
	c.ClientID = cidi
	suc := odbbi.UpdateClient(&c)
	if !suc {
		t.Fail()
	}
}

func TestMySQLDBi_GetClient(t *testing.T) {
	c := odbbi.GetClient(cidi)
	fmt.Println("client found: ", c)
	if c.Name != "tester5" {
		t.Fail()
	}
}

func TestMySQLDBi_GetClients(t *testing.T) {
	cs := odbbi.GetClients()
	fmt.Println("client found: ", cs)
	for _, c := range *cs {
		fmt.Println("client found in getClients: ", c)
	}
	if len(*cs) == 0 {
		t.Fail()
	}

}

func TestMySQLDBi_SearchClients(t *testing.T) {
	cs := odbbi.SearchClients("test")
	fmt.Println("client found in search: ", cs)
	for _, c := range *cs {
		fmt.Println("client found in searchClients: ", c)
	}
	if len(*cs) == 0 {
		t.Fail()
	}

}

func TestMySQLDBi_DeleteClient(t *testing.T) {
	suc := odbbi.DeleteClient(cidi)
	if !suc {
		t.Fail()
	}
}

func TestMySQLDBi_DeleteClient2(t *testing.T) {
	suc := odbbi.DeleteClient(cid2i)
	if !suc {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/
import (
	"fmt"
	"strconv"

	lg "github.com/Ulbora/Level_Logger"
	dbi "github.com/Ulbora/dbinterface"
)

//MySQLOauthDB MySQLOauthDB
type MySQLOauthDB struct {
	DB  dbi.Database
	Log *lg.Logger
}

func (d *MySQLOauthDB) testConnection() bool {
	d.Log.Debug("in testConnection")
	var rtn = false
	var a []interface{}
	d.Log.Debug("d.DB: ", fmt.Sprintln(d.DB))
	rowPtr := d.DB.Test(oauthTest, a...)
	d.Log.Debug("rowPtr", *rowPtr)
	d.Log.Debug("after testConnection test", *rowPtr)
	if len(rowPtr.Row) != 0 {
		foundRow := rowPtr.Row
		int64Val, err := strconv.ParseInt(foundRow[0], 10, 0)
		//log.Print("Records found during test ")
		//log.Println("Records found during test :", int64Val)
		if err != nil {
			d.Log.Error(err)
		}
		if int64Val >= 0 {
			rtn = true
		}
	}
	return rtn
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	dbtx "github.com/Ulbora/dbinterface"
)

//AddAccessToken AddAccessToken
func (d *MySQLOauthDB) AddAccessToken(tx dbtx.Transaction, t *odb.AccessToken) (bool, int64) {
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var suc bool
	var id int64
	var a []interface{}
	if tx == nil && t.RefreshTokenID == 0 {
		a = append(a, t.Token, t.Expires)
		suc, id = d.DB.Insert(insertAccessTokenNull, a...)
	} else if tx == nil {
		a = append(a, t.Token, t.Expires, t.RefreshTokenID)
		suc, id = d.DB.Insert(insertAccessToken, a...)
	} else if t.RefreshTokenID == 0 {
		a = append(a, t.Token, t.Expires)
		suc, id = tx.Insert(insertAccessTokenNull, a...)
	} else {
		a = append(a, t.Token, t.Expires, t.RefreshTokenID)
		suc, id = tx.Insert(insertAccessToken, a...)
	}

	return suc, id
}

//UpdateAccessToken UpdateAccessToken
func (d *MySQLOauthDB) UpdateAccessToken(tx dbtx.Transaction, t *odb.AccessToken) bool {
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var suc bool
	var a []interface{}
	if tx == nil && t.RefreshTokenID == 0 {
		a = append(a, t.Token, t.Expires, t.ID)
		suc = d.DB.Update(updateAccessTokenNull, a...)
	} else if tx == nil {
		a = append(a, t.Token, t.Expires, t.RefreshTokenID, t.ID)
		suc = d.DB.Update(updateAccessToken, a...)
	} else if t.RefreshTokenID == 0 {
		a = append(a, t.Token, t.Expires, t.ID)
		suc = tx.Update(updateAccessTokenNull, a...)
	} else {
		a = append(a, t.Token, t.Expires, t.RefreshTokenID, t.ID)
		suc = tx.Update(updateAccessToken, a...)
	}
	return suc
}

//GetAccessToken GetAccessToken
func (d *MySQLOauthDB) GetAccessToken(id int64) *odb.AccessToken {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	row := d.DB.Get(getAccessToken, a...)
	rtn := parseAccessTokenRow(&row.Row)
	return rtn
}

//DeleteAccessToken DeleteAccessToken
func (d *MySQLOauthDB) DeleteAccessToken(tx dbtx.Transaction, id int64) bool {
	var suc bool
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	if tx == nil {
		suc = d.DB.Delete(deleteAccessToken, a...)
	} else {
		suc = tx.Delete(deleteAccessToken, a...)
	}
	return suc
}

func parseAccessTokenRow(foundRow *[]string) *odb.AccessToken {
	var rtn odb.AccessToken
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			cTime, err := time.Parse(odb.TimeFormat, (*foundRow)[2])
			if err == nil {
				rtn.ID = id
				rtn.Token = (*foundRow)[1]
				rtn.Expires = cTime
				if (*foundRow)[3] != "" {
					refTokID, _ := strconv.ParseInt((*foundRow)[3], 10, 64)
					rtn.RefreshTokenID = refTokID
				}
			}
		}
	}
	return &rtn
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbPgi db.Database
var odbPgi odb.Oauth2DB
var cidPgi int64
var spIDPgi int64
var spID2Pgi int64

func TestMySQLOauthDBPgi_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbPgi = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbPgi

	odbPgi = &moadb

	dbPgi.Connect()
}

func TestMySQLOauthDBPgi_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbPgi.AddClient(&c, nil)
	fmt.Println("client add res: ", res)
	fmt.Println("client id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidPgi = id
	}
}

func TestMySQLOauthDBPgi_AddPasswordGrant(t *testing.T) {

	var rt odb.RefreshToken
	rt.Token = "somereftoken2"

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var pwg odb.PasswordGrant
	pwg.ClientID = cidPgi
	pwg.UserID = "1234"
	res, id := odbPgi.AddPasswordGrant(&pwg, &at, &rt)
	if !res || id < 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBPgi_DeletePasswordGrant(t *testing.T) {
	res := odbPgi.DeletePasswordGrant(cidPgi, "1234")
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBPgi_DeleteClient(t *testing.T) {
	suc := odbPgi.DeleteClient(cidPgi)
	if !suc {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"fmt"
	"strconv"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
)

//AddAuthorizationCode AddAuthorizationCode
func (d *MySQLOauthDB) AddAuthorizationCode(code *odb.AuthorizationCode, at *odb.AccessToken, rt *odb.RefreshToken, scopeList *[]string) (bool, int64) {
	var suc bool
	var id int64
	if !d.testConnection() {
		d.DB.Connect()
	}
	tx := d.DB.BeginTransaction()
	var cont bool
	if rt != nil && rt.Token != "" {
		rtsuc, rtID := d.AddRefreshToken(tx, rt)
		d.Log.Debug("refTk res: ", rtsuc)
		d.Log.Debug("refTk id: ", rtID)
		if rtsuc {
			at.RefreshTokenID = rtID
			cont = true
		}
	} else {
		cont = true
	}
	if cont {
		//at.RefreshTokenID = rtID
		atsuc, acID := d.AddAccessToken(tx, at)
		d.Log.Debug("atTk res: ", atsuc)
		d.Log.Debug("atTk id: ", acID)
		if atsuc {
			code.AccessTokenID = acID
			var a []interface{}
			a = append(a, code.ClientID, code.UserID, code.Expires, code.AccessTokenID, code.RandonAuthCode, code.AlreadyUsed)
			suc, id = tx.Insert(insertAuthCode, a...)
			d.Log.Debug("ac res: ", suc)
			d.Log.Debug("ac id: ", id)
			if suc {
				//add code for adding scopes
				var scSuc = true
				if scopeList != nil {
					for _, s := range *scopeList {
						var acs odb.AuthCodeScope
						acs.AuthorizationCode = id
						acs.Scope = s
						ssuc, sid := d.AddAuthCodeScope(tx, &acs)
						d.Log.Debug("scope res: ", ssuc)
						d.Log.Debug("scope id: ", sid)
						if !ssuc {
							d.Log.Debug("scope failed authcode: ", ssuc)
							scSuc = false
						}
					}
				}
				if scSuc {
					suc = true
					tx.Commit()
				} else {
					suc = false
					id = 0
					fmt.Println("scope failed authcode rolling back: ", scSuc)
					tx.Rollback()
				}
			} else {
				tx.Rollback()
			}
		} else {
			tx.Rollback()
		}
	} else {
		tx.Rollback()
	}
	return suc, id
}

//UpdateAuthorizationCode UpdateAuthorizationCode
func (d *MySQLOauthDB) UpdateAuthorizationCode(code *odb.AuthorizationCode) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, code.RandonAuthCode, code.AlreadyUsed, code.AuthorizationCode)
	suc := d.DB.Update(updateAuthCode, a...)
	return suc
}

//UpdateAuthorizationCodeAndToken UpdateAuthorizationCodeAndToken
func (d *MySQLOauthDB) UpdateAuthorizationCodeAndToken(code *odb.AuthorizationCode, at *odb.AccessToken) bool {
	var rtn bool
	if !d.testConnection() {
		d.DB.Connect()
	}
	tx := d.DB.BeginTransaction()
	res := d.UpdateAccessToken(tx, at)
	if res {
		var a []interface{}
		a = append(a, code.Expires, code.AuthorizationCode)
		suc := tx.Update(updateAuthCodeToken, a...)
		if suc {
			rtn = true
			tx.Commit()
		} else {
			tx.Rollback()
		}
	} else {
		tx.Rollback()
	}
	return rtn
}

//GetAuthorizationCode GetAuthorizationCode
func (d *MySQLOauthDB) GetAuthorizationCode(clientID int64, userID string) *[]odb.AuthorizationCode {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.AuthorizationCode
	var a []interface{}
	a = append(a, clientID, userID)
	rows := d.DB.GetList(getByAuthorizationCodeClientUser, a...)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		for r := range foundRows {
			foundRow := foundRows[r]
			if len(foundRow) > 0 {
				rowContent := parseAuthCodeRow(&foundRow)
				rtn = append(rtn, *rowContent)
			}
		}
	}
	// rtn := parseAuthCodeRow(&row.Row)
	d.Log.Debug("authCode: ", rtn)
	return &rtn
}

//GetAuthorizationCodeByScope GetAuthorizationCodeByScope
func (d *MySQLOauthDB) GetAuthorizationCodeByScope(clientID int64, userID string, scope string) *[]odb.AuthorizationCode {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var rtn []odb.AuthorizationCode
	var a []interface{}
	a = append(a, clientID, userID, scope)
	rows := d.DB.GetList(getAuthorizationCodeByClientUserScope, a...)
	d.Log.Debug("rows in getbyscope: ", rows)
	if rows != nil && len(rows.Rows) != 0 {
		foundRows := rows.Rows
		d.Log.Debug("foundRows in getbyscope: ", foundRows)
		for r := range foundRows {
			foundRow := foundRows[r]
			d.Log.Debug("foundRow in getbyscope: ", foundRow)
			ac, err := strconv.ParseInt((foundRow)[0], 10, 64)
			if err == nil {
				cid, err := strconv.ParseInt((foundRow)[1], 10, 64)
				if err == nil {
					var rtnc odb.AuthorizationCode
					rtnc.AuthorizationCode = ac
					rtnc.ClientID = cid
					rtnc.UserID = userID
					rtnc.Scope = (foundRow)[2]
					//rtnc.Expires = cTime
					//rtnc.AccessTokenID = atid
					rtnc.RandonAuthCode = (foundRow)[3]
					rtnc.AlreadyUsed, _ = strconv.ParseBool((foundRow)[4])
					d.Log.Debug("rtnc in getbyscope: ", rtnc)
					rtn = append(rtn, rtnc)
				}
			}
			//rowContent := parseAuthCodeRow(&foundRow)

		}
	}
	// rtn := parseAuthCodeRow(&row.Row)
	fmt.Println("authCode in scope: ", rtn)
	return &rtn
}

//GetAuthorizationCodeByCode GetAuthorizationCodeByCode
func (d *MySQLOauthDB) GetAuthorizationCodeByCode(code string) *odb.AuthorizationCode {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, code)
	row := d.DB.Get(getAuthorizationCodeByCode, a...)
	rtn := parseAuthCodeRow(&row.Row)
	d.Log.Debug("authCode: ", rtn)
	return rtn
}

//DeleteAuthorizationCode DeleteAuthorizationCode
func (d *MySQLOauthDB) DeleteAuthorizationCode(clientID int64, userID string) bool {
	var suc bool
	if !d.testConnection() {
		d.DB.Connect()
	}
	//make this a list call
	acodeList := d.GetAuthorizationCode(clientID, userID)
	d.Log.Debug("auth code list: ", acodeList)
	d.Log.Debug("auth code list: ", len(*acodeList))
	if len(*acodeList) == 0 {
		suc = true
	} else {
		for _, acode := range *acodeList {
			if acode.AuthorizationCode > 0 {
				at := d.GetAccessToken(acode.AccessTokenID)
				var rtid int64
				if at.RefreshTokenID > 0 {
					rt := d.GetRefreshToken(at.RefreshTokenID)
					rtid = rt.ID
				}
				tx := d.DB.BeginTransaction()
				// authCodeRevokeProcessor.deleteAuthCodeRevoke do this
				rvkDel := d.DeleteAuthCodeRevolk(tx, acode.AuthorizationCode)
				d.Log.Debug("delete refresh token: ", rvkDel)
				if rvkDel {
					sdel := d.DeleteAuthCodeScopeList(tx, acode.AuthorizationCode)
					d.Log.Debug("delete scope: ", sdel)
					// d.DeleteAuthCodeScopeList(tx, acode.AuthorizationCode)
					if sdel {
						var a []interface{}
						//a = append(a, clientID, userID)
						//acdel := tx.Delete(deleteAuthCode, a...)
						a = append(a, acode.AuthorizationCode)
						acdel := tx.Delete(deleteAuthCodeByCode, a...)
						d.Log.Debug("delete authCode: ", acdel)
						if acdel {
							atdel := d.DeleteAccessToken(tx, acode.AccessTokenID)
							d.Log.Debug("delete AccessToken: ", atdel)
							if atdel {
								var cont = true
								if rtid > 0 {
									cont = d.DeleteRefreshToken(tx, rtid)
									d.Log.Debug("delete RefreshToken: ", cont)
								}
								if cont {
									suc = true
									tx.Commit()
								} else {
									tx.Rollback()
								}
							} else {
								tx.Rollback()
							}
						} else {
							tx.Rollback()
						}
					} else {
						tx.Rollback()
					}
				} else {
					tx.Rollback()
				}
			}
		}
	}
	return suc
}

func parseAuthCodeRow(foundRow *[]string) *odb.AuthorizationCode {
	//fmt.Println("foundRow in parseAuthCodeRow: ", foundRow)
	var rtn odb.AuthorizationCode
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			// rtn.AuthorizationCode = id
			cid, err := strconv.ParseInt((*foundRow)[1], 10, 64)
			if err == nil {
				// rtn.ClientID = cid
				//uid, err := strconv.ParseInt((*foundRow)[2], 10, 64)
				//if err == nil {
				// rtn.UserID = uid
				cTime, err := time.Parse(odb.TimeFormat, (*foundRow)[3])
				//fmt.Println("time error:", err)
				if err == nil {
					atid, err := strconv.ParseInt((*foundRow)[4], 10, 64)
					if err == nil {
						rtn.AuthorizationCode = id
						rtn.ClientID = cid
						rtn.UserID = (*foundRow)[2]
						rtn.Expires = cTime
						rtn.AccessTokenID = atid
						rtn.RandonAuthCode = (*foundRow)[5]
						rtn.AlreadyUsed, _ = strconv.ParseBool((*foundRow)[6])
					}
				}
				//}
			}
		}
	}
	return &rtn
}
package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbRl db.Database
var odbRl odb.Oauth2DB
var cidRl int64
var idRl int64

func TestMySQLOauthDB_ConnectRole(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbRl = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	var rows [][]string
	row1 := []string{"1", "tester5", "2"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbRl

	odbRl = &moadb

	dbRl.Connect()
}

func TestMySQLOauthDB_AddClientRole(t *testing.T) {
	cidRl = 2
	var r odb.ClientRole
	r.ClientID = cidRl
	r.Role = "someRole"
	res, id := odbRl.AddClientRole(&r)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idRl = id
	}
}

func TestMySQLOauthDB_GetClientRoleList(t *testing.T) {
	res := odbRl.GetClientRoleList(cidRl)
	fmt.Println("Role list res: ", res)
	if res == nil || (*res)[0].ClientID != cidRl {
		t.Fail()
	}
}

func TestMySQLOauthDB_DeleteClientRole(t *testing.T) {
	res := odbRl.DeleteClientRole(idRl)
	fmt.Println("role  delete: ", res)
	if !res {
		t.Fail()
	}
}
package mysqldb

import (
	//"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbb3 db.Database
var odbb3 odb.Oauth2DB
var cid3 int64
var cid23 int64

func TestMySQLDB3_Connect(t *testing.T) {

	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	var mTestRow db.DbRow
	mTestRow.Row = []string{"e"}
	mydb.MockTestRow = &mTestRow
	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 2

	mydb.MockInsertSuccess2 = true
	mydb.MockInsertID2 = 4

	mydb.MockInsertSuccess3 = true
	mydb.MockInsertID3 = 4

	mydb.MockInsertSuccess4 = false
	mydb.MockInsertID4 = 4

	mydb.MockUpdateSuccess1 = true

	var mGetRow db.DbRow
	mGetRow.Row = []string{"1", "1235", "tester5", "some site", "some email", "true", "false"}
	mydb.MockRow1 = &mGetRow

	var rows [][]string
	row1 := []string{"1", "1235", "tester5", "some site", "some email", "true", "false"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows
	mydb.MockRows2 = &dbrows
	//mGetRows.Rows[0] = []string{"1", "1235", "tester5", "some site", "some email", "true", "false"}

	mydb.MockDeleteSuccess1 = true
	mydb.MockDeleteSuccess2 = false
	mydb.MockDeleteSuccess3 = false
	mydb.MockDeleteSuccess4 = true

	dbb3 = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbb3

	odbb3 = &moadb

	dbb3.Connect()

}

// func TestMySQLDB_AddClientNullUri(t *testing.T) {
// 	var c odb.Client
// 	c.Secret = "12345"
// 	c.Name = "tester"
// 	c.Email = "bob@bob.com"
// 	c.WebSite = "www.bob.com"
// 	c.Enabled = true
// 	c.Paid = false

// 	fmt.Println("before db add")
// 	res, id := odbb.AddClient(&c, nil)
// 	fmt.Println("res: ", res)
// 	fmt.Println("id: ", id)
// 	if res || id == 0 {
// 		t.Fail()
// 	} else {
// 		cid = id
// 	}
// }

// func TestMySQLDB3_AddClient(t *testing.T) {
// 	var c odb.Client
// 	c.Secret = "1234567"
// 	c.Name = "tester"
// 	c.Email = "bob@bob.com"
// 	c.WebSite = "www.bob.com"
// 	c.Enabled = true
// 	c.Paid = false
// 	var uis []odb.ClientRedirectURI
// 	var u1 odb.ClientRedirectURI
// 	u1.URI = "addSomething"
// 	uis = append(uis, u1)

// 	var u2 odb.ClientRedirectURI
// 	u2.URI = "addSomething2"
// 	uis = append(uis, u2)

// 	fmt.Println("before db add")
// 	res, id := odbb_2.AddClient(&c, &uis)
// 	cid_2 = id
// 	fmt.Println("res: ", res)
// 	fmt.Println("id: ", id)
// 	if !res || id == 0 {
// 		t.Fail()
// 	}
// }

// func TestMySQLDB_UpdateClient(t *testing.T) {
// 	var c odb.Client
// 	c.Secret = "555555"
// 	c.Name = "tester5"
// 	c.Email = "bob5@bob.com"
// 	c.WebSite = "www.bob.com"
// 	c.Enabled = false
// 	c.Paid = false
// 	c.ClientID = cid
// 	suc := odbb.UpdateClient(&c)
// 	if !suc {
// 		t.Fail()
// 	}
// }

// func TestMySQLDB_GetClient(t *testing.T) {
// 	c := odbb.GetClient(cid)
// 	fmt.Println("client found: ", c)
// 	if c.Name != "tester5" {
// 		t.Fail()
// 	}
// }

// func TestMySQLDB_GetClients(t *testing.T) {
// 	cs := odbb.GetClients()
// 	fmt.Println("client found: ", cs)
// 	for _, c := range *cs {
// 		fmt.Println("client found in getClients: ", c)
// 	}
// 	if len(*cs) == 0 {
// 		t.Fail()
// 	}

// }

// func TestMySQLDB_SearchClients(t *testing.T) {
// 	cs := odbb.SearchClients("tester")
// 	fmt.Println("client found in search: ", cs)
// 	for _, c := range *cs {
// 		fmt.Println("client found in searchClients: ", c)
// 	}
// 	if len(*cs) == 0 {
// 		t.Fail()
// 	}

// }

func TestMySQLDB3_DeleteClient(t *testing.T) {
	suc := odbb3.DeleteClient(cid3)
	if suc {
		t.Fail()
	}
}

// func TestMySQLDB2_DeleteClient2(t *testing.T) {
// 	suc := odbb_2.DeleteClient(cid_2)
// 	if suc {
// 		t.Fail()
// 	}
// }

// func TestMySQLDB_DeleteClient2(t *testing.T) {
// 	suc := odbb.DeleteClient(cid2)
// 	if !suc {
// 		t.Fail()
// 	}
// }
package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbrou db.Database
var odbrou odb.Oauth2DB
var cidrou int64

//uil id
var idrouiUid int64

//role id
var idrouiRoid int64

var idrou int64

func TestMySQLOauthDBRoleUri_ConnectAllowURI(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbrou = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow
	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	var rows [][]string
	row1 := []string{"4", "1"}
	rows = append(rows, row1)
	var dbrows db.DbRows
	dbrows.Rows = rows
	mydb.MockRows1 = &dbrows

	var rowsb [][]string
	row1b := []string{"4", "somerole", "1", "someurl", "2"}
	rowsb = append(rowsb, row1b)
	var dbrowsb db.DbRows
	dbrowsb.Rows = rowsb
	mydb.MockRows2 = &dbrowsb

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbrou

	odbrou = &moadb

	dbrou.Connect()
}

func TestMySQLOauthDBRoleUri_AddClientRoleURI(t *testing.T) {
	cidrou = 2
	idrouiUid = 1
	idrouiRoid = 4

	var r odb.ClientRoleURI
	r.ClientAllowedURIID = idrouiUid
	r.ClientRoleID = idrouiRoid
	res := odbrou.AddClientRoleURI(&r)
	// fmt.Println("role uri id: ", id)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBRoleUri_GetClientRoleURIList(t *testing.T) {
	res := odbrou.GetClientRoleAllowedURIList(idrouiRoid)
	fmt.Println("Role URI list res: ", res)
	fmt.Println("Role URI list res.ClientRoleID: ", (*res)[0].ClientRoleID)
	if res == nil || (*res)[0].ClientRoleID != idrouiRoid {
		t.Fail()
	}
}

func TestMySQLOauthDBRoleUri_GetClientRoleURIListByClient(t *testing.T) {
	res := odbrou.GetClientRoleAllowedURIListByClientID(cidrou)
	fmt.Println("Role URI list by client res: ", res)
	if res == nil || (*res)[0].ClientRoleID != idrouiRoid {
		t.Fail()
	}
}

func TestMySQLOauthDBRoleUri_DeleteClientRoleURI(t *testing.T) {
	var r odb.ClientRoleURI
	r.ClientAllowedURIID = idrouiUid
	r.ClientRoleID = idrouiRoid
	res := odbrou.DeleteClientRoleURI(&r)
	if !res {
		t.Fail()
	}
}
package mysqldb

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

import (
	"strconv"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	dbtx "github.com/Ulbora/dbinterface"
)

//AddRefreshToken AddRefreshToken
func (d *MySQLOauthDB) AddRefreshToken(tx dbtx.Transaction, t *odb.RefreshToken) (bool, int64) {
	var suc bool
	var id int64
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, t.Token)
	if tx == nil {
		suc, id = d.DB.Insert(insertRefreshToken, a...)
	} else {
		suc, id = tx.Insert(insertRefreshToken, a...)
	}
	return suc, id
}

//UpdateRefreshToken UpdateRefreshToken
func (d *MySQLOauthDB) UpdateRefreshToken(t *odb.RefreshToken) bool {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, t.Token, t.ID)
	suc := d.DB.Update(updateRefreshToken, a...)
	return suc
}

//GetRefreshToken GetRefreshToken
func (d *MySQLOauthDB) GetRefreshToken(id int64) *odb.RefreshToken {
	if !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	row := d.DB.Get(getRefreshToken, a...)
	rtn := parseRefreshTokenRow(&row.Row)
	return rtn
}

//DeleteRefreshToken DeleteRefreshToken
func (d *MySQLOauthDB) DeleteRefreshToken(tx dbtx.Transaction, id int64) bool {
	var suc bool
	if tx == nil && !d.testConnection() {
		d.DB.Connect()
	}
	var a []interface{}
	a = append(a, id)
	if tx == nil {
		suc = d.DB.Delete(deleteRefreshToken, a...)
	} else {
		suc = tx.Delete(deleteRefreshToken, a...)
	}
	return suc
}

func parseRefreshTokenRow(foundRow *[]string) *odb.RefreshToken {
	var rtn odb.RefreshToken
	if len(*foundRow) > 0 {
		id, err := strconv.ParseInt((*foundRow)[0], 10, 64)
		if err == nil {
			rtn.ID = id
			rtn.Token = (*foundRow)[1]
		}
	}
	return &rtn
}
package mysqldb

import (
	"fmt"
	"testing"

	//"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbAcRv db.Database
var odbAcRv odb.Oauth2DB
var cidAcRv int64 = 1
var acIDAcRv int64 = 2

//var spID2AcRv int64

func TestMySQLOauthDBAcRv_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAcRv = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var getRow db.DbRow
	getRow.Row = []string{"1", "2"}
	mydb.MockRow1 = &getRow

	mydb.MockInsertSuccess1 = true
	mydb.MockInsertID1 = 1

	mydb.MockDeleteSuccess1 = true

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAcRv

	odbAcRv = &moadb

	dbAcRv.Connect()
}

// func TestMySQLOauthDBAcRv_AddClientNullUri(t *testing.T) {
// 	var c odb.Client
// 	c.Secret = "12345"
// 	c.Name = "tester"
// 	c.Email = "bob@bob.com"
// 	c.WebSite = "www.bob.com"
// 	c.Enabled = true
// 	c.Paid = false

// 	fmt.Println("before db add")
// 	res, id := odbAcRv.AddClient(&c, nil)
// 	fmt.Println("client add res: ", res)
// 	fmt.Println("client id: ", id)
// 	if !res || id == 0 {
// 		t.Fail()
// 	} else {
// 		cidAcRv = id
// 	}
// }

// func TestMySQLOauthDBAcRv_AddAuthorizationCode(t *testing.T) {

// 	var rt odb.RefreshToken
// 	rt.Token = "somereftoken2"

// 	var at odb.AccessToken
// 	at.Token = "someacctoken"
// 	at.Expires = time.Now()

// 	var ac odb.AuthorizationCode
// 	ac.ClientID = cidAcRv
// 	ac.UserID = "1234"
// 	ac.Expires = time.Now()
// 	ac.RandonAuthCode = "13445"

// 	res, id := odbAcRv.AddAuthorizationCode(&ac, &at, &rt, nil)

// 	if !res || id < 1 {
// 		t.Fail()
// 	} else {
// 		acIDAcRv = id
// 	}
// }

func TestMySQLOauthDBAcRv_AddAuthCodeRevolk(t *testing.T) {
	var rv odb.AuthCodeRevolk
	rv.AuthorizationCode = acIDAcRv
	res, id := odbAcRv.AddAuthCodeRevolk(nil, &rv)
	fmt.Println("revolk id: ", id)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcRv_AddAuthCodeRevolkTx(t *testing.T) {

	var mtx mdb.MyDbTxMock
	var mdbx mdb.MyDBMock
	mdbx.MockInsertSuccess1 = true
	mdbx.MockInsertID1 = 1

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mdbx.MockTestRow = &mTestRow

	mtx.MyDBMock = &mdbx
	var moadbtx MySQLOauthDB
	var l lg.Logger
	moadbtx.Log = &l
	//moadbtx.DB = &mtx
	var odbbUri2TX = &moadbtx

	var rv odb.AuthCodeRevolk
	rv.AuthorizationCode = acIDAcRv
	res, id := odbbUri2TX.AddAuthCodeRevolk(&mtx, &rv)
	fmt.Println("revolk id: ", id)
	if !res {
		t.Fail()
	}
}
func TestMySQLOauthDBAcRv_GetAuthCodeRevolk(t *testing.T) {
	rv := odbAcRv.GetAuthCodeRevolk(acIDAcRv)
	fmt.Println("revolk : ", rv)
	if rv == nil {
		t.Fail()
	}
}
func TestMySQLOauthDBAcRv_DeleteAuthCodeRevolk(t *testing.T) {
	res := odbAcRv.DeleteAuthCodeRevolk(nil, acIDAcRv)
	if !res {
		t.Fail()
	}
}

// func TestMySQLOauthDBAcRv_DeleteAuthorizationCode(t *testing.T) {
// 	res := odbAcRv.DeleteAuthorizationCode(cidAcRv, "1234")
// 	if !res {
// 		t.Fail()
// 	}
// }

// func TestMySQLOauthDBAcRv_DeleteClient(t *testing.T) {
// 	suc := odbAcRv.DeleteClient(cidAcRv)
// 	if !suc {
// 		t.Fail()
// 	}
// }
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbAui db.Database
var odbAui odb.Oauth2DB
var cidAui int64
var idAui int64

func TestMySQLOauthDBi_ConnectAllowURI(t *testing.T) {
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAui = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAui

	odbAui = &moadb

	dbAui.Connect()
}

func TestMySQLOauthDBi_AddClientInAlowedUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbAui.AddClient(&c, nil)
	fmt.Println("res: ", res)
	fmt.Println("id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidAui = id
	}
}

func TestMySQLOauthDBi_AddClientAllowedURI(t *testing.T) {
	var ur odb.ClientAllowedURI
	ur.ClientID = cidAui
	ur.URI = "someuri"
	res, id := odbAui.AddClientAllowedURI(&ur)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idAui = id
	}
}

func TestMySQLOauthDBi_UpdateClientAllowedURI(t *testing.T) {
	var ur odb.ClientAllowedURI
	ur.ID = idAui
	ur.URI = "someuri2"
	res := odbAui.UpdateClientAllowedURI(&ur)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBi_GetClientAllowedURIByID(t *testing.T) {
	res := odbAui.GetClientAllowedURIByID(idAui)
	fmt.Println("allowed uri res by id: ", res)
	if res == nil || (*res).ClientID != cidAui || (*res).URI != "someuri2" {
		t.Fail()
	}
}

func TestMySQLOauthDBi_GetClientAllowedURIList(t *testing.T) {
	res := odbAui.GetClientAllowedURIList(cidAui)
	fmt.Println("allowed uri list res: ", res)
	if res == nil || (*res)[0].ClientID != cidAui {
		t.Fail()
	}
}

func TestMySQLOauthDBi_GetClientAllowedURI(t *testing.T) {
	res := odbAui.GetClientAllowedURI(cidAui, "someuri2")
	fmt.Println("allowed uri res: ", res)
	if res == nil || (*res).ClientID != cidAui || (*res).URI != "someuri2" {
		t.Fail()
	}
}
func TestMySQLOauthDBi_DeleteClientAllowedURI(t *testing.T) {
	res := odbAui.DeleteClientAllowedURI(idAui)
	fmt.Println("allowed uri  delete: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBi_DeleteClientInAllowedURI(t *testing.T) {
	suc := odbAui.DeleteClient(cidAui)
	if !suc {
		t.Fail()
	}
}
package mysqldb

import (
	"fmt"
	"testing"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbKey db.Database
var odbKey odb.Oauth2DB
var cidKey int64
var idKey int64

func TestMySQLOauthDBKey_ConnectAllowURI(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbKey = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbKey

	odbKey = &moadb

	dbKey.Connect()
}

func TestMySQLOauthDBKey_GetAccessTokenKey(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbKey = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var getRow db.DbRow
	getRow.Row = []string{"1", "somekey"}
	mydb.MockRow1 = &getRow

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbKey

	odbKey = &moadb

	dbKey.Connect()

	key := odbKey.GetAccessTokenKey()
	fmt.Println("access token key: ", key)
	if key == "" {
		t.Fail()
	}
}

func TestMySQLOauthDBKey_GetRefreshTokenKey(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbKey = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var getRow db.DbRow
	getRow.Row = []string{"1", "somekey"}
	mydb.MockRow1 = &getRow

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbKey

	odbKey = &moadb

	dbKey.Connect()

	key := odbKey.GetRefreshTokenKey()
	fmt.Println("refresh token key: ", key)
	if key == "" {
		t.Fail()
	}
}

func TestMySQLOauthDBKey_GetSessionKey(t *testing.T) {
	var mydb mdb.MyDBMock
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbKey = &mydb

	var mTestRow db.DbRow
	mTestRow.Row = []string{}
	mydb.MockTestRow = &mTestRow

	var getRow db.DbRow
	getRow.Row = []string{"1", "somekey"}
	mydb.MockRow1 = &getRow

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbKey

	odbKey = &moadb

	dbKey.Connect()

	key := odbKey.GetSessionKey()
	fmt.Println("session key: ", key)
	if key == "" {
		t.Fail()
	}
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbIgi db.Database
var odbIgi odb.Oauth2DB
var cidIgi int64
var spIDIgi int64
var spID2Igi int64

func TestMySQLOauthDBIgi_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbIgi = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbIgi

	odbIgi = &moadb

	dbIgi.Connect()
}

func TestMySQLOauthDBIgi_AddClientNullUri(t *testing.T) {
	var c odb.Client
	c.Secret = "12345"
	c.Name = "tester"
	c.Email = "bob@bob.com"
	c.WebSite = "www.bob.com"
	c.Enabled = true
	c.Paid = false

	fmt.Println("before db add")
	res, id := odbIgi.AddClient(&c, nil)
	fmt.Println("client add res: ", res)
	fmt.Println("client id: ", id)
	if !res || id == 0 {
		t.Fail()
	} else {
		cidIgi = id
	}
}

func TestMySQLOauthDBIgi_AddImplicitGrantNoScope(t *testing.T) {

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ig odb.ImplicitGrant
	ig.ClientID = cidIgi
	ig.UserID = "1234"
	res, igid := odbIgi.AddImplicitGrant(&ig, &at, nil)
	if !res || igid <= 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBIgi_AddImplicitGrant(t *testing.T) {

	var at odb.AccessToken
	at.Token = "someacctoken"
	at.Expires = time.Now()

	var ig odb.ImplicitGrant
	ig.ClientID = cidIgi
	ig.UserID = "1234"
	var scope = []string{"test1", "test2"}
	res, igid := odbIgi.AddImplicitGrant(&ig, &at, &scope)
	if !res || igid <= 0 {
		t.Fail()
	}
}

func TestMySQLOauthDBIgi_GetImplicitGrant(t *testing.T) {
	res := odbIgi.GetImplicitGrant(cidIgi, "1234")
	if len(*res) < 2 {
		t.Fail()
	}
}

func TestMySQLOauthDBIgi_GetImplicitGrantByScope(t *testing.T) {
	res := odbIgi.GetImplicitGrantByScope(cidIgi, "1234", "test1")
	if len(*res) != 1 {
		t.Fail()
	}
}

func TestMySQLOauthDBIgi_DeleteImplicitGrant(t *testing.T) {
	res := odbIgi.DeleteImplicitGrant(cidIgi, "1234")
	if !res {
		t.Fail()
	}

}

func TestMySQLOauthDBIgi_DeleteClient(t *testing.T) {
	suc := odbIgi.DeleteClient(cidIgi)
	if !suc {
		t.Fail()
	}
}
// +build integration move to top

package mysqldb

import (
	"fmt"
	"testing"
	"time"

	odb "github.com/Ulbora/GoAuth2/oauth2database"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	mdb "github.com/Ulbora/dbinterface_mysql"
)

var dbAti db.Database
var odbAti odb.Oauth2DB
var idAti int64
var refTkIdi int64

//var cidRti int64

func TestMySQLOauthDBAcTokeni_Connect(t *testing.T) {
	//var db db.Database
	var mydb mdb.MyDB
	mydb.Host = "localhost:3306"
	mydb.User = "admin"
	mydb.Password = "admin"
	mydb.Database = "ulbora_oauth2_server"
	dbAti = &mydb

	var moadb MySQLOauthDB
	var l lg.Logger
	moadb.Log = &l
	moadb.DB = dbAti

	odbAti = &moadb

	dbAti.Connect()
}

func TestMySQLOauthDBAcTokeni_AddAccessToken(t *testing.T) {
	var tk odb.AccessToken
	tk.Token = "someacctoken"
	tk.Expires = time.Now()
	res, id := odbAti.AddAccessToken(nil, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idAti = id
	}
}

func TestMySQLOauthDBAcTokeni_UpdateAccessToken(t *testing.T) {
	var tk odb.AccessToken
	tk.ID = idAti
	tk.Token = "someacctoken2"
	tk.Expires = time.Now()
	res := odbAti.UpdateAccessToken(nil, &tk)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcTokeni_GetAccessToken(t *testing.T) {
	res := odbAti.GetAccessToken(idAti)
	fmt.Println("access token: ", res)
	fmt.Println("access token refTokenId: ", res.RefreshTokenID)
	if res == nil || (*res).Token != "someacctoken2" {
		t.Fail()
	}
}

func TestMySQLOauthDBAcTokeni_DeleteAccessToken(t *testing.T) {
	res := odbAti.DeleteAccessToken(nil, idAti)
	fmt.Println("del access token: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcTokeni_AddRefreshToken(t *testing.T) {
	var tk odb.RefreshToken
	tk.Token = "somereftoken"
	res, id := odbAti.AddRefreshToken(nil, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		refTkIdi = id
	}
}

func TestMySQLOauthDBAcTokeni_AddAccessToken2(t *testing.T) {
	var tk odb.AccessToken
	tk.Token = "someacctoken"
	tk.Expires = time.Now()
	tk.RefreshTokenID = refTkIdi
	res, id := odbAti.AddAccessToken(nil, &tk)
	if !res || id <= 0 {
		t.Fail()
	} else {
		idAti = id
	}
}

func TestMySQLOauthDBAcTokeni_UpdateAccessToken2(t *testing.T) {
	var tk odb.AccessToken
	tk.ID = idAti
	tk.Token = "someacctoken2"
	tk.Expires = time.Now()
	tk.RefreshTokenID = refTkIdi
	res := odbAti.UpdateAccessToken(nil, &tk)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcTokeni_GetAccessToken2(t *testing.T) {
	res := odbAti.GetAccessToken(idAti)
	fmt.Println("access token: ", res)
	fmt.Println("access token refTokenId: ", res.RefreshTokenID)
	if res == nil || (*res).Token != "someacctoken2" {
		t.Fail()
	}
}

func TestMySQLOauthDBAcTokeni_DeleteAccessToken2(t *testing.T) {
	res := odbAti.DeleteAccessToken(nil, idAti)
	fmt.Println("del access token: ", res)
	if !res {
		t.Fail()
	}
}

func TestMySQLOauthDBAcTokeni_DeleteRefreshToken(t *testing.T) {
	res := odbAti.DeleteRefreshToken(nil, refTkIdi)
	fmt.Println("del ref token: ", res)
	if !res {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"

	"net/http"
	"net/http/httptest"
	"testing"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	ac "github.com/Ulbora/GoAuth2/rolecontrol"
	lg "github.com/Ulbora/Level_Logger"
	"github.com/gorilla/mux"
)

// add url grant type

func TestOauthRestHandlerRedectURI_AddRedirectURI(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "uri":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRedirectURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy ResponseID
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !bdy.Success {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_AddRedirectURIBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "uri":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRedirectURI(w, r)
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_AddRedirectURIAddFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "uri":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRedirectURI(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_AddRedirectURINotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "uri":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRedirectURI(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_AddRedirectURIBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRedirectURI(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

// // // get list

func TestOauthRestHandlerRedectURI_GetRedirectURIlist(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRedirectURI
	cuo.ID = 4
	cuo.URI = "/test"
	cuo.ClientID = 10

	var cuol = []m.ClientRedirectURI{cuo}

	var man m.MockManager
	man.MockClientRedirectURIList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientId": "55",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRedirectURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || len(bdy) != 1 {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_GetRedirectURIlistNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRedirectURI
	cuo.ID = 4
	cuo.URI = "/test/url"
	cuo.ClientID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRedirectURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_GetRedirectURIlistBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRedirectURI
	cuo.ID = 4
	cuo.URI = "/test"
	cuo.ClientID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRedirectURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_GetRedirectURIlistNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRedirectURI
	cuo.ID = 4
	cuo.URI = "/test"
	cuo.ClientID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRedirectURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientGrantType
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

// // // delete gt

func TestOauthRestHandlerRedectURI_DeleteRedirectURI(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRedirectURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.Success != true {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_DeleteRedirectURIFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = false
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRedirectURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 500 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_DeleteRedirectURINotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRedirectURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_DeleteRedirectURIBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRedirectURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandlerRedectURI_DeleteRedirectURINoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRedirectURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	ac "github.com/Ulbora/GoAuth2/rolecontrol"
	lg "github.com/Ulbora/Level_Logger"
	"github.com/gorilla/mux"
)

func TestOauthRestHandler_AddClientBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	// r, _ := http.NewRequest("POST", "/ffllist", bytes.NewBuffer(aJSON))
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddClient(w, r)
	if w.Code != 415 {
		t.Fail()
	}

}

func TestOauthRestHandler_AddClientBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	//var robj m.Client
	// robj.ClientID = 3
	// robj.Secret = "testsecret"
	// robj.Name = "testname"
	//aJSON, _ := json.Marshal(robj)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddClient(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddClient(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"secret":"testsecret", "name":"testname", "webSite": "testwebsite", "email": "testemail", "enabled": true, "paid": false, "redirectUrls": [{"id":3, "uri":"/test", "clientId": 2}]}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddClient(w, r)
	hd := w.Header()
	fmt.Println("w content type", hd.Get("Content-Type"))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_AddClientFailAdd(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"secret":"testsecret", "name":"testname", "webSite": "testwebsite", "email": "testemail", "enabled": true, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddClient(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddClientNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"secret":"testsecret", "name":"testname", "webSite": "testwebsite", "email": "testemail", "enabled": true, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddClient(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

// update uri super
func TestOauthRestHandler_UpdateClientBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	// r, _ := http.NewRequest("POST", "/ffllist", bytes.NewBuffer(aJSON))
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateClient(w, r)
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateClientBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	// var robj m.ClientAllowedURI
	// robj.ID = 3
	// robj.URI = "/test"
	// robj.ClientID = 1
	//aJSON, _ := json.Marshal(robj)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateClient(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateClient(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockUpdateSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"clientId": 5, "secret":"testsecret", "name":"testname", "webSite": "testwebsite", "email": "testemail", "enabled": true, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateClient(w, r)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateClientFailAdd(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"clientId": 5, "secret":"testsecret", "name":"testname", "webSite": "testwebsite", "email": "testemail", "enabled": true, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateClient(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateClientNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"clientId": 5, "secret":"testsecret", "name":"testname", "webSite": "testwebsite", "email": "testemail", "enabled": true, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateClient(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetClient(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var uri m.ClientRedirectURI
	uri.ID = 33
	uri.URI = "/test/test"
	uri.ClientID = 44
	var uris = []m.ClientRedirectURI{uri}
	cuo.RedirectURIs = &uris

	var man m.MockManager
	man.MockClient = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClient(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body client in test: ", string(body))

	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.ClientID != 10 || (*bdy.RedirectURIs)[0].ID != 33 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetClientNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var man m.MockManager
	man.MockClient = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClient(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetClientBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var man m.MockManager
	man.MockClient = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClient(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_GetClientNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var man m.MockManager
	man.MockClient = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClient(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

//client admin

func TestOauthRestHandler_GetClientAdmin(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var uri m.ClientRedirectURI
	uri.ID = 33
	uri.URI = "/test/test"
	uri.ClientID = 44
	var uris = []m.ClientRedirectURI{uri}
	cuo.RedirectURIs = &uris

	var man m.MockManager
	man.MockClient = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	r.Header.Set("clientId", "3")
	// vars := map[string]string{
	// 	"id": "5",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClientAdmin(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body client admin in test: ", string(body))

	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.ClientID != 10 || (*bdy.RedirectURIs)[0].ID != 33 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetClientAdminNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var man m.MockManager
	man.MockClient = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	r.Header.Set("clientId", "3")
	// vars := map[string]string{
	// 	"id": "5",
	// }
	//r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClientAdmin(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetClientAdminBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var man m.MockManager
	man.MockClient = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	r.Header.Set("clientId", "q")
	// vars := map[string]string{
	// 	"id": "q",
	// }
	//r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClientAdmin(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_GetClientAdminNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var man m.MockManager
	man.MockClient = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClientAdmin(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

// get list

func TestOauthRestHandler_GetClientlist(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var cuol = []m.Client{cuo}

	var man m.MockManager
	man.MockClientList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientId": "55",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClientList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || len(bdy) != 1 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetClientListNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false
	var cuol = []m.Client{cuo}

	var man m.MockManager
	man.MockClientList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "5",
	// }
	//r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetClientList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetSearchClientlist(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var cuol = []m.Client{cuo}

	var man m.MockManager
	man.MockClientList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"secret":"", "name":"testname", "webSite": "", "email": "", "enabled": false, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	h.GetClientSearchList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || len(bdy) != 1 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetSearchClientlistBadName(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var cuol = []m.Client{cuo}

	var man m.MockManager
	man.MockClientList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"secret":"", "name":"", "webSite": "", "email": "", "enabled": false, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	h.GetClientSearchList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 400 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetSearchClientlistBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var cuol = []m.Client{cuo}

	var man m.MockManager
	man.MockClientList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"secret":"", "name":"testname", "webSite": "", "email": "", "enabled": false, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	h.GetClientSearchList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	fmt.Println("w.Code in bad body search: ", w.Code)
	if w.Code != 400 {
		t.Fail()
	}
}
func TestOauthRestHandler_GetSearchClientlistBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var cuol = []m.Client{cuo}

	var man m.MockManager
	man.MockClientList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"secret":"", "name":"testname", "webSite": "", "email": "", "enabled": false, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	h.GetClientSearchList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetSearchClientlistNoAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.Client
	cuo.ClientID = 10
	cuo.Secret = "secrettest"
	cuo.Name = "test name"
	cuo.WebSite = "testwebsite"
	cuo.Email = "testemail"
	cuo.Enabled = true
	cuo.Paid = false

	var cuol = []m.Client{cuo}

	var man m.MockManager
	man.MockClientList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"secret":"", "name":"testname", "webSite": "", "email": "", "enabled": false, "paid": false}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	h.GetClientSearchList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.Client
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 401 {
		t.Fail()
	}
}

// delete uri

func TestOauthRestHandler_DeleteClient(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteClient(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.Success != true {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteClientFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = false
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteClient(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 500 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteClientNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteClient(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteClientBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteClient(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteClientNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteClient(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"fmt"
	"html/template"
	"net/http"
	"net/http/httptest"
	"testing"

	m "github.com/Ulbora/GoAuth2/managers"
	lg "github.com/Ulbora/Level_Logger"
)

func TestOauthWebHandler_Authorize(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=code&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "http://tester.com/test?code=rr666&state=123" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeNotAuth(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = false
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=code&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "/authorizeApp" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeAuthCodeFail(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = false
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=code&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "/oauthError?error=access_denied" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeImplicit(t *testing.T) {
	var om m.MockManager
	om.MockImplicitAuthorized = true
	om.MockImplicitAuthorizeSuccess = true
	var impRtn m.ImplicitReturn
	impRtn.ID = 5
	impRtn.Token = "gjfldflkl"
	om.MockImplicitReturn = impRtn
	//om.MockAuthCode = 55
	//om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "http://tester.com/test?token=gjfldflkl&token_type=bearer&state=123" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeImplicitCompressed(t *testing.T) {
	var om m.MockManager
	om.MockImplicitAuthorized = true
	om.MockImplicitAuthorizeSuccess = true
	var impRtn m.ImplicitReturn
	impRtn.ID = 5
	impRtn.Token = "gjfldflkl"
	om.MockImplicitReturn = impRtn
	//om.MockAuthCode = 55
	//om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	wh.TokenCompressed = true
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "http://tester.com/test?token=eNpKz0rLSUnLyc4BBAAA//8SXAOx&token_type=bearer&state=123" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeImplicitNotAuth(t *testing.T) {
	var om m.MockManager
	om.MockImplicitAuthorized = false
	om.MockImplicitAuthorizeSuccess = true
	var impRtn m.ImplicitReturn
	impRtn.ID = 5
	impRtn.Token = "gjfldflkl"
	om.MockImplicitReturn = impRtn
	//om.MockAuthCode = 55
	//om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "/authorizeApp" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeImplicitFailed(t *testing.T) {
	var om m.MockManager
	om.MockImplicitAuthorized = true
	om.MockImplicitAuthorizeSuccess = false
	var impRtn m.ImplicitReturn
	impRtn.ID = 5
	impRtn.Token = "gjfldflkl"
	om.MockImplicitReturn = impRtn
	//om.MockAuthCode = 55
	//om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "/oauthError?error=access_denied" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeInvalidGrant(t *testing.T) {
	var om m.MockManager
	om.MockImplicitAuthorized = true
	om.MockImplicitAuthorizeSuccess = false
	var impRtn m.ImplicitReturn
	impRtn.ID = 5
	impRtn.Token = "gjfldflkl"
	om.MockImplicitReturn = impRtn
	//om.MockAuthCode = 55
	//om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=someGrant&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "/oauthError?error=invalid_grant" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeBadSession(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=code&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, nil)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	//loc := w.HeaderMap["Location"]
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeNotLoggedIn(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=code&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	//s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Save(r, w)
	h.Authorize(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "/login" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeApp(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	var acc m.AuthCodeClient
	acc.Valid = true
	acc.ClientName = "test client"
	acc.WebSite = "www.test.com"
	om.MockAuthCodeClient = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "code"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=code&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.AuthorizeApp(w, r)
	fmt.Println("code: ", w.Code)
	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeAppNotValid(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	var acc m.AuthCodeClient
	acc.Valid = false
	acc.ClientName = "test client"
	acc.WebSite = "www.test.com"
	om.MockAuthCodeClient = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "code"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=code&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.AuthorizeApp(w, r)
	fmt.Println("code: ", w.Code)
	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeAppNoAuthInfo(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	var acc m.AuthCodeClient
	acc.Valid = true
	acc.ClientName = "test client"
	acc.WebSite = "www.test.com"
	om.MockAuthCodeClient = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "code"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=code&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	//s.Values["authReqInfo"] = ari

	s.Save(r, w)
	h.AuthorizeApp(w, r)
	fmt.Println("code: ", w.Code)
	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeAppBadSession(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	var acc m.AuthCodeClient
	acc.Valid = true
	acc.ClientName = "test client"
	acc.WebSite = "www.test.com"
	om.MockAuthCodeClient = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "code"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=code&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = ari

	s.Save(r, w)
	h.AuthorizeApp(w, nil)
	fmt.Println("code: ", w.Code)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeAppToken(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	var acc m.ImplicitClient
	acc.Valid = true
	acc.ClientName = "test client"
	acc.WebSite = "www.test.com"
	om.MockImplicitClient = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.AuthorizeApp(w, r)
	fmt.Println("code: ", w.Code)
	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeAppTokenNotAuth(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	var acc m.ImplicitClient
	acc.Valid = false
	acc.ClientName = "test client"
	acc.WebSite = "www.test.com"
	om.MockImplicitClient = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.AuthorizeApp(w, r)
	fmt.Println("code: ", w.Code)
	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeAppTokenNotResponsType(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	var acc m.ImplicitClient
	acc.Valid = true
	acc.ClientName = "test client"
	acc.WebSite = "www.test.com"
	om.MockImplicitClient = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "sometype"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&client_id=125&redirect_uri=http://tester.com/test&scope=web&state=123", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.AuthorizeApp(w, r)
	fmt.Println("code: ", w.Code)
	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeByUserCode(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	var acc m.ImplicitClient
	acc.Valid = true
	acc.ClientName = "test client"
	acc.WebSite = "www.test.com"
	om.MockImplicitClient = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "code"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&authorize=true", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.ApplicationAuthorizationByUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "http://test.com/test?code=rr666&state=12eee" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeByUserCodeFailedAuth(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = false
	var acc m.ImplicitClient
	acc.Valid = true
	acc.ClientName = "test client"
	acc.WebSite = "www.test.com"
	om.MockImplicitClient = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "code"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&authorize=true", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.ApplicationAuthorizationByUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])

	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeByUserToken(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockImplicitAuthorizeSuccess = true
	var acc m.ImplicitReturn
	acc.ID = 55
	acc.Token = "lllkldskldfk"

	om.MockImplicitReturn = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&authorize=true", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.ApplicationAuthorizationByUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "http://test.com/test?token=lllkldskldfk&token_type=bearer&state=12eee" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeByUserTokenCompressed(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockImplicitAuthorizeSuccess = true
	var acc m.ImplicitReturn
	acc.ID = 55
	acc.Token = "lllkldskldfk"

	om.MockImplicitReturn = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	wh.TokenCompressed = true
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&authorize=true", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.ApplicationAuthorizationByUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "http://test.com/test?token=eNrKycnJzkkpzs5JScsGBAAA//8gswT/&token_type=bearer&state=12eee" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeByUserTokenFailedAuth(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockImplicitAuthorizeSuccess = false
	var acc m.ImplicitReturn
	acc.ID = 55
	acc.Token = "lllkldskldfk"

	om.MockImplicitReturn = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&authorize=true", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.ApplicationAuthorizationByUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])

	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeByUserBadResponseType(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockImplicitAuthorizeSuccess = true
	var acc m.ImplicitReturn
	acc.ID = 55
	acc.Token = "lllkldskldfk"

	om.MockImplicitReturn = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "someResponse"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&authorize=true", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = &ari

	s.Save(r, w)
	h.ApplicationAuthorizationByUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]
	if w.Code != 302 || loc[0] != "http://test.com/test?error=access_denied&state=12eee" {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeByUserTokenBadSession(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockImplicitAuthorizeSuccess = true
	var acc m.ImplicitReturn
	acc.ID = 55
	acc.Token = "lllkldskldfk"

	om.MockImplicitReturn = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&authorize=true", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = ari

	s.Save(r, w)
	h.ApplicationAuthorizationByUser(w, nil)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])

	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthWebHandler_AuthorizeByUserTokenNoInfo(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockImplicitAuthorizeSuccess = true
	var acc m.ImplicitReturn
	acc.ID = 55
	acc.Token = "lllkldskldfk"

	om.MockImplicitReturn = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?response_type=token&authorize=true", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	//s.Values["authReqInfo"] = ari

	s.Save(r, w)
	h.ApplicationAuthorizationByUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])

	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandler_Error(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockImplicitAuthorizeSuccess = true
	var acc m.ImplicitReturn
	acc.ID = 55
	acc.Token = "lllkldskldfk"

	om.MockImplicitReturn = acc
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test?error=someError", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)
	s.Values["loggedIn"] = true
	s.Values["user"] = "tester"
	s.Values["authReqInfo"] = ari

	s.Save(r, w)
	h.OauthError(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])

	if w.Code != 200 {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"

	m "github.com/Ulbora/GoAuth2/managers"
	ac "github.com/Ulbora/GoAuth2/rolecontrol"
	lg "github.com/Ulbora/Level_Logger"
	"github.com/gorilla/mux"

	oc "github.com/Ulbora/GoAuth2/oauthclient"

	"net/http"
	"net/http/httptest"
	"testing"
)

func TestOauthRestHandler_AddRoleSuperBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	// r, _ := http.NewRequest("POST", "/ffllist", bytes.NewBuffer(aJSON))
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleSuper(w, r)
	if w.Code != 415 {
		t.Fail()
	}

}

func TestOauthRestHandler_AddRoleSuperBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	var robj m.ClientRole
	robj.ID = 3
	robj.Role = "test"
	robj.ClientID = 1
	//aJSON, _ := json.Marshal(robj)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleSuper(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddRoleSuper(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "role":"test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleSuper(w, r)
	hd := w.Header()
	fmt.Println("w content type", hd.Get("Content-Type"))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_AddRoleSuperFailAdd(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "role":"test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleSuper(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddRoleSuperNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "role":"test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleSuper(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

// add url non super

func TestOauthRestHandler_AddRole(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "role":"test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRole(w, r)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_AddRoleNoAssetControl(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "role":"test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRole(w, r)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_AddRoleBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "role":"test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRole(w, r)
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddRoleAddFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "role":"test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRole(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddRoleNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "role":"test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRole(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddRoleBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRole(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

// get list

func TestOauthRestHandler_GetRolelist(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRole
	cuo.ID = 4
	cuo.Role = "test"
	cuo.ClientID = 10

	var cuol = []m.ClientRole{cuo}

	var man m.MockManager
	man.MockClientRoleList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientId": "55",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRoleList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.ClientRole
	json.Unmarshal(body, &bdy)
	fmt.Println("body roles: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || len(bdy) != 1 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetRoleListNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRole
	cuo.ID = 4
	cuo.Role = "test"
	cuo.ClientID = 10

	var man m.MockManager
	//man.MockClientRoleList = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRoleList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientRole
	json.Unmarshal(body, &bdy)
	fmt.Println("body roles: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetRoleListBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRole
	cuo.ID = 4
	cuo.Role = "test"
	cuo.ClientID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRoleList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientRole
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_GetRoleListNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRole
	cuo.ID = 4
	cuo.Role = "test"
	cuo.ClientID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRoleList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientRole
	json.Unmarshal(body, &bdy)
	fmt.Println("body roles: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

// delete uri

func TestOauthRestHandler_DeleteRole(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRole(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.Success != true {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteRoleFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = false
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRole(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 500 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteRoleNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRole(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteRoleBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRole(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteRoleNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRole(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"fmt"
	"html/template"
	"net/http"
	"net/http/httptest"
	"testing"

	m "github.com/Ulbora/GoAuth2/managers"
	lg "github.com/Ulbora/Level_Logger"
)

func TestOauthWebHandlerIndex_Index(t *testing.T) {
	var om m.MockManager

	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	h.Index(w, r)
	fmt.Println("code: ", w.Code)

	if w.Code != 200 {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"net/http"
	"strconv"

	m "github.com/Ulbora/GoAuth2/managers"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//PageParams PageParams
type PageParams struct {
	Title      string
	ClientName string
	WebSite    string
	Scope      string
	Error      string
}

//Authorize Authorize
func (h *OauthWebHandler) Authorize(w http.ResponseWriter, r *http.Request) {
	//h.Session.InitSessionStore()
	//fmt.Println("in authorize--------------------------------------")
	s, suc := h.getSession(r)
	// fmt.Println("s", s)
	// fmt.Println("store s", s.Store())
	// fmt.Println("name in getSession s", s.Name())
	// fmt.Println("id getSession s", s.ID)
	// fmt.Println("Options in getSession s", s.Options)
	// fmt.Println("SessionKey in getSession", h.Session.SessionKey)

	if suc {
		loggedInAuth := s.Values["loggedIn"]
		userAuth := s.Values["user"]
		h.Log.Debug("loggedIn: ", loggedInAuth)
		h.Log.Debug("user: ", userAuth)

		//session, _ := store.Get(r, "temp-name")

		// fmt.Println("store session", session.Store())
		// fmt.Println("name in getSession session", session.Name())
		// fmt.Println("id getSession session", session.ID)
		// fmt.Println("Options in getSession session", session.Options)

		//loggedIn2 := session.Values["loggedIn"]
		//fmt.Println("loggedIn2", loggedIn2)

		larii := s.Values["authReqInfo"]

		h.Log.Debug("arii-----auth", larii)

		respTypeAuth := r.URL.Query().Get("response_type")
		h.Log.Debug("respType: ", respTypeAuth)

		clientIDStrAuth := r.URL.Query().Get("client_id")
		h.Log.Debug("clientIDStr: ", clientIDStrAuth)

		clientIDAuth, idErr := strconv.ParseInt(clientIDStrAuth, 10, 64)
		h.Log.Debug("clientIDAuth: ", clientIDAuth)
		h.Log.Debug("idErr: ", idErr)

		redirectURLAuth := r.URL.Query().Get("redirect_uri")
		h.Log.Debug("redirURLAuth: ", redirectURLAuth)

		scopeAuth := r.URL.Query().Get("scope")
		h.Log.Debug("scopeAuth: ", scopeAuth)

		stateAuth := r.URL.Query().Get("state")
		h.Log.Debug("stateAuth: ", stateAuth)

		var ari AuthorizeRequestInfo
		ari.ResponseType = respTypeAuth
		ari.ClientID = clientIDAuth
		ari.RedirectURI = redirectURLAuth
		ari.Scope = scopeAuth
		ari.State = stateAuth

		if loggedInAuth == true && userAuth != nil {
			h.Log.Debug("loggedIn: ", loggedInAuth)
			h.Log.Debug("user: ", userAuth)
			if respTypeAuth == codeRespType {
				var au m.AuthCode
				au.ClientID = clientIDAuth
				au.UserID = userAuth.(string)
				au.Scope = scopeAuth
				au.RedirectURI = redirectURLAuth
				authed := h.Manager.CheckAuthCodeApplicationAuthorization(&au)
				h.Log.Debug("authed: ", authed)
				if authed {
					ausuc, acode, acodeStr := h.Manager.AuthorizeAuthCode(&au)
					h.Log.Debug("ausuc: ", ausuc)
					h.Log.Debug("acode: ", acode)
					h.Log.Debug("acodeStr: ", acodeStr)
					if ausuc && acode != 0 && acodeStr != "" {
						http.Redirect(w, r, redirectURLAuth+"?code="+acodeStr+"&state="+stateAuth, http.StatusFound)
					} else {
						http.Redirect(w, r, accessDeniedErrorURL, http.StatusFound)
					}
				} else {
					s.Values["authReqInfo"] = ari
					s.Save(r, w)
					larii := s.Values["authReqInfo"]
					h.Log.Debug("arii-----", larii)
					http.Redirect(w, r, authorizeAppURL, http.StatusFound)
				}
			} else if respTypeAuth == tokenRespType {
				var aut m.Implicit
				aut.ClientID = clientIDAuth
				aut.UserID = userAuth.(string)
				aut.Scope = scopeAuth
				aut.RedirectURI = redirectURLAuth
				iauthed := h.Manager.CheckImplicitApplicationAuthorization(&aut)
				h.Log.Debug("iauthed: ", iauthed)
				if iauthed {
					isuc, im := h.Manager.AuthorizeImplicit(&aut)
					if isuc && im.Token != "" {
						if h.TokenCompressed {
							im.Token = h.JwtCompress.CompressJwt(im.Token)
						}
						http.Redirect(w, r, redirectURLAuth+"?token="+im.Token+"&token_type=bearer&state="+stateAuth, http.StatusFound)
					} else {
						http.Redirect(w, r, accessDeniedErrorURL, http.StatusFound)
					}
				} else {
					s.Values["authReqInfo"] = ari
					s.Save(r, w)
					http.Redirect(w, r, authorizeAppURL, http.StatusFound)
				}
			} else {
				http.Redirect(w, r, invalidGrantErrorURL, http.StatusFound)
			}
		} else {
			//session, _ := store.Get(r, "temp-name")
			//session.Values["authReqInfo"] = "ari"
			//err := session.Save(r, w)
			//fmt.Println("sesErr", err)
			s.Values["authReqInfo"] = ari
			//s.Values["testval"] = "someTest"
			sesErr := s.Save(r, w)
			h.Log.Debug("sesErr", sesErr)
			//larii := s.Values["authReqInfo"]
			//fmt.Println("arii-----", larii)
			http.Redirect(w, r, loginURL, http.StatusFound)
		}
	} else {
		w.WriteHeader(http.StatusInternalServerError)
	}
}

//AuthorizeApp AuthorizeApp
func (h *OauthWebHandler) AuthorizeApp(w http.ResponseWriter, r *http.Request) {
	s, suc := h.getSession(r)
	if suc {
		loggedInAuth := s.Values["loggedIn"]
		userAuth := s.Values["user"]
		h.Log.Debug("loggedIn: ", loggedInAuth)
		h.Log.Debug("user: ", userAuth)

		arii := s.Values["authReqInfo"]
		h.Log.Debug("arii", arii)
		if arii != nil {
			ari := arii.(*AuthorizeRequestInfo)
			h.Log.Debug("ari", ari)
			if ari.ResponseType == codeRespType {
				var au m.AuthCode
				au.ClientID = ari.ClientID
				au.RedirectURI = ari.RedirectURI
				h.Log.Debug("au", au)
				authRes := h.Manager.ValidateAuthCodeClientAndCallback(&au)
				h.Log.Debug("authRes", authRes)
				if authRes.Valid {
					h.Log.Debug("authRes", authRes)
					var pg PageParams
					pg.Title = authAppPageTitle
					pg.ClientName = authRes.ClientName
					pg.WebSite = authRes.WebSite
					pg.Scope = ari.Scope
					h.Templates.ExecuteTemplate(w, authorizeHTML, &pg)
				} else {
					var epg PageParams
					epg.Error = invalidRedirectError
					h.Templates.ExecuteTemplate(w, oauthErrorHTML, &epg)
				}
			} else if ari.ResponseType == tokenRespType {
				var auti m.Implicit
				auti.ClientID = ari.ClientID
				auti.RedirectURI = ari.RedirectURI
				iauthr := h.Manager.ValidateImplicitClientAndCallback(&auti)
				if iauthr.Valid {
					var ipg PageParams
					ipg.Title = authAppPageTitle
					ipg.ClientName = iauthr.ClientName
					ipg.WebSite = iauthr.WebSite
					ipg.Scope = ari.Scope
					h.Templates.ExecuteTemplate(w, authorizeHTML, &ipg)
				} else {
					var iepg PageParams
					iepg.Error = invalidRedirectError
					h.Templates.ExecuteTemplate(w, oauthErrorHTML, &iepg)
				}
			} else {
				var ertepg PageParams
				ertepg.Error = invalidRedirectError
				h.Templates.ExecuteTemplate(w, oauthErrorHTML, &ertepg)
			}
		} else {
			var pg PageParams
			pg.Error = invalidReqestError
			h.Templates.ExecuteTemplate(w, oauthErrorHTML, &pg)
		}
	} else {
		w.WriteHeader(http.StatusInternalServerError)
	}
}

//ApplicationAuthorizationByUser ApplicationAuthorizationByUser
func (h *OauthWebHandler) ApplicationAuthorizationByUser(w http.ResponseWriter, r *http.Request) {
	s, suc := h.getSession(r)
	if suc {
		aaut := r.URL.Query().Get("authorize")
		h.Log.Debug("authorize", aaut)

		aaarii := s.Values["authReqInfo"]
		user := s.Values["user"]
		h.Log.Debug("aaarii", aaarii)
		if aaarii != nil && user != nil {

			aaari := aaarii.(*AuthorizeRequestInfo)
			h.Log.Debug("ari", aaari)
			if aaut == "true" && aaari.ResponseType == codeRespType {
				var aac m.AuthCode
				aac.ClientID = aaari.ClientID
				aac.UserID = user.(string)
				aac.Scope = aaari.Scope
				aac.RedirectURI = aaari.RedirectURI
				authSuc, authCode, authCodeStr := h.Manager.AuthorizeAuthCode(&aac)
				if authSuc && authCode != 0 && authCodeStr != "" {
					h.Log.Debug("authSuc", authSuc)
					h.Log.Debug("authCode", authCode)
					h.Log.Debug("authCodeStr", authCodeStr)
					http.Redirect(w, r, aaari.RedirectURI+"?code="+authCodeStr+"&state="+aaari.State, http.StatusFound)
				} else {
					var aaacpg PageParams
					aaacpg.Error = accessDenidError
					h.Templates.ExecuteTemplate(w, oauthErrorHTML, &aaacpg)
				}
			} else if aaut == "true" && aaari.ResponseType == tokenRespType {
				var aai m.Implicit
				aai.ClientID = aaari.ClientID
				aai.UserID = user.(string)
				aai.Scope = aaari.Scope
				aai.RedirectURI = aaari.RedirectURI
				aaiSuc, irtn := h.Manager.AuthorizeImplicit(&aai)
				h.Log.Debug("aaiSuc", aaiSuc)
				h.Log.Debug("irtn", irtn)
				if aaiSuc && irtn.Token != "" {
					if h.TokenCompressed {
						irtn.Token = h.JwtCompress.CompressJwt(irtn.Token)
					}
					http.Redirect(w, r, aaari.RedirectURI+"?token="+irtn.Token+"&token_type=bearer&state="+aaari.State, http.StatusFound)
				} else {
					var aaipg PageParams
					aaipg.Error = accessDenidError
					h.Templates.ExecuteTemplate(w, oauthErrorHTML, &aaipg)
				}
			} else {
				http.Redirect(w, r, aaari.RedirectURI+"?error=access_denied&state="+aaari.State, http.StatusFound)
			}
		} else {
			var pg PageParams
			pg.Error = invalidReqestError
			h.Templates.ExecuteTemplate(w, oauthErrorHTML, &pg)
		}
	} else {
		w.WriteHeader(http.StatusInternalServerError)
	}
}

//OauthError OauthError
func (h *OauthWebHandler) OauthError(w http.ResponseWriter, r *http.Request) {
	authError := r.URL.Query().Get("error")
	var epg PageParams
	epg.Error = authError
	h.Templates.ExecuteTemplate(w, oauthErrorHTML, &epg)
}
//Package handlers ...
package handlers

import (
	"encoding/gob"
	"html/template"
	"net/http"

	cp "github.com/Ulbora/GoAuth2/compresstoken"
	m "github.com/Ulbora/GoAuth2/managers"
	lg "github.com/Ulbora/Level_Logger"
	gs "github.com/Ulbora/go-sessions"
	"github.com/gorilla/sessions"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

const (
	accessDeniedErrorURL = "/oauthError?error=access_denied"
	authorizeAppURL      = "/authorizeApp"
	invalidGrantErrorURL = "/oauthError?error=invalid_grant"
	loginURL             = "/login"
	loginFailedURL       = "/login?error=Login Failed"

	authorizeHTML  = "authorizeApp.html"
	indexHTML      = "index.html"
	loginHTML      = "login.html"
	oauthErrorHTML = "oauthError.html"
)

//OauthWebHandler OauthWebHandler
type OauthWebHandler struct {
	Manager         m.Manager
	Session         gs.GoSession
	Templates       *template.Template
	Store           *sessions.CookieStore
	TokenCompressed bool
	JwtCompress     cp.JwtCompress
	Log             *lg.Logger
	//SessInit  bool
}

//AuthorizeRequestInfo AuthorizeRequestInfo
type AuthorizeRequestInfo struct {
	ResponseType string
	ClientID     int64
	RedirectURI  string
	Scope        string
	State        string
}

//GetNewWebHandler GetNewWebHandler
func (h *OauthWebHandler) GetNewWebHandler() WebHandler {
	var wh WebHandler
	wh = h
	return wh
}

func (h *OauthWebHandler) getSession(r *http.Request) (*sessions.Session, bool) {
	//fmt.Println("getSession--------------------------------------------------")
	var suc bool
	var srtn *sessions.Session
	if h.Store == nil {
		h.Session.Name = "goauth2"
		h.Session.MaxAge = 3600
		h.Store = h.Session.InitSessionStore()
		//errors without this
		gob.Register(&AuthorizeRequestInfo{})
	}
	if r != nil {
		// fmt.Println("secure in getSession", h.Session.Secure)
		// fmt.Println("name in getSession", h.Session.Name)
		// fmt.Println("MaxAge in getSession", h.Session.MaxAge)
		// fmt.Println("SessionKey in getSession", h.Session.SessionKey)

		//h.Session.HTTPOnly = true

		//h.Session.InitSessionStore()
		s, err := h.Store.Get(r, h.Session.Name)
		//s, err := store.Get(r, "temp-name")
		//s, err := store.Get(r, "goauth2")

		loggedInAuth := s.Values["loggedIn"]
		userAuth := s.Values["user"]
		h.Log.Debug("loggedIn: ", loggedInAuth)
		h.Log.Debug("user: ", userAuth)

		larii := s.Values["authReqInfo"]
		h.Log.Debug("arii-----login", larii)

		h.Log.Debug("session error in getSession: ", err)
		if err == nil {
			suc = true
			srtn = s
		}
	}
	//fmt.Println("exit getSession--------------------------------------------------")
	return srtn, suc
}

//SetContentType SetContentType
func (h *OauthWebHandler) SetContentType(w http.ResponseWriter) {
	w.Header().Set("Content-Type", "application/json")
}

//SetSecurityHeader SetSecurityHeader
func (h *OauthWebHandler) SetSecurityHeader(w http.ResponseWriter) {
	w.Header().Set("Cache-Control", "no-store")
	w.Header().Set("Pragma", "no-cache")
}
//Package handlers ...
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"

	lg "github.com/Ulbora/Level_Logger"
)

func TestOauthRestHandlerLogger_SetDebugLogLevel(t *testing.T) {
	var oh OauthRestHandler
	var logger lg.Logger
	oh.Log = &logger

	h := oh.GetNewRestHandler()
	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"logLevel":"debug"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	r.Header.Set("Logging_KEY", "45sdbb2345")
	w := httptest.NewRecorder()
	h.SetLogLevel(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var lres LogResponse
	json.Unmarshal(body, &lres)
	fmt.Println("body: ", string(body))
	fmt.Println("Code: ", w.Code)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !lres.Success || lres.LogLevel != "DEBUG" {
		t.Fail()
	}
}

func TestOauthRestHandlerLogger_SetDebugLogLevelBadReq(t *testing.T) {
	var oh OauthRestHandler
	var logger lg.Logger
	oh.Log = &logger

	h := oh.GetNewRestHandler()
	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"logLevel":"debug"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	r.Header.Set("Logging_KEY", "45sdbb2345")
	w := httptest.NewRecorder()
	h.SetLogLevel(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var lres LogResponse
	json.Unmarshal(body, &lres)
	fmt.Println("body: ", string(body))
	fmt.Println("Code: ", w.Code)
	if w.Code != 400 {
		t.Fail()
	}
}

func TestOauthRestHandlerLogger_SetInfoLogLevel(t *testing.T) {
	var oh OauthRestHandler
	var logger lg.Logger
	oh.Log = &logger

	h := oh.GetNewRestHandler()
	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"logLevel":"info"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	r.Header.Set("Logging_KEY", "45sdbb2345")
	w := httptest.NewRecorder()
	h.SetLogLevel(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var lres LogResponse
	json.Unmarshal(body, &lres)
	fmt.Println("body: ", string(body))
	fmt.Println("Code: ", w.Code)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !lres.Success || lres.LogLevel != "INFO" {
		t.Fail()
	}
}

func TestOauthRestHandlerLogger_SetAllLogLevel(t *testing.T) {
	var oh OauthRestHandler
	var logger lg.Logger
	oh.Log = &logger

	h := oh.GetNewRestHandler()
	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"logLevel":"all"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	r.Header.Set("Logging_KEY", "45sdbb2345")
	w := httptest.NewRecorder()
	h.SetLogLevel(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var lres LogResponse
	json.Unmarshal(body, &lres)
	fmt.Println("body: ", string(body))
	fmt.Println("Code: ", w.Code)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !lres.Success || lres.LogLevel != "ALL" {
		t.Fail()
	}
}

func TestOauthRestHandlerLogger_SetOffLogLevel(t *testing.T) {
	var oh OauthRestHandler
	var logger lg.Logger
	oh.Log = &logger

	h := oh.GetNewRestHandler()
	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"logLevel":"off"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	r.Header.Set("Logging_KEY", "45sdbb2345")
	w := httptest.NewRecorder()
	h.SetLogLevel(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var lres LogResponse
	json.Unmarshal(body, &lres)
	fmt.Println("body: ", string(body))
	fmt.Println("Code: ", w.Code)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !lres.Success || lres.LogLevel != "OFF" {
		t.Fail()
	}
}

func TestOauthRestHandlerLogger_SetOffLogLevelLogKey(t *testing.T) {
	os.Setenv("LOGGING_KEY", "45sdbb2345")
	var oh OauthRestHandler
	var logger lg.Logger
	oh.Log = &logger

	h := oh.GetNewRestHandler()
	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"logLevel":"off"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	r.Header.Set("Logging_KEY", "45sdbb2345")
	w := httptest.NewRecorder()
	h.SetLogLevel(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var lres LogResponse
	json.Unmarshal(body, &lres)
	fmt.Println("body: ", string(body))
	fmt.Println("Code: ", w.Code)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !lres.Success || lres.LogLevel != "OFF" {
		t.Fail()
	}
	os.Unsetenv("LOGGING_KEY")
}

func TestOauthRestHandlerLogger_SetOffLogLevelLogKeyWrongKey(t *testing.T) {
	os.Setenv("LOGGING_KEY", "45sdbb23455")
	var oh OauthRestHandler
	var logger lg.Logger
	oh.Log = &logger

	h := oh.GetNewRestHandler()
	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"logLevel":"off"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	r.Header.Set("Logging_KEY", "45sdbb2345")
	w := httptest.NewRecorder()
	h.SetLogLevel(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var lres LogResponse
	json.Unmarshal(body, &lres)
	fmt.Println("body: ", string(body))
	fmt.Println("Code: ", w.Code)
	if w.Code != 401 {
		t.Fail()
	}
	os.Unsetenv("LOGGING_KEY")
}

func TestOauthRestHandlerLogger_SetBadMediaLogLevel(t *testing.T) {
	var oh OauthRestHandler
	var logger lg.Logger
	oh.Log = &logger

	h := oh.GetNewRestHandler()
	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"logLevel":"off"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	r.Header.Set("Logging_KEY", "45sdbb2345")
	w := httptest.NewRecorder()
	h.SetLogLevel(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var lres LogResponse
	json.Unmarshal(body, &lres)
	fmt.Println("body: ", string(body))
	fmt.Println("Code: ", w.Code)
	if w.Code != 415 {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"

	"net/http"
	"net/http/httptest"
	"testing"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	ac "github.com/Ulbora/GoAuth2/rolecontrol"
	lg "github.com/Ulbora/Level_Logger"
	"github.com/gorilla/mux"
)

func TestOauthRestHandler_AddAllowedURISuperBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	// r, _ := http.NewRequest("POST", "/ffllist", bytes.NewBuffer(aJSON))
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURISuper(w, r)
	if w.Code != 415 {
		t.Fail()
	}

}

func TestOauthRestHandler_AddAllowedURISuperBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	var robj m.ClientAllowedURI
	robj.ID = 3
	robj.URI = "/test"
	robj.ClientID = 1
	//aJSON, _ := json.Marshal(robj)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURISuper(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddAllowedURISuper(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURISuper(w, r)
	hd := w.Header()
	fmt.Println("w content type", hd.Get("Content-Type"))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_AddAllowedURISuperFailAdd(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURISuper(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddAllowedURISuperNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURISuper(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

// add url non super

func TestOauthRestHandler_AddAllowedURI(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURI(w, r)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_AddAllowedURINoAssetControl(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURI(w, r)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_AddAllowedURIBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURI(w, r)
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddAllowedURIAddFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURI(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddAllowedURINotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURI(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_AddAllowedURIBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddAllowedURI(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

// update uri super
func TestOauthRestHandler_UpdateAllowedURISuperBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	// r, _ := http.NewRequest("POST", "/ffllist", bytes.NewBuffer(aJSON))
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURISuper(w, r)
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateAllowedURISuperBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct

	h := oh.GetNewRestHandler()
	var robj m.ClientAllowedURI
	robj.ID = 3
	robj.URI = "/test"
	robj.ClientID = 1
	//aJSON, _ := json.Marshal(robj)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURISuper(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateAllowedURISuper(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockUpdateSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURISuper(w, r)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateAllowedURISuperFailAdd(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURISuper(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateAllowedURISuperNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURISuper(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

// update uri

// add url non super

func TestOauthRestHandler_updateAllowedURI(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockUpdateSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURI(w, r)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateAllowedURINoAssetControl(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockUpdateSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = false
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURI(w, r)
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateAllowedURIBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockUpdateSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURI(w, r)
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateAllowedURIAddFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockUpdateSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURI(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateAllowedURINotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockUpdateSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURI(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_UpdateAllowedURIBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockUpdateSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.UpdateAllowedURI(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetAllowedURI(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientAllowedURI
	cuo.ID = 4
	cuo.URI = "/test/url"
	cuo.ClientID = 10

	var man m.MockManager
	man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetAllowedURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.ID == 0 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetAllowedURINotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientAllowedURI
	cuo.ID = 4
	cuo.URI = "/test/url"
	cuo.ClientID = 10

	var man m.MockManager
	man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetAllowedURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetAllowedURIBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientAllowedURI
	cuo.ID = 4
	cuo.URI = "/test/url"
	cuo.ClientID = 10

	var man m.MockManager
	man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetAllowedURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_GetAllowedURINoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientAllowedURI
	cuo.ID = 4
	cuo.URI = "/test/url"
	cuo.ClientID = 10

	var man m.MockManager
	man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetAllowedURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

// get list

func TestOauthRestHandler_GetAllowedURIlist(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientAllowedURI
	cuo.ID = 4
	cuo.URI = "/test/url"
	cuo.ClientID = 10

	var cuol = []m.ClientAllowedURI{cuo}

	var man m.MockManager
	man.MockClientAllowedURIList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientId": "55",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetAllowedURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || len(bdy) != 1 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetAllowedURIListNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientAllowedURI
	cuo.ID = 4
	cuo.URI = "/test/url"
	cuo.ClientID = 10

	var man m.MockManager
	man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetAllowedURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_GetAllowedURIListBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientAllowedURI
	cuo.ID = 4
	cuo.URI = "/test/url"
	cuo.ClientID = 10

	var man m.MockManager
	man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetAllowedURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_GetAllowedURIListNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientAllowedURI
	cuo.ID = 4
	cuo.URI = "/test/url"
	cuo.ClientID = 10

	var man m.MockManager
	man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetAllowedURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

// delete uri

func TestOauthRestHandler_DeleteAllowedURI(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteAllowedURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.Success != true {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteAllowedURIFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = false
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteAllowedURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 500 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteAllowedURINotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteAllowedURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteAllowedURIBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteAllowedURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandler_DeleteAllowedURINoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteAllowedURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"

	"net/http"
	"net/http/httptest"
	"testing"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	ac "github.com/Ulbora/GoAuth2/rolecontrol"
	lg "github.com/Ulbora/Level_Logger"
	"github.com/gorilla/mux"
)

// add url grant type

func TestOauthRestHandlerGrtType_AddGrantType(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "grantType":"code", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddGrantType(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy ResponseID
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !bdy.Success {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_AddGrantTypeBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "grantType":"code", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddGrantType(w, r)
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_AddGrantTypeAddFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "grantType":"code", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddGrantType(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_AddGrantTypeNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "grantType":"code", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddGrantType(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_AddGrantTypeBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddGrantType(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

// // get list

func TestOauthRestHandlerGrtType_GetGrantTypelist(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientGrantType
	cuo.ID = 4
	cuo.GrantType = "code"
	cuo.ClientID = 10

	var cuol = []m.ClientGrantType{cuo}

	var man m.MockManager
	man.MockClientGrantTypeList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientId": "55",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetGrantTypeList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || len(bdy) != 1 {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_GetGrantTypeListNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientGrantType
	cuo.ID = 4
	cuo.GrantType = "/test/url"
	cuo.ClientID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetGrantTypeList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_GetGrantTypeListBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientGrantType
	cuo.ID = 4
	cuo.GrantType = "code"
	cuo.ClientID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetGrantTypeList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_GetGrantTypeListNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientGrantType
	cuo.ID = 4
	cuo.GrantType = "code"
	cuo.ClientID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetGrantTypeList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientGrantType
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

// // delete gt

func TestOauthRestHandlerGrtType_DeleteGrantType(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteGrantType(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.Success != true {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_DeleteGrantTypeFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = false
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteGrantType(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 500 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_DeleteGrantTypeNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteGrantType(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_DeleteGrantTypeBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"id": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteGrantType(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandlerGrtType_DeleteGrantTypeNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteGrantType(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	"github.com/gorilla/mux"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//AddRoleURI AddRoleURI
func (h *OauthRestHandler) AddRoleURI(w http.ResponseWriter, r *http.Request) {
	var crui m.ClientRoleURI
	ruibsuc, gerr := h.ProcessBody(r, &crui)
	h.Log.Debug("ruisuc: ", ruibsuc)
	h.Log.Debug("crui: ", crui)
	h.Log.Debug("gerr: ", gerr)
	if ruibsuc && gerr == nil {

		//url of this endpoint
		var addRoleU = "/ulbora/rs/clientRoleUri/add"

		var rlucl oc.Claim
		rlucl.Role = "admin"

		rlucl.URL = addRoleU
		rlucl.Scope = "write"
		h.Log.Debug("client: ", h.Client)

		//check that jwt token user role has permission to use the url of this endpoint
		auth := h.Client.Authorize(r, &rlucl)

		if auth {
			// w.Header().Set("Content-Type", "application/json")
			h.SetContentType(w)
			rluContOk := h.CheckContent(r)
			h.Log.Debug("conOk: ", rluContOk)
			if !rluContOk {
				http.Error(w, "json required", http.StatusUnsupportedMediaType)
			} else {
				rluiaSuc := h.Manager.AddClientRoleURI(&crui)
				h.Log.Debug("gtaSuc: ", rluiaSuc)
				//fmt.Println("gtID: ", gtID)
				var rtn Response
				if rluiaSuc {
					rtn.Success = rluiaSuc
					// rtn.ID = gtID
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		} else {
			var rluiartn ResponseID
			w.WriteHeader(http.StatusUnauthorized)
			resJSON, _ := json.Marshal(rluiartn)
			fmt.Fprint(w, string(resJSON))
		}
	} else {
		http.Error(w, gerr.Error(), http.StatusBadRequest)
	}
}

//GetRoleURIList GetRoleURIList
func (h *OauthRestHandler) GetRoleURIList(w http.ResponseWriter, r *http.Request) {
	var ruialURL = "/ulbora/rs/clientRoleUri/list"

	var ruilcl oc.Claim
	ruilcl.Role = "admin"
	ruilcl.URL = ruialURL
	ruilcl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &ruilcl)
	if auth {
		//var id string
		h.SetContentType(w)
		ruilvars := mux.Vars(r)
		h.Log.Debug("vars: ", len(ruilvars))
		if ruilvars != nil && len(ruilvars) != 0 {
			var ruiRoleIDStr = ruilvars["clientRoleId"]
			h.Log.Debug("vars: ", ruilvars)
			ruiRoleID, ruiidErr := strconv.ParseInt(ruiRoleIDStr, 10, 64)
			if ruiRoleID != 0 && ruiidErr == nil {
				h.Log.Debug("roleId: ", ruiRoleID)
				getRuil := h.Manager.GetClientRoleAllowedURIList(ruiRoleID)
				h.Log.Debug("getgtl: ", getRuil)
				w.WriteHeader(http.StatusOK)
				resJSON, _ := json.Marshal(getRuil)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//DeleteRoleURI DeleteRoleURI
func (h *OauthRestHandler) DeleteRoleURI(w http.ResponseWriter, r *http.Request) {
	var droleURI = "/ulbora/rs/clientRoleUri/delete"

	var ruidcl oc.Claim
	ruidcl.Role = "admin"
	ruidcl.URL = droleURI
	ruidcl.Scope = "write"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &ruidcl)
	if auth {
		h.SetContentType(w)
		ruidvars := mux.Vars(r)
		h.Log.Debug("vars del ru: ", len(ruidvars))
		var clientRoleID int64
		var clientAllowedURIID int64

		if ruidvars != nil && len(ruidvars) == 2 {
			var cridStr = ruidvars["clientRoleId"]
			h.Log.Debug("vars delete crid: ", cridStr)
			crid, cridErr := strconv.ParseInt(cridStr, 10, 64)
			if crid != 0 && cridErr == nil {
				clientRoleID = crid
			}
			var cauidStr = ruidvars["clientAllowedUriId"]
			h.Log.Debug("vars delete cauidStr: ", cauidStr)
			cauid, cauidErr := strconv.ParseInt(cauidStr, 10, 64)
			if cauid != 0 && cauidErr == nil {
				clientAllowedURIID = cauid
			}
		} else {
			rlsContOk := h.CheckContent(r)
			h.Log.Debug("conOk: ", rlsContOk)
			if !rlsContOk {
				http.Error(w, "json required", http.StatusUnsupportedMediaType)
			} else {
				var crui m.ClientRoleURI
				rlssuc, rlserr := h.ProcessBody(r, &crui)
				h.Log.Debug("rlssuc: ", rlssuc)
				h.Log.Debug("crui: ", crui)
				h.Log.Debug("rlserr: ", rlserr)
				if !rlssuc && rlserr != nil {
					http.Error(w, rlserr.Error(), http.StatusBadRequest)
				} else {
					clientRoleID = crui.ClientRoleID
					clientAllowedURIID = crui.ClientAllowedURIID
				}
			}
		}
		if clientRoleID != 0 && clientAllowedURIID != 0 {
			h.Log.Debug("clientRoleID: ", clientRoleID)
			var crui m.ClientRoleURI
			crui.ClientRoleID = clientRoleID
			crui.ClientAllowedURIID = clientAllowedURIID
			cruidsuc := h.Manager.DeleteClientRoleURI(&crui)
			var crudrtn Response
			if cruidsuc {
				crudrtn.Success = cruidsuc
				w.WriteHeader(http.StatusOK)
			} else {
				w.WriteHeader(http.StatusInternalServerError)
			}
			resJSON, _ := json.Marshal(crudrtn)
			fmt.Fprint(w, string(resJSON))
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	"github.com/gorilla/mux"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//AddGrantType AddGrantType
func (h *OauthRestHandler) AddGrantType(w http.ResponseWriter, r *http.Request) {
	var cg m.ClientGrantType
	gsuc, gerr := h.ProcessBody(r, &cg)
	h.Log.Debug("gsuc: ", gsuc)
	h.Log.Debug("cg: ", cg)
	h.Log.Debug("gerr: ", gerr)
	if gsuc && gerr == nil {

		//url of this endpoint
		var addAuURL = "/ulbora/rs/clientGrantType/add"

		var gtcl oc.Claim
		gtcl.Role = "admin"

		gtcl.URL = addAuURL
		gtcl.Scope = "write"
		h.Log.Debug("client: ", h.Client)

		//check that jwt token user role has permission to use the url of this endpoint
		auth := h.Client.Authorize(r, &gtcl)

		if auth {
			// w.Header().Set("Content-Type", "application/json")
			h.SetContentType(w)
			aaURIContOk := h.CheckContent(r)
			h.Log.Debug("conOk: ", aaURIContOk)
			if !aaURIContOk {
				http.Error(w, "json required", http.StatusUnsupportedMediaType)
			} else {
				gtaSuc, gtID := h.Manager.AddClientGrantType(&cg)
				h.Log.Debug("gtaSuc: ", gtaSuc)
				h.Log.Debug("gtID: ", gtID)
				var rtn ResponseID
				if gtaSuc && gtID != 0 {
					rtn.Success = gtaSuc
					rtn.ID = gtID
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		} else {
			var gtfrtn ResponseID
			w.WriteHeader(http.StatusUnauthorized)
			resJSON, _ := json.Marshal(gtfrtn)
			fmt.Fprint(w, string(resJSON))
		}
	} else {
		http.Error(w, gerr.Error(), http.StatusBadRequest)
	}
}

//GetGrantTypeList GetGrantTypeList
func (h *OauthRestHandler) GetGrantTypeList(w http.ResponseWriter, r *http.Request) {
	var getAulURL = "/ulbora/rs/clientGrantType/list"

	var gtlcl oc.Claim
	gtlcl.Role = "admin"
	gtlcl.URL = getAulURL
	gtlcl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &gtlcl)
	if auth {
		//var id string
		h.SetContentType(w)
		gtlvars := mux.Vars(r)
		h.Log.Debug("vars: ", len(gtlvars))
		if gtlvars != nil && len(gtlvars) != 0 {
			var gtclientIDStr = gtlvars["clientId"]
			h.Log.Debug("vars: ", gtlvars)
			clientID, gtlidErr := strconv.ParseInt(gtclientIDStr, 10, 64)
			if clientID != 0 && gtlidErr == nil {
				h.Log.Debug("clientID: ", clientID)
				getgtl := h.Manager.GetClientGrantTypeList(clientID)
				h.Log.Debug("getgtl: ", getgtl)
				w.WriteHeader(http.StatusOK)
				resJSON, _ := json.Marshal(getgtl)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//DeleteGrantType DeleteGrantType
func (h *OauthRestHandler) DeleteGrantType(w http.ResponseWriter, r *http.Request) {
	var getAudURL = "/ulbora/rs/clientGrantType/delete"

	var gtdcl oc.Claim
	gtdcl.Role = "admin"
	gtdcl.URL = getAudURL
	gtdcl.Scope = "write"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &gtdcl)
	if auth {
		//var id string
		h.SetContentType(w)
		gtdvars := mux.Vars(r)
		h.Log.Debug("vars: ", len(gtdvars))
		if gtdvars != nil && len(gtdvars) != 0 {
			var gtlidStr = gtdvars["id"]
			h.Log.Debug("vars delete: ", gtdvars)
			id, idErr := strconv.ParseInt(gtlidStr, 10, 64)
			h.Log.Debug("id delete: ", id)
			if id != 0 && idErr == nil {
				h.Log.Debug("id: ", id)
				gtdsuc := h.Manager.DeleteClientGrantType(id)
				var rtn Response
				if gtdsuc {
					rtn.Success = gtdsuc
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}
//Package handlers ...
package handlers

import (
	"testing"
)

func TestUseMockWeb(t *testing.T) {
	h := UseMockWeb()
	if h == nil {
		t.Fail()
	}
}

func TestUseMockRest(t *testing.T) {
	h := UseMockRest()
	if h == nil {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"

	"net/http"
	"net/http/httptest"
	"testing"

	cp "github.com/Ulbora/GoAuth2/compresstoken"
	m "github.com/Ulbora/GoAuth2/managers"
	lg "github.com/Ulbora/Level_Logger"
)

// validate token

func TestOauthRestHandler_ValidateToken(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockValidateAccessTokenSuccess = true
	oh.Manager = &man

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"accessToken":"someaccesstoken", "hashed": false, "userId":"someUser", "clientId": 2, "role": "someRole", "uri": "someUri", "scope":"someScope"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.ValidateAccessToken(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy ValidationResponse
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !bdy.Valid {
		t.Fail()
	}
}

func TestOauthRestHandler_ValidateTokenCompressed(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockValidateAccessTokenSuccess = true
	oh.Manager = &man
	oh.TokenCompressed = true

	h := oh.GetNewRestHandler()
	var token = "jdljdfldjslkjdsdfgdfgdffgdfgfdfgdfgdfgdfgdfdfdfdfdfdfdfdfgdgdfgdffgdfgdfdfgfdfgdfdfgddddgdgdgdgdgdgdgddggdgdgdgdggdfgdfgdfgdgflkldksldfks"
	var jc cp.JwtCompress
	tkn := jc.CompressJwt(token)
	fmt.Println("compressed token in test", tkn)
	fmt.Println("uncompressed token in test", jc.UnCompressJwt(tkn))

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"accessToken":"eNpUjFEKRDEIAy87JKD58/6w4NJHSwYcRVKkUKhJF4O87NDZ/rwx1+cedATAT/DnV6OVDj1BPb8AAAD//8ZtNs8=", "hashed": false, "userId":"someUser", "clientId": 2, "role": "someRole", "uri": "someUri", "scope":"someScope"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.ValidateAccessToken(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy ValidationResponse
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !bdy.Valid {
		t.Fail()
	}
}

func TestOauthRestHandler_ValidateTokenNotValid(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockValidateAccessTokenSuccess = false
	oh.Manager = &man

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"accessToken":"someaccesstoken", "hashed": false, "userId":"someUser", "clientId": 2, "role": "someRole", "uri": "someUri", "scope":"someScope"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.ValidateAccessToken(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy ValidationResponse
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.Valid {
		t.Fail()
	}
}

func TestOauthRestHandler_ValidateTokenBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockValidateAccessTokenSuccess = true
	oh.Manager = &man

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"accessToken":"someaccesstoken", "hashed": false, "userId":"someUser", "clientId": 2, "role": "someRole", "uri": "someUri", "scope":"someScope"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.ValidateAccessToken(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy ValidationResponse
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandler_ValidateTokenBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockValidateAccessTokenSuccess = true
	oh.Manager = &man

	h := oh.GetNewRestHandler()

	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"accessToken":"someaccesstoken", "hashed": false, "userId":"someUser", "clientId": 2, "role": "someRole", "uri": "someUri", "scope":"someScope"}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.ValidateAccessToken(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy ValidationResponse
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"testing"

	db "github.com/Ulbora/dbinterface"
)

func TestUseHanders_UseWebHandler(t *testing.T) {
	var dbi db.Database
	h := UseWebHandler(dbi, false, "url", nil, nil)
	if h == nil {
		t.Fail()
	}
}

func TestUseHanders_UseRestHandler(t *testing.T) {
	var dbi db.Database
	var assets = "WwogICB7CiAgICAgICJ1cmwiOiIvdWxib3JhL3JzL2NsaWVudEFsbG93ZWRVcmkvYWRkIiwKICAgICAgImFzc2V0cyI6WwogICAgICAgICB7CiAgICAgICAgICAgICJjb250cm9sbGVkQXNzZXQiOiJ1bGJvcmEiLAogICAgICAgICAgICAiYWxsb3dlZFJvbGUiOiJzdXBlckFkbWluIgogICAgICAgICB9CiAgICAgIF0KICAgfSwKICAgewogICAgICAidXJsIjoiL3VsYm9yYS9ycy9jbGllbnRBbGxvd2VkVXJpL3VwZGF0ZSIsCiAgICAgICJhc3NldHMiOlsKICAgICAgICAgewogICAgICAgICAgICAiY29udHJvbGxlZEFzc2V0IjoidWxib3JhIiwKICAgICAgICAgICAgImFsbG93ZWRSb2xlIjoic3VwZXJBZG1pbiIKICAgICAgICAgfQogICAgICBdCiAgIH0sCiAgIHsKICAgICAgInVybCI6Ii91bGJvcmEvcnMvY2xpZW50Um9sZS9hZGQiLAogICAgICAiYXNzZXRzIjpbCiAgICAgICAgIHsKICAgICAgICAgICAgImNvbnRyb2xsZWRBc3NldCI6InN1cGVyQWRtaW4iLAogICAgICAgICAgICAiYWxsb3dlZFJvbGUiOiJzdXBlckFkbWluIgogICAgICAgICB9CiAgICAgIF0KICAgfQpd"
	h := UseRestHandler(dbi, assets, false, "url", nil, nil)
	if h == nil {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	"github.com/gorilla/mux"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//AddClient AddClient
func (h *OauthRestHandler) AddClient(w http.ResponseWriter, r *http.Request) {
	//url of this endpoint
	var addCltURL = "/ulbora/rs/client/add"

	var acltcl oc.Claim
	acltcl.Role = "superAdmin"
	acltcl.URL = addCltURL
	acltcl.Scope = "write"
	h.Log.Debug("client: ", h.Client)
	auth := h.Client.Authorize(r, &acltcl)
	if auth {
		h.SetContentType(w)
		acltContOk := h.CheckContent(r)
		h.Log.Debug("conOk: ", acltContOk)
		if !acltContOk {
			http.Error(w, "json required", http.StatusUnsupportedMediaType)
		} else {
			var cus m.Client
			bcsuc, bcerr := h.ProcessBody(r, &cus)
			h.Log.Debug("bcsuc: ", bcsuc)
			h.Log.Debug("client in add: ", cus)
			h.Log.Debug("bcerr: ", bcerr)
			if !bcsuc && bcerr != nil {
				http.Error(w, bcerr.Error(), http.StatusBadRequest)
			} else {
				// if cus.RedirectURIs == nil {
				// 	var rui []m.ClientRedirectURI
				// 	cus.RedirectURIs = &rui
				// }
				// //test only
				// for _, u := range *cus.RedirectURIs {
				// 	fmt.Println("RedirectURIs in client: ", u)
				// }

				acltSuc, acltID := h.Manager.AddClient(&cus)
				h.Log.Debug("acltSuc: ", acltSuc)
				h.Log.Debug("acltID: ", acltID)
				var rtn ResponseID
				if acltSuc && acltID != 0 {
					rtn.Success = acltSuc
					rtn.ID = acltID
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		}
	} else {
		var facltrtn ResponseID
		w.WriteHeader(http.StatusUnauthorized)
		resJSON, _ := json.Marshal(facltrtn)
		fmt.Fprint(w, string(resJSON))
	}
}

//UpdateClient UpdateClient
func (h *OauthRestHandler) UpdateClient(w http.ResponseWriter, r *http.Request) {
	//url of this endpoint
	var upcltURL = "/ulbora/rs/client/update"

	var upcltscl oc.Claim
	upcltscl.Role = "superAdmin"
	upcltscl.URL = upcltURL
	upcltscl.Scope = "write"
	h.Log.Debug("client: ", h.Client)
	auth := h.Client.Authorize(r, &upcltscl)
	if auth {
		// w.Header().Set("Content-Type", "application/json")
		h.SetContentType(w)
		uPcltContOk := h.CheckContent(r)
		h.Log.Debug("conOk: ", uPcltContOk)
		if !uPcltContOk {
			http.Error(w, "json required", http.StatusUnsupportedMediaType)
		} else {
			var upclt m.Client
			ubcltsuc, uberr := h.ProcessBody(r, &upclt)
			h.Log.Debug("ubcltsuc: ", ubcltsuc)
			h.Log.Debug("client in update: ", upclt)
			h.Log.Debug("uberr: ", uberr)
			if !ubcltsuc && uberr != nil {
				http.Error(w, uberr.Error(), http.StatusBadRequest)
			} else {
				uPcltSuc := h.Manager.UpdateClient(&upclt)
				h.Log.Debug("uPcltSuc: ", uPcltSuc)
				var rtn Response
				if uPcltSuc {
					rtn.Success = uPcltSuc
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		}
	} else {
		var fucltrtn Response
		w.WriteHeader(http.StatusUnauthorized)
		resJSON, _ := json.Marshal(fucltrtn)
		fmt.Fprint(w, string(resJSON))
	}
}

//GetClient GetClient
func (h *OauthRestHandler) GetClient(w http.ResponseWriter, r *http.Request) {
	var getCltURL = "/ulbora/rs/client/get"

	var gcltcl oc.Claim
	gcltcl.Role = "superAdmin"
	gcltcl.URL = getCltURL
	gcltcl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &gcltcl)
	if auth {
		//var id string
		h.SetContentType(w)
		gcltvars := mux.Vars(r)
		h.Log.Debug("vars: ", len(gcltvars))
		if gcltvars != nil && len(gcltvars) != 0 {
			var cltidStr = gcltvars["id"]
			h.Log.Debug("vars: ", gcltvars)
			cltid, idErr := strconv.ParseInt(cltidStr, 10, 64)
			if cltid != 0 && idErr == nil {
				h.Log.Debug("id: ", cltid)
				getClt := h.Manager.GetClient(cltid)
				h.Log.Debug("getClt: ", getClt)
				w.WriteHeader(http.StatusOK)
				resJSON, _ := json.Marshal(getClt)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//GetClientAdmin GetClientAdmin
func (h *OauthRestHandler) GetClientAdmin(w http.ResponseWriter, r *http.Request) {
	var getCltaURL = "/ulbora/rs/client/admin/get"

	var gcltacl oc.Claim
	gcltacl.Role = "admin"
	gcltacl.URL = getCltaURL
	gcltacl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &gcltacl)
	if auth {
		//var id string
		h.SetContentType(w)
		//gcltavars := mux.Vars(r)
		//fmt.Println("vars: ", len(gcltavars))
		cltaidStr := r.Header.Get("clientId")
		if cltaidStr != "" {
			//var cltaidStr = gcltavars["id"]
			//fmt.Println("vars: ", gcltavars)
			cltaid, idErr := strconv.ParseInt(cltaidStr, 10, 64)
			if cltaid != 0 && idErr == nil {
				h.Log.Debug("clientId in admin get: ", cltaid)
				getClta := h.Manager.GetClient(cltaid)
				h.Log.Debug("getClt: ", getClta)
				w.WriteHeader(http.StatusOK)
				resJSON, _ := json.Marshal(getClta)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//GetClientList GetClientList
func (h *OauthRestHandler) GetClientList(w http.ResponseWriter, r *http.Request) {
	var getcltlURL = "/ulbora/rs/client/list"

	var gcltlcl oc.Claim
	gcltlcl.Role = "superAdmin"
	gcltlcl.URL = getcltlURL
	gcltlcl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &gcltlcl)
	if auth {
		h.SetContentType(w)
		getcltl := h.Manager.GetClientList()
		h.Log.Debug("getcltl: ", getcltl)
		w.WriteHeader(http.StatusOK)
		resJSON, _ := json.Marshal(getcltl)
		fmt.Fprint(w, string(resJSON))
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//GetClientSearchList GetClientSearchList
func (h *OauthRestHandler) GetClientSearchList(w http.ResponseWriter, r *http.Request) {
	var getCltsURL = "/ulbora/rs/client/search"

	var gcltscl oc.Claim
	gcltscl.Role = "superAdmin"
	gcltscl.URL = getCltsURL
	gcltscl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &gcltscl)
	if auth {
		h.SetContentType(w)
		acltsContOk := h.CheckContent(r)
		h.Log.Debug("conOk: ", acltsContOk)
		if !acltsContOk {
			http.Error(w, "json required", http.StatusUnsupportedMediaType)
		} else {
			var cus m.Client
			bcltssuc, bcltserr := h.ProcessBody(r, &cus)
			h.Log.Debug("bcltssuc: ", bcltssuc)
			h.Log.Debug("client in search: ", cus)
			h.Log.Debug("bcltserr: ", bcltserr)
			if !bcltssuc && bcltserr != nil {
				http.Error(w, bcltserr.Error(), http.StatusBadRequest)
			} else {
				if cus.Name != "" {
					getCltsl := h.Manager.GetClientSearchList(cus.Name)
					h.Log.Debug("getCltsl: ", getCltsl)
					w.WriteHeader(http.StatusOK)
					resJSON, _ := json.Marshal(getCltsl)
					fmt.Fprint(w, string(resJSON))
				} else {
					w.WriteHeader(http.StatusBadRequest)
				}
			}
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//DeleteClient DeleteClient
func (h *OauthRestHandler) DeleteClient(w http.ResponseWriter, r *http.Request) {
	var cltdURL = "/ulbora/rs/client/delete"

	var cltdcl oc.Claim
	cltdcl.Role = "superAdmin"
	cltdcl.URL = cltdURL
	cltdcl.Scope = "write"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &cltdcl)
	if auth {
		h.SetContentType(w)
		cltdvars := mux.Vars(r)
		h.Log.Debug("vars: ", len(cltdvars))
		if cltdvars != nil && len(cltdvars) != 0 {
			var cltdidStr = cltdvars["id"]
			h.Log.Debug("vars delete: ", cltdvars)
			cltdid, idErr := strconv.ParseInt(cltdidStr, 10, 64)
			h.Log.Debug("id delete clientId: ", cltdid)
			if cltdid != 0 && idErr == nil {
				h.Log.Debug("id: ", cltdid)
				cltdSuc := h.Manager.DeleteClient(cltdid)
				var cltdrtn Response
				if cltdSuc {
					cltdrtn.Success = cltdSuc
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(cltdrtn)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}
//Package handlers ...
package handlers

import (
	"net/http"
	"strconv"

	au "github.com/Ulbora/auth_interface"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//var store = sessions.NewCookieStore([]byte("12345"))

//Login  login handler
func (h *OauthWebHandler) Login(w http.ResponseWriter, r *http.Request) {
	//fmt.Println("login --------------------------------------------------")
	// s, _ := h.getSession(r)
	// fmt.Println("s", s)
	// fmt.Println("store s", s.Store())
	// fmt.Println("name in getSession s", s.Name())
	// fmt.Println("id getSession s", s.ID)
	// fmt.Println("Options in getSession s", s.Options)
	// fmt.Println("session name", s.Name())
	// fmt.Println("SessionKey in getSession", h.Session.SessionKey)

	// loggedInAuth := s.Values["loggedIn"]
	// userAuth := s.Values["user"]
	// fmt.Println("loggedIn: ", loggedInAuth)
	// fmt.Println("user: ", userAuth)

	// larii := s.Values["authReqInfo"]

	// fmt.Println("arii-----login", larii)
	// someTest := s.Values["testval"]

	// fmt.Println("someTest-----login", someTest)

	//session, _ := store.Get(r, "temp-name")
	//fmt.Println("store options ", store.Options)

	//tval := session.Values["authReqInfo"]
	//fmt.Println("tval-----login", tval)

	loginErr := r.URL.Query().Get("error")
	var lpg PageParams
	lpg.Error = loginErr
	lpg.Title = loginPageTitle
	h.Log.Debug("login params: ", lpg)
	h.Templates.ExecuteTemplate(w, loginHTML, &lpg)
}

//LoginUser LoginUser
func (h *OauthWebHandler) LoginUser(w http.ResponseWriter, r *http.Request) {
	//fmt.Println("in login form submit--------------------------------------")
	s, suc := h.getSession(r)
	if suc {
		// fmt.Println("store s", s.Store())
		// fmt.Println("name in getSession s", s.Name())
		// fmt.Println("id getSession s", s.ID)
		// fmt.Println("Options in getSession s", s.Options)
		// fmt.Println("session name", s.Name())
		// fmt.Println("SessionKey in getSession", h.Session.SessionKey)

		larii := s.Values["authReqInfo"]
		h.Log.Debug("arii", larii)
		if larii != nil {
			lari := larii.(*AuthorizeRequestInfo)
			h.Log.Debug("ari", *lari)
			username := r.FormValue("username")
			password := r.FormValue("password")
			h.Log.Debug("username", username)
			h.Log.Debug("password", password)
			var lg au.Login
			lg.ClientID = lari.ClientID
			lg.Username = username
			lg.Password = password
			suc := h.Manager.UserLogin(&lg)
			h.Log.Debug("login suc", suc)
			if suc {
				if lari.ResponseType == codeRespType || lari.ResponseType == tokenRespType {
					s.Values["loggedIn"] = true
					s.Values["user"] = username
					serr := s.Save(r, w)
					h.Log.Debug("serr", serr)
					//session, sserr := store.Get(r, "temp-name")
					//fmt.Println("sserr", sserr)
					//session.Store()
					//session.Options.Path = "/oauth/"
					//session.Values["loggedIn"] = true
					//fmt.Println("store", session.Store())
					//session.Save(r, w)

					clintStr := strconv.FormatInt(lari.ClientID, 10)
					http.Redirect(w, r, "/oauth/authorize?response_type="+lari.ResponseType+"&client_id="+clintStr+"&redirect_uri="+lari.RedirectURI+"&scope="+lari.Scope+"&state="+lari.State, http.StatusFound)
				} else {
					http.Redirect(w, r, invalidGrantErrorURL, http.StatusFound)
				}
			} else {
				http.Redirect(w, r, loginFailedURL, http.StatusFound)
			}
		} else {
			// http.Redirect(w, r, invalidGrantErrorURL, http.StatusFound)
			http.Redirect(w, r, loginFailedURL, http.StatusFound)
		}
	} else {
		w.WriteHeader(http.StatusInternalServerError)
	}
}
//Package handlers ...
package handlers

import (
	"bytes"
	"encoding/json"
	"net/http"
	"testing"

	lg "github.com/Ulbora/Level_Logger"
	// m "github.com/Ulbora/GoAuth2/managers"
	// oa "github.com/Ulbora/GoAuth2/oauthclient"
	// rc "github.com/Ulbora/GoAuth2/rolecontrol"
)

type testObj struct {
	Valid bool   `json:"valid"`
	Code  string `json:"code"`
}

func TestOauthRestHandler_ProcessBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var robj testObj
	robj.Valid = true
	robj.Code = "3"
	// var res http.Response
	// res.Body = ioutil.NopCloser(bytes.NewBufferString(`{"valid":true, "code":"1"}`))
	var sURL = "http://localhost/test"
	aJSON, _ := json.Marshal(robj)
	r, _ := http.NewRequest("POST", sURL, bytes.NewBuffer(aJSON))
	var obj testObj
	suc, _ := oh.ProcessBody(r, &obj)
	if !suc || obj.Valid != true || obj.Code != "3" {
		t.Fail()
	}
}

func TestOauthRestHandler_ProcessBodyBadObj(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var robj testObj
	robj.Valid = true
	robj.Code = "3"
	// var res http.Response
	// res.Body = ioutil.NopCloser(bytes.NewBufferString(`{"valid":true, "code":"1"}`))
	var sURL = "http://localhost/test"
	aJSON, _ := json.Marshal(robj)
	r, _ := http.NewRequest("POST", sURL, bytes.NewBuffer(aJSON))
	var obj testObj
	suc, _ := oh.ProcessBody(r, nil)
	if suc || obj.Valid != false || obj.Code != "" {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"encoding/json"
	"errors"

	"net/http"

	cp "github.com/Ulbora/GoAuth2/compresstoken"
	m "github.com/Ulbora/GoAuth2/managers"
	oa "github.com/Ulbora/GoAuth2/oauthclient"
	rc "github.com/Ulbora/GoAuth2/rolecontrol"
	lg "github.com/Ulbora/Level_Logger"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//OauthRestHandler OauthRestHandler
type OauthRestHandler struct {
	Manager         m.Manager
	Client          oa.Client
	AssetControl    rc.AssetControl
	TokenCompressed bool
	JwtCompress     cp.JwtCompress
	Log             *lg.Logger
}

//GetNewRestHandler GetNewRestHandler
func (h *OauthRestHandler) GetNewRestHandler() RestHandler {
	var rh RestHandler
	rh = h
	return rh
}

//CheckContent CheckContent
func (h *OauthRestHandler) CheckContent(r *http.Request) bool {
	var rtn bool
	cType := r.Header.Get("Content-Type")
	if cType == "application/json" {
		// http.Error(w, "json required", http.StatusUnsupportedMediaType)
		rtn = true
	}
	return rtn
}

//SetContentType SetContentType
func (h *OauthRestHandler) SetContentType(w http.ResponseWriter) {
	w.Header().Set("Content-Type", "application/json")
}

//ProcessBody ProcessBody
func (h *OauthRestHandler) ProcessBody(r *http.Request, obj interface{}) (bool, error) {
	var suc bool
	var err error
	//fmt.Println("r.Body: ", r.Body)
	if r.Body != nil {
		decoder := json.NewDecoder(r.Body)
		//fmt.Println("decoder: ", decoder)
		err = decoder.Decode(obj)
		//fmt.Println("decoder: ", decoder)
		if err != nil {
			//log.Println("Decode Error: ", err.Error())
			h.Log.Error("Decode Error: ", err.Error())
		} else {
			suc = true
		}
	} else {
		err = errors.New("Bad Body")
	}

	return suc, err
}
//Package handlers ...
package handlers

import (
	"fmt"

	b64 "encoding/base64"
	"encoding/json"

	m "github.com/Ulbora/GoAuth2/managers"
	msdb "github.com/Ulbora/GoAuth2/mysqldb"
	odb "github.com/Ulbora/GoAuth2/oauth2database"
	oa "github.com/Ulbora/GoAuth2/oauthclient"
	rc "github.com/Ulbora/GoAuth2/rolecontrol"
	px "github.com/Ulbora/GoProxy"
	lg "github.com/Ulbora/Level_Logger"
	db "github.com/Ulbora/dbinterface"
	dau "github.com/Ulbora/default_auth"
	// mdb "github.com/Ulbora/dbinterface_mysql"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//UseWebHandler UseWebHandler
func UseWebHandler(dbi db.Database, compressJtw bool, authURL string, logger *lg.Logger, tokenParams *m.TokenParams) *OauthWebHandler {
	var oauthManagerw m.OauthManager
	oauthManagerw.TokenParams = tokenParams
	oauthManagerw.Log = logger
	var oauthMySqldbw msdb.MySQLOauthDB
	oauthMySqldbw.Log = logger
	oauthMySqldbw.DB = dbi
	var oauthDbw odb.Oauth2DB
	oauthDbw = &oauthMySqldbw
	oauthManagerw.Db = oauthDbw
	var userServiceProxy px.GoProxy
	oauthManagerw.Proxy = userServiceProxy.GetNewProxy()

	var proxy px.GoProxy
	var da dau.DefaultAuth
	da.AuthServerURL = authURL
	da.Proxy = proxy.GetNewProxy()
	oauthManagerw.AuthService = da.GetNew()

	var wh OauthWebHandler
	wh.Log = logger
	wh.Manager = &oauthManagerw
	wh.TokenCompressed = compressJtw
	return &wh
}

//UseRestHandler UseRestHandler
func UseRestHandler(dbi db.Database, assets string, compressJtw bool, authURL string, logger *lg.Logger, tokenParams *m.TokenParams) *OauthRestHandler {
	var oauthManager m.OauthManager
	oauthManager.TokenParams = tokenParams
	oauthManager.Log = logger
	var oauthMySqldb msdb.MySQLOauthDB
	oauthMySqldb.Log = logger
	oauthMySqldb.DB = dbi
	var oauthDb odb.Oauth2DB
	oauthDb = &oauthMySqldb
	oauthManager.Db = oauthDb

	var proxy px.GoProxy
	var da dau.DefaultAuth
	da.AuthServerURL = authURL
	da.Proxy = proxy.GetNewProxy()
	oauthManager.AuthService = da.GetNew()

	var rh OauthRestHandler
	rh.Log = logger

	rh.Manager = &oauthManager

	var clt oa.OauthClient
	clt.Manager = &oauthManager
	clt.TokenCompressed = compressJtw
	clt.Log = logger
	rh.Client = &clt

	var curs []rc.ControlledURL
	if assets != "" {
		//parse assets
		sDec, err := b64.StdEncoding.DecodeString(assets)
		if err == nil {
			json.Unmarshal(sDec, &curs)
			fmt.Println("curs: ", curs)
		}
	}
	var ac rc.OauthAssets
	ac.AddControledURLs(&curs)
	rh.AssetControl = &ac
	rh.TokenCompressed = compressJtw
	return &rh
}
//Package handlers ...
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"

	lg "github.com/Ulbora/Level_Logger"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//LogLevel LogLevel
type LogLevel struct {
	Level string `json:"logLevel"`
}

//LogResponse LogResponse
type LogResponse struct {
	Success  bool   `json:"success"`
	LogLevel string `json:"logLevel"`
}

const (
	defaultLoggingKey = "45sdbb2345"

	debugLevel = "DEBUG"
	infoLevel  = "INFO"
	allLevel   = "ALL"
	offLevel   = "OFF"
)

//SetLogLevel SetLogLevel
func (h *OauthRestHandler) SetLogLevel(w http.ResponseWriter, r *http.Request) {
	var logRes LogResponse
	h.SetContentType(w)
	logContOk := h.CheckContent(r)

	//fmt.Println("conOk: ", logContOk)

	if !logContOk {
		http.Error(w, "json required", http.StatusUnsupportedMediaType)
	} else {
		var loggingKey string
		if os.Getenv("LOGGING_KEY") != "" {
			loggingKey = os.Getenv("LOGGING_KEY")
		} else {
			loggingKey = defaultLoggingKey
		}
		loggingKeyHdr := r.Header.Get("Logging_KEY")
		if loggingKey == loggingKeyHdr {
			var lv LogLevel
			lgsuc, lgerr := h.ProcessBody(r, &lv)
			//fmt.Println("lgsuc: ", lgsuc)
			//fmt.Println("LogLevel: ", lv)
			//fmt.Println("lgerr: ", lgerr)
			if !lgsuc && lgerr != nil {
				http.Error(w, lgerr.Error(), http.StatusBadRequest)
			} else {
				switch strings.ToUpper(lv.Level) {
				case debugLevel:
					h.Log.LogLevel = lg.DebugLevel
					logRes.Success = true
					logRes.LogLevel = debugLevel
				case infoLevel:
					h.Log.LogLevel = lg.InfoLevel
					logRes.Success = true
					logRes.LogLevel = infoLevel
				case allLevel:
					h.Log.LogLevel = lg.AllLevel
					logRes.Success = true
					logRes.LogLevel = allLevel
				case offLevel:
					h.Log.LogLevel = lg.OffLevel
					logRes.Success = true
					logRes.LogLevel = offLevel
				}
			}
		} else {
			w.WriteHeader(http.StatusUnauthorized)
		}
		resJSON, _ := json.Marshal(logRes)
		fmt.Fprint(w, string(resJSON))
	}
}
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	"github.com/gorilla/mux"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//AddAllowedURISuper AddAllowedURISuper
func (h *OauthRestHandler) AddAllowedURISuper(w http.ResponseWriter, r *http.Request) {
	//url of this endpoint
	var addsAuURL = "/ulbora/rs/clientAllowedUriSuper/add"

	var auscl oc.Claim
	auscl.Role = "superAdmin"
	auscl.URL = addsAuURL
	auscl.Scope = "write"
	h.Log.Debug("client: ", h.Client)
	auth := h.Client.Authorize(r, &auscl)
	if auth {
		h.SetContentType(w)
		aasURIContOk := h.CheckContent(r)
		h.Log.Debug("conOk: ", aasURIContOk)
		if !aasURIContOk {
			http.Error(w, "json required", http.StatusUnsupportedMediaType)
		} else {
			var cus m.ClientAllowedURI
			bsuc, berr := h.ProcessBody(r, &cus)
			h.Log.Debug("bsuc: ", bsuc)
			h.Log.Debug("cu: ", cus)
			h.Log.Debug("berr: ", berr)
			if !bsuc && berr != nil {
				http.Error(w, berr.Error(), http.StatusBadRequest)
			} else {
				ausSuc, ausID := h.Manager.AddClientAllowedURI(&cus)
				h.Log.Debug("auSuc: ", ausSuc)
				h.Log.Debug("auID: ", ausID)
				var rtn ResponseID
				if ausSuc && ausID != 0 {
					rtn.Success = ausSuc
					rtn.ID = ausID
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		}
	} else {
		var fsrtn ResponseID
		w.WriteHeader(http.StatusUnauthorized)
		resJSON, _ := json.Marshal(fsrtn)
		fmt.Fprint(w, string(resJSON))
	}
}

//AddAllowedURI AddAllowedURI
func (h *OauthRestHandler) AddAllowedURI(w http.ResponseWriter, r *http.Request) {
	var cu m.ClientAllowedURI
	bsuc, berr := h.ProcessBody(r, &cu)
	h.Log.Debug("bsuc: ", bsuc)
	h.Log.Debug("cu: ", cu)
	h.Log.Debug("berr: ", berr)
	if bsuc && berr == nil {

		//url of this endpoint
		var addAuURL = "/ulbora/rs/clientAllowedUri/add"

		//make sure the user in not trying to add a prohibited url that has "ulbora" in the url
		//looks through a list of assets for the url and determines the role needed based on the asset part of the url
		acsuc, role := h.AssetControl.GetControlledAsset(addAuURL, "ulbora")

		var aucl oc.Claim
		if acsuc {
			aucl.Role = role
		} else {
			aucl.Role = "admin"
		}
		aucl.URL = addAuURL
		aucl.Scope = "write"
		h.Log.Debug("client: ", h.Client)

		//check that jwt token user role has permission to use the url of this endpoint
		auth := h.Client.Authorize(r, &aucl)

		if auth {
			// w.Header().Set("Content-Type", "application/json")
			h.SetContentType(w)
			aaURIContOk := h.CheckContent(r)
			h.Log.Debug("conOk: ", aaURIContOk)
			if !aaURIContOk {
				http.Error(w, "json required", http.StatusUnsupportedMediaType)
			} else {
				auSuc, auID := h.Manager.AddClientAllowedURI(&cu)
				h.Log.Debug("auSuc: ", auSuc)
				h.Log.Debug("auID: ", auID)
				var rtn ResponseID
				if auSuc && auID != 0 {
					rtn.Success = auSuc
					rtn.ID = auID
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		} else {
			var frtn ResponseID
			w.WriteHeader(http.StatusUnauthorized)
			resJSON, _ := json.Marshal(frtn)
			fmt.Fprint(w, string(resJSON))
		}
	} else {
		http.Error(w, berr.Error(), http.StatusBadRequest)
	}
}

//UpdateAllowedURISuper UpdateAllowedURISuper
func (h *OauthRestHandler) UpdateAllowedURISuper(w http.ResponseWriter, r *http.Request) {
	//url of this endpoint
	h.Log.Debug("inside UpdateAllowedURISuper------------------------------------")

	var upsAuURL = "/ulbora/rs/clientAllowedUriSuper/update"

	var upuscl oc.Claim
	upuscl.Role = "superAdmin"
	upuscl.URL = upsAuURL
	upuscl.Scope = "write"
	h.Log.Debug("client: ", h.Client)
	auth := h.Client.Authorize(r, &upuscl)
	h.Log.Debug("auth: ", auth)
	if auth {
		// w.Header().Set("Content-Type", "application/json")
		h.SetContentType(w)
		uPasURIContOk := h.CheckContent(r)
		h.Log.Debug("conOk: ", uPasURIContOk)
		if !uPasURIContOk {
			http.Error(w, "json required", http.StatusUnsupportedMediaType)
		} else {
			var upcus m.ClientAllowedURI
			ubsuc, uberr := h.ProcessBody(r, &upcus)
			h.Log.Debug("ubsuc: ", ubsuc)
			h.Log.Debug("upcu: ", upcus)
			h.Log.Debug("uberr: ", uberr)
			if !ubsuc && uberr != nil {
				http.Error(w, uberr.Error(), http.StatusBadRequest)
			} else {
				uPusSuc := h.Manager.UpdateClientAllowedURI(&upcus)
				h.Log.Debug("auSuc: ", uPusSuc)
				var rtn Response
				if uPusSuc {
					rtn.Success = uPusSuc
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		}
	} else {
		var fusrtn Response
		w.WriteHeader(http.StatusUnauthorized)
		resJSON, _ := json.Marshal(fusrtn)
		fmt.Fprint(w, string(resJSON))
	}
}

//UpdateAllowedURI UpdateAllowedURI
func (h *OauthRestHandler) UpdateAllowedURI(w http.ResponseWriter, r *http.Request) {
	var ucu m.ClientAllowedURI
	upbsuc, uberr := h.ProcessBody(r, &ucu)
	h.Log.Debug("upbsuc: ", upbsuc)
	h.Log.Debug("ucu: ", ucu)
	h.Log.Debug("uberr: ", uberr)
	if upbsuc && uberr == nil {

		//url of this endpoint
		var upAuURL = "/ulbora/rs/clientAllowedUri/update"

		//make sure the user in not trying to add a prohibited url that has "ulbora" in the url
		//looks through a list of assets for the url and determines the role needed based on the asset part of the url
		acsuc, role := h.AssetControl.GetControlledAsset(upAuURL, "ulbora")

		var aucl oc.Claim
		if acsuc {
			aucl.Role = role
		} else {
			aucl.Role = "admin"
		}
		aucl.URL = upAuURL
		aucl.Scope = "write"
		h.Log.Debug("client: ", h.Client)

		//check that jwt token user role has permission to use the url of this endpoint
		auth := h.Client.Authorize(r, &aucl)

		if auth {
			// w.Header().Set("Content-Type", "application/json")
			h.SetContentType(w)
			upaURIContOk := h.CheckContent(r)
			h.Log.Debug("conOk: ", upaURIContOk)
			if !upaURIContOk {
				http.Error(w, "json required", http.StatusUnsupportedMediaType)
			} else {
				uuSuc := h.Manager.UpdateClientAllowedURI(&ucu)
				h.Log.Debug("uuSuc: ", uuSuc)
				var rtn Response
				if uuSuc {
					rtn.Success = uuSuc
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		} else {
			var frtn ResponseID
			w.WriteHeader(http.StatusUnauthorized)
			resJSON, _ := json.Marshal(frtn)
			fmt.Fprint(w, string(resJSON))
		}
	} else {
		http.Error(w, uberr.Error(), http.StatusBadRequest)
	}
}

//GetAllowedURI GetAllowedURI
func (h *OauthRestHandler) GetAllowedURI(w http.ResponseWriter, r *http.Request) {
	var getAuURL = "/ulbora/rs/clientAllowedUri/get"

	var guscl oc.Claim
	guscl.Role = "admin"
	guscl.URL = getAuURL
	guscl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &guscl)
	if auth {
		//var id string
		h.SetContentType(w)
		vars := mux.Vars(r)
		h.Log.Debug("vars: ", len(vars))
		if vars != nil && len(vars) != 0 {
			var idStr = vars["id"]
			h.Log.Debug("vars: ", vars)
			id, idErr := strconv.ParseInt(idStr, 10, 64)
			if id != 0 && idErr == nil {
				h.Log.Debug("id: ", id)
				getAu := h.Manager.GetClientAllowedURI(id)
				h.Log.Debug("getAu: ", getAu)
				w.WriteHeader(http.StatusOK)
				resJSON, _ := json.Marshal(getAu)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//GetAllowedURIList GetAllowedURIList
func (h *OauthRestHandler) GetAllowedURIList(w http.ResponseWriter, r *http.Request) {
	var getAulURL = "/ulbora/rs/clientAllowedUri/list"

	var gulcl oc.Claim
	gulcl.Role = "admin"
	gulcl.URL = getAulURL
	gulcl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &gulcl)
	if auth {
		//var id string
		h.SetContentType(w)
		vars := mux.Vars(r)
		h.Log.Debug("vars: ", len(vars))
		if vars != nil && len(vars) != 0 {
			var clientIDStr = vars["clientId"]
			h.Log.Debug("vars: ", vars)
			clientID, idErr := strconv.ParseInt(clientIDStr, 10, 64)
			if clientID != 0 && idErr == nil {
				h.Log.Debug("clientID: ", clientID)
				getAul := h.Manager.GetClientAllowedURIList(clientID)
				h.Log.Debug("getAul: ", getAul)
				w.WriteHeader(http.StatusOK)
				resJSON, _ := json.Marshal(getAul)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//DeleteAllowedURI DeleteAllowedURI
func (h *OauthRestHandler) DeleteAllowedURI(w http.ResponseWriter, r *http.Request) {
	var getAudURL = "/ulbora/rs/clientAllowedUri/delete"

	var gusdcl oc.Claim
	gusdcl.Role = "admin"
	gusdcl.URL = getAudURL
	gusdcl.Scope = "write"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &gusdcl)
	if auth {
		//var id string
		h.SetContentType(w)
		vars := mux.Vars(r)
		h.Log.Debug("vars: ", len(vars))
		if vars != nil && len(vars) != 0 {
			var idStr = vars["id"]
			h.Log.Debug("vars delete: ", vars)
			id, idErr := strconv.ParseInt(idStr, 10, 64)
			h.Log.Debug("id delete: ", id)
			if id != 0 && idErr == nil {
				h.Log.Debug("id: ", id)
				getAud := h.Manager.DeleteClientAllowedURI(id)
				var rtn Response
				if getAud {
					rtn.Success = getAud
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}
//Package handlers ...
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"

	m "github.com/Ulbora/GoAuth2/managers"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//ValidationResponse ValidationResponse
type ValidationResponse struct {
	Valid bool `json:"valid"`
}

//ValidateAccessToken ValidateAccessToken
func (h *OauthRestHandler) ValidateAccessToken(w http.ResponseWriter, r *http.Request) {
	var vdtr m.ValidateAccessTokenReq
	vdtsuc, gerr := h.ProcessBody(r, &vdtr)
	if h.TokenCompressed {
		vdtr.AccessToken = h.JwtCompress.UnCompressJwt(vdtr.AccessToken)
		fmt.Println("uncompressed token in validate: ", vdtr.AccessToken)
	}
	h.Log.Debug("vdtsuc: ", vdtsuc)
	h.Log.Debug("vdtr: ", vdtr)
	h.Log.Debug("gerr: ", gerr)
	if vdtsuc && gerr == nil {
		h.SetContentType(w)
		vdtContOk := h.CheckContent(r)
		h.Log.Debug("conOk: ", vdtContOk)
		if !vdtContOk {
			http.Error(w, "json required", http.StatusUnsupportedMediaType)
		} else {
			vdtSuc := h.Manager.ValidateAccessToken(&vdtr)
			h.Log.Debug("vdtSuc: ", vdtSuc)
			var rtn ValidationResponse
			if vdtSuc {
				rtn.Valid = vdtSuc
			}
			w.WriteHeader(http.StatusOK)
			resJSON, _ := json.Marshal(rtn)
			fmt.Fprint(w, string(resJSON))
		}
	} else {
		http.Error(w, gerr.Error(), http.StatusBadRequest)
	}
}
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	"github.com/gorilla/mux"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//AddRoleSuper AddRoleSuper
func (h *OauthRestHandler) AddRoleSuper(w http.ResponseWriter, r *http.Request) {
	//url of this endpoint
	var addRlsURL = "/ulbora/rs/clientRoleSuper/add"

	var rlscl oc.Claim
	rlscl.Role = "superAdmin"
	rlscl.URL = addRlsURL
	rlscl.Scope = "write"
	h.Log.Debug("client: ", h.Client)
	auth := h.Client.Authorize(r, &rlscl)
	if auth {
		h.SetContentType(w)
		rlsContOk := h.CheckContent(r)
		h.Log.Debug("conOk: ", rlsContOk)
		if !rlsContOk {
			http.Error(w, "json required", http.StatusUnsupportedMediaType)
		} else {
			var cus m.ClientRole
			rlssuc, rlserr := h.ProcessBody(r, &cus)
			h.Log.Debug("rlssuc: ", rlssuc)
			h.Log.Debug("cu: ", cus)
			h.Log.Debug("rlserr: ", rlserr)
			if !rlssuc && rlserr != nil {
				http.Error(w, rlserr.Error(), http.StatusBadRequest)
			} else {
				arlsSuc, arlsID := h.Manager.AddClientRole(&cus)
				h.Log.Debug("arlsSuc: ", arlsSuc)
				h.Log.Debug("arlsID: ", arlsID)
				var rtn ResponseID
				if arlsSuc && arlsID != 0 {
					rtn.Success = arlsSuc
					rtn.ID = arlsID
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		}
	} else {
		var arlsrtn ResponseID
		w.WriteHeader(http.StatusUnauthorized)
		resJSON, _ := json.Marshal(arlsrtn)
		fmt.Fprint(w, string(resJSON))
	}
}

//AddRole AddRole
func (h *OauthRestHandler) AddRole(w http.ResponseWriter, r *http.Request) {
	var cu m.ClientRole
	rlbsuc, rlberr := h.ProcessBody(r, &cu)
	h.Log.Debug("rlbsuc: ", rlbsuc)
	h.Log.Debug("cu: ", cu)
	h.Log.Debug("rlberr: ", rlberr)
	if rlbsuc && rlberr == nil {

		//url of this endpoint
		var addrl = "/ulbora/rs/clientRole/add"

		//make sure the user in not trying to add a prohibited url that has "ulbora" in the url
		//looks through a list of assets for the url and determines the role needed based on the asset part of the url
		arlacsuc, role := h.AssetControl.GetControlledAsset(addrl, "superAdmin")

		var rlcl oc.Claim
		if arlacsuc {
			rlcl.Role = role
		} else {
			rlcl.Role = "admin"
		}
		rlcl.URL = addrl
		rlcl.Scope = "write"
		h.Log.Debug("client: ", h.Client)

		//check that jwt token user role has permission to use the url of this endpoint
		auth := h.Client.Authorize(r, &rlcl)

		if auth {
			// w.Header().Set("Content-Type", "application/json")
			h.SetContentType(w)
			arlContOk := h.CheckContent(r)
			h.Log.Debug("conOk: ", arlContOk)
			if !arlContOk {
				http.Error(w, "json required", http.StatusUnsupportedMediaType)
			} else {
				arlSuc, arlID := h.Manager.AddClientRole(&cu)
				h.Log.Debug("arlSuc: ", arlSuc)
				h.Log.Debug("arlID: ", arlID)
				var rtn ResponseID
				if arlSuc && arlID != 0 {
					rtn.Success = arlSuc
					rtn.ID = arlID
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		} else {
			var arlrtn ResponseID
			w.WriteHeader(http.StatusUnauthorized)
			resJSON, _ := json.Marshal(arlrtn)
			fmt.Fprint(w, string(resJSON))
		}
	} else {
		http.Error(w, rlberr.Error(), http.StatusBadRequest)
	}
}

//GetRoleList GetRoleList
func (h *OauthRestHandler) GetRoleList(w http.ResponseWriter, r *http.Request) {
	var getRllURL = "/ulbora/rs/clientRole/list"

	var grllcl oc.Claim
	grllcl.Role = "admin"
	grllcl.URL = getRllURL
	grllcl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &grllcl)
	if auth {
		//var id string
		h.SetContentType(w)
		rllvars := mux.Vars(r)
		h.Log.Debug("vars: ", len(rllvars))
		if rllvars != nil && len(rllvars) != 0 {
			var rllClientIDStr = rllvars["clientId"]
			h.Log.Debug("vars: ", rllvars)
			rllclientID, idErr := strconv.ParseInt(rllClientIDStr, 10, 64)
			if rllclientID != 0 && idErr == nil {
				h.Log.Debug("clientID: ", rllclientID)
				getRll := h.Manager.GetClientRoleList(rllclientID)
				h.Log.Debug("getAul: ", getRll)
				w.WriteHeader(http.StatusOK)
				resJSON, _ := json.Marshal(getRll)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//DeleteRole DeleteRole
func (h *OauthRestHandler) DeleteRole(w http.ResponseWriter, r *http.Request) {
	var rldURL = "/ulbora/rs/clientRole/delete"

	var rldcl oc.Claim
	rldcl.Role = "admin"
	rldcl.URL = rldURL
	rldcl.Scope = "write"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &rldcl)
	if auth {
		//var id string
		h.SetContentType(w)
		rldvars := mux.Vars(r)
		h.Log.Debug("vars: ", len(rldvars))
		if rldvars != nil && len(rldvars) != 0 {
			var rldidStr = rldvars["id"]
			h.Log.Debug("vars delete: ", rldvars)
			rldid, idErr := strconv.ParseInt(rldidStr, 10, 64)
			h.Log.Debug("id delete: ", rldid)
			if rldid != 0 && idErr == nil {
				h.Log.Debug("id: ", rldid)
				rlsucd := h.Manager.DeleteClientRole(rldid)
				var rlrtn Response
				if rlsucd {
					rlrtn.Success = rlsucd
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rlrtn)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}
//Package handlers ...
package handlers

import (
	"fmt"
	"html/template"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	m "github.com/Ulbora/GoAuth2/managers"
	lg "github.com/Ulbora/Level_Logger"
)

func TestOauthWebHandlerLogin_Login(t *testing.T) {
	var om m.MockManager

	om.MockAuthCodeAuthorized = true
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()
	r, _ := http.NewRequest("GET", "/test", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	h.Login(w, r)
	fmt.Println("code: ", w.Code)

	if w.Code != 200 {
		t.Fail()
	}
}

func TestOauthWebHandlerLogin_LoginUser(t *testing.T) {
	var om m.MockManager
	om.MockUserLoginSuccess = true
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("username=tester1&password=somepassword"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)

	s.Values["authReqInfo"] = &ari
	s.Save(r, w)

	h.LoginUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]

	if w.Code != 302 || loc[0] != "/oauth/authorize?response_type=token&client_id=1234&redirect_uri=http://test.com/test&scope=web&state=12eee" {
		t.Fail()
	}
}

func TestOauthWebHandlerLogin_LoginUserBadGrant(t *testing.T) {
	var om m.MockManager
	om.MockUserLoginSuccess = true
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token2"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("username=tester1&password=somepassword"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)

	s.Values["authReqInfo"] = &ari
	s.Save(r, w)

	h.LoginUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]

	if w.Code != 302 || loc[0] != "/oauthError?error=invalid_grant" {
		t.Fail()
	}
}

func TestOauthWebHandlerLogin_LoginUserFailLogin(t *testing.T) {
	var om m.MockManager
	//om.MockUserLoginSuccess = true
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("username=tester1&password=somepassword"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)

	s.Values["authReqInfo"] = &ari
	s.Save(r, w)

	h.LoginUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]

	if w.Code != 302 || loc[0] != "/login?error=Login Failed" {
		t.Fail()
	}
}

func TestOauthWebHandlerLogin_LoginUserNoSessionInfo(t *testing.T) {
	var om m.MockManager
	om.MockUserLoginSuccess = true
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("username=tester1&password=somepassword"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	s.Save(r, w)

	h.LoginUser(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]

	if w.Code != 302 || loc[0] != "/login?error=Login Failed" {
		t.Fail()
	}
}

func TestOauthWebHandlerLogin_LoginUserNoSession(t *testing.T) {
	var om m.MockManager
	om.MockUserLoginSuccess = true
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("username=tester1&password=somepassword"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s, suc := wh.getSession(r)
	fmt.Println("suc: ", suc)

	s.Values["authReqInfo"] = ari
	s.Save(r, w)

	h.LoginUser(w, nil)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])

	if w.Code != 500 {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	m "github.com/Ulbora/GoAuth2/managers"
	au "github.com/Ulbora/auth_interface"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//TokenError TokenError
type TokenError struct {
	Error string `json:"error"`
}

//Token Token
func (h *OauthWebHandler) Token(w http.ResponseWriter, r *http.Request) {
	var atsuc bool
	var token *m.Token
	var tokenErr string
	var caseDef bool
	h.Log.Debug("token")
	grantType := r.FormValue("grant_type")
	h.Log.Debug("grant type: ", grantType)

	clientIDStr := r.FormValue("client_id")
	h.Log.Debug("clientIDStr: ", clientIDStr)

	clientID, err := strconv.ParseInt(clientIDStr, 10, 64)
	h.Log.Debug("clientID: ", clientID)
	h.Log.Debug("err: ", err)
	if err == nil {
		switch grantType {
		case authorizationCodeGrantType:
			h.Log.Debug("grant type: ", grantType)
			secret := r.FormValue("client_secret")
			h.Log.Debug("secret: ", secret)
			code := r.FormValue("code")
			h.Log.Debug("code: ", code)
			redirectURI := r.FormValue("redirect_uri")
			h.Log.Debug("redirectURI: ", redirectURI)
			var actk m.AuthCodeTokenReq
			actk.ClientID = clientID
			actk.Secret = secret
			actk.Code = code
			actk.RedirectURI = redirectURI

			atsuc, token, tokenErr = h.Manager.GetAuthCodeToken(&actk)
			h.Log.Debug("atsuc: ", atsuc)

		case passwordGrantType:
			h.Log.Debug("grant type: ", grantType)
			username := r.FormValue("username")
			h.Log.Debug("username: ", username)
			password := r.FormValue("password")
			h.Log.Debug("password: ", password)
			var lg au.Login
			lg.ClientID = clientID
			lg.Username = username
			lg.Password = password
			suc := h.Manager.UserLogin(&lg)
			h.Log.Debug("login suc", suc)
			if suc {
				var pt m.PasswordTokenReq
				pt.Username = username
				pt.ClientID = clientID
				atsuc, token, tokenErr = h.Manager.GetPasswordToken(&pt)
				h.Log.Debug("atsuc: ", atsuc)
			} else {
				tokenErr = unauthorizedClientError
			}
		case credentialGrantType:
			h.Log.Debug("grant type: ", grantType)
			secret := r.FormValue("client_secret")
			h.Log.Debug("secret: ", secret)
			var ct m.CredentialsTokenReq
			ct.ClientID = clientID
			ct.Secret = secret
			atsuc, token, tokenErr = h.Manager.GetCredentialsToken(&ct)
			h.Log.Debug("atsuc: ", atsuc)
		case refreshTokenGrantType:
			h.Log.Debug("grant type: ", grantType)
			secret := r.FormValue("client_secret")
			h.Log.Debug("secret: ", secret)
			refToken := r.FormValue("refresh_token")
			h.Log.Debug("refToken: ", refToken)
			if secret != "" {
				var acrt m.RefreshTokenReq
				acrt.ClientID = clientID
				acrt.Secret = secret
				acrt.RefreshToken = refToken
				atsuc, token, tokenErr = h.Manager.GetAuthCodeAccesssTokenWithRefreshToken(&acrt)
				h.Log.Debug("atsuc: ", atsuc)
			} else {
				var pwrt m.RefreshTokenReq
				pwrt.ClientID = clientID
				pwrt.RefreshToken = refToken
				atsuc, token, tokenErr = h.Manager.GetPasswordAccesssTokenWithRefreshToken(&pwrt)
			}
		default:
			caseDef = true
		}
		if atsuc {
			h.SetContentType(w)
			h.SetSecurityHeader(w)
			w.WriteHeader(http.StatusOK)
			if h.TokenCompressed {
				token.AccessToken = h.JwtCompress.CompressJwt(token.AccessToken)
			}
			resJSON, _ := json.Marshal(token)
			fmt.Fprint(w, string(resJSON))
		} else if caseDef {
			http.Redirect(w, r, invalidGrantErrorURL, http.StatusFound)
		} else {
			var te TokenError
			te.Error = tokenErr
			h.SetContentType(w)
			w.WriteHeader(http.StatusUnauthorized)
			resJSON, _ := json.Marshal(te)
			fmt.Fprint(w, string(resJSON))
		}
	} else {
		http.Redirect(w, r, invalidGrantErrorURL, http.StatusFound)
	}
}
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	"github.com/gorilla/mux"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//AddRedirectURI AddRedirectURI
func (h *OauthRestHandler) AddRedirectURI(w http.ResponseWriter, r *http.Request) {
	var cr m.ClientRedirectURI
	rusuc, ruerr := h.ProcessBody(r, &cr)
	h.Log.Debug("rusuc: ", rusuc)
	h.Log.Debug("cr: ", cr)
	h.Log.Debug("ruerr: ", ruerr)
	if rusuc && ruerr == nil {

		//url of this endpoint
		var addRURL = "/ulbora/rs/clientRedirectUri/add"

		var rucl oc.Claim
		rucl.Role = "admin"
		rucl.URL = addRURL
		rucl.Scope = "write"
		h.Log.Debug("client: ", h.Client)

		//check that jwt token user role has permission to use the url of this endpoint
		auth := h.Client.Authorize(r, &rucl)

		if auth {
			// w.Header().Set("Content-Type", "application/json")
			h.SetContentType(w)
			rdURIContOk := h.CheckContent(r)
			h.Log.Debug("conOk: ", rdURIContOk)
			if !rdURIContOk {
				http.Error(w, "json required", http.StatusUnsupportedMediaType)
			} else {
				ruSuc, ruID := h.Manager.AddClientRedirectURI(&cr)
				h.Log.Debug("ruSuc: ", ruSuc)
				h.Log.Debug("ruID: ", ruID)
				var rtn ResponseID
				if ruSuc && ruID != 0 {
					rtn.Success = ruSuc
					rtn.ID = ruID
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			}
		} else {
			var rurtn ResponseID
			w.WriteHeader(http.StatusUnauthorized)
			resJSON, _ := json.Marshal(rurtn)
			fmt.Fprint(w, string(resJSON))
		}
	} else {
		http.Error(w, ruerr.Error(), http.StatusBadRequest)
	}
}

//GetRedirectURIList GetRedirectURIList
func (h *OauthRestHandler) GetRedirectURIList(w http.ResponseWriter, r *http.Request) {
	var getRURL = "/ulbora/rs/clientRedirectUri/list"

	var rugcl oc.Claim
	rugcl.Role = "admin"
	rugcl.URL = getRURL
	rugcl.Scope = "read"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &rugcl)
	if auth {
		//var id string
		h.SetContentType(w)
		rugvars := mux.Vars(r)
		h.Log.Debug("vars: ", len(rugvars))
		if rugvars != nil && len(rugvars) != 0 {
			var rugclientIDStr = rugvars["clientId"]
			h.Log.Debug("vars: ", rugvars)
			clientID, rugidErr := strconv.ParseInt(rugclientIDStr, 10, 64)
			if clientID != 0 && rugidErr == nil {
				h.Log.Debug("clientID: ", clientID)
				getrul := h.Manager.GetClientRedirectURIList(clientID)
				h.Log.Debug("getrul: ", getrul)
				w.WriteHeader(http.StatusOK)
				resJSON, _ := json.Marshal(getrul)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}

//DeleteRedirectURI DeleteRedirectURI
func (h *OauthRestHandler) DeleteRedirectURI(w http.ResponseWriter, r *http.Request) {
	var drURL = "/ulbora/rs/clientRedirectUri/delete"

	var rudcl oc.Claim
	rudcl.Role = "admin"
	rudcl.URL = drURL
	rudcl.Scope = "write"
	//fmt.Println("client: ", h.Client)
	auth := h.Client.Authorize(r, &rudcl)
	if auth {
		//var id string
		h.SetContentType(w)
		druvars := mux.Vars(r)
		h.Log.Debug("vars: ", len(druvars))
		if druvars != nil && len(druvars) != 0 {
			var druidStr = druvars["id"]
			h.Log.Debug("vars delete: ", druidStr)
			id, idErr := strconv.ParseInt(druidStr, 10, 64)
			h.Log.Debug("id delete: ", id)
			if id != 0 && idErr == nil {
				h.Log.Debug("id: ", id)
				rudsuc := h.Manager.DeleteClientRedirectURI(id)
				var rtn Response
				if rudsuc {
					rtn.Success = rudsuc
					w.WriteHeader(http.StatusOK)
				} else {
					w.WriteHeader(http.StatusInternalServerError)
				}
				resJSON, _ := json.Marshal(rtn)
				fmt.Fprint(w, string(resJSON))
			} else {
				w.WriteHeader(http.StatusBadRequest)
			}
		} else {
			w.WriteHeader(http.StatusBadRequest)
		}
	} else {
		w.WriteHeader(http.StatusUnauthorized)
	}
}
//Package handlers ...
package handlers

import "net/http"

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

const (
	codeRespType     = "code"
	tokenRespType    = "token"
	implicitRespType = "implicit"
	clientRespType   = "client_credentials"
	passwordRespType = "password"

	authorizationCodeGrantType = "authorization_code"
	passwordGrantType          = "password"
	credentialGrantType        = "client_credentials"
	refreshTokenGrantType      = "refresh_token"

	invalidReqestError      = "Invalid Request"
	invalidRedirectError    = "Invalid redirect URI"
	accessDenidError        = "access_denied"
	unauthorizedClientError = "unauthorized_client"

	authAppPageTitle = "Authorize Application"
	loginPageTitle   = "GoAuth2 Login Page"
)

//ResponseID ResponseID
type ResponseID struct {
	Success bool  `json:"success"`
	ID      int64 `json:"id"`
}

//Response Response
type Response struct {
	Success bool `json:"success"`
}

//RestHandler RestHandler
type RestHandler interface {
	AddAllowedURISuper(w http.ResponseWriter, r *http.Request)
	AddAllowedURI(w http.ResponseWriter, r *http.Request)
	UpdateAllowedURISuper(w http.ResponseWriter, r *http.Request)
	UpdateAllowedURI(w http.ResponseWriter, r *http.Request)
	GetAllowedURI(w http.ResponseWriter, r *http.Request)
	GetAllowedURIList(w http.ResponseWriter, r *http.Request)
	DeleteAllowedURI(w http.ResponseWriter, r *http.Request)

	AddGrantType(w http.ResponseWriter, r *http.Request)
	GetGrantTypeList(w http.ResponseWriter, r *http.Request)
	DeleteGrantType(w http.ResponseWriter, r *http.Request)

	AddRedirectURI(w http.ResponseWriter, r *http.Request)
	GetRedirectURIList(w http.ResponseWriter, r *http.Request)
	DeleteRedirectURI(w http.ResponseWriter, r *http.Request)

	AddRoleSuper(w http.ResponseWriter, r *http.Request)
	AddRole(w http.ResponseWriter, r *http.Request)
	GetRoleList(w http.ResponseWriter, r *http.Request)
	DeleteRole(w http.ResponseWriter, r *http.Request)

	AddRoleURI(w http.ResponseWriter, r *http.Request)
	GetRoleURIList(w http.ResponseWriter, r *http.Request)
	DeleteRoleURI(w http.ResponseWriter, r *http.Request)

	AddClient(w http.ResponseWriter, r *http.Request)
	UpdateClient(w http.ResponseWriter, r *http.Request)
	GetClient(w http.ResponseWriter, r *http.Request)
	GetClientAdmin(w http.ResponseWriter, r *http.Request)
	GetClientList(w http.ResponseWriter, r *http.Request)
	GetClientSearchList(w http.ResponseWriter, r *http.Request)
	DeleteClient(w http.ResponseWriter, r *http.Request)

	ValidateAccessToken(w http.ResponseWriter, r *http.Request)

	SetLogLevel(w http.ResponseWriter, r *http.Request)
}

//WebHandler WebHandler
type WebHandler interface {
	Index(w http.ResponseWriter, r *http.Request)
	Authorize(w http.ResponseWriter, r *http.Request)
	AuthorizeApp(w http.ResponseWriter, r *http.Request)
	ApplicationAuthorizationByUser(w http.ResponseWriter, r *http.Request)
	OauthError(w http.ResponseWriter, r *http.Request)

	Login(w http.ResponseWriter, r *http.Request)
	LoginUser(w http.ResponseWriter, r *http.Request)

	Token(w http.ResponseWriter, r *http.Request)
}
//Package handlers ...
package handlers

import (
	//"html/template"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	m "github.com/Ulbora/GoAuth2/managers"
	lg "github.com/Ulbora/Level_Logger"
)

func TestOauthWebHandlerToken_AuthCodeToken(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeTokenSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "bearer"
	om.MockToken = tk
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=authorization_code&client_id=3456&client_secret=aaaa45&code=123abc&redirect_uri=http://someTest/test.com"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy *m.Token
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))

	if w.Code != 200 || bdy.AccessToken != "125444" {
		t.Fail()
	}
}

func TestOauthWebHandlerToken_AuthCodeTokenBadGrant(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeTokenSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "bearer"
	om.MockToken = tk
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=authorization_code2&client_id=3456&client_secret=aaaa45&code=123abc&redirect_uri=http://someTest/test.com"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy *m.Token
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))

	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]

	if w.Code != 302 || loc[0] != "/oauthError?error=invalid_grant" {
		t.Fail()
	}
}

func TestOauthWebHandlerToken_AuthCodeTokenBadClient(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeTokenSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "bearer"
	om.MockToken = tk
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=authorization_code&client_id=a3456&client_secret=aaaa45&code=123abc&redirect_uri=http://someTest/test.com"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	fmt.Println("location: ", w.HeaderMap["Location"])
	loc := w.HeaderMap["Location"]

	if w.Code != 302 || loc[0] != "/oauthError?error=invalid_grant" {
		t.Fail()
	}
}

func TestOauthWebHandlerToken_AuthCodeTokenFailed(t *testing.T) {
	var om m.MockManager
	//om.MockAuthCodeTokenSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "bearer"
	om.MockToken = tk
	om.MockTokenError = "some_error"
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=authorization_code&client_id=3456&client_secret=aaaa45&code=123abc&redirect_uri=http://someTest/test.com"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy TokenError
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))

	if w.Code != 401 || bdy.Error != "some_error" {
		t.Fail()
	}
}

func TestOauthWebHandlerToken_PasswordToken(t *testing.T) {
	var om m.MockManager
	om.MockPasswordTokenSuccess = true
	om.MockUserLoginSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "bearer"
	om.MockToken = tk
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=password&client_id=3456&password=aaaa45&username=tester1"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy *m.Token
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))

	if w.Code != 200 || bdy.AccessToken != "125444" {
		t.Fail()
	}
}

func TestOauthWebHandlerToken_PasswordTokenFailedLogin(t *testing.T) {
	var om m.MockManager
	om.MockPasswordTokenSuccess = true
	//om.MockUserLoginSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "bearer"
	om.MockToken = tk
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=password&client_id=3456&password=aaaa45&username=tester1"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy TokenError
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))

	if w.Code != 401 || bdy.Error != "unauthorized_client" {
		t.Fail()
	}
}

func TestOauthWebHandlerToken_CredentialsToken(t *testing.T) {
	var om m.MockManager
	om.MockCredentialsTokenSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "bearer"
	om.MockToken = tk
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=client_credentials&client_id=3456&client_secret=aaaa45"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy *m.Token
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))

	if w.Code != 200 || bdy.AccessToken != "125444" {
		t.Fail()
	}
}

func TestOauthWebHandlerToken_AuthCodeRefreshToken(t *testing.T) {
	var om m.MockManager
	om.MockAuthCodeRefreshTokenSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "refresh"
	om.MockToken = tk
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=refresh_token&client_id=3456&client_secret=aaaa45&refresh_token=123abc"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy *m.Token
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))

	if w.Code != 200 || bdy.AccessToken != "125444" {
		t.Fail()
	}
}

func TestOauthWebHandlerToken_PasswordRefreshToken(t *testing.T) {
	var om m.MockManager
	om.MockPasswordRefreshTokenSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "refresh"
	om.MockToken = tk
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=refresh_token&client_id=3456&refresh_token=123abc"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy *m.Token
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))

	if w.Code != 200 || bdy.AccessToken != "125444" {
		t.Fail()
	}
}

func TestOauthWebHandlerToken_PasswordRefreshTokenCompressed(t *testing.T) {
	var om m.MockManager
	om.MockPasswordRefreshTokenSuccess = true
	var tk m.Token
	tk.AccessToken = "125444"
	tk.TokenType = "refresh"
	om.MockToken = tk
	var ari AuthorizeRequestInfo
	ari.ResponseType = "token"
	ari.ClientID = 1234
	ari.RedirectURI = "http://test.com/test"
	ari.Scope = "web"
	ari.State = "12eee"

	var wh OauthWebHandler
	var l lg.Logger
	wh.Log = &l
	//wh.Templates = template.Must(template.ParseFiles("testHtmls/test.html"))
	wh.Manager = &om
	wh.TokenCompressed = true
	h := wh.GetNewWebHandler()

	r, _ := http.NewRequest("POST", "/test", strings.NewReader("grant_type=refresh_token&client_id=3456&refresh_token=123abc"))
	r.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")

	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	//s, suc := wh.getSession(r)
	//fmt.Println("suc: ", suc)

	//s.Values["authReqInfo"] = ari
	//s.Save(r, w)

	h.Token(w, r)
	fmt.Println("code: ", w.Code)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy *m.Token
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))

	if w.Code != 200 || bdy.AccessToken != "eNoyNDI1MTEBBAAA//8EMgE1" {
		t.Fail()
	}
}
//Package handlers ...
package handlers

import (
	"fmt"
	"net/http"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//Index  Index
func (h *OauthWebHandler) Index(w http.ResponseWriter, r *http.Request) {
	fmt.Println("index test")
	//var lpg PageParams
	//lpg.Title = loginPageTitle
	h.Log.Debug("template: ", h.Templates)
	h.Templates.ExecuteTemplate(w, indexHTML, nil)
}
//Package handlers ...
package handlers

import (
	m "github.com/Ulbora/GoAuth2/managers"
	oa "github.com/Ulbora/GoAuth2/oauthclient"
	rc "github.com/Ulbora/GoAuth2/rolecontrol"
)

/*
 Copyright (C) 2019 Ulbora Labs LLC. (www.ulboralabs.com)
 All rights reserved.

 Copyright (C) 2019 Ken Williamson
 All rights reserved.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

//UseMockWeb UseMockWeb
func UseMockWeb() *OauthWebHandler {
	var om m.MockManager
	om.MockAuthCodeAuthorized = true
	om.MockImplicitAuthorized = true
	var acc m.AuthCodeClient
	//acc.Valid = true
	acc.ClientName = "Test Client"
	acc.WebSite = "www.TestClient.com"
	om.MockAuthCodeClient = acc

	var ic m.ImplicitClient
	ic.Valid = true
	ic.ClientName = "Test Client"
	ic.WebSite = "www.TestClient.com"
	om.MockImplicitClient = ic
	om.MockAuthCodeAuthorizeSuccess = true
	om.MockUserLoginSuccess = true
	om.MockAuthCode = 55
	om.MockAuthCodeString = "rr666"

	om.MockImplicitAuthorizeSuccess = true
	var ir m.ImplicitReturn
	ir.ID = 3
	ir.Token = "12345"
	om.MockImplicitReturn = ir

	var tkn m.Token
	tkn.AccessToken = "65165165"
	tkn.TokenType = "Bearer"
	tkn.RefreshToken = "16161"
	tkn.ExpiresIn = 50000

	om.MockAuthCodeTokenSuccess = true
	om.MockCredentialsTokenSuccess = true
	om.MockAuthCodeRefreshTokenSuccess = true
	om.MockPasswordTokenSuccess = true
	om.MockToken = tkn
	om.MockTokenError = "token failed"

	var wh OauthWebHandler
	wh.Manager = &om
	return &wh
}

//UseMockRest UseMockRest
func UseMockRest() *OauthRestHandler {
	var om m.MockManager
	om.MockInsertSuccess1 = true
	om.MockInsertID1 = 34
	om.MockUpdateSuccess1 = true
	om.MockDeleteSuccess1 = true

	var mc m.Client
	mc.ClientID = 510
	mc.Secret = "12345"
	mc.Name = "test client"
	mc.WebSite = "www.testclient.com"
	mc.Email = "tester@testclient.com"
	mc.Enabled = true

	var cuo m.ClientRedirectURI
	cuo.ID = 4
	cuo.URI = "/test"
	cuo.ClientID = 10
	mc.RedirectURIs = &[]m.ClientRedirectURI{cuo}
	om.MockClient = mc

	om.MockClientList = []m.Client{mc}

	var gt m.ClientGrantType
	gt.ID = 2
	gt.GrantType = "code"
	gt.ClientID = 22

	om.MockClientGrantTypeList = []m.ClientGrantType{gt}

	var au m.ClientAllowedURI
	au.ID = 5
	au.URI = "/testurl"
	au.ClientID = 4

	om.MockClientAllowedURI = au
	om.MockClientAllowedURIList = []m.ClientAllowedURI{au}

	var ru m.ClientRedirectURI
	ru.ID = 4
	ru.URI = "/testuri"
	ru.ClientID = 554

	om.MockClientRedirectURIList = []m.ClientRedirectURI{ru}

	var crl m.ClientRole
	crl.ID = 44
	crl.Role = "hotshot"
	crl.ClientID = 25

	om.MockClientRoleList = []m.ClientRole{crl}

	var rul m.ClientRoleURI
	rul.ClientRoleID = 1
	rul.ClientAllowedURIID = 2

	var rul2 m.ClientRoleURI
	rul2.ClientRoleID = 11
	rul2.ClientAllowedURIID = 21

	om.MockClientRoleURIList = []m.ClientRoleURI{rul, rul2}

	om.MockValidateAccessTokenSuccess = true

	var rh OauthRestHandler
	rh.Manager = &om

	var clt oa.MockOauthClient
	clt.MockValid = true
	rh.Client = &clt

	var ac rc.MockOauthAssets
	ac.MockSuccess = true
	rh.AssetControl = &ac
	return &rh
}
//Package handlers ...
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"

	"net/http"
	"net/http/httptest"
	"testing"

	m "github.com/Ulbora/GoAuth2/managers"
	oc "github.com/Ulbora/GoAuth2/oauthclient"
	ac "github.com/Ulbora/GoAuth2/rolecontrol"
	lg "github.com/Ulbora/Level_Logger"
	"github.com/gorilla/mux"
)

// add url grant type

func TestOauthRestHandlerRoleURI_AddRoleURI(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"clientRoleId":3, "clientAllowedUriId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy ResponseID
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || !bdy.Success {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_AddRoleURIBadMedia(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"clientRoleId":3, "clientAllowedUriId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleURI(w, r)
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_AddRoleURIFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = false
	//man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"clientRoleId":3, "clientAllowedUriId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleURI(w, r)
	if w.Code != 500 {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_AddRoleURINotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"clientRoleId":3, "clientAllowedUriId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", aJSON)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleURI(w, r)
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_AddRoleURIBadBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockInsertSuccess1 = true
	man.MockInsertID1 = 5
	oh.Manager = &man

	var asc ac.MockOauthAssets
	asc.MockSuccess = true
	asc.MockAllowedRole = "admin"
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"id":3, "url":"/test", "clientId": 2}`))
	//aJSON, _ := json.Marshal(robj)
	//fmt.Println("aJSON: ", aJSON)
	r, _ := http.NewRequest("POST", "/ffllist", nil)
	//r, _ := http.NewRequest("POST", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	h.AddRoleURI(w, r)
	if w.Code != 400 {
		t.Fail()
	}
}

// // get list

func TestOauthRestHandlerRoleURI_GetRoleURIList(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRoleURI
	cuo.ClientRoleID = 4
	cuo.ClientAllowedURIID = 10

	var cuol = []m.ClientRoleURI{cuo}

	var man m.MockManager
	man.MockClientRoleURIList = cuol
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientRoleId": "55",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRoleURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy []m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("len(bdy): ", len(bdy))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || len(bdy) != 1 {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_GetRoleURIListNotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRoleURI
	cuo.ClientRoleID = 4
	cuo.ClientAllowedURIID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientRoleId": "5",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRoleURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_GetRoleURIListBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRoleURI
	cuo.ClientRoleID = 4
	cuo.ClientAllowedURIID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientRoleId": "q",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRoleURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientAllowedURI
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_GetRoleURIListNoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l
	var cuo m.ClientRoleURI
	cuo.ClientRoleID = 4
	cuo.ClientAllowedURIID = 10

	var man m.MockManager
	//man.MockClientAllowedURI = cuo
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.GetRoleURIList(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy m.ClientGrantType
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

// delete gt

func TestOauthRestHandlerRoleURI_DeleteRoleURI(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientRoleId":       "5",
		"clientAllowedUriId": "6",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRoleURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.Success != true {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_DeleteRoleURIFail(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = false
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientRoleId":       "5",
		"clientAllowedUriId": "6",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRoleURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 500 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_DeleteRoleURINotAuth(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = false
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientRoleId":       "5",
		"clientAllowedUriId": "6",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRoleURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 401 {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_DeleteRoleURIBadParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	vars := map[string]string{
		"clientRoleId":       "b",
		"clientAllowedUriId": "6",
	}
	r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRoleURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 400 || w.Header().Get("Content-Type") != "application/json" {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_DeleteRoleURINoParam(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	r, _ := http.NewRequest("GET", "/ffllist", nil)
	// vars := map[string]string{
	// 	"id": "q",
	// }
	// r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRoleURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("code: ", w.Code)
	if w.Code != 415 {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_DeleteRoleURIJson(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"clientRoleId":3, "clientAllowedUriId": 2}`))
	r, _ := http.NewRequest("GET", "/ffllist", aJSON)
	r.Header.Set("Content-Type", "application/json")
	// vars := map[string]string{
	// 	"clientRoleId":       "5",
	// 	"clientAllowedUriId": "6",
	// }
	//r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRoleURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	if w.Code != 200 || w.Header().Get("Content-Type") != "application/json" || bdy.Success != true {
		t.Fail()
	}
}

func TestOauthRestHandlerRoleURI_DeleteRoleURIJsonNoBody(t *testing.T) {
	var oh OauthRestHandler
	var l lg.Logger
	oh.Log = &l

	var man m.MockManager
	man.MockDeleteSuccess1 = true
	oh.Manager = &man

	var asc ac.MockOauthAssets
	oh.AssetControl = &asc

	var oct oc.MockOauthClient
	oct.MockValid = true
	oh.Client = &oct
	fmt.Println("oh.Client: ", oh.Client)

	h := oh.GetNewRestHandler()

	//aJSON := ioutil.NopCloser(bytes.NewBufferString(`{"clientRoleId":3, "clientAllowedUriId": 2}`))
	r, _ := http.NewRequest("GET", "/ffllist", nil)
	r.Header.Set("Content-Type", "application/json")
	// vars := map[string]string{
	// 	"clientRoleId":       "5",
	// 	"clientAllowedUriId": "6",
	// }
	//r = mux.SetURLVars(r, vars)
	w := httptest.NewRecorder()
	h.DeleteRoleURI(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	var bdy Response
	json.Unmarshal(body, &bdy)
	fmt.Println("body: ", string(body))
	fmt.Println("code: ", w.Code)
	fmt.Println(" w.Header()", w.Header().Get("Content-Type"))
	if w.Code != 400 {
		t.Fail()
	}
}
